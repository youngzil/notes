{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 个人读书学习笔记 技术其他 《阿里巴巴Java开发手册》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Java/JavaSE/JavaSE.html":{"url":"Books/tech/Java/JavaSE/JavaSE.html","title":"Java","keywords":"","body":" 1、Java基础学习 2、JVM学习 3、Java并发和多线程 4、 5、 Java基础学习 Java基础：IO、集合、多线程、反射字节流和字符流BIO和NIO集合多线程：进程，线程和协程的区别 并发工具类SPIJDK、JDK7、JDK8java agent零拷贝：减少内核态和用户态时的数据重复拷贝，java.nio.channel.FileChannel的transferTo()，transferFrom()方法内存映射文件：mmap()方法java热部署、模块化：jarslink泛型：泛型上限通配符extends与泛型下限通配符super反射初始化环形缓冲区的实现原理（ring buffer）quickstart-disruptorjava锁1、synchronized和lock的用法区别 各自底层原理3、如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源4、java基础：Object有方法java常见的异常Comparable与Comparator的区别Runtime类：获取jvm信息，执行程序什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？java进程间通讯方式（IPC）：Socket，RMI、RPC，共享内存内存泄漏，现象，排查oom的可能原因，排查惊群问题(The \"thundering herd\" problem) Java线程的5种状态及切换Java 语法糖 hashmap数据结构 volidate关键字作用：线程可见性、有序性，不保证原子性 直接内存详解 4、集合：java集合.mdList、Set、Map、Queue并发集合：ConcurrentHashMap、ConcurrentSkipListSet、CopyOnWriteArrayList等 6、反射、java agent，反射初始化：java反射和agent.mdRTTI和反射机制区别反射的使用：获取类、构造方法，成员变量，成员方法、注解、泛型 7、Java的简单类型及其封装器类8、Object类的方法，和Thread类方法的区别9、String StringBuffer,StringBuilder原理：底层的数据结构是 字符数组 char[]10、sleep、wait notyfi都干啥的，sycnized怎么用的，concurrent包下面的锁用过哪些，怎么实现的 33、volatile原理34、数据结构：堆和树35、Queue队列的常用方法36、数组、链表，队列 ，栈，散列表，树，图38、Linux探秘之用户态与内核态39、java进程CPU过高问题如何排查？40、Java8中用sun.misc.Contended避免伪共享(false sharing)41、动态代理和静态代理 23、负载均衡.md:负载均衡算法24、java热部署、模块化：jarslink25、SPI和JDK、JDK7、JDK826、一致性哈希算法(consistent hashing)27、java常见异常28、Comparable与Comparator的区别29、对Runtime的了解:Runtime类30、什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？31、java进程间通信(IPC interProcess communication)：32、如何实现分布式缓存 18、分布式锁实现.md：数据库、redis、zookeeper19、加解密.md：加解密的分类和实现20、单例模式有三种实现方式21、图片加载缓慢优化.md：22、泛型通配符extends与super的区别.md：泛型：泛型上限通配符extends与泛型下限通配符super12、图的遍历，深度广度啊13、内存溢出，内存泄露，，怎么调优，类加载14、BloomFilter 与 CuckooFilter JVM学习 JVM结构、垃圾回收、类加载机制、内存泄露排查 linux系统工具能利用工具排查CPU、内存和网络IO问题排查JVM优化技术JVM参数javaGC、内存模型 jvm诊断命令堆怎么区分的？为什么分代？对象回收，内存等怎么判断是否回收？哪些类型的对象？java中一个类加载过程？主要考虑类加载器过程，加载过程，双亲委派模型oom怎么排查，堆dump、线程dump怎么查看JVM内存模型：五个区域和各自保存的对象，会抛出什么异常：年轻代、年老代、持久代（方法去）、堆外内存（直接内存） 计算机内存模型和CPU缓存一致性协议MESI： 缓存伪共享、 零拷贝：transTo、transFrom、map mmap：安全、高效（zero copy）、gc CPU缓存分类：CPU三级缓存：CPU、L1、L2、L3、主内存 缓存一致性协议：MESI 伪共享(False Sharing)：缓存行进行字节填充，保证头尾加载到不同的缓存行，避免出入对互斥，不能并发，成为伪共享。jdk8中Contended注解 缓存系统中是以缓存行（cache line）为单位存储的：现在64byte，早期32byte，范围32-128byte 缓存段竞争：导致总线风暴 volatile字段：使用内存屏障，保证可见性和有序性，不保证原子性 MESI－CPU缓存一致性协议、JVM内存模型、内存结构 类加载机制（双亲委派），类加载过程 垃圾回收：垃圾收集算法、垃圾收集器，对象存活方式判断，GC Roots包括，类回收条件，堆（年轻代、年老代），java对象的引用（强引用，软引用，弱引用，虚引用） 垃圾回收、内存调优、常见参数 jdk的命令行工具 1、启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 2、JVM类加载机制，哪几种类加载器，类加载之间的父子关系是怎样的？每个类加载器都加载哪些类？classloader的功能和工作模式 3、jvm内存模型： 4、GC策略，GC过程，GCROOTs哪里来的(哪些可以是GCROOTs)，常见的垃圾回收器， 5、oom怎么排查，jvm诊断命令堆dump、线程dump怎么查看 6、jvm类加载机制 内存模型 GC类型、算法、回收机制， jvm诊断命令 jvm学习.md JVM GC日志分析工具： GCHisto、GCViewer JVM内存结构，和Java虚拟机的运行时区域有关。Java内存模型，和Java的并发编程有关。Java对象模型，和Java对象在虚拟机中的表现形式有关。 JAVA中的内存泄露：堆区不断增长，最后不断触发FullGC, 甚至crashjdk的命令行工具：jps、jinfo + jstat 、jmap（-dump、jhat）、jstack堆外内存：原因、场景、使用：存活时间长，大内存的 java对象的引用包括：强引用，软引用，弱引用，虚引用Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。 .java 编译到.class过程？类加载过程java文件编译成class文件的过程类加载过程：校验，加载-双亲委派模型，初始化，卸载等 Java并发和多线程 Java线程的5种状态及切换 java基础：多线程的概念能不能介绍一下线程同步的常见问题，以及怎么处理？ 死锁、饥饿、活锁、 Java线程的5种状态及切换java进程和Linux线程的关系多线程概念：线程同步（两种锁、特殊变量volatile、线程变量ThreadLocal、并发工具类）、线程间通信、线程死锁、线程控制（挂起、停止和恢复）Unsafe类的使用java线程的创建和分类Linux进程间通信线程池：查看ThreadPool.md 线程状态切换的代价 ThreadPoolExecutor或者Executors工具类（4种）来创建 参数：7个 创建线程流程和销毁线程流程 提交任务：execute() 和 submit() execute()：FutureTask（ExecutorCompletionService） submit()：Callable接口、Future接口 RejectedExecutionHandler策略 其他方法：beforeExecute、afterExecute、 ThreadLocal使用：以线程为单位进行隔离，因为WeakReference不会导致内存泄漏，线程复用的时候没有remove可能会导致后面的任务取到前面任务存进去的值，导致程序出错 concurrent包并发、并发工具类：java并发包concurrent和并发工具类.md java并发包concurrent：1、Atomic原子类型：Long、Integer、Boolean、Refrence等2、并发锁Lock锁：ReentrantLock、ReentrantReadWriteLock等3、线程池：Callable接口、Future接口、FutureTask（ExecutorCompletionService）、Executors、ExecutorService、ThreadPoolExecutor、ThreadFactory、4、并发集合：ConcurrentHashMap、ConcurrentSkipListSet、CopyOnWriteArrayList和CopyOnWriteArraySet等5、并发工具类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、ForkJoinPool等Java并发工具类：并发开始：同步屏障CyclicBarrier并发结束：等待多线程完成的CountDownLatch并发控制：控制并发线程数的Semaphore并发交换：两个线程进行数据交换的Exchanger 并发类，如ThreadLocal 、volatile并发编程中的三个概念：原子性，可见性，有序性，和volatile关键字的两层语义java线程状态转换和线程并发Unsafe类的CAS操作java并发基础AQS类.md 在那些场景用了哪些多线程的什么接口 blockqueue中获取数据流程？lock方法？condationconcurrenthashmap并发工具类 多线程用过的一个场景，用了哪些jdk的接口线程池的参数使用，接收任务的流程？执行的流程？线程池中线程空闲销毁原理？等待知道超时销毁？blockqueue从里面去任务，阻塞知道取出任务，源码查看过吗？lock方法？candition怎么使用？并发工具类：四个，concurrenthashmap， 泛型通配符extends与super 1、 泛型上限通配符，只能用于方法返回，只能返回T和T子类型 2、泛型下限通配符，只能用于限定方法入参，只能传入T和T的父类型 3、? 既不能用于入参也不能用于返参 hash冲突解决java读取文件方式javaagentJMXjava内部类 了Java的基础知识，容器类，线程安全和非安全的，多线程相关基础知识，实现方式，死锁的检查与排查1.String， StringBuffer， StringBuilder 的区别，为什么String 不可改变，StringBuilder可以改变？ 3.什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？ Throwable、Error、Exception、RuntimeException 区别和联系各是什么checked exception 和 unchecked exception的区别是什么？volatile的特性是什么？ 可以完美解决多线程同步问题吗？threadlocal有什么用？ 多线程使用有什么需要注意的地方？ 使用完后为什么要remove？synchronized和reentrantlock的底层原理各是什么？ 有什么优缺点？JVM加载class文件的原理机制？为什么要用双亲委托模型？ 如何打破双亲委托模型？职业规划如何？ 为什么要加入蚂蚁金服？ 对未来的期待怎么样？ Java基础：IO、集合、多线程、并发、反射 虚拟机了解多少？服务器上只有jre没有jdk，怎么看文件，启动参数设置oom打印日志 JVM崩溃Log日志和GC日志https://blog.csdn.net/warship_f/article/details/78078945https://blog.csdn.net/Me_ZH/article/details/78700671 JVM 发生OOM的四种情况https://www.cnblogs.com/baizhanshi/p/6704731.html?utm_source=itdadao&utm_medium=referralhttps://blog.csdn.net/pbuzhidaol/article/details/72871898 javaOOM类型.md https://www.cnblogs.com/gdpuzxs/p/7044963.htmlhttps://www.cnblogs.com/ITtangtang/p/3978102.html重写classloader：（1）继承ClassLoader （2）重写findClass（）方法 （3）调用defineClass（）方法 http://www.cnblogs.com/aspirant/p/7200523.html(1)阿里的面试官问我，可以不可以自己写个String类答案：不可以，因为 根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了; (2)能否在加载类的时候，对类的字节码进行修改答案：可以，使用Java探针技术，可以参考：Java探针-Java Agent技术-阿里面试题 什么是类加载器类加载器与类的”相同“判断类加载器种类双亲委派模型类加载过程自定义类加载器JAVA热部署实现 SPI和Class.forName()：SPI使用的是本类加载器，是AppClassLoader，后者使用的Bootstrap ClassLoader 何时触发初始化1、为一个类型创建一个新的对象实例时（比如new、反射、序列化）2、调用一个类型的静态方法时（即在字节码中执行invokestatic指令）3、调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式4、调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）5、初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）6、JVM启动包含main方法的启动类时。 热部署步骤：1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；2、更新class3、使用新的ClassLoader去加载class JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）： 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法 详解Javac将java文件编译为class文件的过程https://blog.csdn.net/shaozengwei/article/details/38659569http://wiki.jikexueyuan.com/project/java-vm/polymorphism.htmlhttp://www.voidcn.com/article/p-dzpxhmqt-bnx.html Java 代码编译和执行的整个过程包含了以下三个重要的机制：1、Java 源码编译机制2、类加载机制3、类执行机制 Java 源码编译由以下三个过程组成：1、分析和输入到符号表2、注解处理3、语义分析和生成 class 文件 最后生成的 class 文件由以下部分组成：1、结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息。2、元数据。对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。3、方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。JVM 的类加载是通过 ClassLoader 及其子类来完成的：双亲委派模型1）Bootstrap ClassLoader负责加载$JAVA_HOME中jre/lib/rt.jar里所有的 class，由 C++ 实现，不是 ClassLoader 子类。 2）Extension ClassLoader负责加载Java平台中扩展功能的一些 jar 包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的 jar 包。 3）App ClassLoader负责记载 classpath 中指定的 jar 包及目录中 class。 4）Custom ClassLoader属于应用程序根据自身需要自定义的 ClassLoader，如 Tomcat、jboss 都会根据 J2EE 规范自行实现 ClassLoader。 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从 Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 Classloader 已加载就视为已加载此类，保证此类只所有 ClassLoade r加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 验证：验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。 初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 类执行机制JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。 编译过程java文件---》class文件：源代码、词法分析、语法分析、语法树、语义分析器、注解抽象语法树、字节码生成器，JVM字节码 Java 语法糖语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 https://my.oschina.net/hosee/blog/618953https://blog.csdn.net/u013256816/article/details/84917112https://blog.csdn.net/varyall/article/details/81283231https://blog.csdn.net/u010454030/article/details/82458413https://blog.csdn.net/qq_27093465/article/details/52279473 hashmap数据结构：线程不安全的，操作丢失put、remove等，扩容造成链表的闭环所致CPU 100%等线程不安全的，安全的有：hashtable、concurrenthashmapjdk7数组+链表，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式jdk8中链表变为红黑树结构，便于查询，JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看红黑树）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。JDK8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树因为在hash冲突严重的情况下，链表的查询效率是O(n），所以JDK8做了优化对于单个链表的个数大于8的链表，会直接转为红黑树结构算是以空间换时间，这样以来查询的效率就变为O(logN) 这个Entry应该放在数组的哪一个位置上（这个位置通常称为位桶或者hash桶，即hash值相同的Entry会放在同一位置，用链表相连），是通过key的hashCode来计算的。当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。 总结一下map.put后的过程：当hashCode 值相同时候，在本链表使用equals方法进行比较，都不相同时才放入数组中，并且next指向之前的链表当向 HashMap 中 put 一对键值时，它会根据 key的 hashCode 值计算出一个位置， 该位置就是此对象准备往数组中存放的位置。如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否是否值相同，map不允许键值对重复)， 如果此链上有对象的话，再去使用 equals方法进行比较，如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。值得注意的是，当key为null时，都放到table[0]中 ConcurrentHashMap扩容：默认16个Segment，在JDK7里面最大并发个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的，简化了并发设计，不足之处在于并发的粒度稍粗在JDK8里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的table元素的读写，好处在于并发的粒度更细，影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像JDK7中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点 如何实现一个并发情况下线程安全性的方案？加锁、排队、线程变量，原子变量threadlocal实现原理？如何实现线程安全？线程为单位隔离，是否会造成内存溢出？ https://blog.csdn.net/hellorichen/article/details/71107594java中一个线程等待另一个线程执行完后再执行：1.notify、wait方法，Java中的唤醒与等待方法，关键为synchronized代码块，参数线程间应相同，也常用Object作为参数2.CountDownLatch类：重要方法为countdown()与await()；一个同步辅助类，常用于某个条件发生后才能执行后续进程。给定计数初始化CountDownLatch，调用countDown(）方法，在计数到达零之前，await方法一直受阻塞。3.join方法：将线程B加入到线程A的尾部，当A执行完后B才执行。4.线程共享一个变量，根据变量状态来判断，类似CountDownLatch类的作用 http://www.importnew.com/14958.htmlhttps://blog.csdn.net/u012050154/article/details/50903326yield()方法：线程的优先权（高中低，1-10，并不是一定的，由调度程序决定哪一个线程被执行，相同优先级通常受时间片管制，但这并不是Java的要求。）：一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。join()方法：线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。 1、sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；2、sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；3、sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态； java基础知识掌握程度一般，对于Java 引用，堆外内存不了解，对于HashMap，线程池了解一点；对于LRU算法实现没有清晰思路；对于并发问题接触较少。 nio的代码，三个标识虚拟机：使用，看问题只有jre，没有jdk，可以设置dumpoutlog 如何快速定位JVM中消耗CPU最多的线程？1、首先我们可以通过top -Hp 来看这个进程里所有线程的 CPU 消耗情况，得到类似下面的数据。可以看到 cpu 最高的线程是 pid 为 18250 的线程，占了 99.8%：2、接着我们可以通过 jstack的输出来看各个线程栈：线程栈我们注意到 nid 的值其实就是线程 ID，它是十六进制的3、我们将消耗 CPU 最高的线程18250，转成十六进制0X47A，然后从上面的线程栈里找到nid=0X47A的线程，然后可以查看其堆栈信息 熟悉IO、多线程、集合理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发;4、熟悉多线程编程，熟练使用java并发包下的各项常用基础设施;5、熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务; 熟悉java concurrent包 ，熟悉高并发，分布式通信，存储等相关技术 扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术；1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；1、Java基础：概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO网络与文件、多线程、concurrent包并发、反射 SOA、环形缓冲区的实现原理（ring buffer）quickstart-disruptor 垃圾回收：垃圾收集算法、垃圾收集器，对象存活方式判断，类回收条件，堆（年轻代、年老代），java对象的引用（强引用，软引用，弱引用，虚引用）方法区垃圾回收：废弃常量、无用的类 finalize()方法不可靠表现2方面判断对象是否存活一般有两种方式、GC Roots包括 内存调优：减少youngGC的频率和fullGC的次数常见参数：废弃类回收的控制参数、堆参数（初始大小，最大大小、年轻代和年老代比例）、设置GC回收器，GC打印格式和文件、HeapDump日志路径、并行收集器设置查看垃圾回收和内存问题定位工具和步骤 类加载机制和双亲委派机制，类加载过程，java创建一个对象的流程类加载机制（双亲委派）：安全、缓存、高效，类加载过程：加载、验证、准备、初始化、卸载，4中类加载器，重写findClass是符合双拼委派机制，重写loadclass是破坏的， ClassLoader可以实现的功能：1、自定义加载类，实现切面功能、方法调用链、代码保护加解密等，如切面log日志，切面其他功能、2、系统开发模块化，比如阿里的jarslink、支付宝的sofaArk3、热部署功能、热加载 2、IO网络与文件BIO是面向流、阻塞IO，顺序读 NIO面向缓冲、非阻塞IO、选择器Selector，可以使用position等跳跃读 AIO 字节流和字符流 输入流、输出流 Channels：4种 Buffers：1+2+3+1 Selectors：4个事件 Buffer分配：3种 方法：常用的读写切换、定位等 buffer读写方法 Buffer的capacity,position和limit https://blog.csdn.net/Big_Blogger/article/details/77654240https://blog.csdn.net/Big_Blogger/article/details/77654240直接内存详解：分配和回收 直接内存：不受young gc的影响，只有full gc的时候回收，当众多的DirectByteBuffer对象从新生代被送入老年代后触发了 full gc才会会释放回收，MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。 （1）直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。（2）直接内存不是分配在JVM堆中。并且直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。（3）MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。 直接内存回收： 1、GC之后，“触发”调用Cleaner.clean() 方法，进而调用Deallocator.run() 在run方法中调用unsafe.freeMemory(long var1)释放堆外内存。 2、当然我也找到一种不需要GC回收由程序员自己回收的方式，不推荐使用((DirectBuffer)buffer).cleaner().clean(); 3、Unsafe进行分配和回收 网络： SocketChannel:创建连接，读写数据，从channel到buffer，从buffer到channel ServerSocketChannel:监听连接，默认是阻塞模式，可以设置为非阻塞模式（while循环） 零拷贝( zero-copy ) 文件IO：通过mmap实现的零拷贝I/O，内存映射文件：mmap()方法 网络IO：FileChannel.transferTo 和 FileChannel.transferFrom方法 零拷贝：减少内核态和用户态时的数据重复拷贝，java.nio.channel.FileChannel的transferTo()，transferFrom()方法 17、synchronized的缺陷：不中断，不并发读，不知道有没有成功获取到锁 Lock和synchronized对比：可重入，不中断，不公平，lock可中断、可公平，并发读，手动释放，是接口类 锁的分类和升级：可升不可降 sleep和wait区别：sleep不会释放对象锁，wait释放对象锁 线程的状态切换 总的来说, Lock + Condition + await()/signal/signalAll ≈ Synchronized + Object.wait()/notify/signalAll Condition原理：线程放入等待链表,可以实现“选择性通知”，而notify由JVM随机选择的 Java8中用sun.misc.Contended避免伪共享(false sharing)：https://blog.csdn.net/aigoogle/article/details/415183691、long padding来避免伪共享2、jdk8新特性，Contended注解避免false sharing：需要在jvm启动时设置-XX:-RestrictContended 动态代理和静态代理.md动态代理：cglib、jdk静态代理：javassist、AspectJ java se：单例锁的种类：可重入锁，阻塞锁，自旋锁：在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。关键字synchronized与wait()和notify()/notifyAll()方法相结合可以实现等待/通知模式。 Lock、Condition+await+signal/signalAllServlet、Filter、Listener线程池的参数、队列、流程、超时原理ExecutorService（ThreadPoolExecutor）：submit()、execute()Callable、Future、FutureTask、ExecutorCompletionService工具类Executorsunsafe的使用：直接内存分配、cas、park线程挂起和恢复ThreadLocal、InheritableThreadLocal GC日志分析工具：GCHistojava对象的引用包括：强引用，软引用，弱引用，虚引用Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。finalize()方法不可靠表现2方面判断对象是否存活一般有两种方式GC Roots包括？内存模型分代：年轻代（一个Eden区，两个Survivor区）、年老代、持久代（java8，元空间，本地内存）young GC、full GC垃圾收集算法：Copying（复制）、Mark-Sweep（标记-清除）、Mark-Compact（标记-整理）、Generational Collection（分代收集）垃圾收集器：串行Serial/Serial Old、Parallel、Parallel Old、并发标记CMS，G1CMS流程：初始标记、并发标记、重新标记、并发清楚，并发重置初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。其中的1，3两个步骤需要暂停所有的应用程序线程的 一致性哈希算法(consistent hashing)http://blog.csdn.net/cywosp/article/details/23397179/https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368https://blog.csdn.net/thinkmo/article/details/26833565一致性hash算法1、使用的MurMurHash算法，是非加密HASH算法，性能很高， 比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免） 等HASH算法要快很多，而且据说这个算法的碰撞率很低. http://murmurhash.googlepages.com/2、使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 把机器和对象使用相同的hash均衡分散到hash环上，对象顺时针放在距离自己最近的机器节点上平衡性：使用虚拟节点来保证，新增或者删除机器节点，对象平衡分散被影响，并且之后的对象依然平衡分散单调性：新增或者删除机器节点，只是影响相邻的部分对象，但按照顺时候移动，可能出现不平衡问题（使用虚节点）分散性：节点hash后分散 Object类的方法getClasshashcodeequalclone()toStringwaitnotifynotifyAllfinalize() Thread类：start、run、sleep、stopObject类：wait、notify、notifyAll，这三个方法都依赖锁对象，所对象可以是任意对象，所以定义在Object中 start()和run()的区别start():启动线程并调用线程中的run()方法。run():执行该线程对象要执行的任务 sleep()和wait()的区别sleep():不释放锁对象，释放CPU使用权在休眠的时间内，不能唤醒。wait():释放锁对象，释放CPU释放权，在等待时间内能被唤醒。 一个英文字母(不分大小写)或者符号占一个字节的空间，一个中文汉字或者符号占两个字节的空间． 字节(Byte):通常将可表示常用英文字符8位二进制称为一字节。 1字节(Byte） = 8位(bit) java常见异常http://blog.csdn.net/qq635785620/article/details/7781026NullPointerException - 空指针引用异常ClassCastException - 类型强制转换异常。IllegalArgumentException - 传递非法参数异常。ArithmeticException - 算术运算异常ArrayStoreException - 向数组中存放与声明类型不兼容对象异常IndexOutOfBoundsException - 下标越界异常NegativeArraySizeException - 创建一个大小为负数的数组错误异常NumberFormatException - 数字格式异常SecurityException - 安全异常UnsupportedOperationException - 不支持的操作异常 RuntimeException当应用程序试图在需要对象的地方使用 null 时，抛出NullPointerException异常当试图将对象强制转换为不是实例的子类时，抛出该异常（ClassCastException)指示索引或者为负，或者超出字符串的大小，抛出StringIndexOutOfBoundsException异常 Throwable、Error、Exception、RuntimeException 区别和联系各是什么 1.Throwable类是 Java 语言中所有错误或异常的超类。它的两个子类是Error和Exception；2.Error是Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。3.Exception类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件4.RuntimeException类是Exception类的子类。RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明。它是Exception的子类。 Exception：1．可以是可被控制(checked) 或不可控制的(unchecked)2．表示一个由程序员导致的错误3．应该在应用程序级被处理 Error：1．总是不可控制的(unchecked)2．经常用来表示系统错误或低层资源的错误3．如何可能的话，应该在系统级被捕捉 Java 中定义了两类异常：　　1) Checked exception: 这类异常都是Exception的子类 。异常的向上抛出机制进行处理，假如子类可能产生A异常，那么在父类中也必须throws A异常。可能导致的问题：代码效率低，耦合度过高。　　2) Unchecked exception: 这类异常都是RuntimeException的子类，虽然RuntimeException同样也是Exception的子类，但是它们是非凡的，它们不能通过client code来试图解决，所以称为Unchecked exception 。您应该知道的是Java 提供了两种Exception 的模式，一种是执行的时候所产生的Exception (Runtime Exception)，另外一种则是受控制的Exception (Checked Exception)。　　所有的Checked Exception 均从java.lang.Exception 继承而来，而Runtime Exception 则继承java.lang.RuntimeException 或java.lang.Error (实际上java.lang.RuntimeException 的上一层也是java.lang.Exception)。 因此从程序的运作机制上看，Runtime Exception与Checked Exception 不一样，然而从逻辑上看，Runtime Exception 与Checked Exception 在使用的目的上也不一样。　　一般而言，Checked Exception 表示这个Exception 必须要被处理，也就是说程序设计者应该已经知道可能会收到某个Exception(因为要try catch住) ，所以程序设计者应该能针对这些不同的Checked Exception 做出不同的处理。　　而Runtime Exception 通常会暗示着程序上的错误，这种错误会导致程序设计者无法处理，而造成程序无法继续执行下去。 讲一下 RunTimeException 的造成的原因「非检查型异常」，并说一下为什么不处理 RunTimeException？ RuntimeException是Exception子类。而Exception还有其它类型的异常，我们统一称为非Runtime异常。 RuntimeException的特点是非检查型异常，也就是Java系统中允许可以不被catch，在运行时抛出。而其它定非运行时异常如果抛出的话必须显示的catch，否则编译不过。 RuntimeException常见异常： 1 NullPointerException，空指针异常。 2 NumberFormatException，字符串转化成数字时。 3 ArrayIndexOutOfBoundsException， 数组越界时。 4 StringIndexOutOfBoundsException， 字符串越界时。 5 ClassCastException，类型转换时。 6 UnsupportedOperationException，该操作不支持，一般子类不实现父类的某些方法时。 7 ArithmeticException，零作为除数等。 8 IllegalArgumentException，表明传递了一个不合法或不正确的参数 运行时出现错误，说明你的代码有问题，程序已经无法继续运行，所以对RuntimeException的处理时不必要的。之所以不处理，目的就是要是程序停止，修正代码。 参考 http://blog.csdn.net/liuj2511981/article/details/8524418http://blog.csdn.net/kingzone_2008/article/details/8535287http://blog.csdn.net/kwu_ganymede/article/details/51382461 Comparable与Comparator的区别http://www.importnew.com/17434.htmlComparable：bean实现该接口，//Collections.sort(list)（Arrays.sort）; 两种方式都可以，此种方式源码中就是调用的list.sort(null)Comparator：bean不需要实现该接口，直接当做实现传递给Collections.sort(list)（Arrays.sort）Collections.sort(list, new Comparator() { @Override public int compare(Employee o1, Employee o2) { return o1.getSalary() - o2.getSalary(); } }); 一、Comparator强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。接口方法： int compare(Object o1, Object o2); 二、Comparable强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。接口方法： int compareTo(Object o);Comparable的用法一般来说，Comparable是为了对某个类的集合进行排序，所以此时一般都是这个需要排序的类本身去实现Comparable接口。换句话说，如果某个类实现了Comparable接口，那么这个类的数组或者说List就可以进行排序了。 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用：1、类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身2、可以使用多种排序标准，比如升序、降序等 Comparable & Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序， Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。 对Runtime的了解:Runtime类Runtime:运行时，是一个封装了JVM的类。每一个JAVA程序实际上都是启动了一个JVM进程，每一个JVM进程都对应一个Runtime实例，此实例是由JVM为其实例化的。所以我们不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。查看官方文档可以看到，Runtime类中没有构造方法，本类的构造方法被私有化了， 所以才会有getRuntime方法返回本来的实例化对象，这与单例设计模式不谋而合public static Runtime getRuntime() 注意：Runtime类本身就是单例设计模式的一种应用，因为整个JVM中只存在一个Runtime类的对象，可以使用Runtime类取得JVM的系统信息，或者使用gc()方法释放掉垃圾空间，还可以运行本机的程序run.exec(\"notepad.exe\")exec()方法的返回值是Process类，Process类也有一些方法可以使用，比如结束一个进程，通过destroy()结束 什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？http://blog.csdn.net/ls5718/article/details/51896159死锁检测：http://blog.csdn.net/littleschemer/article/details/47449911https://www.cnblogs.com/lovedesy123/p/7752077.html死锁的定义多线程以及多进程改善了系统资源的利用率并提高了系统 的处理能力。然而，并发执行也带来了新的问题——死锁。所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 互斥锁(mutex)Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。 二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。 死锁产生的原因产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。1、互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。2、不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。3、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。4、循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有，如图2-15所示。 如何避免死锁在有些情况下死锁是可以避免的。三种用于避免死锁的技术：1、加锁顺序（线程按照一定的顺序加锁）【破坏循环等待条件】2、加锁时限、或 一次加锁所有的资源（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题【破坏请求保持条件】3、使用锁等待机制：Java 显示锁支持通知(notify/notifyall)和等待(wait)【破坏不可剥夺条件】3、死锁检测一个简单的死锁检测算法每个进程、每个资源制定唯一编号设定一张资源分配表，记录各进程与占用资源之间的关系设置一张进程等待表，记录各进程与要申请资源之间的关系 死锁恢复打破死锁有两种方法：（1）简单地终止一个或多个进程以打破循环等待。——进程终止（2）从一个或多个死锁进程那里抢占一个或多个资源。——资源抢占进程终止有以下两中方法：（i）终止所有死锁进程。（II)一次只终止一个进程直到取消死锁循环为止。如果选择资源抢占，那么将必须考虑三个问题：（i）选择一个牺牲品（II）回滚（III）饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品） jstack可以看到Found one Java-level deadlockpstack： 功能是打印输出此进程的堆栈信息。可以输出所有线程的调用关系栈jstack：jstack是java虚拟机自带的一种堆栈跟踪工具，所以仅适用于java程序，功能跟pstack一样，但是更强大，可以提示哪个地方可能死锁了。 pstack和jstack判断死锁，都需要多执行几次命令，观察每次的输出结果，才能推测是否死锁了。 java进程间通信(IPC interProcess communication)：除了上面提到的Socket之外，当然首选的IPC可以使用Rmi，或者Corba也可以。另外Java nio的MappedByteBuffer也可以通过内存映射文件来实现进程间通信(共享内存)。远程过程调用（Remote Procedure Call, RPC）远程方法调用（Remote Method Invocation, RMI） 在java中主要的通信方式有以下几种：1、socket通信2、RMI（远程方法调用）3、消息队列（第三方框架Kafka，ActiveMQ等）4、JMX（java management extensions）java扩展管理5、文件共享，文件锁（一个进程向文件中写文件，一个负责读文件）6、信号 7、信号量 java进程CPU过高问题如何排查？一般JAVA进程CPU过高主要是程序中出现了死循环，死循环会导致两种情况：第一种，死循环本身不需要耗费太多CPU时间，但会不停创建对象，从而导致java堆内存溢出，但有时候内存快占满了，没有报内存移除错误，JVM在不停的做FGC，从而出现CPU使用超过100%；第二种情况，就是死循环内有请求资源或者网络连接等操作； 第一种情况需要dump出当前jvm内存对象进行分析，找到导致JVM频繁做FGC的对象，再结合业务代码定位具体代码位置；第二种情况需要查找占用cpu时间的线程，根据线程代码提示定位具体出问题的代码。 第一种情况分析方法： 通过top命令查看当前系统CPU使用情况，定位CPU使用率超过100%的进程ID； jstat -gc pid time 命令查看JVM垃圾回收情况，time参数是统计频率，一般1-3秒都可以，若出现频繁的FGC，则需要进一步分析内存情况； 用命令jmap -dump:format=b,file=test.dump pid导出当前进程内存信息，然后用MAT工具进行分析，即可找出问题； 第二种情况的分析方法： 通过top命令查看当前系统CPU使用情况，定位CPU使用率超过100%的进程ID； 通过ps aux | grep PID命令进一步确定具体的线程信息； 通过ps -mp pid -o THREAD,tid,time命令显示线程信息列表，然后找到耗时的线程ID； 将需要的线程ID转换为16进制格式：printf \"%x\\n\" tid 最后找到线程堆栈信息：jstack pid |grep tid -A 30,其中tid是上面转换后的16进制的线程ID这样就找到了最终导致CPU100%的代码了，然后就是对具体的代码分析原因。 volatile原理：http://blog.csdn.net/opensure/article/details/46669337Java中Volatile底层原理与应用：内存屏障http://blog.csdn.net/u012465296/article/details/53020676volatile是一种“轻量级的锁”，它能保证锁的可见性，但不能保证锁的原子性。 http://ifeve.com/memory-barriers-or-fences/内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。Java内存模型中volatile变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。 缓存一致性：http://www.infoq.com/cn/articles/cache-coherency-primerhttp://www.infoq.com/cn/articles/atomic-operations-and-contentionMESI－CPU缓存一致性协议：http://blog.csdn.net/realxie/article/details/7317630volatile使用场景：Double-Check Locking，缓存对象的map等（不保证原子性，使用在并发环境下的原子操作情况下）一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。3）并发编程中的三个概念：原子性，可见性，有序性，volatile只保证可见性和有序性，不保证原子性1、CPU的三级缓存，volatile的缓存失效是指的cpu的二级缓存，CPU的三级缓存：一级在CPU内部，容量小，速度快，二级是在CPU和内存之间的，当线程需要读取数据时候，先读取缓存，不存在才读取内存数据，三级缓存是对二级缓存的补充。2、普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前可以立即从内存刷新，即一个线程修改了某个变量的值，其它线程读取的话肯定能看到新的值；3、Lock前缀指令会引起处理器缓存回写到内存。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。1）将当前处理器缓存行的数据会写回到系统内存。它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。2）这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。关键点：其实相当于线程 像缓存行写数据的时候，会锁住缓存行，是其他线程不能读，写完后失效缓存行，其他线程便可以从内存读到共享变量的最新值了；4、如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 当CPU看到一条读内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段。如果没有，它会把整个缓存段从内存（或者从更高一级的缓存，如果有的话）中加载进来。是的，一次加载整个缓存段，这是基于这样一个假设：内存访问倾向于本地化（localized），如果我们当前需要某个地址的数据，那么很可能我们马上要访问它的邻近地址。一旦缓存段被加载到缓存中，读指令就可以正常进行读取。 如果我们只处理读操作，那么事情会很简单，因为所有级别的缓存都遵守以下规律，我称之为：基本定律：在任意时刻，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。一旦我们允许写操作，事情就变得复杂一点了。这里有两种基本的写模式：直写（write-through）和回写（write-back）。 直接模式更简单，但是回写模式有它的优势：它能过滤掉对同一地址的反复写操作，并且，如果大多数缓存段都在回写模式下工作，那么系统经常可以一下子写一大片内存，而不是分成小块来写，前者的效率更高。 不同的级别缓存可能使用不同的写策略，所以缓存行大小也可能不同。 MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。MESI协议（译者注：MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态失效（Invalid）缓存段、共享（Shared）缓存段、独占（Exclusive）缓存段、已修改（Modified）缓存段，属于脏段只有E、M状态下的缓存才能写，也就是在写之前，先申请独占，使其他的CPU的同段缓存失效 1、缓存行：所谓缓存行就是缓存中可以分配的最小存储单位。一般是64字节，老的是32字节如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽缓存是分“段”（line）的，一个段对应一块存储空间，大小是32（较早的ARM、90年代/2000年代早期的x86和PowerPC）、64（较新的ARM和x86）或128（较新的Power ISA机器）字节。我们会看到有CPU的一级缓存是32字节，而二级缓存却有128字节。2、缓存伪共享：因为对于英特尔酷睿i7，酷睿， Atom和NetBurst， Core Solo和Pentium M处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，导致一个缓存行加载多个共享变量，一个处理器锁定时，锁定该缓存行时候，多锁定了对象，导致其他处理器处理不了，变为锁的互斥性，导致不能并发，成为伪共享如JDK7的并发包里新增一个队列集合类LinkedTransferQueue（它使用一个内部类类型来定义队列的头队列（Head）和尾节点（tail）），JDK加载时候会把头尾分别进行字节填充，保证头尾加载到不同的缓存行，避免出入对互斥，不能并发，成为伪共享。Java8中用sun.misc.Contended避免伪共享(false sharing)：https://blog.csdn.net/aigoogle/article/details/415183691、long padding来避免伪共享2、jdk8新特性，Contended注解避免false sharing：需要在jvm启动时设置-XX:-RestrictContended3、CPU处理器的缓存三级：L1、L2、L3，最早CPU和L1通信，L1和内存通信，现在CPU--》L1--》L2--》内存L1　Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，容量小L2 Cache 都在CPU中L3　Cache(三级缓存)，分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。降低内存延迟和提升大数据量计算能力对游戏都很有帮助。4、缓存一致性协议MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。MESI协议（译者注：MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态失效（Invalid）缓存段、共享（Shared）缓存段、独占（Exclusive）缓存段、已修改（Modified）缓存段，属于脏段只有E、M状态下的缓存才能写，也就是在写之前，先申请独占，使其他的CPU的同段缓存失效 缓存段竞争：要产生缓存段竞争，我们需要多个处理器频繁访问同一缓存段，并且其中部分的访问是写操作。如果两个或多个处理器频繁地访问相同的缓存段，那么这些缓存段的内容必须保持同步。如果想更新其中一个缓存段的内容，必须先获得独占权，这意味着其他所有处理器必须先丢弃它们缓存中的同一缓存段的拷贝。这带来的结果是，下一次有另外一个处理器要访问这个缓存段，它的内容必须先通过总线来加载。所以结果就是缓存失效率（对于其他处理器来说）和总线上额外的通讯流量都增加了。这种多个处理器访问一个频繁被更新的缓存段的现象，叫做“缓存（段）竞争”。如果你想在多个处理器共用内存的环境中拖慢一个并行的程序，这也许是最简单的方法。总线风暴：总线上额外的通讯流量增加很多 数据结构：堆和树http://blog.csdn.net/juanqinyang/article/details/51418629http://blog.csdn.net/leex_brave/article/details/51490647堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。堆优先顺序就是大的元素排在前面，小的元素排在后面，这样得到的堆称为最大堆。最大堆中堆顶的元素是整个堆中最大的，并且每一个分支也可以看成一个最大堆。同样的，我们可以定义最小堆， 树：树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。http://blog.jobbole.com/111680/http://blog.csdn.net/HaoDaWang/article/details/78065162?locationNum=2&fps=1 1二叉树：每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。2满二叉树：一个深度为k(>=-1)且有2^(k+1) - 1个结点的二叉树称为满二叉树。3完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。4平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。平衡查找树之AVL树平衡二叉树之红黑树B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。B+树是B树的变体，也是一种多路搜索树，叶子节点指向下一个叶子节点B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。 Queue队列的常用方法Queue方法：add、remove、element 抛异常offer、poll、peek 返回booleanput、take 阻塞 队列：FIFO，栈：FILO 数组、链表，队列 ，栈，散列表，树，图：http://blog.csdn.net/mz454619501/article/details/46652317http://blog.csdn.net/hhu1506010220/article/details/52128383http://blog.csdn.net/wei78008023/article/details/50735415http://blog.csdn.net/qq_15654993/article/details/75267581http://blog.csdn.net/RodeStillFaraway/article/details/50530142常用数据结构的时间复杂度：http://blog.csdn.net/CloudyBird/article/details/51206789数组Array：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的链表Linked List：非连续非顺序的存储结构，循环链表和单链表、双向链表，链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。队列Queue：FIFO，顺序队列和循序队列栈Stack：FILO散列表Hash表:树Tree：树（tree）是包含n（n>0）个结点的有穷集堆Heap：图Graph： 访问数组中第 n 个数据的时间花费是 O(1) 但是要在数组中查找一个指定的数据则是 O(N)。当向数组中插入或者删除数据的时候，最好的情况是在数组的末尾进行操作，时间复杂度是O(1) ，但是最坏情况是插入或者删除第一个数据，时间复杂度是 O(N) 。在数组的任意位置插入或者删除数据的时候，后面的数据全部需要移动，移动的数据还是和数据个数有关所以总体的时间复杂度仍然是 O(N) 。 在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ，但是插入和删除数据的时间复杂度是 O(1) ，因为只需要调整指针就可以 基本概念 程序 = 算法 + 数据结构 数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。 常见数据结构 集合：set，multiset 线性结构：数组、链表、队列、栈 树形结构：二叉树及其变型，线段树 图形结构：各种图 数据结构体系图： Java线程的5种状态及切换(透彻讲解)https://www.cnblogs.com/nwnu-daizh/p/8036156.htmlhttp://blog.csdn.net/pange1991/article/details/53860651 新建-->就绪-->运行-->死亡（start(),获取cpu时间片,run/main结束）运行-->阻塞-->就绪-->运行（sleep、t2.join、等用户输入，3中阻塞条件结束，获取cpu时间片）运行-->等待队列-->锁池队列-->就绪（wait()+notify/notifyAll、synchronized(obj) ）运行-->就绪（yield()、时间片用完） 在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，让出cpu该其他线程，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 Linux探秘之用户态与内核态 https://blog.csdn.net/qq_39823627/article/details/78736650https://blog.csdn.net/qq_42022528/article/details/87860311https://www.jianshu.com/p/85e931636f27https://www.cnblogs.com/xuhj001/p/3374440.html用户态和内核态的理解和区别： 执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。比如linux进程有4GB地址空间，可能0G-3G是用户空间，3G-4G大部分是共享的，是内核态的地址空间。这里存放整个内核的代码和所有的内核模块以及内核所维护的数据。 用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。 用户态和内核态的区别：1、特权等级不同，安全2、集中管理，减少有限资源的访问和使用冲突 内核态：硬盘读取数据, 网络数据发送、或者从键盘获取输入等CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序 用户态只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 :用户态 和 内核态 用户态和内核态的切换：当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果 用户态切换到内核态的3种方式：系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。（1）系统调用：fork（）等（2）异常：如缺页异常（3）外围设备的中断 Linux探秘之用户态与内核态https://www.cnblogs.com/bakari/p/5520860.htmlhttps://www.cnblogs.com/yuyang0920/p/7278446.htmlhttp://blog.csdn.net/benjamin721/article/details/51316596http://blog.csdn.net/ljlstart/article/details/51279184http://blog.csdn.net/u014142287/article/details/51934940 Linux零拷贝zero-copy技术：减少数据在内核和用户空间之间拷贝次数https://www.jianshu.com/p/fad3339e3448https://www.cnblogs.com/metoy/p/4033366.htmlhttp://blog.csdn.net/hzrandd/article/details/51025341http://blog.csdn.net/linsongbin1/article/details/77650105当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上。 减少拷贝次数的一种方法是调用mmap()来代替read调用应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。 内存映射文件File Mapping在大文件或者非常频繁的文件操作中内存映射文件性能较高的原因http://blog.csdn.net/whoamiyang/article/details/53365385https://www.oschina.net/translate/10-things-to-know-about-memory-mapped-file-in-javahttps://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6 内存映射文件的效率原因是read()是系统调用，其中进行了数据 拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，如图2中过程1，然后再将这些数据拷贝到用户空间，如图2中过程2，在这个过程中，实际上完成 了两次数据拷贝 ；而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 一次数据拷贝 。因此，内存映射的效率要比read/write效率高。 数据共享编辑文件数据共享这种数据共享是让两个或多个进程映射同一文件映射对象的视图，即它们在共享同一物理存储页。这样，当一个进程向内存映射文件的一个视图写入数据时，其他的进程立即在自己的视图中看到变化。注意，对文件映射对象要使用同一名字。访问方法这样，文件内的数据就可以用内存读/写指令来访问，而不是用ReadFile和WriteFile这样的I/O系统函数，从而提高了文件存取速度。 为什么使用缓冲区读取文件会比不使用快:原因是每次进行IO操作,都要从用户态陷入内核态,由内核把数据从磁盘中读到内核缓冲区,再由内核缓冲区到用户缓冲区,如果没有buffer，读取都需要从用户态到内核态切换，而这种切换很耗时，所以，采用预读，减少IO次数，如果有buffer,根据局部性原理,就会一次多读数据,放到缓冲区中,减少了IO次数. pageCachehttps://blog.csdn.net/iter_zc/article/details/44195731https://blog.csdn.net/kisimple/article/details/42559779 String StringBuffer,StringBuilder原理 String对象有final修饰，是不可变的，也可以理解为常量，显然是线程安全的。 StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。 　　抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。 　　StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。 　　最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 因为StringBuilder是线程不安全的，直接调用了父类的方法，而StringBuffer中每个方法都加了synchronized，保证了线程安全，其他全部一样。 StringBuffer与Stringbuilder用法完全相同，但是StringBuffer的线程是安全的，执行速度慢，StringBuilderd执行速度快，线程不安全，遇到多线程时，用StringBuffer。 StringBuffer与StringBilder使用时都不改变字符串的地址。 String使用时改变字符串地址。 因为String是一个不可变的字符串，每次追加会生成一个新字符串，在最新的jdk中 + 也是调用StringBuilder来实现的 而StringBuffer和StringBuilder是在原基础上追加。 本身都是通过字符数组来存储，对象内部定义字符数组String：new是放在堆区，+或者substring都是通过改变字符数组生成新的字符数组来实现一个是非同步的StringBuilder，一个是同步的StringBuffer（synchronized在方法上），都是字符数组，append时先扩容，把字符数组拷贝到一个新的大的字符数组，再进行拼接，还是拼接拷贝到一个新的字符数组， https://blog.csdn.net/qq_42022528/article/details/87860311 线程状态切换的代价： 因为线程切换也是需要时间的，就跟自旋锁和互斥锁的效率一样，线程睡眠和唤醒也是需要时间和消耗资源的。 java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。 synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。所以明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Java/JavaSE/IO.html":{"url":"Books/tech/Java/JavaSE/IO.html","title":"I/O","keywords":"","body":"I/O BIO,NIO,AIO 总结 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Java/JavaSE/Java8.html":{"url":"Books/tech/Java/JavaSE/Java8.html","title":"Java8","keywords":"","body":"Java8 Java 8 新特性总结 Java 8 学习资源推荐 Java8 forEach 指南 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Java/JavaSE/读书和笔记.html":{"url":"Books/tech/Java/JavaSE/读书和笔记.html","title":"读书和笔记","keywords":"","body":"读书和笔记 Java 编程规范以及优雅 Java 代码实践总结 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Framework/Framework.html":{"url":"Books/tech/Framework/Framework.html","title":"常用框架","keywords":"","body":"常用框架 1、 2、 3、 4、 5、 Disruptor 无锁队列Disruptor Guava Guava工具类 apache-commons框架 apache-commons学习.md Servlet Servlet3异步NIO Guice 依赖注入框架 Crypto 加解密工具 字节码框架ASM 字节码修改工具 jOOQ Object Oriented QueryingjOOQ面向对象查询 quickstart-jool jOOλ，Java lambdas和Stream APIquickstart-joor jOOR - 更好地进行Java反射。quickstart-joou jOOU - 无符号整数，Object Oriented Unsigned无符号的quickstart-joox jOOX - 应用于W3C DOM的jQuery的强大功能 logging框架 日志框架：logback、log4j2、log4j、jul JSON框架 json工具：fastjson、Gson、jackson等 Reflect反射 Java反射框架：reflections等 YAML框架 yaml文件解析 XML框架 quickstart-xbean java XML解析 quickstart-xml quickstart-xmlbeans JVM序列化框架 JVM序列化工具：jdk、fst、kryo、hession、thrift等 String字符串压缩 字符串压缩 FastDFS FastDFS是一个开源的分布式文件系统 Quartz Quartz是一个开源的作业调度框架 JFinal JAVA 极速WEB+ORM框架 JFinal UUID UUID工具类 Objenesis框架 Objenesis是一个专用于在创建对象时绕过构造函数的库。在任何JVM上都有。 Proxy代理 动态代理和静态代理，Java Agent，字节码工具等 Java和Kotlin、Groovy、Scala的代码和相互调用 其他语言： Java和Kotlin、Groovy、Scala的代码和相互调用 /Users/yangzl/git/quickstart-framework/quickstart-kotlin quickstart-groovy quickstart-kotlin quickstart-scala 其他框架 quickstart-lombok lombok框架 quickstart-elastic-job Elastic-Job 是一个分布式调度解决方案 quickstart-hppc Java集合类扩展 quickstart-websocket websocket协议使用 quickstart-velocity Velocity是一个基于Java的模板引擎 quickstart-jgit Java git工具 quickstart-jython Jython是一种完整的语言，而不是一个Java翻译器或仅仅是一个Python编译器，它是一个Python语言在Java中的完全实现。 quickstart-jctools JCTools是一款对jdk并发数据结构进行增强的并发工具，主要提供了map以及queue的增强数据结构。 quickstart-machine-learning 机器学习相关 quickstart-mnemonic Apache Mnemonic 是一个面向非易失性混合内存存储的库，它提出了一个非易失性/持久的 Java 对象模型和持久的计算服务，能显着提高了海量实时数据处理/分析的性能。 quickstart-web JavaWeb框架 quickstart-proguard Java混淆器 ProGuard，我们通常说的proguard包括四个功能，shrinker（压缩）, optimizer（优化）,obfuscator（混淆）,preverifier（预校验）。 lintcode等： quickstart-code lintcode等刷题、剑指Offer 微服务、Web框架 quickstart-dropwizard Dropwizard与Spring Boot类似，也是构建微服务可选的工具 quickstart-plexus Plexus——Spring之外的IoC容器 quickstart-servicecomb ServiceComb 是华为开源的一套包含代码框架生成，服务注册发现，负载均衡，服务可靠性（容错熔断，限流降级，调用链追踪）等功能的微服务框架。 apache-commons学习.md 常用刷题网站和博客.md 剑指Offer学习 2、Disruptor学习.md 无锁队列Disruptor 3、Guava学习.md 4、javaSE基础知识点 quickstart-javase 5、JSON框架学习 quickstart-json 6、Linux学习 quickstart-linux 7、日志框架 quickstart-logging 8、Lua学习.md 9、java代理学习 quickstart-proxy 动态代理和静态代理的区别 静态代理优缺点 动态代理优缺点 cglib和Jdk动态代理的区别 10、java Servlet学习 quickstart-servlet 11、javaWeb学习 quickstart-web 12、 熟悉分布式、缓存、消息队列等中间件技术熟悉常用设计模式熟悉并对javaEE、SOA、spring、osgi等技术潮流保持关注，有数据库、分布式、性能优化、高并发、高可用性系统设计开发经验 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/MQ消息.html":{"url":"Books/tech/MQ/MQ消息.html","title":"MQ消息组件","keywords":"","body":"MQ消息 1、RocketMQ 2、ActiveMQ 3、Kafka 4、RabbitMQ 5、MQTT 6、OpenMessaging activemq-apollo 支持STOMP协议，已经废弃 RocketMQ 消息类型： 从通讯方式：同步、异步、oneway 普通消息tag消息顺序消息事务消息延时消息（定时消息）优先级消息（activemq） RocketMQ系统部署架构：Namesrv 和 Broker（Master、Slave）RocketMQ生产者模型、消费者模型RocketMQ存储模型:offset-->commitlog-->mmap 生产者发送流程发送普通消息负载发送顺序消息发送事务消息 Broker：broker消息存储过程、创建文件机制、刷盘机制broker查找消息过程如果想把一台broker下掉，但不能影响线上消息。RocketMQ的文件 主题和消息：消息发送到消费流程消息重复原因和消费幂等的必要性线上关闭Topic自动创建事务消息流程 消费者问题：1、多个消费者只有一个消费者消费：instanceId相同的问题2、全新的消费组第一次上线，设置从尾部开始消费，但是实际从头开始消费，如果是老的消费组重新上线，就从上次消费过的位置继续消费3、消费组中的消费者负载均衡4、 RocketMQ和kafka的区别RocketMQ和ActiveMQ的区别常见问题 ActiveMQ JMS的基本组成：ConnectionFactory，Connection，Session，Destination（queue，topic），Producer，Consumer，Message（TextMessage、MapMessage、BytesMessage、StreamMessage和ObjectMessage） JMS规范JMS消息组成：JMS消息由3部分组成：消息头、属性和消息体 Activemq的同步和异步消息ActiveMQ顺序消息：consumer之独有消费者（exclusive consumer）、 Message Groups特性 activemq开启jmx监控ActiveMQ的共享文件方式部署手册LevelDB部署 Kafka Kafka生产、保存、消费流程Kafka在zk上注册的节点Producer和Consumer说明.mdkafka架构内部原理查找消息同一分区消息乱序 RabbitMQ MQTT OpenMessaging 参考消息分类ActiveMQ学习RocketMQ学习Kafka学习 Rocketmq原理https://blog.csdn.net/wuzhengfei1112/article/details/78076718 Activemq和Rocketmq：实现的协议：存储消息的方式和处理：生产端和消费端 activemq、Rocketmq、rabbitmq、 自己做的消息组件框架的封装模式？为什么这么做？封装了哪些消息中间件，各个消息中间件的原理，区别？主题、队列等怎么统一适配？封装了哪些功能？服务端？客户端？一般用什么消息组件？为什么？遇到有什么问题？rocketmq数据存储方式：数据头+消息体，根据消息头判断读取多大的消息体先读取固定长度的消息头，消息头中含有消息体的大小，再从消息头开始往后读取消息体大小的数据作为消息体内容内存映射文件作用：效率，安全不丢失 消息中间件：openmq、zeromq、hivemq、hornetq、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/Pulsar.html":{"url":"Books/tech/MQ/Pulsar.html","title":"Pulsar","keywords":"","body":"Pulsar Pulsar是一个分布式pub-sub消息平台，具有非常灵活的消息传递模型和直观的客户端API。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/Jafka.html":{"url":"Books/tech/MQ/Jafka.html","title":"Jafka","keywords":"","body":"Jafka 一个快速，简单的分布式发布-订阅消息系统（mq） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/OpenMessaging.html":{"url":"Books/tech/MQ/OpenMessaging.html","title":"OpenMessaging","keywords":"","body":"OpenMessaging 云原生，与供应商无关的开放式规范，用于分布式消息传递 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/OpenMQ.html":{"url":"Books/tech/MQ/OpenMQ.html","title":"OpenMQ","keywords":"","body":"OpenMQ Open-MQ 是一个开源的消息中间件，类似IBM的 WebSphere MQ(MQSeries)，采用 C++ 和 Qt 库编写的，支持Windows、Unix 以及 Mac OS 平台，支持 JMS。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/ZeroMQ.html":{"url":"Books/tech/MQ/ZeroMQ.html","title":"ZeroMQ","keywords":"","body":"ZeroMQ ZeroMQ（简称ZMQ）是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/HiveMQ.html":{"url":"Books/tech/MQ/HiveMQ.html","title":"HiveMQ","keywords":"","body":"HiveMQ HiveMQ的MQTT代理使以高效，快速和可靠的方式轻松地在连接的设备之间来回移动数据。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/HornetQ.html":{"url":"Books/tech/MQ/HornetQ.html","title":"HornetQ","keywords":"","body":"HornetQ HornetQ是一个开放源代码项目，用于构建多协议，可嵌入，非常高性能的集群异步消息传递系统。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/Artemis.html":{"url":"Books/tech/MQ/Artemis.html","title":"Artemis","keywords":"","body":"Artemis 高性能，无阻塞的体系结构，用于下一代事件驱动的消息传递应用程序。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/MQ/Nanomsg.html":{"url":"Books/tech/MQ/Nanomsg.html","title":"Nanomsg","keywords":"","body":"Nanomsg nanomsg是一个消息通信组件 - zeromq的作者之一用C语言重写的通信框架， Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/RPC/Remoting和RPC框架.html":{"url":"Books/tech/RPC/Remoting和RPC框架.html","title":"远程通讯和RPC框架","keywords":"","body":"远程通讯RPC 1、Netty框架 2、Dubbo框架 3、 Netty框架 Java NIO的实现，文件和内存的读写，网络IO的实现 看过nio的源码吗？bytebuffer的使用，写读容量参数 Netty学习 netty概念和常用类：group、channel、handler、optionnetty执行流程：拆包、解码、封装对象Server端Boss线程和worker线程比较：boss设置为1，监听端口的netty两种线程模型和JDK线程池模型比较Netty的高性能及NIO的epoll空轮询bug：判定和解决：重建selectorTCP粘包/拆包与Netty解决方案：4种：分隔符，回车换行分隔符，定长报文，消息头和消息体netty的网络创建在哪里java nio的selector 和linux的epoll select netty小对象、大对象的管理 netty执行流程Server端Boss线程和worker线程比较：boss设置为1，我猜测是为了减少线程切换，因为处理事情比较简单，不耗费时间netty两种线程模型和JDK线程池模型比较Netty的高性能及NIO的epoll空轮询bugTCP粘包/拆包与Netty解决方案：netty的网络创建在哪里java nio的selector 和linux的epoll selectJava异步NIO框架Netty实现高性能高并发： netty高性能 传输：异步非阻塞通信、零拷贝（直接内存和transferTo）、线程池、灵活的TCP参数配置能力（option参数的设置） 协议：Protobuf的支持、Thrift的 线程：高效的Reactor线程模型、无锁化的串行设计理念：Netty的NioEventLoop是单线程的 Java异步NIO框架Netty实现高性能高并发：netty高性能传输：异步非阻塞通信、零拷贝（直接内存和transferTo）、灵活的TCP参数配置能力（option参数的设置）协议：多种序列化协议，Protobuf的支持、Thrift的线程：高效的Reactor线程模型、线程池、无锁化的串行设计理念：Netty的NioEventLoop是单线程的内存：内存池化，各种不同大小对象管理：三种大小对象类型 Netty实现原理netty的相关所有，使用的协议hession用来干嘛的：Hessian本身即是基于Http的RPC实现Java序列化和Hessian序列化的区别netty的相关，管道是什么设计模式：责任链模式 或者 管道设计模式 Netty零拷贝Netty内存管理：堆外内存池 使用Handler的注意事项 netty的Channel的ID值可以通过调用 Channel.id() 获取Channel的ID值。 全局唯一的channel ID每个 Channel 都会有一个全局唯一的ID，生成规则如下：MAC 地址(EUI-48 or EUI-64)，最好是全局唯一的当前进程IDSystem#currentTimeMillis()System#nanoTime()32-bit的随机integer序列化递增的32-bit integer. netty框架的了解？boss线程，work线程数主要接口有哪些？源码使用流程？ Dubbo框架 dubbo的长连接池，如果出现网络抖动，会怎么处理？Dubbo超时机制导致的雪崩连接 1、remoting：netty、mina、grizzy、xsocketrpc：dubbo、grpc、 RPC框架：dubbo、grpc、finagle、single-jdk实现、thrift、jupiter、tars、远程调用：grizzly、hessian、mina、netty、t-io网关：kong、litte-proxy、nginx、tengine 远程通讯调用框架/Users/yangzl/git/quickstart-remoting/docs quickstart-netty quickstart-mina quickstart-hessian quickstart-t-io quickstart-xsocketquickstart-grizzly /Users/yangzl/git/quickstart-rpc/docs/Users/yangzl/git/quickstart-remoting/docs/netty/Netty学习.md 2、调用链的TraceID是怎么传递的？怎么串起来的？放在请求头中：TraceID，SpanID，ParentSpanID，是否抽样Sampled（设置百分比）等3、评论系统的数据库设计？4、dubbo访问超时是怎么处理的？超时自动重试， 如何实现负载均衡,有哪些算法可以实现?http://blog.csdn.net/zgwangbo/article/details/51533657https://www.cnblogs.com/szlbm/p/5588555.htmlhttp://blog.csdn.net/mengdonghui123456/article/details/53981976http://blog.csdn.net/zhoudaxia/article/details/23672319 均衡算法主要解决将请求如何发送给后端服务。经常会用到以下四种算法：随机法（Random）、轮询法（Round Robin）、一致哈希（consistent-hash）和主备（master-slave）。、加权随机（Weight Random）法、、加权轮询（Weight Round Robin）法、源地址哈希（Hash）法、最小连接数（Least Connections）法、 对于RPC应用高性能的三个主题永远是IO模型、数据协议、线程模型。 netty介绍http://blog.csdn.net/haoyuyang/article/details/53243785http://ifeve.com/netty5-user-guide/ Netty IO模型netty是一个流行的NIO的框架JDK1.4提供了对非阻塞IO（NIO）的支持，JDK1.6版本使用epoll替代了传统的select/poll，极大的提升了NIO通信的性能 在*nix中将IO模型分为5类。Blocking I/ONonblocking I/OI/O Multiplexing (select and poll)Signal Driven I/O (SIGIO)Asynchronous I/O (the POSIX aio_functions) TCP粘包、拆包问题解决方案：①消息定长，例如每个报文的大小固定为200个字节，如果不够，空位补空格。②在包尾部增加特殊字符进行分割，例如加回车等。③将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理。 Netty中解决TCP粘包/拆包的方法：①分隔符类：DelimiterBasedFrameDecoder（自定义分隔符）②定长：FixedLengthFrameDecoder Netty高性能之Reactor线程模型Reactor模式是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler Netty是一个高性能的NIO通信框架，提供异步的、事件驱动的网络编程模型。使用Netty可以方便用户开发各种常用协议的网络程序。例如：TCP、UDP、HTTP等等。 netty的线程模型http://blog.csdn.net/u010853261/article/details/62043709http://blog.csdn.net/zxhoo/article/details/17634683http://blog.csdn.net/zxh87/article/details/73467873http://blog.csdn.net/u012495483/article/details/747476011 Reactor单线程模型2 Reactor多线程模型3 Reactor主从多线程模型 Netty 的服务器端的 acceptor 阶段, 没有使用到多线程, 因此上面的 主从多线程模型 在 Netty 的服务器端是不存在的. NioEventLoopGroup实际上就是个线程池NioEventLoopGroup在后台启动了n个NioEventLoop来处理Channel事件每一个NioEventLoop负责处理m个ChannelNioEventLoopGroup从NioEventLoop数组里挨个取出NioEventLoop来处理Channel BossEventLoopGroup通常是一个单线程的EventLoop，EventLoop维护着一个注册了ServerSocketChannel的Selector实例，BossEventLoop不断轮询Selector将连接事件分离出来，通常是OP_ACCEPT事件，然后将accept得到的SocketChannel交给WorkEventLoopGroup，WorkerEventLoopGroup会由next选择其中一个EventLoopGroup来将这个SocketChannel注册到其维护的Selector并对其后续的IO事件进行持续的处理。在Reactor模式中BossEventLoopGroup主要是对多线程的扩展，而每个EventLoop的实现涵盖IO事件的分离，和分发(Dispatcher)。 Rocketmq的BossEventLoopGroup是单线程的，WorkEventLoopGroup是serverSelectorThreads个线程，DefaultEventExecutorGroup是serverWorkerThreads个线程 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/CloudNative/Container容器.html":{"url":"Books/tech/CloudNative/Container容器.html","title":"容器","keywords":"","body":"容器学习 1、Docker学习 2、Kubernetes学习 3、Istio学习 3、Serverless学习 4、Pouch框架 5、其他辅助框架 Docker学习 Docker概念，组件，命令Dockerfile指令docker-compose部署复杂容器服务 把tar文件镜像导入本地镜像仓库 Kubernetes学习 Kubernetes概念、组件kubectl命令 K8s部署流程 k8s配置文件：如网关等，实际项目的配置，kind种类有哪些 Istio学习 Istio概念、组件Istio的部署 go语言 Serverless学习 Serverless最佳实践原则 Pouch框架 其他辅助框架 consul使用raft协议，raft协议是什么？etcd的使用 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Reactive/Reactive响应式编程.html":{"url":"Books/tech/Reactive/Reactive响应式编程.html","title":"Reactive响应式编程","keywords":"","body":"反应式编程 1、 2、 3、 4、 5、 Reactive Programming(RP),响应式编程 /Users/yangzl/git/quickstart-reactive/docs quickstart-reactivex quickstart-reactor quickstart-reactive-streams quickstart-rsocket quickstart-spring-webflux quickstart-akka quickstart-springboot-rsocket quickstart-ratpack Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/ArchitectureDesign/ArchitectureDesign架构和设计.html":{"url":"Books/tech/ArchitectureDesign/ArchitectureDesign架构和设计.html","title":"架构和设计","keywords":"","body":"1、DesignPattern设计模式 设计模式 quickstart-design-pattern 设计模式和代码示例 设计模式学习.md 设计模式的六大原则 设计模式：23种 创建型模式设计模式详解 结构型设计模式详解 行为型设计模式详解 DesignPattern设计模式 1、创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 创建型模式：Factory Method、Abstract Factory、Singleton、Builder、Prototype2、结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式 结构型模式：Adapter、Decorator、Proxy、Facade、Bridge、Composite、Flyweight3、行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 行为型模式：Strategy、Template Method、Observer、Iterator、Chain of Responsibility、Command、Memento、State、Visitor、Mediator、Interpreter 其他的：还有两类：并发型模式和线程池模式。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式.html":{"url":"Books/tech/Distributed/分布式.html","title":"分布式","keywords":"","body":"1、分布式理论 2、 分布式理论 分布式理论单机：ACID，分布式：2PC、3PC分布式设计原则：CAP、BASE分布式一致性：Paxos、Raft、ZABRaft：拉票类型的，由Leader-->FollowerZAB:投票类型的，由LeaderZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段一致性模型：强一致、弱一致性、最终一致性（一段时间达到一致性）一致性模型、XA分布式协议，补偿事务（TCC）（TCC编程（Try、Confirm、Cancel））XA规范：应用程序（ AP ）、事务管理器（ TM、是交易中间件 ）、资源管理器（ RM。是数据库 ）、通信资源管理器（ CRM，是消息中间件 ） Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增) 怎么实现全局递增的唯一ID？(讲了TDDL的一次取一批ID，然后再本地慢慢分配的做法) 分布式事务一致性/Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/分布式事务与一致性算法.md 问题 @所有人 [跳跳]阿里人现身说法：最全面的分布式事务解决方案 🌵全面剖析阿里面试套路 🌵分布式事务来龙去脉 🌵两阶段提交协议 🌵三阶段提交协议 🌵TCC（Try Confirm Cancel）解决方案 🌵LCN（Lock Confirm Notify）解决方案 🌵阿里巴巴分布式事务框架：Seata 🌵消息队列+本地事件表方案 🌵可靠消息服务方案 🌵最大努力通知方案 👉戳此进直播间：https://ke.qq.com/course/399017?taid=10348929858541225&tuin=a982d3d7 [疑问]如何用消息队列解决分布式事务 [玫瑰]分布式事务介绍 [玫瑰]常用分布式事务解决方案 [玫瑰]消息队列解决分布式事务流程 [玫瑰]手敲代码实战落地。 [勾引]戳此进直播间啦：https://ke.qq.com/course/399017?taid=10179983024985769&tuin=6c381156 @所有人 [嘿哈]大行其道的微服务中，分布式事务该如何解决？ 分布式事务的场景。 分布式事务中CAP,BASE理论。 2PC、3PC 提交协议。 基于消息队列的分布式解决方案。 [勾引]戳此进直播间啦：https://ke.qq.com/course/399017?taid=9800909211440809&tuin=6c381156 @所有人 [机智]纯干货分享#分布式事务#Seata落地实战 🎈分布式事务介绍。 🎈常用分布式事务解决方案。 🎈Seata原理。 🎈Seata实战落地。 🔔戳此进直播间啦：https://ke.qq.com/course/399017?taid=10228292817131177&tuin=6c381156 @所有人 [炸弹]纯干货分享#分布式事务#LCN落地实战 🌟分布式事务介绍。 🌟2PC，3PC原理介绍。 🌟LCN原理。 🌟LCN事务实战落地。 👉戳此进直播间啦：https://ke.qq.com/course/399017?taid=9800909211440809&tuin=6c381156 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式算法.html":{"url":"Books/tech/Distributed/分布式算法.html","title":"分布式算法","keywords":"","body":" Gossip协议:Redis集群服务端通讯协议 DHT实现：Kademlia算法 分布式系统算法：Paxos、Raft、ZAB 两军问题与拜占庭将军问题 Gossip协议:Redis集群服务端通讯协议 Consensus Algorithm—— Gossip协议 Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。 gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在分布式系统中被广泛使用，比如我们可以使用 gossip 协议来确保网络中所有节点的数据一样。 Gossip 协议的执行过程： Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。 Gossip 的特点（优势） 可扩展性（Scalable） 去中心化 容错（Fault-tolerance） 健壮性（Robust） 最终一致性（Convergent consistency） Gossip 的缺陷 1）消息的延迟 2）消息冗余 Gossip 有两种类型： Anti-Entropy（反熵）：以固定的概率传播所有的数据 Rumor-Mongering（谣言传播）：仅传播新到达的数据 Redis Cluster 是一个可以在多个 Redis 节点之间进行数据共享的分布式集群，在服务端，通过节点之间的特殊协议进行通讯，这个特殊协议就充当了中间层的管理部分的通信协议，这个协议称作Gossip流言协议。 Gossip协议的使用 Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型： 1、Meet 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。 2、Ping 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。 3、Pong 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。 4、Fail 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。 由于去中心化和通信机制，Redis Cluster 选择了最终一致性和基本可用。 基于Gossip协议的故障检测 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此交换各个节点状态信息，检测各个节点状态：在线状态、疑似下线状态PFAIL、已下线状态FAIL。 自己保存信息：当主节点A通过消息得知主节点B认为主节点D进入了疑似下线(PFAIL)状态时,主节点A会在自己的clusterState.nodes字典中找到主节点D所对应的clusterNode结构，并将主节点B的下线报告添加到clusterNode结构的fail_reports链表中，并后续关于结点D疑似下线的状态通过Gossip协议通知其他节点。 一起裁定：如果集群里面，半数以上的主节点都将主节点D报告为疑似下线，那么主节点D将被标记为已下线(FAIL)状态，将主节点D标记为已下线的节点会向集群广播主节点D的FAIL消息，所有收到FAIL消息的节点都会立即更新nodes里面主节点D状态标记为已下线。 最终裁定：将 node 标记为 FAIL 需要满足以下两个条件： 1、有半数以上的主节点将 node 标记为 PFAIL 状态。 2、当前节点也将 node 标记为 PFAIL 状态。 也就是说当前节点发现其他结点疑似挂掉了，那么就写在自己的小本本上，等着通知给其他好基友，让他们自己也看看，最后又一半以上的好基友都认为那个节点挂了，并且那个节点自己也认为自己挂了，那么就是真的挂了，过程还是比较严谨的。 参考 https://zhuanlan.zhihu.com/p/41228196 https://www.jianshu.com/p/133560ef28df https://www.jianshu.com/p/de7b026f4997 https://blog.csdn.net/b6ecl1k7BS8O/article/details/86653449 https://hyperledger-fabric.readthedocs.io/zh_CN/latest/gossip.html 集群版Redis和Gossip协议 https://zhuanlan.zhihu.com/p/72629038 https://juejin.im/post/5dd65d676fb9a05a9a22ac6f DHT实现：Kademlia算法 Kademlia是分布式哈希表/散列表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。 Kademlia算法是一种分布式存储及路由的算法。 分布式哈希表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。 使用场景： 分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。 算法的三个参数：keyspace，k和α keyspace -- 即ID有多少位 -- 决定每个节点的通讯录有几层 k -- 每个一层k-bucket里装k个node的信息，即 -- 每次查找node时，返回k个node的信息 -- 对于某个特定的data，离其key最近的k个节点被会要求存储这个data α -- 每次向其他node请求查找某个node时，会向α个node发出请求 节点的指令 Kademlia算法中，每个节点只有4个指令 PING -- 测试一个节点是否在线 STORE -- 要求一个节点存储一份数据 FIND_NODE -- 根据节点ID查找一个节点 FIND_VALUE -- 根据KEY查找一个数据，实则上跟FIND_NODE非常类似 k-bucket的维护及更新机制 每个bucket里的节点都按最后一次接触的时间倒序排列 每次执行四个指令中的任意一个都会触发更新 当一个节点与自己接触时，检查它是否在K-bucket中 -- 如果在，那么将它挪到k-bucket列表的最底（最新） -- 如果不在，PING一下列表最上面（最旧）的一个节点 -- a) 如果PING通了，将旧节点挪到列表最底，并丢弃新节点 -- b) 如果PING不通，删除旧节点，并将新节点加入列表 该机制保证了任意节点加入和离开都不影响整体网络。 总结 Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。 在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。 DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。 Kademlia算法在2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。Kademlia可以作为信息安全技术的奠基之一。 Kademlia的优点在于： 1、对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要n步搜索即可找到目标节点； 2、K-bucket的更新机制一定程度上保持了网络的活性和安全性。 参考 https://www.jianshu.com/p/f2c31e632f1d https://colobu.com/2018/03/26/distributed-hash-table/ https://zhuanlan.zhihu.com/p/40286711 https://azhuge233.com/kademlia%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/ https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式事务与一致性算法.html":{"url":"Books/tech/Distributed/分布式事务与一致性算法.html","title":"分布式事务与一致性算法","keywords":"","body":"传统数据库事务:ACID， 老的方式分布式数据库：2PC、3PC 一致性算法：分布式CAP、BASE模型、柔性事务（补偿事务（TCC）（TCC编程（Try、Confirm、Cancel））） 分布式事务解决方案，包括强一致性的两阶段提交协议，三阶段提交协议，以及最终一致性的可靠事件模式、补偿模式，阿里的 TCC 模式。 刚性事务：XA分布式协议:2PC、3PC、 柔性事务：BASE模型、TCC、 分布式系统算法：Paxos、Raft、ZAB 两军问题与拜占庭将军问题 2PC/3PC用于保证多个数据分片上事务的原子性 Paxos协议用于保证同一个数据分片在多个副本的一致性 Paxos（分布式一致性算法）：Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 由proposer/acceptor/learner组成 Basic Paxos：提案阶段 投票阶段， 对一个值达成一致 Multi Paxos：统一由leader发起提议，可节省prepare步骤，连续多个paxos instance来对多个值达成一致 Raft 算法：Leader、Follower、Candidate候选人 选举流程：Candidate候选人向所有的服务器邀请投票给自己，如果收到大多数的Server的同意，就当选为Leader，其他的Server为Follower，如果一轮没有选出，则在一定的timeout后重新发起投票，直到选出Leader 使用流程：Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，然后再向所有 Follower 发出提交通知 Raft：拉票类型的，由Leader-->Follower ZAB:投票类型的，由Leader ZAB 协议 ( Zookeeper Atomic Broadcast) 原子广播协议：保证了发给各副本的消息顺序相同 两种角色+一种角色：Leader和Follower两个角色 + Observer 三种状态：Looking、Following、Leading 选举流程：初始化时候，故障恢复时候（选举和同步数据）、正常广播时候 传统事务:ACID 老的方式实现分布式事务是通过两阶段提交来实现的:2PC、3PC、 在分布式领域基于CAP理论以及BASE理论，有人就提出了 柔性事务 的概念 柔性事务（遵循BASE理论）是指相对于ACID刚性事务而言的。 支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。 1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。 2、补偿型：TCC型事务（Try/Confirm/Cancel）可以归为补偿型。 3、异步确保型，将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。 4、最大努力型，PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试） 柔性事务针对分布式事务的解决方法： 1、记录日志+补偿 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。 2、消息 多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。 3、“无锁”设计 放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。 https://github.com/dotnetcore/CAP 1、分布式领域CAP理论， Consistency(一致性), 数据一致更新，所有数据变动都是同步的 Availability(可用性), 好的响应性能 Partition tolerance(分区容忍性) 可靠性 数据一致性(consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性(strong consistency) (又叫原子性 atomic、线性一致性 linearizable consistency) 服务可用性(availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待 分区容错性(partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务 CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性： 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效) 可用性(Availability) ： 每个操作都必须以可预期的响应结束 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成 C、A、P三者最多只能满足其中两个，和FLP定理一样，CAP定理也指示了一个不可达的结果(impossibility result)。 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 2、关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区： Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。 Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。 Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。 Durability. 一旦事务完成，就不能返回。 3、BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库) Soft state软状态 状态可以有一段时间不同步，异步。 Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。 这个时候有同学可能会把数据库的2PC（两阶段提交）搬出来说话了。OK，我们就来看一下数据库的两阶段提交。 对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。 MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段： 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。 一致性模型 强一致 弱一致性 最终一致性（一段时间达到一致性） XA协议由Tuxedo首先提出的，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准。目前，Oracle、Informix、DB2和Sybase等各大数据库厂家都提供对XA的支持。XA协议采用两阶段提交方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。XA协议包括两套函数，以xa开头的及以ax开头的。 X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。这个思想在java 平台里面到处都是。 XA规范： 应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ） Application Transcation Manage Rosource Manage Communication Resource Manage 常见的事务管理器（ TM ）是交易中间件 常见的资源管理器（ RM ）是数据库 常见的通信资源管理器（ CRM ）是消息中间件 https://www.jianshu.com/p/ab1a1c6b08a1 柔性事务针对分布式事务的解决方法： 1、记录日志+补偿 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。 2、消息 多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。 3、“无锁”设计 放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。 https://blog.csdn.net/cxzhq2002/article/details/46892211 https://www.zhihu.com/question/31813039 柔性事务（遵循BASE理论）是指相对于ACID刚性事务而言的。 支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。 1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。 这是分布式环境下事务处理的典型模式。 2、补偿型： TCC型事务（Try/Confirm/Cancel）可以归为补偿型。 3、异步确保型 将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。 4、最大努力型 PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试） 1、2PC和3PC 二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做) 跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。 3PC (three phase commit) 与两阶段提交不同的是，三阶段提交有两个改动点。 1、引入超时机制。同时在协调者和参与者中都引入超时机制。 2、在第一阶段分为询问阶段，具体操作两个阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。最后提交阶段如果RM超时未收到TM的commit请求，就默认提交（根据概率来的，正常应该是commit的） 也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。 因为有了准备提交(prepare to commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。 TCC编程模式 所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。 补偿事务（TCC） TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段： Try 阶段主要是对业务系统做检测及资源预留 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 2、Paxos（分布式一致性算法） Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 Paxos协议用于解决多个副本之间的一致性问题。 2PC/3PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性 由proposer/acceptor/learner组成 Paxos算法描述：经过上面的推导，我们总结下Paxos算法的流程。 提案询问阶段（Prepare阶段）：如果提案版本号N大于该Acceptor已经响应过的所有Prepare请求的编号，就接收，并承诺不再接收比N小的提案（prepare步骤+acceptor的promise） 提案投票阶段：发送一个针对[N,V]提案，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案 Paxos算法分为两个阶段。具体如下： 阶段一：提案阶段 (a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。 (b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。 阶段二：投票阶段 (a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。 (b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。 Basic Paxos：上面理论 Multi Paxos：proposer leader在Multi Paxos中还有助于提升性能，常态下统一由leader发起提议，可节省prepare步骤(leader不用问询acceptor曾接受过的ID最大的提议、只有leader提议也不需要acceptor进行promise)直至发生leader宕机、重新选主。 Paxos是对一个值达成一致，Multi-Paxos是连续多个paxos instance来对多个值达成一致，这里最核心的原因是multi-paxos协议中有一个Leader。Leader是系统中唯一的Proposal，在lease租约周期内所有提案都有相同的ProposalId，可以跳过prepare阶段，议案只有accept过程，一个ProposalId可以对应多个Value，所以称为Multi-Paxos。 Paxos协议数据同步方式相对于基于传统1主N备的同步方式有啥区别？ 一般情况下，传统数据库的高可用都是基于主备来实现，1主1备2个副本，主库crash后，通过HA工具来进行切换，提升备库为主库。在强一致场景下，复制可以开启强同步，Oracle和Mysql都是类似的复制模式。但是如果备库网络抖动，或者crash，都会导致日志同步失败，服务不可用。为此，可以引入1主N备的多副本形式，我们对比都是3副本的情况，一个是基于传统的1主2备，另一种基于paxos的1主2备。传统的1主两备，进行日志同步时，只要有一个副本接收到日志并就持久化成功，就可以返回，在一定程度上解决了网络抖动和备库crash问题。但如果主库出问题后，还是要借助于HA工具来进行切换，那么HA切换工具的可用性如何来保证又成为一个问题。基于Paxos的多副本同步其实是在1主N备的基础上引入了一致性协议，这样整个系统的可用性完全有3个副本控制，不需要额外的HA工具。而实际上，很多系统为了保证多节点HA工具获取主备信息的一致性，采用了zookeeper等第三方接口来实现分布式锁，其实本质也是基于Paxos来实现的。 3、Raft 算法也是一种少数服从多数的算法（脑裂问题也是可以解决的） 一致性算法：最初的状态都是Follower，任意一个Server都可以申请成为Candidate并申请所有的Server投票给自己，如果收到大多数的Server的同意，就当选为Leader，其他的Server为Follower，如果一轮没有选出，则在一定的timeout后重新发起投票，直到选出Leader Leader挂掉后，集群重新选主，老的Leader恢复后自动成为Follower 当因为网络原因发生脑裂，拥有大多数的一方重新选主，Client发过来的请求都可以成功，少数派的一方接收到的Client请求都是失败的，重新加入后少数派的Server自动成为Follower Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。 在任何时候一个服务器可以扮演以下角色之一： Leader：负责 Client 交互 和 log 复制，同一时刻系统中最多存在一个，处理所有客户端交互，日志复制等，一般一次只有一个Leader. Follower：被动响应请求 RPC，从不主动发起请求 RPC， 类似选民，完全被动 Candidate候选人 : 由Follower 向Leader转换的中间状态，类似Proposer律师，可以被选为一个新的领导人。 Raft：拉票类型的，由Leader-->Follower ZAB:投票类型的，由Leader 4、ZAB 协议 ( Zookeeper Atomic Broadcast) 原子广播协议：保证了发给各副本的消息顺序相同 两种角色+一种角色：Leader和Follower两个角色 + Observer 三种状态：Looking、Following、Leading ZAB 中的节点有三种状态 following：当前节点是跟随者，服从 leader 节点的命令 leading：当前节点是 leader，负责协调事务 election/looking：节点处于选举状态 阶段 ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段 选举（Election） election阶段必须确保选出的Leader具有highestZXID，否则在Recovery阶段没法保证数据的一致性，Recovery阶段Leader要求Follower向自己同步数据没有Follower要求Leader保持数据同步，所有选举出来的Leader要具有最新的ZXID； 在选举的过程中会对每个Follower节点的ZXID进行对比只有highestZXID的Follower才可能当选Leader； 恢复（Recovery） ：数据同步 在election阶段选举出来的Leader已经具有最新的ZXID，所有本阶段的主要工作是根据Leader的事务日志对Follower节点数据进行更新； 数据更新：复制，回滚 广播(Broadcast)：类似2PC提交，只是2PC是接收全部的参与者同意，ZAB只需要超半数同意即可 客户端提交事务请求时Leader节点为每一个请求生成一个事务Proposal，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交 协议状态 ZAB协议中存在着三种状态，每个节点都属于以下三种中的一种： Looking ：系统刚启动时或者Leader崩溃后正处于选举状态 Following ：Follower节点所处的状态，Follower与Leader处于数据同步阶段； Leading ：Leader所处状态，当前集群中有一个Leader为主进程； ZAB中的三种角色：Leader、Follower、Observer Leader、负责发起事务 Follower、负责读写和响应leader的提议 Observer：只负责读取服务 选举流程 https://blog.csdn.net/luonanqin/article/details/78314096 https://zhuanlan.zhihu.com/p/27335748 https://dbaplus.cn/news-141-1875-1.html 初始化时候：初始化epoch和lastzxid一样，serverid最大的作为候选leader 故障恢复时候： 故障选举： 1、每个server的epoch自增，并且将自己的新的epoch发送给其他server， 2、每个server对比自己的新的epoch和接受的epoch比较，把自己的新更新较大的那个epoch 3、依次比较epoch、zxid、serverid，哪个都是最大的就成为leader 故障同步数据： 1、leader给每个follower建立一个handler线程和一个事务队列 2、每个follower给leader发送lastzxid等信息，leader和自身的max/minzxid进行比较 3、如果lastzxidmaxzxid，就删除大于maxzxid数据 正常广播时候： 1、leader发送议案给follower，超过半数的follower回复ack， 2、Leader将再次向集群内Follower广播Commit信息，Commit为将之前的Proposal提交; Leader： Leader作为整个ZooKeeper集群的主节点，负责响应所有对ZooKeeper状态变更的请求。它会将每个状态更新请求进行排序和编号，以便保证整个集群内部消息处理的FIFO。 这里补充一下ZooKeeper的请求类型。对于exists，getData，getChildren等只读请求，收到该请求的zk服务器将会在本地处理，因为由第一讲的ZAB理论可知，每个服务器看到的名字空间内容都是一致的，无所谓在哪台机器上读取数据，因此如果ZooKeeper集群的负载是读多写少，并且读请求分布得均衡的话，效率是很高的。对于create，setData，delete等有写操作的请求，则需要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为一个事务（transaction）。 Follower Follower的逻辑就比较简单了。除了响应本服务器上的读请求外，follower还要处理leader的提议，并在leader提交该提议时在本地也进行提交。Follower处理提议的过程已经在ZAB一章中描述过了。 另外需要注意的是，leader和follower构成ZooKeeper集群的法定人数，也就是说，只有他们才参与新leader的选举、响应leader的提议。 Observer 如果ZooKeeper集群的读取负载很高，或者客户端多到跨机房，可以设置一些observer服务器，以提高读取的吞吐量。Observer和Follower比较相似，只有一些小区别：首先observer不属于法定人数，即不参加选举也不响应提议；其次是observer不需要将事务持久化到磁盘，一旦observer被重启，需要从leader重新同步整个名字空间。 ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议；ZAB可以说是在Paxos算法基础上进行了扩展改造而来的，ZAB协议设计了支持崩溃恢复，ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求，采用ZAB协议将服务器数状态以事务形式广播到所有Follower上；由于事务间可能存在着依赖关系，ZAB协议保证Leader广播的变更序列被顺序的处理，：一个状态被处理那么它所依赖的状态也已经提前被处理；ZAB协议支持的崩溃恢复可以保证在Leader进程崩溃的时候可以重新选出Leader并且保证数据的完整性; 处理过程： 在ZooKeeper中所有的事务请求都由一个主服务器也就是Leader来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal分发给集群中其他所有的Follower，然后Leader等待Follwer反馈，当有 过半数（>=N/2+1） 的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit为将之前的Proposal提交; ZooKeeper启动时所有节点初始状态为Looking，这时集群会尝试选举出一个Leader节点，选举出的Leader节点切换为Leading状态；当节点发现集群中已经选举出Leader则该节点会切换到Following状态，然后和Leader节点保持同步；当Follower节点与Leader失去联系时Follower节点则会切换到Looking状态，开始新一轮选举；在ZooKeeper的整个生命周期中每个节点都会在Looking、Following、Leading状态间不断转换； 状态切换图 ：Leader在超时时间内接收不到超半数的Follower发过来的心跳或TCP连接断开，那Leader会结束当前周期的领导，切换到Looking状态，所有Follower节点也会放弃该Leader节点切换到Looking状态，然后开始新一轮选举 选举出Leader节点后ZAB进入原子广播阶段，这时Leader为和自己同步的每个节点Follower创建一个操作序列，一个时期一个Follower只能和一个Leader保持同步，Leader节点与Follower节点使用心跳检测来感知对方的存在；当Leader节点在超时时间内收到来自Follower的心跳检测那Follower节点会一直与该节点保持连接；若超时时间内Leader没有接收到来自过半Follower节点的心跳检测或TCP连接断开，那Leader会结束当前周期的领导，切换到Looking状态，所有Follower节点也会放弃该Leader节点切换到Looking状态，然后开始新一轮选举； ZAB 协议的核心：定义了事务请求的处理方式。 　　所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader服务器，而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一个客户端事务请求转换成一个事务proposal（提议），并将该 Proposal分发给集群中所有的Follower服务器。之后 Leader 服务器需要等待所有Follower 服务器的反馈,一旦超过半数的Follower服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower服务器分发Commit消息，要求其将前一个proposal进行提交。 如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）的事务 Proposal,那么就可以保证这个新选举出来的 Leader —定具有所有已经提交的提案。同时，如果让具有最高编号事务 Proposal 的机器来成为 Leader, 就可以省去 Leader 服务器检查 Proposal 的提交和丢弃工作的这一步操作。 数据同步 　　Leader 服务器会为每一个 Follower 服务器都准备一个队列，并将那些没有被各 Follower 服务器同步的事务以 Proposal 消息的形式逐个发送给 Follower 服务器，并在每一个 Proposal 消息后面紧接着再发送一个 Commit 消息，以表示该事务已经被提交。等到 Follower 服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应用到本地数据库中后， Leader 服务器就会将该 Follower 服务器加入到真正的可用 Follower 列表中，并开始之后的其他流程。 　　下面来看 ZAB 协议是如何处理那些需要被丢弃的事务 Proposal 的。在 ZAB 协议的事务编号 ZXID 设计中， ZXID 是一个 64 位的数字，低 32 位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求， Leader 服务器在产生一个新的事务 Proposal 的时候，都会对该计数器进行加1操作；高 32 位代表了 Leader 周期 epoch 的编号，每当选举产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务 Proposal 的 ZXID ,并从该 ZXID 中解析出对应的 epoch 值，然后再对其进行加1操作，之后就会以此编号作为新的 epoch, 并将低 32 位置0来开始生成新的 ZXID 。 　　基于这样的策略，当一个包含了上一个 Leader 周期中尚未提交过的事务 Proposal的服务器启动加入到集群中，发现此时集群中已经存在leader，将自身以Follower 角色连接上 Leader 服务器之后， Leader 服务器会根据自己服务器上最后被提交的 Proposal来和 Follower 服务器的 Proposal进行比对，发现follower中有上一个leader周期的事务Proposal时，Leader 会要求 Follower 进行一个回退操作——回退到一个确实已经被集群中过半机器提交的最新的事务 Proposal 。 主从架构下，leader 崩溃，数据一致性怎么保证？leader 崩溃之后，集群会选出新的 leader，然后就会进入恢复阶段，新的 leader 具有所有已经提交的提议，因此它会保证让 followers 同步已提交的提议，丢弃未提交的提议（以 leader 的记录为准），这就保证了整个集群的数据一致性。 选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？这是通过 Fast Leader Election 实现的，leader 的选举只需要超过半数的节点投票即可，这样不需要等待所有节点的选票，能够尽早选出 leader。 paxos 算法与 raft 算法的差异 raft强调是唯一leader的协议，此leader至高无上 raft：新选举出来的leader拥有全部提交的日志，而 paxos 需要额外的流程从其他节点获取已经被提交的日志，它允许日志有空洞 相同点：得到大多数的赞成，这个 entries 就会定下来，最终所有节点都会赞成 分布式事务的作用是保证跨节点事务的原子性，涉及事务的节点要么都提交(执行成功)，要么都不提交(回滚)。分布式事务的一致性通常通过2PC来保证(Two-Phase Commit, 2PC)，2PC的最大问题是，协调者是单点(需要有一个备用节点)，另外协议是阻塞协议，任何一个参与者故障，都需要等待(可以通过加入超时机制)。 Paxos协议用于解决多个副本之间的一致性问题。 2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性，所以两者可以是互补的关系，绝不是替代关系。对于2PC协调者单点问题，可以利用Paxos协议解决，当协调者出问题时，选一个新的协调者继续提供服务。 raft协议和zab协议区别： 第一次写答案.最近正在实现raft协议, zab协议没看过,就刚才粗略地现看了下ZooKeeper Internals和论文, 所以下面的回答只是我自己的一些拙见,欢迎大牛们斧正.因为raft比zab出来晚点,可能raft 里面的有些东西会借鉴zab协议.其实两个协议差不到哪里去,本质上都是维护一个replicated log. 相同点(不全,没有实现过zab): 1、都使用timeout来重新选择leader. 2、采用quorum来确定整个系统的一致性(也就是对某一个值的认可),这个quorum一般实现是集群中半数以上的服务器,zookeeper里还提供了带权重的quorum实现. 3、都由leader来发起写操作. 4、都采用心跳检测存活性. 5、leader election都采用先到先得的投票方式. 不同点(不全,没有实现过zab): 1、zab用的是epoch和count的组合来唯一表示一个值, 而raft用的是term和index. 2、zab的follower在投票给一个leader之前必须和leader的日志达成一致,而raft的follower则简单地说是谁的term高就投票给谁. 3、raft协议的心跳是从leader到follower, 而zab协议则相反.4、raft协议数据只有单向地从leader到follower(成为leader的条件之一就是拥有最新的log), 而zab协议在discovery阶段, 一个prospective leader需要将自己的log更新为quorum里面最新的log,然后才好在synchronization阶段将quorum里的其他机器的log都同步到一致. BTW, raft实现起来比zab会简单很多. CAP原理和BASE思想 http://www.jdon.com/37625 http://www.cnblogs.com/bangerlee/p/5328888.html FLP Impossibility http://blog.csdn.net/chen77716/article/details/27963079 关于分布式事务、两阶段提交协议、三阶提交协议 http://blog.jobbole.com/95632/ https://www.cnblogs.com/binyue/p/3678390.html 分布式事务与一致性算法Paxos & raft & zab http://blog.csdn.net/followmyinclinations/article/details/52870418 raft协议和zab协议有啥区别？ https://www.zhihu.com/question/28242561 Paxos算法 https://www.cnblogs.com/linbingdong/p/6253479.html https://www.cnblogs.com/cchust/p/5617989.html http://blog.csdn.net/xiaqunfeng123/article/details/51712983 https://www.cnblogs.com/bangerlee/p/5655754.html https://yq.aliyun.com/articles/156281 分布式系统的Raft算法： http://www.jdon.com/artichect/raft.html http://www.cnblogs.com/mindwind/p/5231986.html https://raft.github.io/ http://www.infoq.com/cn/articles/raft-paper ZAB协议： http://blog.csdn.net/wangyangzhizhou/article/details/52698555 http://blog.jobbole.com/104985/ https://www.cnblogs.com/jian-xiao/p/5821675.html ZAB中的三种角色：Leader、Follower、Observer https://blog.csdn.net/mayp1/article/details/52026797 拜占庭问题与两军问题 http://blog.csdn.net/wulinjun777/article/details/59012687 2PC是指Oracle的两阶段提交协议（Two-Phase Commit protocol）。 2PC用于确保所有分布式事务能够同时提交（Commit）或者回滚（Rollback），以便使的数据库能够处于一致性状态（consistent state）。 分布式事务可以通过DBA_2PC_PENDING 和 DBA_2PC_NEIGHBORS 字典视图查看。 分布式事务处理是指一个事务可能涉及多个数据库操作 分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务必须产生一致的结果（全部提交或全部回滚）。 XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议，XA被许多数据库（如Oracle和DB2）和中间件等工具(如CICS 和 Tuxedo).本地支持 。 X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）、通信资源管理器（CRM）四部分。在这个模型中，通常事务管理器（TM）是交易中间件，资源管理器（RM）是数据库，通信资源管理器（CRM）是消息中间件。 一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个DTP环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。 XA就是X/Open DTP定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。XA接口函数由数据库厂商提供。通常情况下，交易中间件与数据库通过XA 接口规范，使用两阶段提交来完成一个全局事务，XA规范的基础是两阶段提交协议。 在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。 在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式事务框架.html":{"url":"Books/tech/Distributed/分布式事务框架.html","title":"分布式事务框架","keywords":"","body":" 现有分布式处理方案 分布式事务中间件Seata的设计原理 JDTX是由京东数科的数据研发团队倾力打造的分布式事务中间件 分布式事务：中间件方案 现有分布式处理方案 一致性理论基石： ACID本地事务 XA协议：2PC、3PC CAP理论 BASE理论 数据一致性分为三个种类型：强一致性，弱一致性以及最终一致性 一致性模型，数据的一致性模型可以分成以下3类： 强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。 最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。 数据库实现的就是强一致性，能够保证在写入一份新的数据库，立即使其可见。 最终一致性是弱一致性的强化版，系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。 微服务作为分布式系统，同样受 CAP[1] 原理的制约，在 CAP 理论中， C：Consistency、A：Availability、P：Partition tolerance 三者不可同时满足，而服务化中，更多的是提升 A 以及 P，在这个过程中不可避免的会降低对 C 的要求，因此，BASE 理论随之而来。 BASE[2] 理论来源于 ebay 在 2008 年 ACM 中发表的论文，BASE 理论的基本原则有三个：Basically Available，Soft state，Eventually consistent，主要目的是为了提升分布式系统的可伸缩性，论文同样阐述了如何对业务进行调整以及折中的手段，BASE 理论的提出为分布式事务的发展指出了一个方向。 在最终一致性的实现过程中，最基本的操作就是保证事务参与者的幂等性，所谓的幂等性，就是业务方能够使用相关的手段，保证单个事务多次提交依然能够保证达到同样的目的。 ACID本地事务：强一致性 现有成熟的分布式解决方案包括XA两阶段提交、可靠消息与TCC模式等类型。XA两阶段提交属于强一致事务，可靠消息与TCC模式属于柔性事务。 XA协议：2PC、3PC：XA两阶段提交，2PC两阶段提交（2PC, Two-phase Commit）方案、三阶段提交协议 3PC---强一致性 2PC二阶段提交方案：强一致性 3PC三阶段提交 TCC事务,TCC模式（Try-Confirm-Cancel）补偿模式---最终一致性 可靠本地消息表：最终一致性 MQ事务：最终一致性 Saga事务：最终一致性 saga的具体实现分为两种：Choreography（编排）以及 Orchestration（编配） 参考关于分布式事务，XA协议的学习笔记RocketMQ 4.3正式发布，支持分布式事务 编制（orchestration）和编排（choreography）是常用于描述“合成Web服务的两种方式”的术语。 虽然它们有共同之处，但还是有些区别的。 Web服务编制（Web Services Orchestration，WSO）指为业务流程（business processes）而进行Web服务合成， 而Web服务编排（Web Services Choreography，WSC）指为业务协作（business collaborations）而进行Web服务合成。 SOA中的两个概念：编制（orchestration）和编排（choreography）WS中Orchestration和Choreography的含意Choreography vs Orchestration编配和编排的定义之争Web服务聚合中的Orchestration和ChoreographyMicroservices Choreography vs Orchestration: The Benefits of Choreography微服务协调与编排：协调的好处 事务的隔离级别： 数据库的四种隔离级别：脏读、不可重复读、幻读 Read uncommitted 读未提交 在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。 因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。 Read committed 读提交 在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。 Repeatable read 重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。 Serializable 序列化 该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。 分布式事务中间件Seata的设计原理 https://seata.io/zh-cn/ https://github.com/seata/seata https://github.com/seata/seata-samples https://seata.io/zh-cn/docs/overview/what-is-seata.html https://github.com/seata/seata/wiki/%E6%A6%82%E8%A7%88 Fescar 的发展历程 阿里是国内最早一批进行应用分布式（微服务化）改造的企业，所以很早就遇到微服务架构下的分布式事务问题。 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast & EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 TXC/GTS/Fescar 一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。 参考 https://www.sofastack.tech/blog/seata-distributed-transaction-deep-dive/ http://jm.taobao.org/2017/04/27/20170427/ https://juejin.im/post/5d2616256fb9a07eef6a3619 https://cloud.tencent.com/developer/article/1463287 https://www.kubernetes.org.cn/5603.html https://yq.aliyun.com/articles/334238 JDTX是由京东数科的数据研发团队倾力打造的分布式事务中间件 参考 http://blog.itpub.net/31556440/viewspace-2662840/ 分布式事务：中间件方案 TX-LCNhttps://www.txlcn.org/zh-cn/ atomikoshttps://www.atomikos.com/ 开源类事务管理器 GTS https://www.aliyun.com/aliware/txc?spm=5176.8142029.388261.386.a72376f4lqvQxv 全局事务服务（Global Transaction Service ，简称GTS）用于实现分布式环境下高性能事务一致性。 FESCAR （推荐）现在改名字，是分布式事务中间件Seata https://github.com/wxbty/meepo http://www.iocoder.cn/categories/TCC-Transaction/ 可靠消息分布式事务中间件 https://gitee.com/silk7/shine-mq 参考 https://blog.csdn.net/fly910905/article/details/87356755 https://www.zhihu.com/question/64921387 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/常见分布式集群选举机制总结.html":{"url":"Books/tech/Distributed/常见分布式集群选举机制总结.html","title":"常见分布式集群选举机制总结","keywords":"","body":" Zookeeper选举 Kafka选举 Redis选举 Eureka选举 RocketMQ选举 Zookeeper选举 参考 https://www.jianshu.com/p/49ce02abc7ba Kafka选举 Kafka Controller控制器的选举：kafka集群的controller选举 分区leader的选举 消费者相关的选举 Kafka Controller控制器的选举 在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。比如当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。再比如当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。 Kafka Controller的选举是依赖Zookeeper来实现的，在Kafka集群中哪个broker能够成功创建/controller这个临时（EPHEMERAL）节点他就可以成为Kafka Controller。 Kafka Controller的选举其实就是创建临时节点，这和Zookeeper分布式锁的实现原理基本相同。 分区leader的选举： 分区leader副本的选举由Kafka Controller 负责具体实施。当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的leader副本下线，此时分区需要选举一个新的leader上线来对外提供服务）的时候都需要执行leader的选举动作。 基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。 消费者相关的选举： 组协调器GroupCoordinator需要为消费组内的消费者选举出一个消费组的leader，这个选举的算法也很简单，分两种情况分析。 1、如果消费组内还没有leader，那么第一个加入消费组的消费者即为消费组的leader。 2、如果某一时刻leader消费者由于某些原因退出了消费组，那么会重新选举一个新的leader， 在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member_id，而value是消费者相关的元数据信息。 leaderId表示leader消费者的member_id，它的取值为HashMap中的第一个键值对的key，这种选举的方式基本上和随机无异。 总体上来说，消费组的leader选举过程是很随意的。 Kafka选举参考 https://blog.csdn.net/u013256816/article/details/89369160 https://www.jianshu.com/p/49ce02abc7ba Redis选举 redis集群的主从切换 redis没有类似Zookeeper的选举机制。redis的master挂掉以后，redis集群是通过主从切换来保证高可用性的。 redis主从切换有2种方式：手动切换和自动切换。 这里我们讨论自动切换，redis主从自动切换需要哨兵模式的支持，哨兵模式简单来说就是：监控master和slave，在master出现故障的时候，自动将slave切换成master，master恢复以后，作为新master的slave对外提供服务。 参考 https://www.jianshu.com/p/49ce02abc7ba Eureka选举 Eureka集群的相互复制 准确的来说，Eureka集群中的各节点之间不存在主从关系。Eureka集群中的节点的关系是对等的，其他3种集群则都存在主从关系，这是Eureka集群的一个特色。 Eureka集群的各个server之间通过相互注册的方式来实现集群的高可用性。数据同步的方式是增量备份，这样可以保证每个server都是最新最全的数据。从而保证集群的高可用性。这样即使某个server挂了，集群还可以对外提供服务。 总结： Eureka server集群不存在选举机制，Eureka server集群各节点的关系是对等的，Eureka server通过相互复制来保证高可用性。 参考 https://www.jianshu.com/p/49ce02abc7ba RocketMQ选举 NameServ之间都是全量的数据，没有选举 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式锁实现.html":{"url":"Books/tech/Distributed/分布式锁实现.html","title":"分布式锁实现","keywords":"","body":" 分布式锁实现原理 DB数据库乐观锁 基于Redis的分布式锁 基于ZooKeeper的分布式锁 分布式锁实现原理 在同一个jvm进程中时，可以使用JUC提供的一些锁来解决多个线程竞争同一个共享资源时候的线程安全问题，但是当多个不同jvm进程中的线程共同竞争同一个共享资源时候，juc包的锁就无能无力了，这时候就需要分布式锁了。 常见的有使用zk的最小版本，redis的set函数，数据库锁来实现 首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： 1、互斥性。在任意时刻，只有一个客户端能持有锁。 2、不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 3、具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。 4、解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 针对分布式锁的实现目前有多种方案：互斥、超时、可重入等 1、基于数据库实现分布式锁：获取锁插入一条记录，释放锁就删除记录 2、基于缓存（redis，memcached）实现分布式锁 3、基于Zookeeper实现分布式锁 分布式锁实现 DB memcached(add) Redis(setnx) zookeeper(临时有序节点) 代码org.quickstart.javase.distributed.lock 使用数据库悲观锁实现不可重入的分布式锁 使用Redis单实例实现不可重入的分布式锁 使用zookeeper序列节点实现不可重入的分布式锁 分布式锁实现： https://www.cnblogs.com/yuyutianxia/p/7149363.html http://blog.csdn.net/x_i_y_u_e/article/details/50864205 http://www.importnew.com/27477.html?utm_source=tuicool&utm_medium=referral DB数据库乐观锁 DB数据库： 使用select * from lock where uid = 1 for update的拍他锁，设置不自动提交，先执行该SQL，然后执行业务，然后提交 数据库实现缺点：数据库单点问题 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。 非阻塞的？搞一个while循环，直到insert成功再返回成功。 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。 memcached(add) 基于Redis的分布式锁 利用setnx+expire命令 (错误的做法)setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。 使用set+expire+事务 或者 使用setnx+Lua脚本（包含setnx和expire两条指令）说道Redis分布式锁大部分人都会想到：setnx+lua，或者知道set key value px milliseconds nx。 这种实现方式有3大要点（也是面试概率非常高的地方）： set命令要用set key value px milliseconds nx； value要具有唯一性； 释放锁时要验证value值，不能误解锁； 事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况： 在Redis的master节点上拿到了锁； 但是这个加锁的key还没有同步到slave节点； master故障，发生故障转移，slave节点升级为master节点； 导致锁丢失。 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法) EX seconds – 设置键key的过期时间，单位时秒 PX milliseconds – 设置键key的过期时间，单位时毫秒 NX – 只有键key不存在的时候才会设置key的值 XX – 只有键key存在的时候才会设置key的值 Redlock算法与Redisson实现（Redisson实现了Redlock算法） the Redlock algorithm在Redis的分布式环境中，Redis 的作者提供了RedLock 的算法来实现一个分布式锁。 基于Redis的分布式锁实现Redlock：Redis分布式锁最牛逼的实现使用Redis的分布式锁Redis分布式锁背后的原理 Redis： 使用SetNX，设置过期时间，过期时间太小会出现业务没有做完锁就释放了 还可以设置超过多少次没有获取就等待，随机生成一个等待时间，等时间到后在进行重试，升级成重量级锁 基于缓存： redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。 使用缓存实现分布式锁的优点: 性能好，实现起来较为方便。 使用缓存实现分布式锁的缺点: 通过超时时间来控制锁的失效时间并不是十分的靠谱。 基于ZooKeeper的分布式锁 基于ZK的方式： 基于zookeeper临时有序节点可以实现的分布式锁。大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的 瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导 致的锁无法释放，而产生的死锁问题。 锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（ Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。 非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。 不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的 时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。 单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。 使用zookeeper实现分布式锁 首先我们先来看看使用zk实现分布式锁的原理，在zk中是使用文件目录的格式存放节点内容，其中节点类型分为： 持久节点（PERSISTENT ）：节点创建后，一直存在，直到主动删除了该节点。 临时节点（EPHEMERAL）：生命周期和客户端会话绑定，一旦客户端会话失效，这个节点就会自动删除。 序列节点（SEQUENTIAL ）：多个线程创建同一个顺序节点时候，每个线程会得到一个带有编号的节点，节点编号是递增不重复的，如下图： 如上图，三个线程分别创建路径为/root/node的节点，可知在zk服务器端会在root下存在三个node节点，并且器编号唯一递增。 具体在节点创建过程中，可以混合使用，比如临时顺序节点（EPHEMERAL_SEQUENTIAL），这里我们就使用临时顺序节点来实现分布式锁。 分布式锁实现：创建临时顺序节点,比如/root/node，假设返回结果为nodeId。 获取/root下所有孩子节点，用自己创建的nodeId的序号与所有子节点比较，看看自己是不是编号最小的。如果是最小的则就相当于获取到了锁，如果自己不是最小的，则从所有子节点里面获取比自己次小的一个节点，然后设置监听该节点的事件，然后挂起当前线程。 当最小编号的线程获取锁，处理完业务后删除自己对应的nodeId，删除后会激活比自己大一号的节点的线程从阻塞变为运行态，被激活的线程应该就是当前node序列号最小的了，然后就会获取到锁。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式ID生成服务.html":{"url":"Books/tech/Distributed/分布式ID生成服务.html","title":"分布式ID","keywords":"","body":" 分布式ID的生成方案 分布式ID的生成方案 分布式ID的生成方案：分段 数据库自增长序列或字段：第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表 号段模式：我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。 Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现，可以利用Redis中的incr命令来实现原子性的自增与返回 UUID Twitter的snowflake雪花算法：snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图 其他框架 百度（uid-generator） ：uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。 美团（Leaf） ：美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。 滴滴Tinyid 分布式ID： 1、UUID 2、使用每个应用分一段序列号，请求的时候一次请求一段放在本地待使用，Zookeeper记录最大的Id 3、主要思路采用了MySQL自增长ID的机制(auto_increment + replace into)，以MySQL举例，利用给字段设置 auto_increment_increment 和 auto_increment_offset 来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。 4、CenterCode+AppCode+使用Redis的原子操作 INCR和INCRBY， 5、类snowflake方案：这种方案生成一个64bit的数字，64bit被划分成多个段，分别表示时间戳、机器编码、序号。 6、TDDL序列生成方式：按应用进行每次一个步长的增长，步长变动可以使用Zookeeper来通知 参考大型互联网公司分布式ID方案总结 https://www.jianshu.com/p/9d7ebe37215e https://tech.meituan.com/2017/04/21/mt-leaf.html https://www.cnblogs.com/haoxinyue/p/5208136.html https://github.com/beyondfengyu/SnowFlake https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect 分布式主键 数据库自增长序列或字段 UUID Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。 Twitter的snowflake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。 www.toutiao.com/i6682672464708764174分布式ID的生成方案 唯一ID的特性： 1、整个系统ID唯一 2、ID是数字类型，而且是趋势递增的 3、ID简短，查询效率快 1、UUID 2、MySQL主键自增 3、雪花snowflake算法 4、Redis生成方案 分布式ID的生成方案：分段 数据库自增长序列或字段 Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。 UUID Twitter的snowflake雪花算法 5、其他框架 美团 Leaf 滴滴 Tinyid 百度 UidGenerator 1、UUID 优点： 代码实现简单。 本机生成，没有性能问题 因为是全球唯一的ID，所以迁移数据容易 缺点： 每次生成的ID是无序的，无法保证趋势递增 UUID的字符串存储，查询效率慢 存储空间大 ID本事无业务含义，不可读 应用场景： 类似生成token令牌的场景 不适用一些要求有趋势递增的ID场景 2、MySQL主键自增：这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。 优点： 数字化，id递增 查询效率高 具有一定的业务可读 缺点： 存在单点问题，如果mysql挂了，就没法生成iD了 数据库压力大，高并发抗不住 3、MySQL多实例主键自增：这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长 每台的初始值分别为1,2,3...N，步长为N（这个案例步长为4） 可以自行定义max_id的起点，和step步长，保存在在数据库中，每次业务请求都去请求一段数据【max_id + 1，max_id+step】区间的ID保存在JVM本地缓存中 多个节点请求同一个业务的ID，可以使用事务的方式，把查询和更新max_id放在一个事务中 步长是可以随时修改的 因为会有一个线程，会观察什么时候去自动获取。两个buffer之间自行切换使用。就解决了突发阻塞的问题。 优点： 解决了单点问题 缺点： 一旦把步长定好后，就无法扩容； 而且单个数据库的压力大，数据库自身性能无法满足高并发 应用场景： 数据不需要扩容的场景 4、雪花snowflake算法 这个算法网上介绍了很多，老顾这里就不详细介绍。雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点： 此方案每秒能够产生409.6万个ID，性能快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点： 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。 5、Redis生成方案 利用redis的incr原子性操作自增，一般算法为： 年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增 优点： 有序递增，可读性强 缺点： 占用带宽，每次要向redis进行请求 每次都要去Redis去请求，有网络请求耗时，并发强依赖了Redis。这个设计是有风险的，一旦Redis挂了，整个系统不可用。考虑到ID安全性的问题，如：Redis方案中，用户是可以预测下一个ID号是多少，因为算法是递增的。 Leaf——美团点评分布式ID生成系统美团 Leaf：https://github.com/Meituan-Dianping/Leafhttps://github.com/zhuzhong/idleafhttps://tech.meituan.com/2019/03/07/open-source-project-leaf.htmlhttps://tech.meituan.com/2017/04/21/mt-leaf.html 滴滴 Tinyidhttps://github.com/didi/tinyid 百度 UidGeneratorhttps://github.com/baidu/uid-generator 分布式ID的实现方式：https://www.iteye.com/blog/uule-2420466https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect Twitter的snowflake雪花算法 最新的 https://twitter.github.io/twitter-server/ https://github.com/twitter/twitter-server 老的2010版本，已经淘汰了Snowflake的初始版本，已经迁移到twitter-server项目了 https://github.com/twitter-archive/snowflake/releases 参考https://www.kutu66.com/GitHub/article_103050https://github.com/zhongxunking/idcenterhttps://cloud.tencent.com/developer/article/1533454 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式缓存.html":{"url":"Books/tech/Distributed/分布式缓存.html","title":"分布式缓存","keywords":"","body":"参考 分布式缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式存储系统.html":{"url":"Books/tech/Distributed/分布式存储系统.html","title":"分布式存储系统","keywords":"","body":"一大批优秀的开源分布式存储系统，包括ceph、swift、Lustre和glusterfs等。 GlusterFS https://www.gluster.org https://github.com/gluster/glusterfs Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Distributed/分布式数据库.html":{"url":"Books/tech/Distributed/分布式数据库.html","title":"分布式数据库","keywords":"","body":"Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/DataStructure/数据结构与算法.html":{"url":"Books/tech/DataStructure/数据结构与算法.html","title":"数据结构与算法","keywords":"","body":" 1、 2、 3、 4、 5、 3、数据结构和算法：树的类型 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/DataStructure/数据结构.html":{"url":"Books/tech/DataStructure/数据结构.html","title":"数据结构学习","keywords":"","body":"Java集合数据结构 Collection ├─List │ ├─ArrayList │ ├─LinkedList │ ├─Vector ├─Stack │ ├─Set │ ├─HashSet │ ├─TreeSet Map ├─HashMap ├─TreeMap ├─LinkedHashMap 数据结构 线性表：数组（Array）和链表（linked list）等 队列（Queue） 栈（Stack） 树（tree） 图（Map） 一.什么是数据结构 答：数据结构是指数据存储的组织方式。大致上分为线性表、队列（Queue）、栈（Stack）、树（tree）、图（Map）。 二.线性表 线性表又细分为两大类，即数组（Array）和链表（linked list） 不同于内存Heap和Stack的区别 常见的数据结构：堆栈、队列、数组、链表和红黑树 数据存储的常用结构有： 队列queue：FIFO 栈stack：FILO 数组Array：数组是在内存中开辟一段连续的空间 链表LinkedList： 红黑树： 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点: 先进后出（存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。 栈的入口、出口的都是栈的顶端位置。 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。 队列的入口、出口各占一侧。 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。 每个结点包括两个部分： 一个是存储数据元素的数据域， 一个是存储下一个结点地址的指针域。 链表结构有单向链表与双向链表。 采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍。 参考 https://zhuanlan.zhihu.com/p/63138829 https://www.cnblogs.com/yinzhengjie/p/9244986.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/DataStructure/各种树的复杂度和原理.html":{"url":"Books/tech/DataStructure/各种树的复杂度和原理.html","title":"各种树的复杂度和原理","keywords":"","body":" 二叉树：二叉排序树、满二叉树、完全二叉树、平衡二叉树 B树：平衡多路搜索树B树（B-tree）、B+Tree、红黑树 Trie树（Prefix Tree）介绍 二叉树：二叉排序树、满二叉树、完全二叉树、平衡二叉树 二叉树： 二叉排序树满二叉树、完全二叉树、平衡二叉树 树： 二叉树（Binary Tree）：是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 二叉树是树的一种特殊情形，是一种更简单而且应用更加广泛的树。 满二叉树：满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 一棵深度为k，且有2^（k-1）个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。 完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。 除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。 具有n个结点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^（k-1）个叶子结点，至多有2^k-1个结点。 平衡二叉树：平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 前中后指的是根节点的位置，都是先左再右： 前序遍历：是先访问根，再访问左子树，然后访问右子树后序遍历：是先访问左子树，再访问右子树，然后访问根中序遍历：是先访问左子树，再访问根，然后访问右子树层次遍历：即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同） 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 二叉排序树，又称为二叉查找树。二叉排序树或者是一棵空树，或者是具有以下性质的二叉树：若其左子树不为空，则左子树上的所有节点的值均小于它的根结点的值；若其右子树不为空，则右子树上的所有节点的值均大于它的根结点的值；左右子树又分别是二叉排序树。 一棵空树，或者是具有下列性质的二叉树： （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3）左、右子树也分别为二叉排序树； （4）没有键值相等的结点。 二叉排序树： https://blog.csdn.net/google19890102/article/details/54378628 B树：平衡多路搜索树B树、B+Tree、红黑树 B树：平衡多路搜索树B树（B-tree）、B+Tree、红黑树 1、阶的概念 对于一棵m阶B-tree，每个结点至多可以拥有m个子结点。 即遍观整棵树，子节点最多的个数是m，那么这棵树就是m阶树。 2、树的度 树的度就是树的高度，即树的层数。 B-树就是B树 英文名字叫做B-tree，中间的短线是英文连接符，只是翻译的时候将短线翻译成了减号。 全称Balance-tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B-tree有多条路，即父节点有多个子节点。 B-树用途 使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。 B+树的定义 B+树是B树的一种变形，它更适合实际应用中操作系统的文件索引和数据库索引。定义如下：（为和大多资料保持一致，这里使用阶数mmm来定义B+树，而不像之前的B树中，使用的是最小度ttt来定义） 根据B+树的结构，我们可以发现B+树相比于B树，在文件系统，数据库系统当中，更有优势，原因如下： 1、B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I/O读写次数也就降低了。 2、B+树的查询效率更加稳定 由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 3、B+树更有利于对数据库的扫描 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能。 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。 红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。 参考 https://blog.csdn.net/u010916338/article/details/86134334 https://blog.csdn.net/guoziqing506/article/details/64122287 https://blog.csdn.net/v_JULY_v/article/details/6105630 Trie树（Prefix Tree）介绍 一、Trie树（Prefix Tree）介绍 Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。 Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 二、Trie树的优缺点 Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点 1、插入和查询的效率很高，都为O(m)O(m)，其中 mm 是待插入/查询的字符串的长度。 关于查询，会有人说 hash 表时间复杂度是O(1)O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。 2、Trie树中不同的关键字不会产生冲突。 3、Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。 4、Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。 5、Trie树可以对关键字按字典序排序。 缺点 1、当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。 2、空间消耗比较大。 三、Trie树的应用 1、字符串检索 2、词频统计 3、字符串排序 4、前缀匹配 5、作为其他数据结构和算法的辅助结构 1、字符串检索 检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较： 如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。 如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。 ``` struct trie_node { bool isKey; // 标记该节点是否代表一个关键字 trie_node *children[26]; // 各个子节点 }; ``` 2、词频统计 Trie树常被搜索引擎系统用于文本词频统计 。 ``` struct trie_node { int count; // 记录该节点代表的单词的个数 trie_node *children[26]; // 各个子节点 }; ``` 思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。 注意：第一、第二种应用也都可以用 hash table 来做。 3、字符串排序 Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。 4、前缀匹配 例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a->b->开头的路径上的关键字即可。 trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 5、作为其他数据结构和算法的辅助结构 如后缀树，AC自动机等。 参考 https://blog.csdn.net/lisonglisonglisong/article/details/45584721 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/常见算法学习.html":{"url":"Books/tech/Algorithm/常见算法学习.html","title":"常见算法","keywords":"","body":" 排序算法：十种 查找算法：七种 其他查找算法 树的数据结构和复杂度（时间和空间） 图：有向图、无向图、图的出度和入度 缓存淘汰算法：缓存算法（页面置换算法）-FIFO、LFU、LRU 排序算法：复杂度（时间、空间） 排序算法：十种 十种常见排序算法可以分为两大类： 比较类排序： 1、冒泡排序（Bubble Sort）：冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 2、选择排序（Selection Sort）：选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 3、插入排序（Insertion Sort）：插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 4、希尔排序（Shell Sort）：1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 5、归并排序（Merge Sort）：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 6、快速排序（Quick Sort）：快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 7、堆排序（Heap Sort）：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 非比较类排序： 8、计数排序（Counting Sort）：计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 9、桶排序（Bucket Sort）：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 10、基数排序（Radix Sort）：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 参考十大经典排序算法（动图演示）图解排序算法http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1面试中的 10 大排序算法总结 查找算法：七种 查找算法分类 1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。 查找性能：从快到慢： 顺序查找，时间复杂度O(N), 分块查找，时间复杂度O(logN+N/m); 二分查找，时间复杂度O(logN) Fibonacci查找，时间复杂度O(logN) 差值查找，时间复杂度O(log(logN)) 哈希查找，时间复杂度O(1) [Data Structure & Algorithm] 七大查找算法 顺序查找 二分查找（折半查找） 插值查找 斐波那契查找 树表查找： 二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树， 平衡查找树之2-3查找树（2-3 Tree） 平衡查找树之红黑树（Red-Black Tree） B树和B+树（B Tree/B+ Tree） 分块查找 哈希查找：哈希表法（散列表） 顺序查找：条件：无序或有序队列。 按顺序比较每个元素，直到找到关键字为止。 时间复杂度：O(n) 二分查找（折半查找） ：条件：有序数组 先跟中间比较，再跟较大或较小那一边比较 时间复杂度：O(logn) 插值查找 斐波那契查找 树表查找 分块查找：思想：顺序查找和二分查找的结合。 原理：将n个数据元素\"按块有序\"划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须\"按块有序\"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字； 而第2块中任一元素又都必须小于第3块中的任一元素，……。 然后使用二分查找及顺序查找。 时间复杂度：介于O(n) 和O(logn)之间。 哈希查找：哈希表法（散列表） 条件：先创建哈希表（散列表） 原理：根据键值方式(Key Value)进行查找，通过散列函数，定位数据元素。 时间复杂度：几乎是O(1)，取决于产生冲突的多少。 参考 https://www.cnblogs.com/maybe2030/p/4715035.html https://blog.csdn.net/guoweimelon/article/details/50906299 https://zhuanlan.zhihu.com/p/37440434 http://codingxiaxw.cn/2017/01/14/66-leetcode-find/ https://juejin.im/post/5c7e843351882546c20a8669 其他查找算法 参考 docs/SQL/数据库索引.md 查找算法： 1、最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。 数据结构：有序或无序队列 复杂度：O(n) 2、二分查找（binary search） 数据结构：有序数组 复杂度：O(logn) 3、二叉排序树的特点是： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 搜索的原理： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则搜索左子树；否则： 查找右子树。 数据结构：二叉排序树 时间复杂度： O(log2N) 4、哈希散列法(哈希表) 其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。 数据结构：哈希表 时间复杂度：几乎是O(1)，取决于产生冲突的多少，也就是链表长度，因为链表查找复杂度为O(n) 5、分块查找 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。 算法流程： 先选取各块中的最大关键字构成一个索引表； 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 6、平衡多路搜索树B树（B-tree） B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。 首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。 例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN) 由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质 7、B+Tree 其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。 树的数据结构和复杂度（时间和空间） 树的概念： 结点：指二叉树中一个个的点，就是下图中的0、1、2、3、4、5、6； 度：指父结点下面有几个孩子结点，举两个例子你就明白了。针对结点1，他下面有两个孩子3、4，所以说结点1的度为2；针对结点4，他下面一个孩子都没有，所以说结点4的度为0；叶子就是度为0的结点。 置于遍历有一点点麻烦，但要抓住以下要点就可以了（不管任何大小的树）： 前序：是先访问根，再访问左子树，然后访问右子树 后序：是先访问左子树，再访问右子树，然后访问根 中序：是先访问左子树，再访问根，然后访问右子树 完全二叉树，除了叶子结点这层外，其他层结点都是度为2的，所以这样的树高度应该最矮了。 以下图为例子： 前序序列：0134256后序序列：3415620中序序列：3140526 图：有向图、无向图、图的出度和入度 图论（离散数学）： 出度和入度可以把人与人之间为识的关系对应到一个图中。如果a认识b就a->b连一条边。有向图来说，结常与结点间的连接。V1到V2，V1到V3。说明V1的出度是2。V2到V1说明V1的入度是1 数据结构中入度出度分别用什么符号表示入度：ID in degree出度：OD out degree 有向图顶点集的度数是不是等于出度加入度在一个有向图中，所有顶点的入度之和等于所有顶点出度之和，一条边必有起点和终点，这是同时存在的，不存在一条边只有起点或者只有终点，所以所有顶点的入度之和等于所有顶点出度之和 在有向图中，入度高的点和出度高的点各自的含义是不同的。粗浅地说，出度高的点我们往往叫做Authority，就是那种权威性很好，所以对其他点影响力较强或者输出信息较多的点。而相应的，入度比较高的点称为Hub，即那种作为中介的，从别人那里获取信息比较多的点。当然，计算Authority和Hub更权威的方法有HITS算法等，往往并非单纯依赖出入度这么简单。 度数这个概念仅适用于无向图，即相邻的点的个数（或者说是连接的边的个数）。在有向图中，一般来说只分开考虑入度和出度，基本上见不到说把两者加起来记做度数的。 缓存淘汰算法 缓存淘汰算法：缓存算法（页面置换算法）-FIFO、LFU、LRU 链表+HashMap实现LRU算法 ：链表存储数据项的顺序，HashMap存储数据项 FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。双向链表：新来的数据放在链表尾部，淘汰时候删除头部 LRU：Least Recently Used，最近最少使用。链表+HashMap实现LRU算法：链表存储数据项的顺序，HashMap存储数据项 LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。链表实现 LRU和LFU侧重点不同， LRU主要体现在对元素的使用时间上, 而LFU主要体现在对元素的使用频次上。 LFU的缺陷是：在短期的时间内，对某些缓存的访问频次很高，这些缓存会立刻晋升为热点数据，而保证不会淘汰，这样会驻留在系统内存里面。而实际上，这部分数据只是短暂的高频率访问，之后将会长期不访问,瞬时的高频访问将会造成这部分数据的引用频率加快，而一些新加入的缓存很容易被快速删除，因为它们的引用频率很低。 参考 /Users/yangzl/git/quickstart-cache/docs/缓存学习.md https://www.cnblogs.com/wyq178/p/11790015.html 排序算法：复杂度（时间、空间） 这个简单。排序算法分为比较算法和非比较算法， 其中比较算法包括交换排序「冒泡和快排」、选择排序「简单选择排序和堆排序」、插入排序「直接插入排序、希尔排序」、归并排序「二路归并和多路归并」， 非比较排序有计数排序、桶排序、基数排序。「公式：不稳定的有：快些选堆」 1、冒泡排序。稳定的，平均时间复杂度为 O(n²)，最好时间复杂度那肯定就是一次循环 O(n)，最坏时间复杂度为 O(n²)。空间复杂度 O(1)。 2、快速排序。不稳定，平均时间复杂度为O(nlogn)，最好的时间复杂度为O(nlogn)，最坏就是选定的基准值在最边上，这样就是O(n²)，注意哦，快排的空间复杂度平均是 O(logn)，最差 O(n)。 3、简单选择排序。不稳定，平均、最好、最坏时间复杂度都为O(n²)。空间复杂度 O(1)。 4、堆排序。不稳定，平均、最好、最坏的时间复杂度为O(nlogn)。空间复杂度 O(1)。 5、直接插入排序。稳定。最好O(n)，平均、最坏时间复杂度O(n²)。空间复杂度 O(1)。 6、希尔排序。不稳定。最好O(n)，平均O(n1.3)，最坏肯定是O(n²)。空间复杂度O(1)。 7、归并排序。稳定。最好、最坏、最差时间复杂度O(nlogn)，空间复杂度O(n)。 8、计数排序。稳定，空间换时间。适合数比较集中在一起的，这样k就少了，时间复杂度为 O(n+k)，空间复杂度也为O(n+k)。「个人还是觉得其实空间复杂度为O(k)，因为我可以把值放回去的时候可以放到原数组上，所以是O(k)。」 9、桶排序，桶越多，时间复杂度很简单，为O(n+k)，空间复杂度最坏为O(n+k)，其中 n 是因为桶内部所有元素得排序， k 是指桶的数量。 10、基数排序，时间复杂度O(n*k)，k为最大数的位数，空间复杂度为O(n)。 堆排序的稳定性，如何实现堆排序，具体细节 我们知道堆的结构是节点i的孩子为2 i和2 i + 1节点， 大顶堆要求父节点大于等于其2个子节点， 小顶堆要求父节点小于等于其2个子节点。 堆排序。不稳定，平均、最好、最坏的时间复杂度为O(nlogn)。空间复杂度 O(1)。 由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N logN)。故堆排序的时间复杂度为O(N logN)。 归并排序的稳定性，如何实现归并排序，具体细节 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 平均时间复杂度、最好情况、最坏情况均为O(nlogn)，辅助空间O(n)。 归并排序。稳定。最好、最坏、最差时间复杂度O(nlogn)，空间复杂度O(n)。 归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(NlogN)。 因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(NlogN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。 说一下jdk自带的排序用到了哪些排序算法，展开讲一下 1、Arrays.sort() & Collections.sort() 2、JDK中的自带的排序算法实现原理精彩总结 jdk层面实现的sort总共是两类，一个是 Arrays.sort()， Collections.sort()； 1、Arrays.sort() a、如果数组内元素是基本数据类型，最主要采用的是双轴快速排序「其实就是三路快排一模一样的思路，只不过三路快排中间是 = pivot1，而双轴快速排序是（pivot1，pivot2），具体戳链接：https://www.cnblogs.com/nullzx/p/5880191.html 。 总结就是数组长度小于47的时候是用直接插入算法，大于47并且小于286是采用双轴快速排序，大于286如果连续性好「也就是元素大多有序，有一个flag专门用来记录数组元素的升降次数，代表这个数组的连续性」采用的是归并排序，否则还是依旧采用双轴快速排序。 b、如果数组内元素是对象，采用的是TimSort.sort()，跟 Collections.sort()一样，都是采用的这个函数，这是归并排序算法和插入排序的结合。 Collections.sort()，采用 TimSort.sort()。 TimSort.sort() 大概原理： 1、当待排序元素小于32个时，采用二分插入排序，是插入排序的一种改进，可以减少插入排序比较的次数。当找到插入位置时，直接利用System.copy()函数即可。 2、当待排序元素大于等于32个时，进行归并排序（和传统的归并不一样），首先将排序元素分区，每个分区的大小区间为[16,32)，然后依次对每个分区进行排序（具体实现依然是二分插入排序），排完序的分区压入栈（准确的说不是栈，而是一个数组，用来记录排序好的分区），当栈内的分区数满足条件时，进行分区合并，合并为一个更大的分区，当栈中只剩一个分区时，排序完成。 经典排序算法----堆与堆排序（不稳定） 经典排序算法----归并排序（稳定） https://blog.csdn.net/qianqin_2014/category_6339684.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/递归算法.html":{"url":"Books/tech/Algorithm/递归算法.html","title":"递归算法","keywords":"","body":"什么是递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。 进一步剖析「递归」，先有「递」再有「归」， 「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解）， 「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,....,直到最开始的问题解决,文字说可能有点抽象，那我们就以阶层 f(6) 为例来看下它的「递」和「归」。 参考 https://mp.weixin.qq.com/s/Hew44D8rdXb3pf8mZGk67w Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/Top K之海量数据找出现次数最多或不重复的.html":{"url":"Books/tech/Algorithm/Top K之海量数据找出现次数最多或不重复的.html","title":"Top K 之海量数据找出现次数最多或，不重复的","keywords":"","body":"Top K 之海量数据找出现次数最多或，不重复的.md 1、海量数据 求最大的 K个数问题，如何解决？ 2、海量数据求中位数，如何解决？ 3、在海量数据中找出出现频率最高的前k个数 4、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 大概统计一下，海量数据求 TopK 的普遍方法 如何判断一个元素是否存在一个集合中？ 海量数据找出不重复的元素思路一：分治法 + HashMap (HashMap 不要局限在 Java 语言) 思路二：位图法 Bitmap(一个 bit 仅会是 0 或 1) 海量数据找出出现次数最多的 思路一：分治法 + HashMap 纯数字的可以考虑思路二：位图法 Bitmap 参考https://juejin.im/post/5aa0ee9f518825557c010bc0 海量数据 求最大的 K个数问题，如何解决？ 1、按位划分区域，可以尽快的缩小范围，比如最高位 0 分一堆，1 分成一堆而且不用排序，这是第一选择。 2、最经典的方法当然是 堆 了，比如要求前1000个最大的数，那就直接建一个 1000 大小的小根堆，然后遍历，只要发现后面的数比小根堆的根节点大，就把根节点和该数交换，重新调整堆，遍历完之后，堆中的数自然就是最大的 1000 个数了； 3、当然能使用堆排序的前提是内存中要能够放得下这个 K，如果放不下呢？那就只能外部排序了，排序完之后拿到第 K 大的数即可，当然排序前可以和方法一搭配一下。 海量数据求中位数，如何解决？ 1、可以按照位来分组，比如说最高位是0的一组，是 1 的一组，这样可以统计出那一组更少，这样就排除了一大半，然后继续这样排查，最终缩小范围后直接内部排序。 2、直接外部排序，然后取中间值，最笨的方法。 在海量数据中找出出现频率最高的前k个数 例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。 1、如果重复率很高，可以采用前缀树，因为 trie 树适用于数据量大，重复多，但是数据种类小必须得可以放入内存； 2、按照 hash 进行分组，这样就能避免相同的数分到不同区域去了，导致不好统计。hash 分组完毕后，然后用前缀树 或者 hashmap 来计算每个组的前 k 个频率最高的数，最后对各个组的前 k 个数进行统计即可。 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 1、这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。 2、然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找 3、再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 4、并将这两类分别写入到两个文件中，其中一个文件中数的个数=10亿（这相当于折半了）；与要查找的数的次最高位比较并接着进入相应的文件再查找。……. 以此类推，就可以找到了,而且时间复杂度为O(logn)。 大概统计一下，海量数据求 TopK 的普遍方法： 1、最快的不需要排序就能排除一大堆的数据的方法就是看 “位”，比如最高位为 0 的分一块，为 1 的分一块，这样迅速就分出一大块不需要的了，尤其适合找中位数，等分的差不多了就可以进行内部排序了。 2、堆排序，适用于求海量数据最大 K or 最小的 K 个数； 3、分治hash，适用于那些内存很小，数据很大，但是又想求最大的 K 个众数的问题，可以先 hash 到很多个组，然后在组内部使用 hashmap 或者 前缀树 「google等字符」，取到组内前 K 个众数，最后进行组间比较久okay了； 4、当然不能忘了万能法，那就是外部排序，然后再进行相应的处理。 如何判断一个元素是否存在一个集合中？ 先来看几个比较常见的例子 字处理软件中，需要检查一个英语单词是否拼写正确 在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上 在网络爬虫里，一个网址是否被访问过 yahoo, gmail等邮箱垃圾邮件过滤功能 这几个例子有一个共同的特点： 如何判断一个元素是否存在一个集合中？ 这里必须介绍一下 bitmap 这个方法了，例如我要从海量数据中找一个数是否出现过，就可以用位图的思路去做，如果数字是 7 ，那就在第 7 位 置 1，如果该位置已经是 1 了，那就代表出现过，不用更改。 如果问题变为从海量数据中找一个数是否出现过一次，那这个时候就得用 2 bitmap 来表示了，也就是一个数如果出现一次，置为 01 ，出现过两次，置为 10，然后再出现，都是10，这个时候如果我们只用一位，是不能表示出出现的次数的。 至于我们常说的布隆过滤器，其实也就是在bitmap之前进行一个hash，例如将字符串进行hash成数组，然后使用位图，解决这类问题。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/256M的内存如何对16g的数组进行排序.html":{"url":"Books/tech/Algorithm/256M的内存如何对16g的数组进行排序.html","title":"256M的内存如何对16g的数组进行排序","keywords":"","body":"参考 256M的内存如何对16g的数组进行排序 多路归并，因为没要求存储，只要求了内存，可以多路归并，加入每个元素都是 1M，则可以最多分成 256 组，然后进行归并。 具体描述：采用外部排序，先将16 g数组分成 256 M 一组，然后分别读入内存进行内部排序「比如说可以使用快排」，将这些组内元素全部排好序之后，然后运用败者树和置换-选择排序，进行多路归并，即可。 胜者树与败者树 胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。 不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。 胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。 在k路归并排序中经常用到。 胜者树与败者树参考 https://blog.csdn.net/whz_zb/article/details/7425152 http://c.biancheng.net/view/3453.html https://blog.csdn.net/FX677588/article/details/72471357 https://www.jianshu.com/p/b8faa1affe17 https://www.cnblogs.com/tonychen-tobeTopCoder/p/5797002.html https://blog.csdn.net/xiezhi123456/article/details/87632559 https://blog.csdn.net/life_liver/article/details/8554133 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/比较两个大文件的重复数据的算法.html":{"url":"Books/tech/Algorithm/比较两个大文件的重复数据的算法.html","title":"比较两个大文件的重复数据的算法","keywords":"","body":"思路1：使用bloom filter算法。 如果不考虑100%准确率，那么bloom filter将是很好的选择 思路2：hash hash的原理就不说了，这里主要使用“大而化小，分而治之”的策略。 遍历a（假如a是较大的文件），对a的每一行做hash运算，根据hash值将该行数据映射到一个小文件a1-a100文件中； 此时遍历b，做同样的hash算法，映射到b1-b100小文件中；（注意：两个字符串如果相同，那么他们经过同一hash算法得到的必然也是相等的） 逐个比较文件对，此时数据量够小，可以装载到hashmap中进行比对，最后得到结果。 参考https://www.zhihu.com/question/21827402/answer/387830719https://my.oschina.net/vdroid/blog/373439https://blog.csdn.net/qingdujun/article/details/82343756https://blog.csdn.net/tiankong_/article/details/77234726 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Algorithm/负载均衡原理、种类和算法.html":{"url":"Books/tech/Algorithm/负载均衡原理、种类和算法.html","title":"负载均衡原理、种类和算法","keywords":"","body":" 负载均衡原理 负载均衡类型 负载均衡算法 负载均衡原理 随机、轮训、加权 源地址hash法、最小连接数、最快响应速度等 负载均衡(Load Balance，简称LB)是一种服务器或网络设备的集群技术。 负载均衡将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备，从而提高了业务处理能力，保证了业务的高可用性。 负载均衡基本概念有：实服务、实服务组、虚服务、调度算法、持续性等，其常用应用场景主要是服务器负载均衡，链路负载均衡。 负载均衡器主要分为硬件负载均衡和软件负载均衡两大类。 应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。 负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备） 负载均衡的作用（解决的问题）： 1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）； 2.提供故障转移，实现高可用； 3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）； 4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理） 负载均衡类型 根据实现技术不同，可分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等。 DNS负载均衡 HTTP负载均衡（Nginx,Haproxy） IP负载均衡：在网络层通过修改请求目标地址进行负载均衡。 链路层负载均衡：通信协议的数据链路层修改mac地址，进行负载均衡。 混合型负载均衡： 根据OSI模型可将负载均衡分为： 1）二层负载均衡（一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应）； 2）三层负载均衡（一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应）； 3）四层负载均衡（在三次负载均衡的基础上，用 ip+port 接收请求，再转发到对应的机器）； 4）七层负载均衡（根据虚拟的url或是IP，主机名接收请求，再转向相应的处理服务器）。 这其中，最常见的是四层和七层负载均衡 负载均衡算法 常用的负载均衡算法分为两类： 1）一种是静态负载均衡； 轮询法： 随机法： 源地址哈希法： 加权轮询法： 加权随机法： 键值范围法： 2）一种是动态负载均衡。 最小连接数法： 最快响应速度法： 观察模式法： 负载均衡算法： 常用的负载均衡算法有，轮询，随机，最少链接，源地址散列，加权等方式； 轮询（Round Robin，RR）：加权轮询（Weighted Round Robin，WRR） 将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。 优点：服务器请求数目相同； 缺点：服务器压力不一样，不适合服务器配置不同的情况； 随机（Random） 请求随机分配到各个服务器。 优点：使用简单； 缺点：不适合机器配置不同的场景； 最少连接（Least Connections）：加权最少链接（Weighted Least Connections）简称WLC 将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。 优点：根据服务器当前的请求处理情况，动态分配； 缺点：算法实现相对复杂，需要监控服务器请求连接数； Hash源地址散列（Source hashing） 根据IP地址进行Hash计算，得到IP地址。 优点：4将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。 缺点：目标服务器宕机后，会话会丢失； 加权 在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。 优点：根据权重，调节转发服务器的请求数目； 缺点：使用相对复杂； 参考 https://blog.csdn.net/Kim_Weir/article/details/80550133 https://www.jianshu.com/p/215b5575107c https://www.jianshu.com/p/7bb52818b8a9 https://blog.51cto.com/7346473/1597135 https://segmentfault.com/a/1190000019026606 https://blog.csdn.net/a724888/article/details/80775778 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Gateway/Gateway网关.html":{"url":"Books/tech/Gateway/Gateway网关.html","title":"网关","keywords":"","body":" Gateway网关 1、 2、 3、 4、 5、 网关、微服务[quickstart-gateway] 代理服务器 流量网关 或者 代理服务器 或者 负载均衡 API服务网关 /Users/yangzl/git/quickstart-gateway/docs 1、 网关之降级、熔断、限流、隔离、幂等性验证、超时重试机制的相关知识简单整理 1、微服务架构中没有接口限流，可能会遇到哪些问题？ 2、针对微服务接口限流，如何选择合适的限流算法？ 3、如何根据场景和性能要求权衡选择单机还是分布式限流？ 4、如何根据业务需求灵活的选择不同的限流熔断机制？ 5、如何对接口选择合适的限流时间粒度和最大限流值？ 6、如何验证微服务接口限流功能的有效性和正确性？ 7、如何打造高度容错、高 TPS、低延迟的限流框架？ 2、 高并发流量限制（计数器、漏桶、令牌桶）：限流（过载保护）采用漏桶算法和令牌桶算法实现限流技术(time limiting)令牌桶(Token Bucket)和漏桶(leaky bucket)是 最常用的两种限流的算法。令牌桶(Token Bucket)：可以突发流量，产生Token的速率（rate）+ 桶的大小【最大突发流量】 + 初始令牌个数漏桶(leaky bucket)：固定速率，桶大小+漏洞的大小(rate) 背景：通常在高并发访问的情况下，会通过限流的手段来控制流量问题，以保证服务器处于正常压力下，一般对超过的部分不做处理，即丢弃。限流的手段通常有计数器、漏桶、令牌桶。注意限流和限速（所有请求都会处理）的差别，视业务场景而定1、计数器：在一段时间间隔内（时间窗），处理请求的最大数量固定，超过部分不做处理2、漏桶：漏桶大小固定，处理速度固定，但请求进入速度不固定（在突发情况请求过多时，会丢弃过多的请求）3、令牌桶：令牌桶的大小固定，令牌的产生速度固定，但是消耗令牌（即请求）速度不固定（可以应对一些某些时间请求过多的情况）；每个请求都会从令牌桶中取出令牌，如果没有令牌则丢弃该次请求。 Google开源工具包Guava提供了限流工具类RateLimiter,该类基于令牌桶算法(Token Bucket)来完成限流 https://blog.csdn.net/peiwuyang/article/details/45066341https://blog.csdn.net/tianyaleixiaowu/article/details/74942405https://blog.csdn.net/collonn/article/details/72877812https://blog.csdn.net/I_will_try/article/details/77881188http://ifeve.com/guava-ratelimiter/https://my.oschina.net/hanchao/blog/1833612 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Modular/Modular模块化.html":{"url":"Books/tech/Modular/Modular模块化.html","title":"模块化和类隔离","keywords":"","body":"模块化 1、 2、 3、 4、 5、 [quickstart-modular] 模块化 Java9 java9模块化开发 JarsLink 阿里开源，已经合并到sofa-jarslink里面了 1、 模块化 /Users/yangzl/git/quickstart-modular Fat Jar学习.md 模块化.md 服务框架- Pandora sofa-jarslink：jarslink的最新版本 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/网络和HTTP.html":{"url":"Books/tech/Net/网络和HTTP.html","title":"网络和HTTP","keywords":"","body":"网络和HTTP 1、 2、 3、 4、 5、 1、熟悉常用网络协议，如TCP/IP, HTTP;ajax请求流程，ajax状态码，http状态码 OSI七层与TCP/IP五层网络架构 TCP/IP连接过程：三次握手四次挥手 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因 http连接过程：域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 存在的问题：不安全，被监听，被伪装，被篡改 https连接过程：+SSL层，过程是先非对称协商秘钥，然后进行加密传输 HTTP状态码 TCP粘包、拆包问题 2、网络： /Users/yangzl/git/quickstart-http/README.md CORS跨域请求.md HTTP、HTTPS、HTTP2、HTTP3.md http和http2的区别.md HTTP学习.md Http请求模拟工具.md TCPIP网络传输学习.md TCP和UDP的最完整的区别.md 淘宝全站HTTPS实践.pdf http和TCP http和http2的区别:http、https、spdy、http2 Socket和TCP/IP 3、 1、HTTP特点 2、HTTP1.0、HTTP1.1、HTTP2、HTTP3的区别 3、TCP的三次握手、四次挥手 4、https连接建立过程 4、 TCP三次握手四次挥手讲解： https://blog.csdn.net/hguisu/article/details/38700899 面试题目 https://hit-alibaba.github.io/interview/basic/network/TCP.html 1.TCP/IP 三次握手 四次挥手osi参考模型：tcp/ip四层概念模型：应用层（应用层、表现层、会话层）、传输层、网络层、数据链路层（数据链路层、物理层）（3 1 1 2） TCP/IP:协议的集合，代表性的有ip、tcp、http。ip:网络层。代表网际协议。tcp：传输层。tcp是可靠的，udp是不可靠的。http：应用层协议，主要解决如何包装数据。除了http还有ftp、telnet等等把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 tcp三次握手：建立tcp连接。client端发送一个数据包，server端确认收到连接并返回给client，client确认然后连接建立完成。随后client和server端可以开始传输数据。tcp四次握手：断开tcp连接。client端发送一个FIN请求，server收到一个FIN请求表示client这一端不在发送数据了，但是还能接收数据，此时tcp连接还没有关闭。直到server端再发送一个FIN请求，表示server端也不会再发送数据了；client端收到FIN后，给server一个ack响应，server端进入closed状态。 2.Http的格式说明request由请求行、请求头、请求体组成请求行（参考：GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1 请求类型 请求地址 协议版本）请求头（参考：HOST是主机地址，User-Agent是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送，等等Host: www.fishbay.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6）空行：请求头后面必须有一行空行请求数据：请求体 response由状态行、响应头、响应体组成。参考如下：HTTP/1.1 200 OK 状态行Server: nginx 响应头Date: Mon, 20 Feb 2017 09:13:59 GMTContent-Type: text/plain;charset=UTF-8Vary: Accept-EncodingCache-Control: no-storePragrma: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTCache-Control: no-cacheContent-Encoding: gzipTransfer-Encoding: chunkedProxy-Connection: Keep-alive 空行{\"res\":ok\"} 响应体 3.状态码说明200 OK 请求成功301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 资源未找到500 Internal Server Error 服务端内部错误502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 网络：1、TCP/IP 三次握手 四次挥手2、Http的格式说明、状态码说明3、进程间通信方式 OSI七层与TCP/IP五层网络架构详解http://network.51cto.com/art/201310/413853.htmhttp://blog.csdn.net/cc1949/article/details/79063439OSI七层模型7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 OSI中的层 功能 TCP/IP协议族应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet表示层 数据格式化，代码转换，数据加密 没有协议会话层 解除或建立与别的接点的联系 没有协议传输层 提供端对端的接口 TCP，UDP网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 (2)TCP/IP五层模型的协议五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。 传输层：四层交换机、也有工作在四层的路由器网络层：路由器、三层交换机数据链路层：网桥(现已很少使用)、以太网交换机(二层交换机)、网卡(其实网卡是一半工作在物理层、一半工作在数据链路层) 物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层 http、tcp/ip和socket的区别tcp/ip协议的详解http状态码 有两种缓存方法：让代理服务器进行缓存和让客户端浏览器进行缓存。Cache-Control 用于控制缓存的行为。Cache-Control: no-cache 有两种含义，如果是客户端向缓存服务器发送的请求报文中含有该指令，表示客户端不想要缓存的资源；如果是源服务器向缓存服务器发送的响应报文中含有该指令，表示缓存服务器不能对资源进行缓存。Expires 字段可以用于告知缓存服务器该资源什么时候会过期。当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。 TCPIP、Http、Socket的区别http://blog.csdn.net/lu123535884/article/details/43270041https://www.cnblogs.com/fuyuanming/articles/4848250.html 网络由下往上分为　　物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。　　IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。　　三者从本质上来说没有可比性。 socket则是对TCP/IP协议的封装和应用。　　也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，　　而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：　　“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。　　如果想要使传输的数据有意义，则必须使用到应用层协议。　　应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。　　WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”　　而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。　　通过Socket，我们才能使用TCP/IP协议。　　实际上，Socket跟TCP/IP协议没有必然的联系。　　所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，总结：socket是针对TCP/IP协议开放的API。自建socket等于废弃应用层的协议（例如http），自己新建应用层协议（所以 socket套接字要绑定端口，类似于http要一个端口）。再换句话说，http是用socket实现了TCP/IP。因为socket是针对TCP/IP协议开放的API，所以socket是有三次握手这样的特性的。 而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。 通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也 能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道 的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。网络有一段关于 socket和TCP/IP协议关系的说法比较容易理解：“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外 的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是 Socket编程接口。” HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。 TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上 保证了)保证了连接的可靠性;而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正 确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 HTTP协议http://www.blogjava.net/zjusuyong/articles/304788.html HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP状态码：https://www.cnblogs.com/hjxcode/p/5663830.htmlhttp://blog.csdn.net/ahzxj2012/article/details/52510491Type Reason-phrase Note1XX Informational 信息性状态码，表示接受的请求正在处理2XX Success 成功状态码，表示请求正常处理完毕3XX Redirection 重定向状态码，表示需要客户端需要进行附加操作4XX Client Error 客户端错误状态码，表示服务器无法处理请求5XX Server Error 服务器错误状态码，表示服务器处理请求出错 TCPIP：三次握手四次挥手，查看TCP连接状态数量：netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'http://blog.csdn.net/linux_ever/article/details/51136723http://blog.csdn.net/whuslei/article/details/6667471https://www.cnblogs.com/Jessy/p/3535612.html收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因有二：一、Client重发可能丢失的ACK报文：保证TCP协议的全双工连接能够可靠关闭,保证Server端收到ACK，如果Server端未收到ACK，会再次收到Server的FIN，可以再次发送ACK二、保证这次连接的重复数据段从网络中消失，下次相同IP和Port不会再接收本次连接滞留在网络中的数据，如果新建的连接和上次的port相同，之前关闭的连接的数据滞留在网络再次发送到Server，Server会认为是新的连接发送的，导致数据混淆 TCP连接需要三次握手分开需要四次挥手：TCP三次握手过程1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:\"我已收到回复,我现在要开始传输实际数据了 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 4次断开1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置13 由B 端再提出反方向的关闭请求,将FIN置14 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础 TCP状态码： 各个状态的意义如下：1、Client：发送SYN后SYN-SENT -在发送连接请求后等待匹配的连接请求；2、Server：接受到SYN，并且发送ACK后LISTEN - 侦听来自远方TCP端口的连接请求；SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；3、Clinet+Server：Clinet发送ACK后，Server接收到ACK后ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 1、Client发送FIN后FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 2、Server接收到FIN，并且返回ACKCLOSE-WAIT - 等待从本地用户发来的连接中断请求； 3、Client收到ACK后FIN-WAIT-2 - 从远程TCP等待连接中断请求； 4、Server发送FIN后LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； 5、Client接受FIN并且返回ACKTIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 6、Server接收到ACK和Client等待2个MSL(Max Segment Lifetime)后TimeOut超时CLOSED - 没有任何连接状态； CLOSING -等待远程TCP对连接中断的确认； SYN_RECV 状态：服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。 一般服务器都会设置net.ipv4.tcp_syncookies=1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。 CLOSE_WAIT状态发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。 http调用：feign、httpClient、okhttp、unirest、jdk、jersey-http Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议.html":{"url":"Books/tech/Net/HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议.html","title":"HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议","keywords":"","body":"采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因 http连接过程（5步）：域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 存在的问题：不安全，被监听，被伪装，被篡改 https连接过程(5步)：+SSL层，过程是先非对称协商秘钥，然后进行加密传输 加解密 单向加密和双向加密（对称加密和非对称加密） 单向加密(信息摘要)：MD5、SHA 对称加密：DES、3DES、AES 非对称加密：RSA、DSA、ECDSA 查看项目quickstart-crypto /Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/加解密.md Ajax请求流程 AJAX状态码 HTTP状态码 OSI七层与TCP/IP五层网络架构详解 TCP/IP连接过程：三次握手四次挥手 MTU和MSS区别 Ajax请求流程 xhr对象 【Ajax发送请求】这件事情并不是一句话带过就可以的，在Ajax中对整个请求从创建到发送都有一套严格的标准流程。在Ajax规则中，“请求”从创建到被发送需要至少经历如下几个步骤： 通过XMLHttpRequest类创建xhr对象 为xhr对象添加属性与回调方法 令xhr对象执行open()方法，指明请求被发往某处 4.令xhr对象执行send()方法，发出请求 AJAX状态码 一共有5中请求状态，从0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 // readyState值说明 // 0,初始化,XHR对象已经创建,还未执行open // 1,载入,已经调用open方法,但是还没发送请求 // 2,载入完成,请求已经发送完成 // 3,交互,可以接收到部分数据 // 4: 请求已完成，且响应已就绪 HTTP状态码 // status值说明 // 200:成功 // 404:没有发现文件、查询或URl // 500:服务器产生内部错误 1 信息，服务器收到请求，需要请求者继续执行操作 2 成功，操作被成功接收并处理 3 重定向，需要进一步的操作以完成请求 4 客户端错误，请求包含语法错误或无法完成请求，403 拒绝 404 not found 5** 服务器错误，服务器在处理请求的过程中发生了错误 readyState属性 值为0，对应常量UNSET：表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。 值为1，对应常量OPENED：表示send()方法还没有被调用，仍可以使用setRequestHeader()设定HTTP请求头 值为2，对应常量HEADERS_RECEIVED：表示send()方法已经执行，并且头信息和状态码已经收到。 值为3，对应常量LOADING：表示正在接收服务器传来的body部分的数据，如果responseType属性是text或者空字符串，responseText就会包含已经收到的部分信息。 值为4，对应常量DONE，表示服务器数据已经完全接收，或者本次接收已经失败了。 OSI七层与TCP/IP五层网络架构详解 http://network.51cto.com/art/201310/413853.htm http://blog.csdn.net/cc1949/article/details/79063439 OSI七层模型 7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 OSI中的层 功能 TCP/IP协议族 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 提供端对端的接口 TCP，UDP 网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 (2)TCP/IP五层模型的协议 五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。 传输层：四层交换机、也有工作在四层的路由器 网络层：路由器、三层交换机 数据链路层：网桥(现已很少使用)、以太网交换机(二层交换机)、网卡(其实网卡是一半工作在物理层、一半工作在数据链路层) 物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层 TCP/IP连接过程：三次握手四次挥手 TCPIP：三次握手四次挥手，查看TCP连接状态数量：netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' http://blog.csdn.net/linux_ever/article/details/51136723 http://blog.csdn.net/whuslei/article/details/6667471 https://www.cnblogs.com/Jessy/p/3535612.html 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime) 原因有二： 一、Client重发可能丢失的ACK报文：保证TCP协议的全双工连接能够可靠关闭,保证Server端收到ACK，如果Server端未收到ACK，会再次收到Server的FIN，可以再次发送ACK 二、保证这次连接的重复数据段从网络中消失，下次相同IP和Port不会再接收本次连接滞留在网络中的数据，如果新建的连接和上次的port相同，之前关闭的连接的数据滞留在网络再次发送到Server，Server会认为是新的连接发送的，导致数据混淆 TCP连接需要三次握手分开需要四次挥手： TCP三次握手过程 1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段, 主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我. 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事: 我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:\"我已收到回复,我现在要开始传输实际数据了 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 4次断开 1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1 3 由B 端再提出反方向的关闭请求,将FIN置1 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束. 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础 TCP状态码： 1、Client：发送SYN后 SYN-SENT -在发送连接请求后等待匹配的连接请求； 2、Server：接受到SYN，并且发送ACK后 LISTEN - 侦听来自远方TCP端口的连接请求； SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； 3、Clinet+Server：Clinet发送ACK后，Server接收到ACK后 ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 1、Client发送FIN后 FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 2、Server接收到FIN，并且返回ACK CLOSE-WAIT - 等待从本地用户发来的连接中断请求； 3、Client收到ACK后 FIN-WAIT-2 - 从远程TCP等待连接中断请求； 4、Server发送FIN后 LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； 5、Client接受FIN并且返回ACK TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 6、Server接收到ACK和Client等待2个MSL(Max Segment Lifetime)后TimeOut超时 CLOSED - 没有任何连接状态； CLOSING -等待远程TCP对连接中断的确认； SYN_RECV 状态： 服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。 一般服务器都会设置net.ipv4.tcp_syncookies=1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。 这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。 CLOSE_WAIT状态 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。 HTTP请求流程 域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 Request URL: https://www.baidu.com/img/bd_logo1.png?where=super 请求的url Request Method: GET 请求的方法 请求的参数等 Request Version：HTTP/1.1 请求的http协议版本 Status Code: 200 OK Remote Address: 61.135.169.125:443 Referrer Policy: unsafe-url User-Agent： 客户端信息，用户代理信息等 Accept: 可以接受的MIME类型的所有类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cache-Control: no-cache Connection: keep-alive 连接时候使用keep-alive特性 Cookie: BAIDUID=CB8A67CFBD7637407BE94645AA5C2D39:FG=1; BIDUPSID=CB8A67CFBD7637407BE94645AA5C2D39; PSTM=1533969843; BD_UPN=123253; BDUSS=Q2SzZ2VXViaUtQdnNzSDlTRjR4YVQtbHBiVzVsZjVFOXNoUk43Nk9IQUxFYmhiQVFBQUFBJCQAAAAAAAAAAAEAAAAh1JYfeW91bmd6aWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuEkFsLhJBba2; delPer=0; BD_CK_SAM=1; BDRCVFR[C0p6oIjvx-c]=I67x6TjHwwYf0; H_PS_PSSID=1454_21106_20692_26350_22073; BD_HOME=1; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; pgv_pvi=262569984; pgv_si=s4821341184; ZD_ENTRY=baidu; MCITY=-%3A; PSINO=7; sugstore=1 Host: www.baidu.com 主机名 Pragma: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 HTTP Response响应头信息 Header 解释 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives... Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives... Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic http通信存在的问题 1、容易被监听 http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的 2、被伪装 http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。 3、被篡改 hacker中间篡改数据后，接收方并不知道数据已经被更改 HTTPS是一种协议，等于HTTP+TLS（由于历史原因，SSL3.0之后就被TLS1.0替代了）。 openssl是一套开源工具集，主要有两个特性： 1、实现了ssl2,ssl3，TLSv1，TLSv1.1，TLSv1.2协议。 2、实现目前常用的加密算法。 没有一个非常精准的方法来判断HTTPS是否使用openssl，但是根据网站返回的server类型，可以大致估计是否使用了openssl，比如如果使用apache或者nginx，那么肯定是使用了openssl。保守估计至少70%以上的网站是使用openssl的。而windows系列的服务器包括IIS，windows server等都是使用schannel，没有使用openssl，不会受heartbleed影响。 https连接过程： 1、客户端发送请求到服务器端，发送客户端支持的加密协议及版本，SSL、TLS 2、服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在，服务器从中筛选合适的加密协议，返回证书，证书中有公钥 3、客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端 4、服务器端使用私有密钥解密数据，并使用收到的共享密钥使用对称加密密钥加密数据，发送到客户端 5、客户端使用共享密钥解密数据、SSL加密建立……… HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的具体描述如下： 1.浏览器将自己支持的一套加密规则发送给网站。 2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 3.浏览器获得网站证书之后浏览器要做以下工作： a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 4.网站接收浏览器发来的数据之后要做以下的操作： a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 b) 使用密码加密一段握手消息，发送给浏览器。 5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 另外，HTTPS一般使用的加密与HASH算法如下： 非对称加密算法：RSA，DSA/DSS 对称加密算法：AES，RC4，3DES HASH算法：MD5，SHA1，SHA256 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS和HTTP的区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全。 HTTP协议的主要特点可概括如下： 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 2.2 HTTP协议的几个重要概念 1.连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。 2.消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。 3.请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号 4.响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。 5.资源(Resource)：由URI标识的网络数据对象或服务。 6.实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。 7.客户机(Client)：一个为发送请求目的而建立连接的应用程序。 8.用户代理(User agent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。 9.服务器(Server)：一个接受连接并对请求返回信息的应用程序。 10.源服务器(Origin server)：是一个给定资源可以在其上驻留或被创建的服务器。 11.代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 12.网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 13.通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 14.缓存(Cache)：反应信息的局域存储。 1.建立连接 连接的建立是通过申请套接字(Socket)实现的。客户打开一个套接字并把它约束在一个端口上，如果成功，就相当于建立了一个虚拟文件。以后就可以在该虚拟文件上写数据并通过网络向外传送。 2.发送请求 打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。 HTTP/1.0 请求消息的格式为： 请求消息=请求行(通用信息|请求头|实体头) CRLF[实体内容] 请求 行=方法 请求URL HTTP版本号 CRLF 方 法=GET|HEAD|POST|扩展方法 U R L=协议名称+宿主名+目录与文件名 请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下： 对象 GET的结果 文件 文件的内容 程序 该程序的执行结果 数据库查询 查询结果 HEAD——要求服务器查找某对象的元信息，而不是对象本身。 POST——从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。 一个请求的例子为： GET http://networking.zju.edu.cn/zju/index.htm HTTP/1.0 头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答 。 请求头——告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。 实体头——实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。 实体——请求或应答对象本身。 3.发送响应 服务器在处理完客户的请求之后，要向客户机发送响应消息。 HTTP/1.0的响应消息格式如下： 响应消息=状态行(通用信息头|响应头|实体头) CRLF 〔实体内容〕 状 态 行=HTTP版本号 状态码 原因叙述 状态码表示响应类型 1×× 保留 2×× 表示请求成功地接收 3×× 为完成请求客户需进一步细化请求 4×× 客户错误 5×× 服务器错误 响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。 4.关闭连接 客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话 SSL是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”，它是在上世纪90年代中期，由网景公司设计的（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）。 为啥要发明SSL这个协议捏？因为原先互联网上使用的HTTP协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改，发明SSL协议，就是为了解决这些问题。 到了1999年，SSL因为应用广泛，已经成为互联网上的事实标准，IETF就在那年把SSL标准化，标准化之后的名称改为TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。 HTTP和HTTPS的区别 https://www.cnblogs.com/bluestorm/p/5763533.html https://segmentfault.com/a/1190000011185129 https://juejin.im/entry/58d7635e5c497d0057fae036 TCP协议中的三次握手和四次挥手(图解) https://blog.csdn.net/whuslei/article/details/6667471 https://blog.csdn.net/qq_38950316/article/details/81087809 HTTP请求过程 https://www.linux178.com/web/httprequest.html https请求建立过程 https://blog.csdn.net/wangjun5159/article/details/51510594 https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html OSI七层协议和TCP/IP四层协议 https://blog.csdn.net/qq_18425655/article/details/52314970 MTU和MSS区别 MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小； 以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。 MSS：Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。 如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。 参考https://www.jianshu.com/p/3be7582ddf78 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/IP地址分类-内网IP.html":{"url":"Books/tech/Net/IP地址分类-内网IP.html","title":"IP地址分类-内网IP","keywords":"","body":"InterNIC将IP地址分为五类: A类保留给ZF或大型企业， B类分配给中等规模的公司， C类分配给小公司或个人， D类用于组播， E类用于实验， 注：各类可容纳的地址数目不同。 在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。 这三个地址段分别位于A、B、C三类地址内： A类地址：10.0.0.0--10.255.255.255 B类地址：172.16.0.0--172.31.255.255 C类地址：192.168.0.0--192.168.255.255 IP地址范围：1.0.0.1——255.255.255.254 公网是不会使用者三类地址的，即使用这三类IP的一定在公司或者学校（组织）内网中，公网是看不到的。 装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。 另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。 NAT就是网络地址转换的英文缩写，在路由器上配置NAT服务，可提供公司内100~200人同时上网的服务。不需要Proxy Server，所有的服务都可顺利使用（除Netmeeting之类的服务），客户端无需做复杂设定，与应用程序无关。解决了使用Proxy Server带来的烦复的设置工作。NAT有三种类型：静态NAT（staticNAT）、NAT池（pooledNAT）和端口NAT（PAT）。 参考 https://blog.csdn.net/superit401/article/details/78246298 https://blog.csdn.net/sforiz/article/details/6417017 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/NAT和UDP穿孔打洞、HTTP隧道.html":{"url":"Books/tech/Net/NAT和UDP穿孔打洞、HTTP隧道.html","title":"NAT和UDP穿孔打洞、HTTP隧道","keywords":"","body":"NAT(Network Address Translators)，网络地址转换：网络地址转换是在IP地址日益缺乏的情况下产生的，它的主要目的就是为了能够地址重用。 NAT分为两大类，基本的NAT和NAPT(Network Address/Port Translator)。 最开始NAT是运行在路由器上的一个功能模块。 一种是NAT再次创建一个Session，并且再次为这个Session分配一个端口号（比如：62001）。另外一种是NAT再次创建一个Session，但是不会新分配一个端口号，而是用原来分配的端口号62000。前一种NAT叫做Symmetric NAT，后一种叫做Cone NAT。 ClientA（内网10.0.0.1:1234）----》NATA（内网IP，公网IP）----》Server UDP用打洞技术穿透NAT的原理与实现： 那么我们如果想从外部发送一个数据报给内网的计算机有什么办法呢？首先，我们必须在内网的NAT上打上一个“洞”（也就是前面我们说的在NAT上建立一个Session），这个洞不能由外部来打，只能由内网内的主机来打。而且这个洞是有方向的，比如从内部某台主机（比如：192.168.0.10）向外部的某个IP(比如：219.237.60.1)发送一个UDP包，那么就在这个内网的NAT设备上打了一个方向为219.237.60.1的“洞”，（这就是称为UDP Hole Punching的技术）以后219.237.60.1就可以通过这个洞与内网的192.168.0.10联系了。（但是其他的IP不能利用这个洞）。 ClientA NAT-A Server NAT-B ClientB 总结一下这个过程：如果Client A想向Client B发送信息，那么Client A发送命令给Server S，请求Server S命令Client B向Client A方向打洞。 在NAT B上打一个方向为202.187.45.3（即Client A的外网地址）的洞，那么Client A发送到187.34.1.56:40000的信息,Client B就能收到了。 vpn工具禁用UDP加速功能，由于vpn工具使用了UDP穿孔技术，会导致NAT-遍历，影响性能，因此，此功能必须选中，否则无法正常拨号。 P2P技术： HTTP隧道是拿来穿防火墙的，跟穿透NAT是完全不同的概念 我要的是两个不同局域网之内的用户不通过服务器而交换数据（P2P），HTTP隧道，不可能达到此目的。 能否通过IP伪装来实现这一点？ NAT Loopback（NAT回环） HTTP： 在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。 HTTP中继的概念（原封不动的将HTTP消息和响应在Client 和 Web Server之间传输）； HTTP隧道技术 https://blog.csdn.net/nicehunt/article/details/44218775 https://blog.csdn.net/yangdelong/article/details/1584349 https://blog.csdn.net/u011995362/article/details/53729512 应用场景： 防火墙(只开放80)内的机器A 防火墙外部的机器B (http隧道服务器) 防火墙外部的机器C 如果A要通过某种非http协议访问C 应该不能访问 http隧道流程是 A上的软件需要用到非http协议访问外部机器时候 把本来的数据(包括数据、最终IP地址、原始协议等)打包放在一个http包中然后发给B, 这时候防火墙是可以通过的 .B上接收到数据包之后 分解数据形成原始的数据包 按照原协议发送给最终的IP,返回数据之后 打包成http 发送给A。A解释这个http包并且处理. 利用HTTP协议的缺陷来实现对防火墙的渗透，或者说现有的一些HTTP隧道技术的实现，是基于防火墙在对HTTP协议的报文进行识别与过滤时，往往只对其诸如POST、GET等命令的头进行识别，而放行其后的所有报文。 简单的说，HTTP隧道技术就是把所有要传送的数据全部封装到HTTP协议里进行传送，HTTP隧道技术几乎支持了所有的上网方式，如：拨号上网、ADSL、Cable Modem、NAT透明代理、HTTP的GET型和CONNECT型代理、SOCKS4代理、SOCKS5代理等。 另外HTTP隧道技术也用于木马的制作，如把HTTP数据包里Agent段设为IE，对外端口为80，然后把自己的小马注入IE进程，哪个防火墙能分辨出它是木马在发送数据？ HTTP隧道工具HTTPTunnel 在很多服务器上，防火墙会限制主机的出站流量，只允许80之类的端口。如果要使用其他端口，只能通过HTTP隧道方式实现。Kali Linux提供一款HTTP隧道工具HTTPTunnel。该工具可以将其他端口的数据以HTTP协议的方式进行发送和接受。该工具包括服务器端和客户端两部分。 渗透测试人员在公共网络运行服务端，监听80端口，接受和转发数据。然后，在被限制的主机上运行客户端，监听本地特定的应用端口（如12355），并以HTTP协议方式转发到服务器端的80端口。在被限制的主机上，直接执行其他程序，连接本地的12355端口，就可以规避防火墙的拦截了。 参考 https://blog.csdn.net/liujiayu2/article/details/46537313 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/DNS/DNS域名.html":{"url":"Books/tech/Net/DNS/DNS域名.html","title":"DNS域名","keywords":"","body":" DNS介绍和DNS查询方式 如何设计一个DNS HTTPDNS原理 域名防劫持 DNS介绍和DNS查询方式 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 开始时，域名的字符仅限于ASCII字符的一个子集。2008年，ICANN通过一项决议，允许使用其它语言作为互联网顶级域名的字符。使用基于Punycode码的IDNA系统，可以将Unicode字符串映射为有效的DNS字符集。因此，诸如“XXX.香港”、“XXX.台湾”的域名可以在地址栏直接输入并访问，而不需要安装插件。但是，由于英语的广泛使用，使用其他语言字符作为域名会产生多种问题，例如难以输入，难以在国际推广等。 域名必须以英文句号“.”结尾，DNS服务器已经可以自动补上结尾的句号 早期的域名必须以英文句号“.”结尾，例如，当用户访问 www.wikipedia.org 的HTTP服务时必须在地址栏中输入：http://www.wikipedia.org.，这样DNS才能够进行域名解析。如今DNS服务器已经可以自动补上结尾的句号。 域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。 域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。二级域名下面是三级域名，它位于二级域名的左侧。 例如，在zh.wikipedia.org中，顶级域名是org，wikipedia是二级域名，zh是三级域名 DNS通过允许一个名称服务器把他的一部分名称服务（众所周知的zone）“委托”给子服务器而实现了一种层次结构的名称空间。此外，DNS还提供了一些额外的信息，例如系统别名、联系信息以及哪一个主机正在充当系统组或域的邮件枢纽。 任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。尽管如此，当提到在公共的Internet DNS系统上实现的域名时，术语“域名”是最常使用的。 这是基于504个全球范围的“根域名服务器”（分成13组，分别编号为A至M）[2]。从这504个根服务器开始，余下的Internet DNS名字空间被委托给其他的DNS服务器，这些服务器提供DNS名称空间中的特定部分。 DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。 以查询 zh.wikipedia.org 为例： 1、客户端发送查询报文\"query zh.wikipedia.org\"至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。 2、如果记录老化或不存在，则： 1、DNS服务器向根域名服务器发送查询报文\"query zh.wikipedia.org\"，根域名服务器返回顶级域 .org 的权威域名服务器地址。 2、DNS服务器向 .org 域的权威域名服务器发送查询报文\"query zh.wikipedia.org\"，得到二级域 .wikipedia.org 的权威域名服务器地址。 3、DNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文\"query zh.wikipedia.org\"，得到主机 zh 的A记录，存入自身缓存并返回给客户端。 根DNS的名字和IP都是什么？ 在这个网址： https://www.internic.net/domain/named.root 打开可以看到，里面有13个根的名字和IP，其名字从A.root-servers.net到M.root-servers.net。 A开头那个简称A根，是主根，其他12个（B、C、D、E、F、G、H、I、J、K、L、M）是辅根。 参考https://cloud.tencent.com/developer/article/1683972 如何设计一个DNS 名词： 1、BGP 边界网关协议（Border Gateway Protocol）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。 2、EGP 外部网关协议（Exterior Gateway Protocol）是AS之间使用的路由协议，最初于1982年由BBN技术公司的EricC.Rosen及DavidL.Mills提出。其最早在RFC827中描述，并于1984年在RFC904中被正式规范。EGP是一种简单的（网络）可达性协议，其与现代的距离-矢量协议和路径-矢量协议不同，它仅限适用于树状拓扑的网络。 由于EGP存在很多的局限性，IETF边界网关协议工作组制定了标准的边界网关协议（BGP），当前被广泛使用。 3、AS 自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也被称为是一个路由选择域（routing domain）。一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号（ASN）。 https://www.infoq.cn/article/how-to-design-dns/ 参考 https://www.infoq.cn/article/how-to-design-dns/ https://github.blog/2017-05-31-dns-infrastructure-at-github/ HTTPDNS原理 HTTPDNS原理DNS与HTTPDNSHTTPDNS 域名防劫持 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 常见的DNS域名劫持方式及解决方法域名劫持原理与几种方法域名劫持 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Net/DNS/常用的DNS服务器.html":{"url":"Books/tech/Net/DNS/常用的DNS服务器.html","title":"常用的DNS服务器","keywords":"","body":"114DNS：★★★★★ 国内用户量巨大的DNS，访问速度快，各省都有节点，同时满足电信、联通、移动各运营商用户，可以有效预防劫持。 地址： 114.114.114.114 114.114.115.115 阿里DNS：★★★★ 国内新晋DNS，背靠阿里大数据，未来前途不可限量。鉴于运营时间短，数据有待完善，推荐做备用. 地址： 223.5.5.5 223.6.6.6 OneDNS：★★★★ 恶意网站实验室出品，专注网络安全。运行于云端的oneDNS和定期汇总生成的MWSL-hosts屏蔽文件，可有效屏蔽挂马、色情、赌博、低俗广告等多种类型的恶意网站，阻断病毒传播途径，保障冲浪安全。 地址： 112.124.47.27 114.215.126.16 DNS派：★★★ 国内小众DNS，专注绿色、安全、稳定。 地址： 101.226.4.6 123.125.81.6 OpenDNS：★★ 国际大牌，在中国有点水土不服，但胜在稳定和全面。 地址： 208.67.222.222 208.67.220.220 GoogleDNS：★★ 地址： 8.8.8.8 8.8.4.4 你懂的，国内基本残废了一半。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/Cache和KV数据库.html":{"url":"Books/tech/Cache/Cache和KV数据库.html","title":"缓存和KV数据库","keywords":"","body":"缓存项目 1、Redis学习 2、Memcached学习 3、缓存学习 4、其他缓存框架 5、 Redis学习 RedisRedis默认端口6379安装启动：./redis-server redis.conf Redis部署模式：1、单节点模式2、单节点主从：单节点带有从节点模式（一主一从，一主多从， 树型主从结构（从节点还有子从节点））3、主从带Sentinel哨兵模式4、集群模式：Redis Cluster Redis集群模式搭建、扩缩容：手动 和 ruby脚本主从带Sentinel哨兵模式:Sentinel的工作方式Redis集群解决方案 Redis的最常被问到知识点总结.md Redis主从复制机制 Redis事务 Redis Bitmaps：批量字节操作主要有三个命令：BITOP，BITCOUNT，BITPOS批量字节操作Bitmap：setbit、getbit、bitcount Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。Redis的五种数据类型的实现是什么数据结构 Redis命令：Key（键）、String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、SortedSet（有序集合）、Pub/Sub（发布/订阅）、Transaction（事务） Redis中支持RDB和AOF这两种持久化机制redis提供6种数据淘汰策略缓存算法（页面置换算法）-FIFO、LFU、LRU 缓存淘汰算法之LRU Redis服务端处理流程：计算槽、槽节点查找、处理/ASK/MOVED Redis如何解决key冲突：使用redis的不同db（集群模式部署不行），key带上业务含义如何解决Redis的并发竞争key问题：Redis事务、分布式锁 Redis和Memcached区别：支持数据类型、持久化、数据备份恢复、路由规则、网络IO模型 Memcached学习 Memcached ：增删改查命令：add/set、replace、get、delete遍历memcached：statsMemcached 所有命令都是原子性的 memcached：命令：连接：telnetset、add、replace、get、delete 缓存学习 1、缓存热点Key、大Value 2、缓存一致性问题 3、Redis和Memcached的区别 4、分布式缓存和Redis Key设计技巧 5、缓存的作用和分类 6、缓存算法（页面置换算法）-FIFO、LFU、LRU 缓存淘汰算法之LRU 7、 8、 其他缓存框架 quickstart-caffeine框架Caffeine：1、Caffeine 的三种缓存填充策略：手动、同步加载和异步加载。2、Caffeine 有三个值回收策略：基于大小，基于时间和基于引用。3、刷新：（不同于过期）可以将缓存配置为在指定时间段后自动刷新条目。4、统计：Caffeine 有记录缓存使用情况的统计方式： ConcurrentLinkedHashMap框架ConcurrentLinkedHashMap提供一个基于权重管理容量的Map，有以下特性1、基于LRU（Least recently used，最近最少使用）算法来替换Map中的元素2、再高负载情况下，和ConrrentHashMap具有相同的性能3、Can bound by the size of the values (e.g. Multimap cache) （这条没看懂）4、提供元素移除的通知事件 guava-cache学习/Users/yangzl/git/quickstart-cache/quickstart-guava-cache/README.md jcache学习/Users/yangzl/git/quickstart-cache/quickstart-jcache/README.md jetcache学习：缓存统一的接口，类似slf4j/Users/yangzl/git/quickstart-cache/quickstart-jetcache/README.md ehcache hazelcast tair Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/Caffeine.html":{"url":"Books/tech/Cache/Caffeine.html","title":"Caffeine","keywords":"","body":"Caffeine Caffeine缓存框架 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/JetCache.html":{"url":"Books/tech/Cache/JetCache.html","title":"JetCache","keywords":"","body":"JetCache JetCache是一种Java缓存抽象，可为各种缓存解决方案提供一致的使用。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/JCache.html":{"url":"Books/tech/Cache/JCache.html","title":"JCache","keywords":"","body":"JCache Java缓存规范JCache API（JSR107），它对Java对象缓存进行标准化，方便高效开发，让程序员摆脱实现缓存有效期、互斥、假脱机（spooling）和缓存一致性等负担。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/GuavaCache.html":{"url":"Books/tech/Cache/GuavaCache.html","title":"GuavaCache","keywords":"","body":"GuavaCache Guava LocalCache 缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/ConcurrentLinkedHashMap.html":{"url":"Books/tech/Cache/ConcurrentLinkedHashMap.html","title":"ConcurrentLinkedHashMap","keywords":"","body":"ConcurrentLinkedHashMap 基于LRU（Least recently used，最近最少使用）算法来替换Map中的元素 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/EhCache.html":{"url":"Books/tech/Cache/EhCache.html","title":"EhCache","keywords":"","body":"EhCache EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/Hazelcast.html":{"url":"Books/tech/Cache/Hazelcast.html","title":"Hazelcast","keywords":"","body":"Hazelcast zelcast是一个高度可扩展的数据分发和集群平台，可用于实现分布式数据存储、数据缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/Codis.html":{"url":"Books/tech/Cache/Codis.html","title":"Codis","keywords":"","body":"Codis Redis 的集群解决方案有社区的，也有官方的，社区的解决方案有 Codis 和Twemproxy,官方的集群解决方案就是 Redis Cluster Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Cache/Tair.html":{"url":"Books/tech/Cache/Tair.html","title":"Tair","keywords":"","body":"Tair air是一个Key/Value结构数据的解决方案，它默认支持基于内存和文件的两种存储方式，分别和我们通常所说的缓存和持久化存储对应。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Register/Register注册中心和Config配置中心.html":{"url":"Books/tech/Register/Register注册中心和Config配置中心.html","title":"注册中心和配置中心","keywords":"","body":"注册中心配置中心 1、Zookeeper 2、 3、 4、 5、 [quickstart-register][quickstart-config] Zookeeper Zookeeper了解多少？客户端是原生的还是开源的？watcher是一次性的？为什么是一次性的？效率不能保证 Zookeeper 直接watch：api复杂，只能一级一级关注，一次性的】 Zookeeper:原生：Watcher、curator：Cache分为三类监听类型：节点监听（NodeCache）和节点直接子节点监听（PathChildrenCache）、节点多级子节点监听TreeCache。 Consul相关：consul结构和部署、raft一致性协议/quickstart-register/doc/Consul.md /Users/yangzl/git/quickstart-register/quickstart-zookeeper/docs Apache ZooKeeper Watcher 机制.md Curator.md zoo.cfg zoo-sample.cfg zoo_sample.cfg Zookeeper命令.md Zookeeper学习.md Zookeeper客户端.md Zookeeper服务端和客户端的配置.md 单节点部署启动.md 集群部署启动.md 配置中心：携程Apollo配置中心、disconf、注册中心：Zookeeper、consul、etcd 开源分布式配置中心选型http://vernonzheng.com/2015/02/09/%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/ Zookeeper.md Consul.md Etcd.md Eureka.md Nacos学习.md Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Monitor/Monitor监控.html":{"url":"Books/tech/Monitor/Monitor监控.html","title":"系统监控","keywords":"","body":"系统监控 1、 2、 3、 4、 5、 监控：zabbit Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Database/DB数据库.html":{"url":"Books/tech/Database/DB数据库.html","title":"数据库","keywords":"","body":"数据库 1、MySQL 2、Oracle 3、数据库操作框架 4、数据库中间件 5、轻量级数据库 6、其他数据库工具 MySQL DML、DDL、DCL的区别 数据库的概念：库，用户，等 SQL列约束、主键约束、外键约束SQL唯一约束、主键、外键三范式：1NF、2NF、3NF 锁表原因及解决思路JDBC接口使用PreparedStatement预编译的好处SQL关键字：DISTINCT、Where(AND/OR、IN、BETWEEN、LIKE)GROUP BY(HAVING)、ORDER BY 数据库优化 SQL优化 索引的种类、数据结构、时间复杂度、实现原理 MySQL自适应索引(Adaptive hash index, AHI)实现解析 游标（cursor） 数据库中事务的四大特性（ACID） 1、DML、DDL、DCL的区别DDL（data definition language）数据库定义语言：CREATE、ALTER、DROP等DCL（Data Control Language）数据库控制语言：包括（grant,deny,revoke等）语句DML（data manipulation language）数据操纵语言:常用到的 SELECT、UPDATE、INSERT、DELETE。 SQL唯一约束、主键、外键三范式：第一范式(1NF)：定义所需要的数据项、确保有数据没有重复的组、确保有一个主键、第二范式(2NF)：满足所有1NF的规则，必须有任意列不依赖主键关系第三范式(3NF)：满足第二范式 、所有非主字段都是依赖于主键 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。第二范式：在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。也就是一类，比如订单信息和客户信息分成两个表第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 2、数据库优化 数据库优化套路 分库分表、优化SQL语句、执行计划和Hint（提示） 数据库优化：1) SQL语句及索引的优化2) 数据库表结构的优化数据库架构扩展：主从复制与读写分离、增加缓存、分库、分表、分区，开启慢查询日志，3) 系统配置的优化4) 硬件优化 3、SQL优化：执行计划和Hint：EXPLAIN 或 EXPLAIN PLAN FOR 、/+ all_rows / 查看执行计划：mysql：EXPLAIN 或者 oracle：EXPLAIN PLAN FOR访问数据扫描方式：全表扫描、通过ROWID的扫描、索引扫描（索引唯一扫描、索引范围扫描、索引全扫描、索引快速扫描）表之间连接：四种SQL优化：执行计划和Hint（提示）、SQL语句优化SQL语句优化：优化语句使用索引、加Hint(提示) SQL优化 一个 SQL 语句的具体执行过程，比如会怎么利用索引，怎么优化之类的 什么样的sql不走索引：where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等 检查SQL是否使用了索引：用explain 来执行检验sql mysql:key列显示MySQL实际决定使用的键（索引） SQL语句优化：避免全表扫描MySQL行级锁、表级锁、页级锁的优化 4、索引的种类、数据结构、时间复杂度、实现原理 索引的作用，结构，为什么可以加快查询，缺点 占用空间，增删改变慢 数据库中主键与索引的区别 加索引能使查询变快，加索引后会使写入、修改、删除变慢，占用存储空间 索引的实现使用的数据结构：B-tree 或者 B+tree（局部性原理、磁盘预读、） 由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 索引的种类：唯一索引、聚集索引、非聚集索引、覆盖索引 索引查询的流程：非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据索引数据结构设相关的计算机原理：磁盘预读原理 和 B+树 B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小 索引类型：a、普通索引：没有限制b、唯一索引：索引列的值必须唯一，但允许有空值。c、主键索引：特殊的唯一索引，不允许有空值。d、组合索引：最左前缀。1):查询条件中出现联合索引第一列,或者全部,则能利用联合索引.2)条件列中只要条件相连在一起,以本文例子来说就是:last_name=’1′ and first_name=’1′与first_name=’1′ and last_name=’1′,无论前后,都会利用上联合索引.3)查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询.复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的e、全文索引 索引的坏处：虽然大大提高了查询速度，但是会降低表的更新速度，例如insert、delete、update时，不仅要更新表，还要更新索引文件。 数据库中事务的定义，什么是数据库事务 数据库中事务的四大特性（ACID） 怎么实现ACID：实现ACID的核心技术是并发控制和日志技术 并发控制：2PL、OCC、MVCC：保证并发操作的正确性 日志：Redo/Undo,WAL协议：保证故障场景下可恢复 数据库事务定义：一致性、隔离性 事务（Transaction）的4大特性ACID ACID 原子性、一致性、隔离性（Isolation）、持久性 事务（Transaction）的隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable： SQL标准定义了4种事务隔离级别：读未提交，读已提交，可重复读，串行化事物隔离级别的实现原理：共享锁、独占锁、行级锁、表级锁事务隔离解决问题：脏读、不可重复读、幻读 read-uncommited 读未提交，别人修改了未提交就能看得到。会产生脏读read-commited 读提交，默认的就是这个。 会产生读取旧数据，repeatable-read 可重复读。会产生幻读，就是突然蹦出来的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。serializable 可串行化，强制事务串行执行。但是性能低下。 Select、where、order by、COUNT、HAVING 、 4、redis怎么防止内存穿透，怎么做到缓存和数据库一致 DB数据库深度分页：覆盖索引、主键索引+join、倒序排列、缓存若干页、业务不允许查太多页 数据库，innobd，隔离级别，行级锁 JDBC规范提供的接口和类Statement、PreparedStatement、CallableStatement区别 12、mybatis中的 $｛param｝与#｛param｝区别 13、mysql主从复制主从好处：数据安全备份、读写分离、业务数据分库存储主从原理：主库的binlog、position输出线程、从库的I/O线程接收binlog、position线程 和 从库的SQL线程 mysql主从复制存在的问题：主库宕机后，数据可能丢失从库只有一个sql Thread，主库写压力大，复制很可能延时 解决方法：半同步复制—解决数据丢失的问题并行复制—-解决从库复制延迟的问题 mysql数据库底层的排序机制？ sort page是怎么工作的？ 1、数据库分页重复和分页实现 使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据 Oracle分页查询的三种方法2、数据库深度分页优化3、分库分表如何做到永不迁移数据和避免热点1、数据库分库分表原因、策略、带来的问题、解决2、数据库分布式事务解决：JTA的XA协议、二阶段提交（2PC、3PC）、柔性事务、最终一致性事务（消息）3、spring事务(Transaction)的七种事务传播行为及五种隔离级别 数据库（database）、表（table）、视图（view）、索引（index）、序列（sequence）、表连接方式：INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN、SELF JOIN、CARTESIAN JOIN（笛卡尔乘积）、UNION ALL、UNION 框架：mybatis、hibernate 数据库问题：索引分类，有什么用，好处、有什么优缺点，为什么可以加快查询，怎么检查一个SQL是否走索引， 索引使用条件、判断是否使用、不使用的情况 聚集索引、非聚集索引、覆盖索引（复合索引或者多字段索引查询），不加索引（全表扫描） B-tree 或者 B+tree 占用空间，增删改变慢 数据库：范式、索引、优化、锁、oracle、mysql、mybatis 数据库的锁：表级锁、页级锁、行级锁，悲观锁、乐观锁查找算法分类： mysql的主从是怎么实现的mysql当表达到一定数量，查询变慢，为什么？感觉是数据库优化的问题，建索引、分库分表、主从读写分离 mysql主从同步基于什么来做的？mysql为什么一张表到了一定量查询会变慢？ MySQL有三种锁的级别：页级、表级、行级。 Oracle OracleJDBC 链接oracle的三种URL写法：SID方式 、ServerName方式、RAC方式 SID是数据库实例的名字Service_name参数，该参数对应一个数据库，而不是一个实例一个数据库对应多个实例（SID）一个数据库可以对应多个Service_name oracle的sid与实例1.SID:对应着实例，一个数据库可以有多个实例（如RAC），SID是用来标识这个数据库内部每个实例的名字。2.SERVICE_NAME：是这个数据库对外宣称的名字，对应着数据库。 Oracle序列的创建 Oracle 物化视图 说明 https://blog.csdn.net/tianlesoftware/article/details/4713553 数据库操作框架 数据库中间件 轻量级数据库 其他数据库工具 数据库：数据源、druid、h2、sqlite、yugong、，mybatis、liquibase、jooq、sharding-sphere、thinkjd Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/BigData/Data处理.html":{"url":"Books/tech/BigData/Data处理.html","title":"大数据处理","keywords":"","body":"大数据处理 1、Flink框架 2、JStorm和Storm框架 3、Elasticsearch框架 4、Spark框架 5、Spider爬虫 [quickstart-data] 大数据、流式计算 Flink框架 JStorm和Storm框架 Elasticsearch框架 Spark框架 Spider爬虫 数据处理：druid-io、flume、hadoop、hbase、、lucene、solr、、 1、大数据统计重复数和大数据Top 100 问题 大数据统计重复数1、直接使用map保存记录2、先分成若干份，再全部合并 大数据Top 100 问题：1、直接使用快速排序（占用内存大）2、先取出100个数据，然后进行排序，后面的依次跟100个数据的最小值比较，大了就替换3、先分成若干份，分别取出前100，再依次合并（或全部合并） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/SOFA/SOFA.html":{"url":"Books/tech/SOFA/SOFA.html","title":"SOFA","keywords":"","body":" 1、 2、 3、 4、 5、 SOFARPC介绍 SOFARPC 和其它的开源的 RPC 框架一样，做了很多分层很多的模型抽象，例如图中的 Filter/Router/Cluster/Loadbalance/Serilization/Protocol/Transport 等这些模型。它的特点如下： 透明化、高性能丰富的扩展机制、事件机制支持自定义Filter和自定义Router支持多种负载均衡策略，随机/权重/轮询/一致性hash 等支持多种注册中心，zookeeper/consul/etcd/nacos 等支持多协议， Bolt/Rest/HTTP/H2/gRPC/dubbo 等支持多种调用方式，同步、单向、回调、泛化等支持集群容错、服务预热、自动故障隔离 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/WebApp/ApplicationContainer.html":{"url":"Books/tech/WebApp/ApplicationContainer.html","title":"Web应用容器","keywords":"","body":"1、 应用Web容器quickstart-jettyquickstart-tomcatquickstart-undertowquickstart-jerseyquickstart-jbossquickstart-weblogicquickstart-webspherequickstart-quickserver 2、集群/分布式环境下Session共享解决 3、 4、 5、 6、 7、 8、 9、 10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、 集群/分布式环境下Session共享解决： 集群/分布式环境下3种session处理策略第一种：粘性session第二种：服务器session复制第三种：session共享机制:使用分布式缓存方案比如memcached、Redis，但是要求Memcached或Redis必须是集群。数据库 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Linux/Linux.html":{"url":"Books/tech/Linux/Linux.html","title":"Linux","keywords":"","body":" 1、Linux学习 2、 3、 4、 5、 Linux环境变量修改 Linux用户空间与内核空间、地址空间 TCP参数 操作系统-内存管理机制 quickstart-linux Linux命令、Shell脚本等 Linux学习 Linux用户空间与内核空间、地址空间.md1、内核空间和用户空间2、Linux进程地址空间逻辑地址空间和物理地址空间进程地址空间和内核地址空间进程内存布局解释3、内存地址的计算方法 linux文件IO、网络IO、5种IO类型 1、查看Linux系统版本2、linux安装软件的方式3、linux下select/poll/epoll机制的比较4、C10K问题5、惊群现象 Linux系统函数read()/write()/pread()/pwrite()的区别 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Spring/Spring.html":{"url":"Books/tech/Spring/Spring.html","title":"Spring","keywords":"","body":" 1、 2、 3、 4、 5、 SpringBoot [quickstart-spring-boot][quickstart-spring-boot2] SpringCloud [quickstart-spring-cloud][quickstart-spring-cloud2] SpringMVC [quickstart-spring-framework] SpringData [quickstart-spring-data] SpringBoot学习 /Users/yangzl/git/quickstart-spring-boot/docs /Users/yangzl/git/quickstart-spring-boot2/docs SpringCloud学习 /Users/yangzl/git/quickstart-spring-cloud/docs /Users/yangzl/git/quickstart-spring-cloud2/docs spring和springmvc熟悉吗 spring ioc 的实现原理？怎么把对象初始化的，平时是new的，这个是怎么创建的？aop的实现原理？ Spring：1、spring中的transactional注解，requestMapping注解的实现原理 2、springMvc原理 如何集成web 1、spring依赖注入怎么注入2、Spring注解 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Spring相关：springframework、springMvc、SpringBoot、SpringCloudquickstart-spring-data Spring IOC/DI和AOP原理IOC: Inversion of Control(控制反转)是一种设计思想，就是容器控制应用程序所需要外部资源的创建和管理，然后将其反转给应用程序。DI: Dependency Injection，即“依赖注入”。应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入。其实IOC和DI本就是同一个概念的两种不同的表述 优点　　第一，资源集中管理，实现资源的可配置和易管理，降低对象关系维护的复杂度。　　第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。 AOP利用一种称为“横切”的技术，剖解开封装的对象内部，将那些影响多个类的公共行为封装到一个可重用模块，并将其名为方面(Aspect)。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 实现方式　　　　实现AOP的技术，主要分为两大类：　　一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；JDK动态代理，cglib　　二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。AspectJ、Javassist， 优点　　①.横切关注点的代码都集中于一块，不再是分散在各个业务组件中，不会出现大量重复代码；　　②.核心模块只关注核心功能的代码，与通用模块分离，模块间藕合度降低。 以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Test/Test测试.html":{"url":"Books/tech/Test/Test测试.html","title":"测试","keywords":"","body":"测试相关 1、 2、 3、 4、 5、 test：jmeter、loadrunner、seleniumjunit、testng、jmh、mock Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/编程语言.html":{"url":"Books/tech/Language/编程语言.html","title":"编程语言","keywords":"","body":"C语言：C、C++ JVM语言：Java、Groovy、Scala、Kotlin、Clojure Python： Lua： 前端：JavaScript Go： C - 1972 C语言是1972年在贝尔实验室发明的，当时丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson）正在开发UNIX。Ken Thompson之前开发了B语言。Dennis Ritchie决定从B语言中获得灵感，通过添加类型来创建C语言。 C++ - 1980 最初在1980年由Bjarne Stroustrup以C和类的名义创建，后来在1983年以c++语言命名。c++编程语言现在已被ISO标准化，并广泛应用于工业和其他领域。 Python - 1991 Python是一种解释性编程语言，具有多范式、多平台的特点。Python支持结构化、函数式和面向对象的命令式编程。这些年来，Python变得非常流行，甚至在2019年成为最受欢迎的语言之一。 Lua - 1993 Lua创建于1993年，是一种自反的命令式脚本语言，用于嵌入其他应用程序以扩展功能。 Ruby - 1995 Matsumoto Yukihiro由于对自己的Smalltalk和Lisp开发经历感到失望，于1993年开始在Emacs下设计Ruby语言。他在1995年发布了第一版。Ruby是解释型的、面向对象的、多范式的编程语言。 Java - 1995 Java是James Gosling在1995年创建的一种面向对象的编程语言，至今仍是业界最流行和使用最多的语言。Java允许完成客户机到web应用程序的所有工作，而谷歌将其作为Android移动操作系统上开发应用程序的语言，进一步扩展了它的功能。 JavaScript - 1995 JavaScript是一种脚本编程语言，主要用于Web，但现在可以在服务器端使用Node.js等。JavaScript是一种面向原型的编程语言。 PHP - 1995 就编程语言而言，1995年无疑是极其重要的一年，因为在Java和JavaScript之后，PHP也在这一年诞生。PHP主要用于Web，是一种面向对象的命令式语言，可以像其他解释语言一样在本地工作。 C# - 2000 c#是微软在2000年与Sun就Java语言发生争执后创建的。c#是一种面向对象的编程语言，用于在Microsoft上开发。该语言派生于c++和Java，使用它们的一般语法和一些概念。c#也可以用于开发ASP上的web应用程序。 Groovy - 2003 Groovy是一种运行在Java平台上的面向对象编程语言。Groovy是Java语言的替代品，它的灵感来自Python、Ruby或Smalltalk。 Scala - 2003 Scala是一种多范式编程语言，旨在以简洁优雅的形式表达常见的编程模型。Scala通过静态类型集成了面向对象和函数式编程的范例。 Clojure - 2007 Clojure是一种经过编译的跨平台函数式编程语言，旨在创建安全且易于分发的程序。Clojure是基于Lisp的三大语言之一。Clojure可以转换为Java代码、JavaScript代码和. net代码。因此，Clojure可以在JVM、CLR、浏览器和Node.js上使用。 Go - 2009 Go是一种经过编译的并发式编程语言，灵感来自C和Pascal。这种语言是由谷歌从Robert Griesemer、Rob Pike和Ken Thompson（他在1969年创造了B语言）最初提出的概念发展而来的。 Rust - 2010 Rust是由Mozilla设计和开发的多范型编译的编程语言。Rust是“一种安全、并发、实用的语言”，同时支持纯函数式编程风格、actor模型、过程式编程以及面向对象编程。Rust常被称为c++的潜在继承者之一。 Kotlin — 2011 Kotlin是一种面向对象的函数式编程语言，具有静态类型，允许在Java虚拟机、JavaScript和本地的多种平台进行编译。2017年，谷歌使Kotlin成为继Java之后Android官方支持的第二种编程语言。 Swift - 2014 Swift是一种经过编译的、多范式的对象编程语言，其设计目标是简单、高性能和安全。它是由苹果公司开发的开源软件，从而与Objective-C一起成为开发移动iOS应用程序的解决方案。 参考 https://developer.aliyun.com/article/736663 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/Golang.html":{"url":"Books/tech/Language/Golang.html","title":"Golang","keywords":"","body":"参考quickstart-golang go语言 https://golang.org/project/ 源码https://golang.org/dl/ mac 下安装go环境 执行brew install go 未安装brew则先安装brew 见文章末 配置环境变量 1. 设置goroot 2. 设置gopath goroot和go path都设置到启动linux其中项中 执行 sudo vi /etc/profile 加入 go config export PATH=$PATH:/usr/local/opt/go/libexec/bin export GOPATH=/Users/xxx/go 执行wq! 强制保存 ps: 安装 brew 在终端输入命令 ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装后更新下 brew update 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/Python.html":{"url":"Books/tech/Language/Python.html","title":"Python","keywords":"","body":"参考 quickstart-python 1、Python+自动化运维 Python+自动化测试 Python+AI Python+爬虫 Python+大数据 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/Lua.html":{"url":"Books/tech/Language/Lua.html","title":"Lua","keywords":"","body":"参考quickstart-lua 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/Erlang.html":{"url":"Books/tech/Language/Erlang.html","title":"Erlang","keywords":"","body":"Erlang： 官网：http://www.erlang.org/ 文档：http://erlang.org/doc/design_principles/users_guide.html 下载：http://www.erlang.org/downloads https://github.com/erlang/otp brew install go RabbitMQ 3.7.0 发布，正式支持 Erlang/OTP 20 （OTP 20.1.4 已发布，OTP (Open Telecom Platform) 是一个开源的 Erlang 分发和一个用 Erlang 编写的应用服务器。） 开放电信平台 OTP OTP (Open Telecom Platform) 是一个开源的 Erlang 分发和一个用 Erlang 编写的应用服务器，由爱立信开发。 OTP 包含： 一个 Erlang 解释器 一个 Erlang 编译器 服务器之间的通讯协议 一个 Corba 对象请求代理 名为 Dialyzer 的静态分析工具 一个分布式的数据库服务 Mnesia 大量的开发库 https://www.oschina.net/p/otp Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/Ruby.html":{"url":"Books/tech/Language/Ruby.html","title":"Ruby","keywords":"","body":" 1、Ruby on Rails Ruby on Rails是一个可以使你开发、部署、维护 web 应用程序变得简单的框架。这个 Web 开发框架在开发人员当中极其流行，它声称“为确保编程员满意和持续高效地工作进行了优化”。用户包括 Basecamp、推特、Shopify 和 GitHub 等公司。 支持的操作系统：Windows、Linux 和 OS X 相关网站：https://rubyonrails.org 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Language/C++.html":{"url":"Books/tech/Language/C++.html","title":"C++/C","keywords":"","body":"参考quickstart-cpp 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Blockchain/Blockchain区块链.html":{"url":"Books/tech/Blockchain/Blockchain区块链.html","title":"区块链","keywords":"","body":"区块链Blockchain 指纹（fingerprint） 比特币Bitcoin 以太坊 区块链资料 区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。 中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。 区块链共享价值体系首先被众多的加密货币效仿，并在工作量证明上和算法上进行了改进，如采用权益证明和SCrypt算法。随后，区块链生态系统在全球不断进化，出现了首次代币发售ICO；智能合约区块链以太坊；“轻所有权、重使用权”的资产代币化共享经济； 和区块链国家。目前，人们正在利用这一共享价值体系，在各行各业开发去中心化电脑程序(Decentralized applications, Dapp)，在全球各地构建去中心化自主组织和去中心化自主社区(Decentralized autonomous society, DAS)。 2008年11月，一位自称中本聪(Satoshi Nakamoto)的人提出了比特币，而区块链技术正是实现比特币的关键。 区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。 区块链在数据结构上就是有序链表，每一个区块就是链表中的存储单元可以记录交易相关的数据，而记录前后区块的记录就是链表的指针域。 那么问题来了，我们都知道改变链表的内容是很简单的，我们可以插入一个新的存储单元，然后更新指针域就可以了，如何做到“不可篡改”呢？ 区块链的链表指针域经过了特殊的设计，使用了两次哈希计算： 首先他的指针就是上一段区块的哈希值， 第二，他对本区块也做了一次哈希（注意：这一次哈希是用到了指向上一个区块的哈希值，使二者耦合），并存储在区块中，用来校验内容，内容哪怕改变一个字节也无法校验通过。 有了这样的设计，黑客如果修改某一个区块，这个区块的哈希值校验就无法通过，为此，黑客需要修改当前区块之后的所有区块哈希值来起到伪造的目的。 由于区块链的规模巨大（百亿级别），黑客需要拥有比肩全网算力的水平才能达到目的。 黑客这么做显然是赔钱的啊（正常也没这个能力），这样就间接完成了不可篡改。 什么是区块链？从科技层面来看，区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。从应用视角来看，简单来说，区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。这些特点保证了区块链的“诚实”与“透明”，为区块链创造信任奠定基础。而区块链丰富的应用场景，基本上都基于区块链能够解决信息不对称问题，实现多个主体之间的协作信任与一致行动。 　　区块链如何创造信任与合作机制，深入到具体的应用场景，就能够看得更加清楚。区块链“不可篡改”的特点，为经济社会发展中的“存证”难题提供了解决方案，为实现社会征信提供全新思路；区块链“分布式”的特点，可以打通部门间的“数据壁垒”，实现信息和数据共享；区块链形成“共识机制”，能够解决信息不对称问题，真正实现从“信息互联网”到“信任互联网”的转变；区块链通过“智能合约”，能够实现多个主体之间的协作信任，从而大大拓展了人类相互合作的范围。总体而言，区块链通过创造信任来创造价值，它能保证所有信息数字化并实时共享，从而提高协同效率、降低沟通成本，使得离散程度高、管理链条长、涉及环节多的多方主体仍能有效合作。 参考： [3] 廖雪峰.区块链原理 https://www.liaoxuefeng.com/wiki/1207298049439968/1311929706479649 [4] Investopedia.Blockchain: Everything You Need to Know - Investopedia https://www.investopedia.com/terms/b/blockchain.asp [5] 贵阳市人民政府.贵阳区块链发展和应用 http://www.cbdio.com/image/site2/20161231/3417eb9bbd5919d2122102.pdf Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Blockchain/Ethereum以太坊.html":{"url":"Books/tech/Blockchain/Ethereum以太坊.html","title":"Ethereum以太坊","keywords":"","body":"以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Blockchain/Bitcoin比特币.html":{"url":"Books/tech/Blockchain/Bitcoin比特币.html","title":"Bitcoin","keywords":"","body":"在区块链之前是机器学习和人工智能（ML/AI）与加密相关的东西，如哈希、签名、混淆等比特币以及类似的 POW 区块链区块链项目EOS以太坊ETHBTC 区块链Blockchain 指纹（fingerprint） 比特币Bitcoin 比特币（英语：Bitcoin）是一种去中心化，非普遍全球可支付的电子加密货币（也是虚拟货币）。原理是Blockchain https://bitcoin.org/en/ 比特币网站 https://blockchain.info/zh-cn/ 火币网：https://www.huobipro.com/zh-cn/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Blockchain/NFT.html":{"url":"Books/tech/Blockchain/NFT.html","title":"NFT","keywords":"","body":"Non-fungible Token（非同质通证） NFT（非同质化代币，non-fungible token）是一种被称为区块链（数位账本）上的数据单位，每个代币可以代表一个独特的数码资料。由于其不能互换，非同质化代币可以代表数位文件，如画作、声音、影片、游戏中的项目或其他形式的创意作品。 什么是NFT What You Need To Know About Non-Fungible Tokens (NFTs) Non-fungible token wiki Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/AI/MachineLearning机器学习.html":{"url":"Books/tech/AI/MachineLearning机器学习.html","title":"机器学习","keywords":"","body":"Machine Learning, ML,机器学习 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/AI/tensorflow.html":{"url":"Books/tech/AI/tensorflow.html","title":"tensorflow","keywords":"","body":"英文官方网站： http://tensorflow.org/ 官方GitHub仓库： https://github.com/tensorflow/tensorflow 中文版 GitHub 仓库： https://github.com/jikexueyuanwiki/tensorflow-zh TensorFlow中文社区 http://www.tensorfly.cn/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/AI/人工智能技术.html":{"url":"Books/tech/AI/人工智能技术.html","title":"人工智能技术","keywords":"","body":"人工智能技术，如机器学习、深度学习、神经网络等等， 这些技术大多来自于学术机构或科研单位的研究成果，学者们首先会通过一些论文和报告给出某个概念的清晰定义，然后再有相关科技公司进行研发和生产。 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器， 该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。 人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/AI/蚂蚁金服共享智能技术实践：如何降低数据共享的难度.html":{"url":"Books/tech/AI/蚂蚁金服共享智能技术实践：如何降低数据共享的难度.html","title":"蚂蚁金服共享智能技术实践：如何降低数据共享的难度","keywords":"","body":"解决数据孤岛，在满足隐私保护和数据安全的前提下，在不同的组织、公司与用户之间进行数据共享。 为了解决这一问题，国内外不少科技公司先后推出了解决方案，比如谷歌推出的联邦学习、蚂蚁金服提出的共享智能等 当前，业界解决隐私泄露和数据滥用的数据共享技术路线主要有两条。 一条是基于硬件可信执行环境（TEE：Trusted Execution Environment）技术的可信计算， 另一条是基于密码学的多方安全计算（MPC：Multi-party Computation）。 TEE 字面意思是可信执行环境，核心概念为以第三方硬件为载体，数据在由硬件创建的可信执行环境中进行共享。 目前在生产环境可用的 TEE 技术，比较成熟的基本只有 Intel 的 SGX 技术，基于 SGX 技术的各种应用也是目前业界的热门方向，微软、谷歌等公司在这个方向上都有所投入。 MPC（Multi-party Computation，多方安全计算）一直是学术界比较火的话题，但在工业界的存在感较弱，之前都是一些创业小公司在这个方向上有一些探索，例如 Sharemind，Privitar，直到谷歌提出了基于 MPC 的在个人终端设备的“联邦学习”(Federated Learning）的概念，使得 MPC 技术一夜之间在工业界火了起来。 人工智能目前存在的难题是鱼与熊掌不可兼得，也就是隐私性跟可用性难以兼顾。 如果想要 AI 系统发挥作用，就可能需要牺牲隐私。但是，在大量真实场景中，如果做不到同时兼顾隐私和可用性，会导致很多 AI 落地的困境。 随着对数据安全和重视和隐私保护法案的出台，曾经粗放式的数据共享受到挑战，各个数据拥有者重新回到数据孤岛的状态。 同时，互联网公司也更加难以收集和利用用户的隐私数据，数据孤岛反而成为了常态。如果希望更好的利用数据，就必须在满足隐私保护和数据安全的前提下，在不同的组织、公司与用户之间进行数据共享。 为了解决这一问题，国内外不少科技公司先后推出了解决方案，比如谷歌推出的联邦学习、蚂蚁金服提出的共享智能等。本文，InfoQ 对蚂蚁金服机器学习算法中台负责人周俊进行了采访，了解共享智能如何解决金融领域的数据共享问题。 参考 https://www.infoq.cn/article/UjafrLAg5V4v7Mj2TMTC Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/AI/ArtificialIntelligence人工智能.html":{"url":"Books/tech/AI/ArtificialIntelligence人工智能.html","title":"人工智能","keywords":"","body":"人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能的定义可以分为两部分，即“人工”和“智能”。 “人工”比较好理解，争议性也不大。有时我们会要考虑什么是人力所能及制造的，或者人自身的智能程度有没有高到可以创造人工智能的地步，等等。但总的来说，“人工系统”就是通常意义下的人工系统。 关于什么是“智能”，就问题多多了。这涉及到其它诸如意识（CONSCIOUSNESS）、自我（SELF）、思维（MIND）（包括无意识的思维（UNCONSCIOUS_MIND））等等问题。人唯一了解的智能是人本身的智能，这是普遍认同的观点。但是我们对我们自身智能的理解都非常有限，对构成人的智能的必要元素也了解有限，所以就很难定义什么是“人工”制造的“智能”了。因此人工智能的研究往往涉及对人的智能本身的研究。其它关于动物或其它人造系统的智能也普遍被认为是人工智能相关的研究课题。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/others/CloudComputing云计算.html":{"url":"Books/tech/others/CloudComputing云计算.html","title":"CloudComputing云计算","keywords":"","body":"云计算（英语：cloud computing），是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的电脑基建作计算和资源。 服务模式：美国国家标准和技术研究院的云计算定义中明确了三种服务模式： 1、软件即服务（SaaS）：消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Adobe Creative Cloud，Microsoft CRM与Salesforce.com。 2、平台即服务（PaaS）：消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine。 3、基础设施即服务（IaaS）：消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace。 部署模型：美国国家标准和技术研究院的云计算定义中也涉及了关于云计算的部署模型： 1、公有云（Public Cloud） 2、私有云（Private Cloud） 3、社群云（Community Cloud） 4、混合云（Hybrid Cloud） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/others/EdgeComputing边缘计算.html":{"url":"Books/tech/others/EdgeComputing边缘计算.html","title":"EdgeComputing边缘计算","keywords":"","body":"边缘运算（英语：Edge computing），又译为边缘计算，是一种分散式运算的架构，将应用程序、数据资料与服务的运算，由网络中心节点，移往网络逻辑上的边缘节点来处理。边缘运算将原本完全由中心节点处理大型服务加以分解，切割成更小与更容易管理的部分，分散到边缘节点去处理。边缘节点更接近于用户终端装置，可以加快资料的处理与传送速度，减少延迟。在这种架构下，资料的分析与知识的产生，更接近于数据资料的来源，因此更适合处理大数据。 参考 https://www.jiqizhixin.com/graph/technologies/466f587d-614f-42ce-847a-4f731c93be4e Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/tech/Front/Front前端.html":{"url":"Books/tech/Front/Front前端.html","title":"前端开发","keywords":"","body":"前端框架 1、 2、 3、 4、 5、 1、 2、 3、 https://github.com/twbs/bootstrap Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/Tools开发工具.html":{"url":"Books/Tools/Tools开发工具.html","title":"开发工具","keywords":"","body":"开发工具 1、Maven学习 2、 3、 4、 5、 Maven学习 1、Maven工程标准架构、打包编译命令2、Maven详解Maven基本概念：仓库、jarMaven依赖管理和依赖冲突解决Maven生命周期关于scope依赖范围 工具：maven、gradle、ant+ivynexus、jenkinssonar、findbugs、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/Gitbook.html":{"url":"Books/Tools/Gitbook.html","title":"Gitbook","keywords":"","body":"Gitbook Gitbook介绍 Gitbook官网 Gitbook文档 Gitbook Github地址 Gitbook CLI Gitbook插件 GitBook文档（中文版） Gitbook使用 gitbook init gitbook install gitbook build gitbook serve Gitbook配置 book.json配置 基本信息、links、plugins、pluginsConfig等 book.json示例1 book.json示例2 GitBook相关配置及优化 gitbook简单使用 GitBook插件整理 GitBook 简明教程 gitbook使用及book.json详细配置 book.json部分配置参考 { \"title\": \"Kubernetes\", \"description\": \"Kubernetes \", \"language\": \"zh-hans\", \"author\": \"Jimmy\", \"plugins\": [ \"page-toc-button\", \"back-to-top-button\", \"image-captions\", \"-lunr\", \"-search\", \"search-plus\", \"-highlight\", \"prism\", \"prism-themes\", \"sitemap-general\" ], \"pluginsConfig\": { \"image-captions\": { \"caption\": \"图 _PAGE_LEVEL_._PAGE_IMAGE_NUMBER_：_CAPTION_\" }, \"prism\": { \"css\": [ \"prism-themes/themes/prism-ghcolors.css\" ] }, \"sitemap-general\": { \"prefix\": \"https://jimmysong.io/kubernetes-handbook/\" } } } Gitbook插件 Gitbook插件官方Github Gitbook插件官方文档 gitbook 入门教程之小白都能看懂的 Gitbook 插件开发全流程 GitBook v3.2.3 使用教程 gitbook 入门教程之实用插件(新增3个插件) gitbook常用的插件 GitBook插件整理 - book.json配置 Gitbook详解（五）-插件的配置和使用详解 GitBook 和它有趣的插件 gitbook 插件项目 Gitbook插件篇 推荐12个实用的gitbook插件 Gitbook插件推荐 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/Blog文章笔记写作系统.html":{"url":"Books/Tools/Blog文章笔记写作系统.html","title":"Blog文章笔记写作系统","keywords":"","body":"Blog文章笔记写作系统 可选方案 GitBook + GitBook/GitHub + GitBook/Travis/Github Actions + GitBook/Github Pages 在 master 上写 md，然后 push 到 master， Travis 自动执行 gitbook build，并且把生成好的文档 push 到 gh-pages，好让 pages 服务生效。 其他的开源Blog框架：Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll 打造完美写作系统：Gitbook+Github Pages+Github Actions 使用 travis + gitbook + github pages 优雅地发布自己的书 七大开源blog框架介绍 文件格式 可选文件格式 AsciiDoc Markdown HTML Word GitBook默认使用Markdown语法，从 2.0.0 版本起，GitBook也能支持AsciiDoc作为输入的格式了。 文档站点生成器 Gitbook VuePress docsify docsify 入坑指南与我放弃 Gitbook 的那些理由 使用Gitbook创建的云原生的书籍可供参考 CI工具 GitBook Travis Github Actions 可以使用Travis构建然后推送到gh-pages，也可以使用GitHub Action gitbook-action.yml示例 一文多发平台 ArtiPub (Article Publisher 的简称，意为 \"文章发布者\") 是一款开源的一文多发平台 ArtiPub一文多发平台 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/AsciiDoc.html":{"url":"Books/Tools/fileformat/AsciiDoc.html","title":"AsciiDoc文件","keywords":"","body":"Lightweight markup language 轻量级标记语言（LML），也称为简单或人性化的标记语言，是一种标记语言与简单的，不引人注目的语法。 AsciiDoc规范 AsciiDoc两种实现： asciidoc-py： Python)实现 Asciidoctor： Ruby)实现 Asciidoctor文档 AsciiDoc Syntax Quick Reference 具有ADOC 文件扩展名的文件很可能是一个AsciiDoc文件。 简而言之，这些类型的ADOC文件用于将纯文本文件转换为易于阅读的格式，如HTML或PDF 。 什么是ADOC文件？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/markdown/Markdown.html":{"url":"Books/Tools/fileformat/markdown/Markdown.html","title":"Markdown文件","keywords":"","body":" Markdown介绍 Markdown编辑器推荐 Markdown介绍 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。[4]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。 markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 相比WYSIWYG编辑器 优点： 1、因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持markdown编辑模式。 所见即所得（英语：What You See Is What You Get，缩写：WYSIWYG）是由菲利普·威尔逊（Flip Wilson）所提出的一种计算机文本编辑器方面的技术，使得编辑文字时在屏幕上直接呈现最终显示效果，如打印到纸张上的效果，故也称可视化操作。今日此项技术通常是文书处理系统所必需的（TeX例外），但对于其他文档来说却不一定，例如HTML。 语法参考： https://daringfireball.net/projects/markdown/ https://github.com/younghz/Markdown https://www.appinn.com/markdown/ https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet https://yuhongjun.github.io/tech/2017/05/02/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88.html#1-%E6%96%9C%E4%BD%93%E5%92%8C%E7%B2%97%E4%BD%93 https://www.jianshu.com/p/191d1e21f7ed Markdown编辑器推荐 Markdown编辑器推荐 Typora 在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。 Typora 是一款支持实时预览的 Markdown 文本编辑器。看到Typora的第一眼，我就爱上了它。它没有专业软件那么复杂而难以上手的功能，却也没有为了简洁而妥协到难以使用，它的每一寸肌肤都恰到好处，与它相处的每一刻都十分愉悦。 由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 GFM 标准，它是由著名代码托管网站 GitHub 所制定的。Typora 主要使用的也是 GFM 标准。 Typora官网 Typora 完全使用详解Typora入门：全网最全教程2020Typora小白完全使用教程 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/markdown/Markdown语法.html":{"url":"Books/Tools/fileformat/markdown/Markdown语法.html","title":"Markdown语法","keywords":"","body":"markdown编辑器语法——文字颜色、大小、字体与背景色的设置 https://blog.csdn.net/manjianchao/article/details/53668280 参考 http://xianbai.me/learn-md/article/extension/table.html 标题： h1级标题 h2级标题 h3级标题 h4级标题 h5级标题 h6级标题 锚点1级 锚点2级 锚点3级 锚点4级 锚点5级 锚点6级 锚点7级 锚点8级，可见7、8级都被忽略了 测试测试 测试2 分割线：三个以上的短线 即可作出分割线，有空行 分割线 三个或者三个以上的 - 或者 * 都可以。 示例： --- 图片语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 超链接：连接名称 我是链接名 点我刷新 超链接语法：超链接名title可加可不加 示例： 简书 百度 超链接名 示例 简书 另一种超链接写法：[链接名][链接代号] here 然后在别的地方定义 3 这个详细链接信息， 直接展示链接的写法：http://www.izhangbo.cn 键盘键 Ctrl+[ and Ctrl+] code格式：反引号 Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调： 斜体强调 粗体强调 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 这是引用的内容 这是引用的内容 这是引用的内容 图片 使用 icon 图标文字 段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 表格： Item Value value Computer $1600 sss Phone $12 ssss Pipe $1 sss 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有三个才行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 无序列表：使用 - 加一个空格（） 无需列表1 无序列表2 无序列表3 无序列表 语法： 无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表：使用 数字 加一个英文句点，点后面有空格是换行 有序列表 有序列表 有序列表 有序列表 有序列表 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 注意：序号跟内容之间要有空格 换行缩进形成代码区块 这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用 给引用的文本开始位置都加一个 '>'， 便可组成一个块引用。在块引用中，可以结合 其他markdown元素一块使用，比如列表。 强调 也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码... 代码... 代码... 单行代码 create database hero; 代码块 function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/markdown/模板.html":{"url":"Books/Tools/fileformat/markdown/模板.html","title":"md模板","keywords":"","body":"整个文档内容，可以是文件名字 1、第一点内容 1、细点1 1、你好 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2、顶顶顶顶 2、细点2 3、细点3 2、第二点内容 1、哈哈哈哈 2、嘻嘻嘻 3、你好啊 3、第三点内容 你好啊 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/markdown/Markdown语法模板.html":{"url":"Books/Tools/fileformat/markdown/Markdown语法模板.html","title":"Markdown语法模板","keywords":"","body":"﻿@TOC 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F 替换：Ctrl/Command + G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 这个是加深文本颜色的 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片 链接: link. 图片: 带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 [ ] 计划任务 [x] 完成任务 创建一个表格 一个简单的表格是这么创建的： 项目 | Value -------- | ----- 电脑 | $1600 手机 | $12 导管 | $1 设定内容居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右 | 第一列 | 第二列 | 第三列 | |:-----------:| -------------:|:-------------| | 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： | TYPE |ASCII |HTML |----------------|-------------------------------|-----------------------------| |Single backticks|'Isn't this fun?' |'Isn't this fun?' | |Quotes |\"Isn't this fun?\" |\"Isn't this fun?\" | |Dashes |-- is en-dash, --- is em-dash|-- is en-dash, --- is em-dash| 创建一个自定义列表 Markdown : Text-to-HTML conversion tool Authors : John : Luke 如何创建一个注脚 一个具有注脚的文本。2 2. 注脚的解释 ↩ 注释也是必不可少的 Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过欧拉积分 $$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图： sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入 导出 如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Tools/fileformat/markdown/Typora模板.html":{"url":"Books/Tools/fileformat/markdown/Typora模板.html","title":"Typora模板","keywords":"","body":"删除 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/面试学习技术网站.html":{"url":"Books/Interview/面试学习技术网站.html","title":"面试学习技术网站","keywords":"","body":"知识点相关 1.JavaGuide Github地址： https://github.com/Snailclimb/JavaGuide JavaGuide-Interview star: 64.0k 介绍: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 2.CS-Notes Github 地址：https://github.com/CyC2018/CS-Notes Star: 68.3k 介绍: 技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。 3. advanced-java Github地址：https://github.com/doocs/advanced-java star: 23.4k 介绍: 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习。 4.JCSprout Github地址：https://github.com/crossoverJie/JCSprout star: 21.2k 介绍: Java Core Sprout：处于萌芽阶段的 Java 核心知识库。 各种框架Demo学习示例代码tutorials Github地址：https://github.com/eugenp/tutorials 介绍: 涵盖了大多数框架的使用示例代码，java学习使用示例 各种框架Demo学习示例教程 地址：https://www.baeldung.com/ 介绍: 大多数框架的使用示例代码 5.toBeTopJavaer Github地址：https://github.com/hollischuang/toBeTopJavaer star: 4.0 k 介绍: Java工程师成神之路。 6.architect-awesome Github地址：https://github.com/xingshaocheng/architect-awesome star: 34.4 k 介绍:后端架构师技术图谱。 7.technology-talk Github地址： https://github.com/aalansehaiyang/technology-talk star: 6.1k 介绍: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识。 8.fullstack-tutorial Github地址： https://github.com/frank-lam/fullstack-tutorial star: 4.0k 介绍: fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试。 9.3y Github地址：https://github.com/ZhongFuCheng3y/3y star: 1.9 k 介绍: Java 知识整合。 10.java-bible Github地址：https://github.com/biezhi/java-bible star: 2.3k 介绍: 这里记录了一些技术摘要，部分文章来自网络，本项目的目的力求分享精品技术干货，以Java为主。 11.interviews Github地址: https://github.com/kdn251/interviews/blob/master/README-zh-cn.md star: 35.3k 介绍: 软件工程技术面试个人指南（国外的一个项目，虽然有翻译版，但是不太推荐，因为很多内容并不适用于国内）。 11.Java面试+Java学习指南 Github地址: https://github.com/AobingJava/JavaFamily star: 介绍: 【Java面试+Java学习指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 算法相关网站 1.LeetCodeAnimation Github 地址： https://github.com/MisterBooo/LeetCodeAnimation Star: 33.4k 介绍: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路）。 2.awesome-java-leetcode Github地址：https://github.com/Blankj/awesome-java-leetcode star: 6.1k 介绍: LeetCode 上 Facebook 的面试题目。 3.leetcode Github地址：https://github.com/azl397985856/leetcode star: 12.0k 介绍: LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。) HackerRank 地址：HackerRank 介绍: 该网站非常出名，大多数程序相关岗位的人都知道这个网站,而且都不需要配置任何编译开发环境 就可以直接开始写算法，函数一类的挑战题目。网站上也有很多算法题，难度从低到高，非常的全面，可以深入学习算法。 TopCoder 地址：TopCoder 介绍: TopCoder这个网站可以说是一个程序设计比赛的网站，成立于2001年，最早的在线编程竞技平台之一，网站提供了一系列的算法挑战，采用比赛、评分、支酬等方式吸引众多平面设计师和程序员业余工作。参赛者可使用代码编辑器直接进行在线作答，比拼获胜者可获得竞赛赞助方提供的奖励，大家可以上去那里跟来自全世界的程序员(事实上大多数也是大学生)进行更直接的交流。 Geekforgeeks 地址：Geekforgeeks 介绍: Geeksforgeeks是印度的一家致力于计算机科学的百科全书,根据不同的用户计算机水平而发布不同的难度等级,从基础到专家级,内容涵盖了编程、算法、面试问题等。 它有许多常见算法练习的解决方案。每个解决方案包括许多不同的方法，以及每种方法的复杂性，一种非常有帮助的网站。 Lintcode 地址：Lintcode 介绍: 支持中英双语，汇集了算法、数据结构，人工智能，系统设计等众多领域的题目，网站还会举办编程比赛，很多算法爱好者在这里切磋技艺。汇集了各大公司的算法面试题。有阶梯式训练题库,帮你选好应该刷的题目,在线刷题。 Codeforces 地址：Codeforces 介绍: Codeforces 又被戏称为 CF，是一家俄罗斯的网站，这里有很好的比赛，很好的题目，很好的选手，简称\"三好\"。是一个举办比赛、做题和交流的平台，网站自带blog功能，可以求助/发布题解。 地址：https://coderbyte.com/ 介绍: 地址：https://www.kaggle.com/ 介绍: 地址：https://www.codechef.com/ 介绍: 地址：https://codesignal.com/ 介绍: 九章算法 地址：九章算法 介绍: Codegym 地址：Codegym 介绍: Codegym是一个以Java为中心的平台，它比其他平台上都要更加深入的介绍Java，这个网站将理论和实践知识相结合，你可以在上面找到1200多个练习项目。主要具备以下特点：互动课程，这部分有500多小时的编程课程 内置IDE，帮助你解决实践问题 活跃的Java社区 这个平台通过游戏化和故事化让学习变得有趣 Treehouse 地址：Treehouse 介绍: Treehouse是另一个将编程知识简单化讲解的平台，它会教你处理特定项目所需的技能，比如创建一个APP，创建一个WordPress博客等。Treehouse支持所有流行的编程语言——Java、Python、c++、Ruby和其他语言，具有以下好处：现实环境中练习问题 与导师面对面的交流 离线访问 Khan Academy 地址：Khan Academy 介绍: 尽管Khan Academy没有Java或Python教程，但该平台是理解计算机科学基本概念的一个很好的起点，完成这些课程后，你将会了解数据结构相关的知识，掌握oOP概念，并获得“程序员思维”，具有以下特点： 免费的课程 涉及前端开发和数据库管理 易于使用的界面 有助于巩固知识的小测试 Udemy 地址：Udemy 介绍: Udemy是一个领先的在线教育平台，提供大多数编程语言课程，用户群体也相当大，课程分为收费和免费，这是由讲师决定，价格从10美元到几百美元不等，主要具有以下特点： 广泛的编程语言选择 可以按照自己的节奏获取学习材料 Code4Startup 地址：Code4Startup 介绍: 如果您想在创业领域获得更多实际经验，Code4Startup是一个很好的平台，可以很好地利用你的开发技能。这个项目允许初级程序员为实际的初创公司编写代码，同时，企业主可以节省招聘人才的费用。 除了作为一个实践场所，Code4Startup还为编程专业的学生提供了大量的免费课程。就我个人而言，Learn Ruby on Rails、Heroku和Wistia API等多个课程我都很喜欢。 One Month 地址：One Month 介绍: 如果你为“我如何在一个月内学会一门编程语言?”，请务必查看这个平台。这个编程网站可以帮助初级程序员快速掌握JS、Python和Ruby的基本概念，遗憾的是，该平台上的大多数课程都是付费，尽管少数免费课程，还有一个讨论编程热点新闻的博客。 PluralSight 地址：PluralSight 介绍: Pluralsight的课程从入门到高级，涵盖了所有流行的编程语言，以及数据科学的基础知识，主要具有以下特性： 课程范围广泛 有专门针对高级开发人员的课程 广泛的订阅计划 Coursera 地址：Coursera 介绍: 与Udemy一样，Coursera是另一个值得CS和编程学生学习的资源。与Udemy不同的是，该平台关注的是大学层面的深入研究，而不是实践理念。 这个平台是计算机科学专业的一个强大的资源，你可以通过它学习斯坦福大学、密歇根大学等学校的课程。 Freecodecamp 地址：Freecodecamp 介绍: 这是最大的技术社区之一，拥有相当广泛的教程和课程，这在我看来是其他网站都没法比的，你会在这里找到实用的、基于项目的作业——这就是为什么一旦你掌握了扎实的编程理论，最好还是去Freecodecamp看看的原因，与此同时，Freecodecamp上拥有大量的免费资源。 Codewars 地址：Codewars 介绍: Codewars是一个代码练习网站，能够培养程序员，特别是编程新手的逻辑思维能力，如果你经常对编程提不起动力学习，那么，Codewars你值得拥有，砌墙式进阶的方式会让你对编程更加感兴趣。除了刷题进阶之外，它的社区也值得关注，在这里你可以看到许多困扰着程序员的问题，还有别人解答的解决方案 地址： 介绍: 地址： 介绍: 技术博客 朱小厮的博客 地址：https://blog.csdn.net/u013256816 介绍: DockOne 地址：http://dockone.io/ 介绍: Kubernetes相关 开源社 地址：https://kaiyuanshe.cn/ 介绍: 开源相关的资讯 中生代技术 地址：https://github.com/freshmantechnology 介绍: 各种技术交流 programcreek 地址：https://www.programcreek.com/ 介绍: Java、Python等代码示例网站 Java基础 地址：http://www.cnblogs.com/xrq730/category/731394.html 介绍: Java基础知识 Java学习博客 地址：https://my.oschina.net/ywbrj042 介绍: Netty、Dubbo等框架 Spring、Java等学习 地址：https://github.com/yqbjtu/springboot 地址：https://github.com/windwant/windwant-service 地址：https://blog.csdn.net/derrantcm/article/details/73456550 地址：https://blog.csdn.net/heatdeath/ 介绍: 2016年阿里中间件性能挑战赛亚军代码 地址：https://github.com/dongeforever/middlewarerace 介绍: MySQL教程 地址：https://github.com/jaywcjlove/mysql-tutorial 介绍: Redis、Netty、RabbitMQ、SpringBoot、SpringCloud学习博客 地址：https://blog.csdn.net/derrantcm/article/details/73456550 介绍: Java各种综合 地址：https://github.com/windwant/windwant-service 介绍: SpringBoot学习 地址：https://github.com/yqbjtu/springboot 介绍: dubbo源码解析 地址：https://mp.weixin.qq.com/s/pSnHnIyldAunJQEXO-kcww 地址：https://github.com/tianheframe/dubbo-2.6.5 介绍: java学习网址 地址：https://www.mkyong.com/java/java-properties-file-examples/ 地址：https://www.jianshu.com/u/f57de6e249f6 介绍: Bash 地址：https://github.com/denysdovhan/bash-handbook 介绍: GoLang 地址：https://github.com/qyuhen/book 地址：https://github.com/chai2010/advanced-go-programming-book 介绍: Python 地址：https://github.com/realpython/python-guide 地址：https://github.com/eastlakeside/interpy-zh 介绍: Docker 地址：https://github.com/yeasy/docker_practice 介绍: DeepLearning深度学习 地址：https://github.com/exacity/deeplearningbook-chinese 地址：https://github.com/exacity/deeplearningbook-chinese 地址：https://github.com/rasbt/python-machine-learning-book 地址：https://github.com/fchollet/deep-learning-with-python-notebooks 地址： 介绍: 大型网站技术架构：摘要与读书笔记 地址：https://www.cnblogs.com/xybaby/p/8907880.html 介绍: https://github.com/justjavac/free-programming-books-zh_CN https://github.com/dypsilon/frontend-dev-bookmarks https://github.com/jobbole/awesome-programming-books https://github.com/hackerkid/Mind-Expanding-Books https://github.com/many-books/study-book https://github.com/EbookFoundation/free-programming-books https://github.com/programthink/books https://github.com/addyosmani/essential-js-design-patterns https://github.com/DuGuQiuBai/Java https://github.com/Pines-Cheng/share https://github.com/chunminglu/bookshttps://github.com/mynane/PDFhttps://github.com/javagrowing/JGrowing 码农周刊整理 地址：https://github.com/nemoTyrant/manong 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/简历和面试.html":{"url":"Books/Interview/简历和面试.html","title":"简历和面试","keywords":"","body":"设计模式、 加解密 面试题目 https://github.com/c-rainstorm/blog/blob/master/interview/%E9%98%BF%E9%87%8C%E4%BA%8C%E9%9D%A2%E5%87%86%E5%A4%87.md https://zhuanlan.zhihu.com/p/70020121 https://zhuanlan.zhihu.com/p/66160652 https://blog.csdn.net/afreon/article/details/79519131 面试过程： 4：问：项目中有哪些难点，是怎么克服的？答：。。。。回答的稀里糊涂的，自己都不知道说了啥(记得好像是说每一个都是难点)5：问：项目采用分布式开发，一共使用到了几个系统？分别是哪些？答：7个...后面的没回答上来(客户web层，客户service层，mq消息队列...)6：问：项目中有用到MQ，主要是实现哪些功能？答：发短信，发邮件7：问：怎样判断mq中的方法成功执行了或者执行失败答：通过状态，比如，A调用B，在A这边捕捉异常，通过返回状态进行判断。8：问：项目中的订单和商品是一个系统还是分的两个系统？答：2个9：怎样保证这两个系统中的数据同步？比如：用户下单后，需要在商品系统那边减库存，如何保证同步？( HR面： 业余爱好 为什么不参加竞赛？ 你觉得你在项目运行过程中作为组长是否最大限度发挥了组员的优势？具体事例？ 如何看待阿里在大数据方面的投入？对阿里的发展有什么建议？对蚂蚁金服的发展有什么看法？ 职业规划，今后想发展的工作方向 家乡在哪里，是否愿意长期在杭州发展？ 薪酬问题及入职情况 蚂蚁金服的总部还是在杭州，一共3轮面试，第一轮电话面试，也是最重要的技术面试，面试时间大约1个多小时，聊了Java的基础知识，容器类，线程安全和非安全的，多线程相关基础知识，实现方式，死锁的检查与排查，JVM内存模型，Java底层代码阅读，原子性，可见性实现原理，数据库相关，ACDI相关原则，乐观锁实现方案，分库分表理论，如何设计分库分表规则，分布式系统的相关理论，3原则，一致性hash原理，了解或使用过哪些开源的RPC框架，基本设计原理是什么，另外最基础的Spring，SpringMVC，ibatis等框架的使用当然是不可缺少的拉。 技术面试感觉下来要求的是一个广度，深度尚可，要对Java各方面都有所涉猎。 第二轮面试就是技术总监当面聊了，去上海office面见了技术总监，出乎意料的是没聊技术相关的，聊了一下过往经历，以及对公司业务发展方向的看法，人很nice，感觉不错。第三轮就是HR当面聊了，hr面嘛，3观要正，价值观要ok，然后就是薪资待遇福利交待，balabala 4.进程间通讯方式（IPC） 扩展：半双工（即数据只能在一个方向上流动）、全双工a、管道（无名管道）b、FIFO（命名管道）c、共享内存d、消息队列e、信号量 6.启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 首先java.exe 会帮助我们找到 JRE ，接着找到位于 JRE 内部的 jvm.dll ，这才是真正的 Java 虚拟机器 , 最后加载动态库，激活 Java 虚拟机器。虚拟机器激活以后，会先做一些初始化的动作，比如说读取系统参数等。一旦初始化动作完成之后，就会产生第一个类加载器―― Bootstrap Loader 1.加载字节码（启动类加载器，扩展类，应用程序类，自定义加载器） 2.验证格式 3.准备（分配内存） 4.解析（解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程） 5.初始化整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。 7.双亲委派a、类加载器分为启动类加载器，bootstrap classloader 加载JAVA_HOME/lib目录下面的classb、扩展类加载器extensnion classloader 加载JAVA_HOME/lib/ext目录下面的classc、程序类加载器application classloader 加载用户类路径（classpath）上所指定的类库d、自定义类加载器 继承ClassLoader抽象类 双亲委派机制：指的是类加载器收到类加载的请求有，将这个请求为派给父类加载器完成。若父类无法完成这个加载请求，子类加载器进行加载。*也就是说，所有的请求多会传送到顶层的启动类加载器，从顶层开始试图加载类，无法加载再向下传递。 打破双亲委派机制：JNDI 线程上下文类加载器。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。 OSGI 热部署 使用的是自定义的类加载器机制，每一个程序模块（bundle）都有一个自己的类加载器。 扩展问题a、能不能自己写一个java.lang.Object的类？如果能怎么写,如果不能为什么?不能自己写以\"java.\"开头的类，其要么不能加载进内存，要么即便你用自定义的类加载器去强行加载，也会收到1个SecurityException。 b、请设计一个能够在服务端执行的分析JVM中状态的程序。 8.classloader的功能和工作模式 JVM内存区域：堆（新生代、老年代）、栈（java虚拟机栈、native方法栈）、方法区（永久代）、程序计数器、 1、面试官可以先问你什么时候一个对象会被GC？　　 算法，根搜索算法，当一个对象不可达时，通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 2、接着继续问你为什么要在这种时候对象才会被GC？　　gc经常发生的是在堆区，堆区分为新生代、老年代，新生代分为一个eden空间和两个survivor空间。a、 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；b、 Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；c、发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。 方法区：存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代 3、接着继续问你GC策略都有哪些分类？标记-清除算法----------标记和清除效率低，而且产生一堆不连续的内存碎片复制算法------------将内存按照容量划分成几块，当某一块的用完之后，直接把存活的对象复制到另一块上面，然后把已使用的一次性清除掉。新生代用的比较多，划分比例为8：1:1，一个eden，两个survivor空间。每次可用的空间能够达到90%。 缺点是较多的复制操作，效率会变低，还会浪费空间。标记-整理算法----------标记之后，整理一下，然后清除掉。 老年代常用算法分代收集算法---------根据对象存活周期，将内存分为几块，根据不同的特点采用最适合的收集算法 4、你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？　　5、你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？　　6、你如果选出来了，继续问你，为什么要选择这个策略？ GCROOT哪里来的(哪些可以是GCROOT)？GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。主要有以下几种：a.虚拟机栈(栈桢中的本地变量表)中的引用的对象b.本地方法栈中JNI的引用的对象c.方法区中的类静态属性引用的对象d.方法区中的常量引用的对象 回收器：1、新生代，均使用标记-复制算法。serial收集器 单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。使用标记-复制垃圾收集算法ParNew收集器 serial的多线程版本，新生代收集器，使用标记-复制垃圾收集算法。可以和CMS一起使用，很重要。Parallel Scavenge收集器，也是多线程的垃圾收集器，但是和parNew的关注点不同，关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是CPU用于运行应用程序的时间和CPU总时间的占比，吞吐量 = 代码运行时间 / (代码运行时间 + 垃圾收集时间) 2、老年代：Serial Old收集器、Parallel Old收集器以及CMS收集器。Serial Old收集器 标记整理算法，单线程。 主要是在JDK1.5版本之前和Parallel Scavenge年轻代收集器配合使用，或者作为CMS收集器的后备收集器。Parallel Old收集器 标记整理算法，多线程。和Parallel Scavenge一样，是关注吞吐量的，经常和Parallel Scavenge一起使用。CMS收集器 目前老年代收集器中比较优秀的垃圾收集器。使用\"标记-清除\"算法的并发收集器，以获取最短停顿时间为目标的收集器。分为个阶段：1、初始标记 stop the world 2、并发标记 3、重新标记 stop the world 4、并发清除。 由于并发清理阶段，如果用户产生了垃圾对象，但是过了标记阶段，所以会产生浮动垃圾，因为不能像其他收集器那样等到完全填满了老年代以后才进行垃圾收集，需要预留一部分空间来保证当出现浮动垃圾的时候可以有空间存放这些垃圾对象。这个空间比例可以设置。 3、G1收集器：不区分所谓的新生代、老年代，将整个内存区域混合在一起，划分成不同的子区域。 在小范围内还是会划分成年轻代、老年代。采用不同的GC方式来处理。 是用什么GC可以设置的，例如java -Xmx10m -Xms10m -XX:+UseG1GC -XX:+PrintGCDetails TestDemo 类加载机制的简单连环炮。1、首先肯定是先问你Java的类加载器都有哪些2、回答了这些以后，可能会问你每个类加载器都加载哪些类？　　3、说完以后，可能会问你这些类加载之间的父子关系是怎样的？　　4、你在回答的时候可能会提到双亲委派模型，5、那么可以继续问你什么是双亲委派模型？　　6、你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？　　例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。 6、你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？看自己的类加载器的逻辑了，如果只重写了findClass方法并没有重写loadClass方法，就没有改变父类委托机制。如果改写了loadClass，就以自己改写的loadClass逻辑为准。a、重写findClass方法的自定义类，首先会通过父类加载器进行加载，如果所有父类加载器都无法加载，再通过用户自定义的findClass方法进行加载。b、重写loadClass来实现，可以在JVM的不同类加载器中保留具有相同全限定名的类，这种情况下，就有可能有大量相同的类，被不同的自定义类加载器加载到JVM中，并且这种实现方式是不符合双亲委派模型。 注意：defineClass 将二进制字节转换成Class类 class文件加载过程：加载（资源，将二进制字节文件存到方法区中）--》验证（文件格式）--》准备（分配类变量的内存空间、设置类变量初始值）--》解析（将常量池的符号引用转换为直接引用）--》初始化（执行java代码，初始化类变量和其他资源） Java的内存模型是怎么设计的？（线程之间的通信机制有两种共享内存和消息传递，java采用的是共享内存模型）a、java内存模型（JAVA Memory Model）描述的是一组规则或规范，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。所有的变量都存储在主存中，每条线程有自己的工作内存，工作内存保存了被该线程所使用到的变量的主内存的副本拷贝。线程对变量的所有操作，都要在工作内存中进行。线程之间的互相访问，也要通过主内存。b、Happens-Beforec、定义了8种操作：lock unlock read->load(不能单独出现) use assign store->write(不能单独出现)、 你回答了以后，还会继续问你为什么要这么设计？问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？只能保证可见性，不能保证写入操作的原子性。当且仅当满足以下条件时，才应该使用a、对变量的写入操作不依赖当前的值，或者只有单个线程更新变量的值。b、该变量不会与其他变量一起，纳入不变性条件。 你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。 ========================================================================================== 9.synchronized和lock的用法区别 各自底层原理synchronized：对象级别的同步块，底层包含monitorenter和monitorexit指令方法级别同步，底层是 ACC_SYNCHRONIZED 标识来判断Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。lock： 10.分布式锁11.如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源12.spring中的transactional注解，requestMapping注解的实现原理13.springMvc原理 如何集成web14.什么是缓存击穿 如何避免缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 15.自己做的项目对自己帮助很大的方面 成长的方面16.如何排查ooma、查看服务器运行日志、项目日志，捕捉到异常JAVA heap space （dump堆转储快照，用工具进行分析，确认到底是内存泄漏还是内存溢出，如果是内存泄漏，查看泄露对象为什么无法回收；如果不存在内存泄漏，说明对象都是必须存活的，则需要修改堆参数-Xms -Xmx）StackOverflowError 线程请求的栈深度大于虚拟机所允许的栈深度（-Xss设置栈内存大小）OutOfMemoryError 虚拟机在扩展栈时，无法申请到足够的空间PermGen space 运行时常量池溢出 or 方法区溢出unsafe.allocateMemory() 直接内存溢出b、查看linux日志 /var/log/message 看看有没有kill掉进程的记录c、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryError，当应用抛出OutOfMemoryError时生成dump文件。 dump文件的几种方式：1、使用jmap -dump命令2、使用jconsole工具3、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryErro4、使用hprof。启动虚拟机加入-Xrunhprof:heap=site，会生成java.hprof.txt文件。该配置会导致jvm运行非常的慢，不适合生产环境。（HPROF可以用来展示和跟踪cpu的使用情况，内存分配的统计数据等。不仅如此，它还支持对 java进程完整的内存dump，所有线程的monitor stats数据） jdk的命令行工具；1、jps 等同于ps，列出正在运行的虚拟机进程2、jstat 用于监视虚拟机各种运行状态信息（例如：jstat gc 2764 250 20）3、jinfo 实时地查看和调整jvm的各项参数4、jmap 用于生成堆转储快照5、jhat 堆转储快照的分析工具6、jstack java堆栈信息跟踪工具（一般多jstack几次才能看出来） jdk的可视化工具：1、JConsole2、VisualVM =====================================问题：Redis Bitmap是什么？ HikariCP连接池（号称性能最好的JDBC连接池:HikariCP）？常用的JDBC连接池包括：DBCP：单线程，性能较差，适用于小型系统C3P0：单线程，并发量低，性能不好BoneCP：一个高效、免费、开源的Java数据库连接池实现库，它的性能几乎是C3P0、DBCP的25倍。性能高于duridDruid：Druid是Java语言中最好的数据库连接池。能够提供强大的监控和扩展功能。特色：为分析监控设计；快速的交互式查询；高可用；可扩展。 springboot自动启动类?---------》答案：SpringApplication.run(); spring常用的接口和类，实现原理（在什么时候初始化，什么时候注入，什么时候调用）？BeanFactory.java，基本的接口类ApplicationContext.java，BeanFactory的扩展类1、DefaultListableBeanFactory是整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory集成自DefaultListableBeanFactory。XmlBeanFactory与DefaultListableBeanFactory不同的地方是XmlBeanFactory使用了自定义的XML读取器XmlBeanDefinitonReader,实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory接口。2、XmlBeanDefinitonReader集成自AbstractBeanDefinitionReader，完成了XML配置文件的读取过程。1）使用ResourceLoader将资源文件路径转换成对应的Resource文件2）通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件3）通过实现接口BeanDefinitonDocumentReader的DefaultBeanDefinitonDocumentReader类对Document进行解析，并使用BeanDefinitonParserDelegate对Element进行解析。3、XmlBeanFactory IOC容器的初始化过程：BeanDefiniton的Resource的资源定位、载入和注册的过程 GC，问怎么标记回收对象的，从GCROOT不可达的对象（根据四种引用关系，强软弱虚），GCROOT哪里来的(哪些可以是GCROOT)？java提供finalize()方法？GC和finalize()方法都是不可靠的 什么时候一个对象会被GC？答：GC发生在堆区，分为新生代和老年代。新生代还分为Eden和两个Survivor区域。a、对象优先在eden分配，当eden空间不够用的时候，发生minor gcb、当老年代空间不够用的时候，发生full gc，一般会伴随着一次minor gc，大对象直接进入老年代。c、发生minor gc时，会检测之前每次晋升到老年代的内存大小，是否大于当前的老年代的剩余大小。如果大于，则进行一次full gc。如果小于，则看是否允许担保失败，如果允许担保失败，则进行一次minor gc，如果不允许，进行full gc。 为什么要在这个时候对象才会被GC？GC策略都有哪些分类？答：标记-清除算法，产生不连续的内存空间，标记和清除效率不高 适用于老年代复制算法，浪费一部分空间，较多的复制操作，效率变低 适用于新生代标记-整理算法，整理需要时间，但是必要的 适用于老年代 这些策略分别都有什么优劣势？都适用于什么场景？给你举个实际的场景，让你选择一个GC的策略？为什么要选择这个策略？什么是gc，什么是cms算法？并发标记清除算法，分为4个步骤，初始标记-》并发标记-》重新标记-》并发清除。会产生浮动垃圾，就是重新标记过程中生产的垃圾，所以要保留一部分空间。 cms算法实现原理？整个过程是怎么样的？怎么避免full gc？1、system.gc() 调用大多数情况下会出发full gc，应该禁止使用。2、老年代空间不足 调优时尽量做到让对象在minor gc阶段呗回收，避免创建过大的对象和数组。3、永久代空间不足也会触发full gc。增大永久代空间、或者改成cms gc。4、cms gc出现promotion failed和concurrent mode failure两种状况会出现full gc。都是因为老年代空间不足造成的措施：增大survivor space、老年代空间或者调低触发并发gc的比例。5、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间6、堆中分配很大的对象，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。设置-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程 java g1垃圾收集器？ 类加载机制的相关问题：java的类加载器都有哪些？每个类加载器都加载哪些类？这些类加载器之间的父子关系是怎么样的？回答的时候可能会提到双亲委派模型，双亲委派模型是什么？java的类加载器为什么要使用双亲委派模型？如何自定义自己的类加载器？自己的类加载器和java自带的类加载器关系如何处理？bootstrapExtendsystem/appself defined 内存的相关问题：内存分为哪几部分？这些部分分别都存储哪些数据？一个对象从创建到销毁都是怎么在这些部分里存活和转移的？内存的哪些部分会参与GC的回收？java的内存模型是怎么设计的？为什么这么设计？回答：Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。在并发编程领域，有两个关键问题：线程之间的通信和同步。线程之间的通信机制有两种：共享内存和消息传递。Java的并发采用的是共享内存模型Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。 java线程、java线程池、java集合、java队列、java正则表达式、java native方法、JAVA泛型jdk和jre的区别 java、Spring中的ServletContext相关Spring的DispacherServlet和ContextLoaderListener中的WebApplicationContext的关系获取spring的ApplicationContext几种方式：直接创建（2种），工具类WebApplicationContextUtils，extends或者implements（ApplicationObjectSupport就是实现ApplicationContextAware） java nio的selector 和linux的epoll select，类似与epoll或者java里面的selector ZeroCopy和mmap思想 集合重写写equals，就必须重写hashCode？使用hash表的时候需要重写 Java基础概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO与文件、多线程、反射 ============================面试题：1、nio、Bio，aio的区别，大概机制，接口nio 同步非阻塞io（不等待，但是主动查询io是否完成），高并发的程序一般用这.Channel、Buffer、Selector Reactor就是Java的NIO。bio 同步阻塞io（等待操作完成）aio 异步非阻塞io（不等待，也不主动查询，io完成会主动通知） AsynchronousChannel、AsynchronousSocketChannel 2、数据库，innobd，隔离级别，行级锁3、分布式4、类加载器和双亲委派机制，何时破坏双亲委派机制5、几种垃圾回收器6、java8新特性，lamda，函数接口7、多线程：创建线程池，两个线程一个初始化，一个循环，改变一个值，并发包下接口类8、java虚拟机的内存模型，内存工作方式9、spring 、aop、ioc10、二叉树算法11、MySQL的事务级别，mybatis一个mapper实现两个sql12、多线程，100个子线程，执行完成，将结果返回主线程13、如何在大量数据中查找某一段的数据，不用limit14、dubbo的原理，结构15、整体介绍负载均衡架构16、多线程的好处？一定能加快运行速度么？因为线程切换也是需要时间的17、Integer和int类型，哪个放在堆内存？哪个在栈内存？ 18、堆里面和栈内存，分别是什么时候回收？19、outofmemory的问题，怎么定位？20、常用有哪些设计模式？21、一致性hash的实现原理 简历：SMART原则 1、同盾科技面试2、公司面试总结3、招聘要求4、公司面试注意事项5、别人的面试经历16、 面试问题：netty小对象、大对象的管理jvm在操作系统层面的内存AQS的Zookeeper怎么保障全部通知到【定时更新】查找数组中重复出现次数最多的数字rocketmq扩容怎么保证顺序消息Redis的五种数据类型的实现是什么数据结构 公司面试注意事项： 项目中遇到的技术难点：并发，稳定性，容错，性能等方面入手。内存泄漏 面试经验：https://mp.weixin.qq.com/s/oQdmQpO4XXFaJbfjt8GvXQ?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com刷题：LeetCode+《剑指offer》基础知识简历：SMART原则英语锻炼面试 消息的功能，为什么这么做，那几个接口怎么适配的：kafka的实现原理：怎么存储，怎么通信零拷贝，java怎么使用hashmap的实现原理：数据+链表，比如put操作：先定位数据位置，再比较链表中是否存在synchronized 和 volatile 区别 先做个简单的自我介绍：主要是三个周期：第一个周期是14年7月到15年8月 南京亚信软件，第二段是15年8月到16年9月：南京快钱 平台的维护对接和需求开发第三段是16年9月到目前是南京亚信软件， 为什么换工作到杭州快钱项目介绍目前的项目介绍 同盾科技面试： 为什么选择封装Acticemq和Rocketmq在什么情况下，选择Acticemq，什么情况下Rocketmq对比一下Acticemq和Rocketmq推荐给客户的时候，怎么推荐哪一个中间件，就是什么场景下使用哪个mq中间吗：并发、部署、运维、高可用 kafka和rocketmq对比有什么区别语言、缓存批量发送-吞吐量和安全、存储时候文件的区别使用的注册中心和协调框架--zookeeper、nameSrv 统一配置平台有几个服务：zookeeper通知、Redis缓存、HDFS和数据库存储，amber服务控制台 如果Zookeeper主节点宕机，重新选主30S不可用，文件更新了，怎么实现实时通知客户端异常重试，重新多少次就打印日志 使用消息通知，消息挂了怎么办，消息怎么判断客户端确实接收到了，通知的时候记录，然后消费端接收的时候，消费成功做反馈客户端如果宕机了，服务端怎么知道呢？ 实时感知，客户端和服务端之间做长连接，如果客户端有几千Client，配置中心只有几个服务，这个你怎么保证这么多连接可用 常见的RPC框架指的是哪些，知道的开源的Rpc框架有哪些，dubbo有使用过吗？dubbo底层通讯序列化使用的是什么？负载均衡是在客户端还是服务端？ netty：tcp拆包和粘包的原因是什么，netty有哪些方式？netty零拷贝指的是什么？那linux的用户态和内核态有什么区别？netty使用的是什么内存？（直接内存和堆外内存），内核态操作的是什么内存？堆内存和堆外内存怎么释放？通过操作系统的什么方法去写内存的？在java里面什么时候才会触发堆外内存回收，回答GC，手动释放，还有吗？如果我要实现内存池，采用什么方式？直接内存，怎么设计呢？unsafe方法有了解吗？CAS这个有了解吗？ABA问题怎么处理 hashmap介绍，1.6和1.8有什么改进？hashmap扩容过程？concurrenthashmap在1.8有什么优化？lamdba表达式有什么优点，为什么使用这个？.stream是干嘛的？ synch声明在静态块和普通方法有什么区别？java有几种锁？lock接口有几种锁？什么时候用读写锁？跟valitile有什么区别，用在什么场景？（其实是读多写少这种），什么时候valitile，什么时候用atom原子类型？一个变量为什么不用atom而是valitile？ barracyle栅栏机制？ java堆内存溢出怎么排查？什么情况下堆内存溢出？什么栈内存溢出？tlab就是内存逃逸分析？ G1和cms对比，有什么优缺点？G1可以设置单个块最大的回收时间，真实有效吗？达到了这个时间会发生什么？ springcloud是不是用过，springboot使用过吗？ 了解过微服务开发吗？答sprngcloud、servermesh， servermesh主流的技术是什么？istio的数据层面和控制面都是哪些组件？各是干什么的？sidecar和dubbo各有什么优势？sidecar和应用之间怎么通信？是怎么代理应用的？应用的请求sidecar怎么获取的？ 大数据有什么了解吗？没有， apigateway有接触吗？开源的接触过什么？跟后端是怎么通信的？（其实还是想问跟后端是rpc框架是什么）rpc通信是什么方式？都不用dubbo吗？那rpc都是用的什么？csf底层用的什么序列化（谷歌那个，td，protobuff），用什么通信？Zookeeper注册？，springcloud的api网关是哪个服务？还有其他的api网关？ 大数据不是做流计算 别人的面试经历1 zookeeper的watcher乐观锁怎么实现 c. 说出一个空间换时间的场景 G1和CMS的区别，G1有啥劣势；Kafka的整体架构；Netty的一次请求过程；自旋锁/偏向锁/轻量级锁（这个问题在头条的面试里也出现了一次）、hbase线上问题排查（刚好遇到过NUMA架构下的一个问题，借此把hbase的内核介绍了下）。 求一棵树两个节点的最近的公共父节点。思路基本是对的，但是有些细节有问题，面试官人很好，边看边跟我讨论，我边改进，前前后后估计用来快半小时。然后又继续问问题，HTTP 301 302有啥区别？设计一个短链接算法；md5长度是多少？ ThreadLocal如果引用一个static变量是不是线程安全的 问了一些基础问题和netty的写流程，还问了一个redis数据结构的实现，结构他问了里面字符串是怎么实现的，有什么优势。一直感觉这个太简单，没好好看，只记得有标记长度，可以直接取。然后就来两道编程题。第一题是求一棵树所有左叶子节点的和，比较简单，一个深度优先就可以搞定。第二题是给定一个值K，一个数列，求数列中两个值a和b，使得a+b=k。我想到了一个使用数组下标的方法（感觉是在哪里有见过，不然估计是想不出来），这种可是达到O(n)的复杂度；他又加了个限制条件，不能使用更多内存，我想到了快排+遍历，他问有没有更优的，实在想不出来，他提了一个可以两端逼近，感觉很巧妙。 先让我讲下kafka的结构，然后怎么防止订单重复提交，然后开始围绕缓存同步问题展开了长达半小时的讨论：先写数据库，再写缓存有什么问题？先写缓存再写数据库有什么问题？写库成功缓存更新失败怎么办？缓存更新成功写库失败怎么办？ 我提到了istio，介绍了设计理念，感觉他有点意外。然后他问java8的新特性，问我知不知道lambda表达式怎么来的，我从lambda演算说到lisp说到scala，感觉他更意外。几个netty的问题，gc的问题， 第一部分就是日志上传和接收，然后就如何保证日志上传的幂等性开始不断深入，先让我设计一个方案，然后问有没有什么改进的，然后如何在保证幂等的前提下提高性能，中间穿插分布式锁、redis、mq、数据库锁等各种问题。 结合秒杀的场景深入，如何实现分布式锁、如何保证幂等性、分布式事务的解决方案。问我分布式锁的缺点，我说性能会出现瓶颈，他问怎么解决，我想了比较久，他提示说发散下思维，我最后想了个简单的方案，直接不使用分布式锁，他好像挺满意。感觉他们更看重思考的过程，而不是具体方案。还问了一致性hash如何保证负载均衡，kafka和rocketmq各自的优缺点，dubbo的一个请求过程、序列化方式，序列化框架、PB的缺点、如何从数据库大批量导入数据到hbase。 也是让我先介绍项目，问我有没有用过mq，如何保证消息幂等性。我就把kafka0.11版本的幂等性方案说了下，就没再问技术问题了 公司面试总结： 19年面试：1、19年5月14号 周二 面试 fit2cloud ，在南京刚刚起步，一个开发，两个销售，在南京建邺万达租的一个一室的房间，暂时不考虑2、京东数科，周三（5/15）14：00，后面确定电话面试，因为面试的回答不好，没有结果额3、途牛 中间件部门，微信视频面试两轮，最后还是说不合适4、杭州同盾，电话面试一轮，收获还是挺多的，后来又到面两轮，还是被刷了5、杭州呆萝卜，文滔推荐了两次，都简历不通过，要有电商业务经验的6、杭州滴滴，猴哥内退小橘业务部门，简历都没过7、在boss上投递了涂鸦，一直显示面试，都2个多星期了，都没有反应，pass 海康二维火百世汇通jd 招聘要求： java基础扎实：熟悉IO、多线程、集合操作等基础技能熟悉分布式、缓存、消息队列等中间件技术熟悉mysql数据库的基本操作 熟悉常用设计模式熟悉并对javaEE、SOA、spring、osgi等技术潮流保持关注，有数据库、分布式、性能优化、高并发、高可用性系统设计开发经验有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解;熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术；熟悉常用算法和数据结构，熟悉分布式系统原理负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 1、重点本科或以上学历（985/211），计算机软件或相关专业，英语CET4以上;2、精通java编程，熟悉java sdk提供的主要能力;3、理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发;4、熟悉多线程编程，熟练使用java并发包下的各项常用基础设施;5、熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务;6、熟悉常用网络协议，如TCP/IP, HTTP;7、能够熟练使用linux，能够利用常用的工具对程序进行跟踪诊断;8、有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解;9、具备良好学习、沟通能力及团队协作精神，对工作积极严谨，勇于承担压力。 这里有世界一流的中间件产品和场景，包括应用托管容器、分布式调用服务、分布式消息服务、分布式数据服务和大数据计算平台等，掌控着超千亿规模的消息推送和分布式数据库调用，是全球流量最大的中间件集群之一这里有世界最大的电商交易业务场景，团队提供的高可用架构基础设施直面双11洪峰流量，包括容量规划、准入控制、限流降级、流量调度、弹性伸缩和全链路压测等，体系化支撑阿里巴巴电商链路的稳定运行这里有世界领先的企业互联网架构平台，以中间件技术部多款核心产品作为基础设施构建的云计算解决方案，面对互联网+的浪潮，帮助企业级客户轻松构建并托管分布式应用，解决集中化和互联网化的业务需求我们的使命：做分布式架构基础设施，建设支撑百万笔交易的分布式架构能力，建设支撑百万台服务器和超万个系统的服务能力我们的愿景：打造世界一流的中间件产品，打造世界一流的高可用架构基础设施，打造世界一流的企业级互联网架构平台全面参与阿里巴巴集团中间件（容器，服务框架、消息中间件、数据中间件等）的设计，核心代码开发，系统稳定性开发，性能优化等工作帮忙业务方解决技术难题，用技术推动业务发展岗位要求: 熟悉java concurrent包 ，熟悉高并发，分布式通信，存储等相关技术 3年以上相关工作经验 熟悉Linux操作系统、熟悉开源的中间件软件 熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先 具有高并发相关工作经验优先 有很强的与客户沟通和理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情； 职位描述： 负责阿里巴巴菜鸟基础技术组件和产品的研发和设计工作，有监控系统经验者优先。 从架构角度横向关注菜鸟业务系统，为菜鸟系统微服务化，云化，流程引擎自动化等共享技术方面做技术支撑。职位要求 计算机相关专业本科或以上学历，三年以上J2EE项目开发经验； 扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术； 精通Java EE相关的主流开源框架，能了解到它的原理和机制，如Spring、iBatis、struts等； 熟悉Oracle、MySql等数据库技术，对sql优化有一定的经验； 思路清晰，良好的沟通能力与技术学习能力； 有基础技术组件，分布式存储/计算相关经验者优先考虑。 岗位描述:蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。岗位要求:1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力；5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； 满足以下三个以上条件：1、从事一线研发工作5年以上，有优秀的设计与代码编写能力2、熟练掌握C/C++/Go/Python/Java/Nodejs等1至2种以上语言（GO加分，同时会Java+GO/Java+Python加分）3、熟悉多种消息中间设计实现如：Kafka, RabbitMQ,activemq等（向社区提交过patch者优先）4、熟悉etcd，consul,zookeeper等分布式组件（阅读过源码并向社区提交过patch者优先）5、熟悉常用算法和数据结构，熟悉分布式系统原理6、熟悉RPC框架、系统架构优化设计等（阅读过dubbo等源码并向社区提交过PR者优先）7、具备网络知识，熟悉TCP/IP通信原理者优先8、有大型高并发项目架构设计经验者优先9、有开源社区贡献者经验优先10、熟悉微服务架构及服务治理优先11、熟悉Kubernetes者优先11、参与过PaaS平台规划，设计研发过PaaS/FaaS关键部件优先 负责小桔车服架构及稳定性建设，主要包括两块工作：一、架构产品规划及架构治理，二、提升车服软件总体稳定性任职要求一、精通java语言，对java语言特性及jvm有全面深度理解；二、熟悉消息中间件的特性，知道高性能消息中间件的设计思路；三、存储系统选型能力强，熟悉搜索产品、kv存储、数据库，能根据业务的当前发展阶段做出最优的存储选型；四、对服务治理有体系化思考，熟悉业界知名服务治理方案如dubbo、spring boot，能比较不同方案的优劣；五、在存储、中间件或服务治理领域有开源贡献者优先；六、对稳定性建设有体系化的思考，知道如何在指定时间内按部就班地将稳定性提升至指定水平。 熟悉Java并发和网络编程，有良好的数据结构和算法功底； 熟悉消息中间件的原理和关键技术，熟悉Kafka/Pulsar/RocketMQ等消息产品的原理和实现，有开源社区贡献者优先； 对CAP理论、Paxos/Raft算法、高可用架构、分布式事务等有一定理解，并由一定实践经验者优先； 有分布式存储的使用和研发经验者优先； 了解或熟悉一种分布式流计算框架的应用场景和关键技术，例如Spark/Flink/Kafka Streams/Apache Samza等，有相关研发经验者优先； 有技术热情和较强的学习能力，有良好的分析解决问题和技术攻关能力，具备良好的沟通能力、抗压能力和团队协作能力； 岗位职责：参与曹操专车中间件（服务框架、消息中间件、数据中间件等）的设计，代码开发，系统稳定性开发，性能优化等工作主要方向：监控告警、网关、日志处理、消息中间件、公用组件服务等岗位要求： 3年以上相关工作经验，Java基础扎实，熟悉多线程，分布式系统，数据存储等相关技术 熟悉常用的中间件技术（如消息系统、RPC框架、缓存系统、存储层中间件等） 掌握多线程及高性能的设计与编码及性能调优，有高并发应用开发经验优先 熟悉Linux操作系统、能够熟练编写shell脚本 有监控、网关、日志处理等系统经验者优先 有大数据处理框架使用经验者优先，如storm、hadoop等 对用过的开源框架能了解到它的原理和机制，有开源项目贡献者优先 有较强的沟通理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情； 工作职责: 负责基础架构技术、产品的设计与研发 负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 优化基础服务性能，提升服务可用性，增加系统稳定性，保障业务高效运行 解决线上服务运行期间出现的各种问题任职要求： 计算机或相关专业本科以上学历（5年及以上工作经验） 精通Java程序开发，熟悉Linux/Unix开发环境 熟悉常用开源分布式系统，精通但不限于kafka/rocketmq/mongodb/redis/opentsdb等任意一种开源产品源代码 良好的分布式理论与实践能力 良好的沟通协作能力，较强的分享精神 有Github等开源社区贡献经验的优先 岗位描述: 负责中间件消息系统核心模块的设计和方案落地。 负责公共云和专有云的稳定性。 负责新产品线的调研和论证。更高层需求： 负责产品路线的选型。 负责公共云和专有云的具体打法，为结果负责。岗位要求: 4年以上分布式系统相关经验。 至少精通一种编程语言，Java或C++。 深入理解分布式存储理论，微服务优化实践。 计算机理论基础扎实，例如对操作系统原理、TCP/IP等有比较深入的理解。 具有独立设计一款生产环境高可用高可靠的中间件能力，例如RocketMQ。 熟悉高并发、分布式通信、存储、开源中间件软件等相关技术者更佳。 有很强的与客户沟通和理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情。 岗位职责：1、参与曹操专车中间件（服务框架、消息中间件、数据中间件等）的设计，代码开发，系统稳定性开发，性能优化等工作；2、主要方向：监控告警、网关、日志处理、消息中间件、公用组件服务等。任职要求：1、4年以上相关工作经验，Java基础扎实，熟悉多线程，分布式系统，数据存储等相关技术；2、熟悉常用的中间件技术（如消息系统、RPC框架、缓存系统、存储层中间件等）；3、掌握多线程及高性能的设计与编码及性能调优，有高并发应用开发经验优先；4、熟悉Linux操作系统、能够熟练编写shell脚本；5、有监控、网关、日志处理等系统经验者优先；6、有大数据处理框架使用经验者优先，如storm、hadoop等；7、对用过的开源框架能了解到它的原理和机制，有开源项目贡献者优先；8、有较强的沟通理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情。 岗位职责： 参与有赞PaaS中间件（容器，服务框架、消息中间件、数据中间件等）的设计，核心代码开发，维护系统稳定性，性能优化等工作 深入理解所负责的中间件的技术原理、架构和使用场景, 帮助业务方更好的利用中间件产品解决技术难题 规划中间件产品的发展方向，用中间件技术、通用产品、通用平台解决业务架构难题,支撑业务系统的快速发展岗位要求： 精通Golang／Java／C++语言 ，5年以上相关工作经验 精通高并发，分布式，存储等相关技术3.熟悉消息中间件，RPC框架，数据层，性能优化等相关技术4.有优秀的问题排查能力5.善于独立思考，有快速学习能力，不断突破技术瓶颈，乐于探索未知领域，在较大压力下保持工作激情 工作职责: 负责基础架构技术、产品的设计与研发 负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 优化基础服务性能，提升服务可用性，增加系统稳定性，保障业务高效运行 解决线上服务运行期间出现的各种问题任职要求： 计算机或相关专业本科以上学历（5年及以上工作经验） 精通Java程序开发，熟悉Linux/Unix开发环境 熟悉常用开源分布式系统，精通但不限于kafka/rocketmq/mongodb/redis/opentsdb等任意一种开源产品源代码 良好的分布式理论与实践能力 良好的沟通协作能力，较强的分享精神 有Github等开源社区贡献经验的优先 岗位描述:蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。岗位要求:1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力；5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； 岗位职责：1、框架和中间件产品迭代2、框架和中间件产品性能优化3、框架和中间件产品上云，支持多租户等云产品特性岗位要求：1、Java基础扎实，掌握Java NIO和Netty基本原理2、熟悉常用RPC框架比如Dubbo、Thrift、gRPC者优先3、熟悉Spring Cloud、Service Mesh微服务解决方案者优先4、熟悉相关调用链开源产品者优先5、具备良好的沟通能力以及技术产品规划改进能力 职位描述：参与蚂蚁在海量数据访问、变更、灾备等场景下，业务数据一致性所依托的分布式事务中间件产品的技术设计、研发和推广； 分布式事务产品功能的设计、研发和运维，及商业版的推广； 蚂蚁分布式事务开源版 fescar 的研发和运营； 配合蚂蚁全站业务发展、技术演进的数据中间件技术；职位要求：1.2年及以上使用JAVA开发的经验，JAVA基础扎实，理解IO、多线程、集合、网络等基础框架、对JVM原理有一定的了解；2.熟悉数据库编程，对mysql、oracle等数据库有一定使用经验；熟悉分布式系统的设计和应用；3.熟悉并具有XA、TCC等分布式事务框架或者解决方案经验者优先；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，有良好的团队合作和沟通能力。 团队介绍：主要负责蚂蚁金服中间件产品的研发、运维和推广；团队目前运营的开源品牌SOFAStack（https://github.com/alipay），在金融级分布式架构领域非常活跃；分布式事务开源版本fescar，在社区也非常活跃；团队技术氛围非常好，有定期分享和参与各种开源论坛的机会，人员的成长和技术视野的提升都非常快。团队Leader很重视团队人员的技术成长，新人有专门的师兄，并且会制定相应成长计划，并定期Review做调整。注：工作地选择杭州或者北京均可；职位描述工作职责：1.作为底层系统开发人员，通过中间件技术、通用产品、通用平台解决业务架构难题，保障和支撑有赞业务的快速增长和迭代；2.参与有赞PaaS中间件(微服务框架、消息中间件、数据中间件、分布式KV存储系统等)的设计、核心代码开发，维护系统稳定性，提升产品和系统的性能；3.深入理解所负责的中间件的技术原理、架构和使用场景，帮忙业务开发更好的利用中间件产品解决技术难题，提升业务的开发和迭代速度；4.参与产品推广、技术宣讲和培训，提升业务开发对底层中间件和系统的了解，减少和消除因对底层系统不了解造成的故障；5.结合业界实践和有赞的实际情况，规划中间件和底层系统平台的发展方向，保障底层系统的持续稳定运行。工作内容：1.了解业务开发的需求和痛点，对业务实际中遇到的问题进行总结，抽象成为对中间件产品的需求设计、开发核心中间件产品，不断满足业务在功能、性能、稳定性等方面的需求；2.在结合有赞的业务场景和实际情况的前提下，吸纳开源产品优秀的设计和架构，并进行针对性的改良和适配；为需求方做技术培训，组织技术分享并能输出技术沉淀；3.协助业务方进行底层系统的技术选型和方案评估，为业务方提供专业的建议和支持；4.推动整体业务开放对底层中间件系统进行规范、合理的使用，保障底层系统的健康、稳定运行。任职要求：1.熟悉C++、Golang或Java语言 ，2年以上相关工作经验；2.熟悉高并发、分布式，存储、微服务架构等相关技术，熟悉网络编程；3.熟悉Linux操作系统、熟悉业界主流和常用的中间件软件；4.善于独立思考，有快速学习能力，不断突破技术瓶颈，乐于探索未知领域，在较大压力下保持工作激情；5.熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先；6.熟练使用关系型数据库，对索引调优有一定经验或者了解其原理者优先；7.有良好的问题排查经验，有 docker 容器管控、PaaS 平台等领域的实践经验者优先。成长建议：1.关注和重视技术基础，对数据结构、算法、操作系统、网络编程等计算机基础课程进行深入的学习，并在实践中不断加深理解；2.不断提升对所维护和开发的产品的了解程度，结合业务实际场景进行深入的思考，提升对技术产品整体的认识能力和架构能力；3.学习和了解业务主流开源中间 任职条件对于Java基础技术体系（包括JVM、类装载机制、多线程并发、IO、网络）有一定的掌握和应用经验；良好的面向对象设计理解，熟悉面向对象设计原则，掌握设计模式及应用场景；熟悉底层中间件、分布式技术（包括缓存、消息系统、热部署、JMX等）；对于高并发、高稳定可用性、高性能、大数据处理有过实际项目产品经验者优先。 高可用架构团队是阿里巴巴保障稳定性的护航舰队，提供的高可用架构基础设施直面双11洪峰流量，包括全链路压测、容量规划、准入控制、限流降级、流量调度、弹性伸缩等；通过同城双活、异地多活、单元化体系建设，支撑阿里巴巴电商链路的分钟级故障切换，保证业务稳定运行。目前，我们承载着产品 PaaS 云化的承前启后的使命，通过阿里云赋能外部用户，急需高可用相关的研发人才，一方面完善高可用中间件自身的核心功能演进，满足业务系统大规模、高并发、高可用的需求；另一方面，需要快速迭代开发，将原来对内部为主的高可用中间件做成真正完善的可以对外部企业开放的云产品，帮助客户构建易使用、易运维的分布式系统。根据对云计算平台的业务需求，从稳定性、功能、性能等方面，负责设计、实现、改进云产品，把原来仅能满足内部使用的中间件组件，打造成功能完善且满足外部企业需求的云产品。开发云产品自身的管控、自动运维、监控、服务计费、产品运营、故障定位等工具。和架构师紧密合作，了解客户当前在技术上遇到的困难，帮忙业务方解决技术问题，用技术推动业务发展。2、熟悉 Java 常见开发框架，有扎实的 Java 基础和丰富的 WEB 开发经验3、精通linux平台上的Java语言编程，熟悉数据库开发技术，熟悉shell编程4、对数据结构、算法设计、系统架构设计等有较为深刻的理解5、熟悉系统高可用和稳定性方法策略，比如同城容灾、异地双活、异地多活等，有实战经验优先6、精于架构设计、性能优化，有故障处理、监控、限流、降级、预案、容量规划实战经验优先7、有前端开发经验，熟悉 ReactJS 者优先 职位名称：蚂蚁金服-消息和分布式计算系统研发工程师/专家职位描述：参与蚂蚁分布式消息中间件和分布式流计算框架的设计和研发工作。通信产品广泛应用在蚂蚁金服的各项业务中，承担了海量的消息投递任务和复杂的单元化路由任务，并且保证系统的高可用和消息的高可靠。职位要求：1.精通 Java 并发和网络编程，有良好的数据结构、算法功底；2.熟悉消息中间件的应用场景和核心技术，熟悉 Kafka/ActiveMQ/RocketMQ等 MQ 产品的原理和实现，有开源社区贡献者优先； 3.对CAP理论、Paxos/Raft 算法、高可用架构、事务等理论有深入理解，并有一定的实践经验；4.了解或熟悉一种分布式流计算框架的应用场景和核心技术，例如 Storm/Kafka Streams/Apache Samza 等，有相关研发经验者优先；5.了解或熟悉IoT架构、MQTT协议等，有相关研发经验者优先；6.有分布式存储的使用和研发经验者优先；7.熟悉 JVM 基本运行原理和性能调优经验者优先； 8.熟悉 Linux 内核者优先。 岗位描述: 蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！ 您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。 岗位要求: 1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节； 2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制； 3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验； 4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力； 5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/开源组织和公司开源项目地址和网站.html":{"url":"Books/Interview/开源组织和公司开源项目地址和网站.html","title":"开源组织和公司开源项目地址和网站","keywords":"","body":"阿里巴巴 Github首页 地址： https://github.com/alibaba 介绍: 支付宝Github首页 地址： https://github.com/alipay 介绍: 阿里中间件团队博客 地址： http://jm.taobao.org/ 介绍: 新美大 Github首页 地址： https://github.com/Meituan-Dianping 介绍: 美团技术团队 地址： https://tech.meituan.com/ 介绍: 美团Github首页 地址： https://github.com/meituan 介绍: 大众点评Github首页 地址： https://github.com/dianping 介绍: 有赞 Github首页 地址： https://github.com/youzan 介绍: 有赞技术团队 地址： https://tech.youzan.com/ 介绍: CNCF（Cloud Native Computing Foundation） Github首页 地址： https://github.com/cncf 介绍: CNCF基金会，云原生社区 谷歌Google Github首页 地址： https://github.com/google 介绍: 脸书facebook Github首页 地址： https://github.com/facebook 介绍: 推特twitter Github首页 地址： https://github.com/twitter 介绍: 亚马逊Amazon Github首页 地址： https://github.com/amzn 介绍: 亚马逊云服务 Github地址： https://github.com/aws 介绍: 腾讯Tencent Github首页 地址： https://github.com/Tencent 介绍: 百度 Github首页 地址： https://github.com/baidu 介绍: 京东 Github首页 地址： https://github.com/CHINA-JD 介绍: 小米 Github首页 地址： https://github.com/orgs/XiaoMi 介绍: 雅虎 Github首页 地址： https://github.com/yahoo 介绍: 领英 Github首页 地址： https://github.com/linkedin 介绍: 网易 Github首页 地址： https://github.com/NetEase 介绍: Netflix Github首页 地址： https://github.com/Netflix 介绍: 亿贝 Github首页 地址： https://github.com/eBay 介绍: 微软 Github首页 地址： https://github.com/Microsoft 介绍: 豆瓣 Github首页 地址： https://github.com/douban 介绍: 唯品会 Github首页 地址： https://github.com/vipshop 介绍: 苹果 Github首页 地址： https://github.com/apple 介绍: 猫途鹰 Github首页 地址： https://github.com/tripadvisor 介绍: 三星 Github首页 地址： https://github.com/SAMSUNG 介绍: 地址： 介绍: 地址： 介绍: 其他技术组织 中生代技术 地址：https://zhongshengdai.com/ 地址：https://yq.aliyun.com/teams/136/type_blog-cid_0-page_6 地址：https://www.itdks.com/member/organizer/16 地址：https://zhuanlan.zhihu.com/freshmantechnology 地址：https://github.com/freshmantechnology 介绍: 中生代技术社区成立于2015年，是一家立足于成都，服务全国的技术社区运营，技术管理咨询和技术人才猎头公司。也有技术分享 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/框架网站.html":{"url":"Books/Interview/框架网站.html","title":"框架网站","keywords":"","body":"不错的框架网站 各种相关 GitHub Pages 地址：https://github.com/jekyll/jekyll 介绍: 博客模板框架 万维网联盟，又称W3C理事会，World Wide Web Consortium (W3C) 地址：https://www.w3.org/ 地址：https://github.com/w3c 地址：https://www.w3schools.com/ 地址：http://www.w3school.com.cn/ 地址：https://www.w3cschool.cn/ 介绍: 在 W3School，你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 oreilly系利图书网站 地址：https://www.oreilly.com/index.html 地址：https://learning.oreilly.com/ 介绍: 码库CTOLib 地址：https://www.ctolib.com/ 介绍: 码库CTOLib.COM每日更新收录实用的开源项目和资源，目前共有55447个收录，并归类到659个分类中 github代码扫描工具，github账号登录 地址：https://codecov.io/ 地址：https://travis-ci.org/ 地址：https://goreportcard.com 地址：https://app.codacy.com/manual/looly/hutool/dashboard 介绍: 代码扫描、测试覆盖率等 Java设计模式 地址：https://github.com/iluwatar/java-design-patterns 介绍: 面试 地址：https://github.com/kdn251/interviews/blob/master/README-zh-cn.md 介绍: Java算法 地址：https://github.com/TheAlgorithms/Java 介绍: Java开发框架 地址：https://github.com/gothinkster/realworld 地址：https://github.com/jhipster/generator-jhipster 介绍: Java相关的教程、各种教程和示例。 地址：https://github.com/akullpp/awesome-java 地址：https://github.com/eugenp/tutorials 介绍: Reactive编程 地址：https://github.com/kaushikgopal/RxJava-Android-Samples 介绍: Reactive编程通过提供很好的抽象来处理异步和基于事件的编程而获得了广泛的普及。RxJava是ReactiveX的Java实现，它通过Observables提供反应式编程。 Java Functional Programming函数式编程概念 地址：https://github.com/winterbe/java8-tutorial 介绍: Java8是已发布的最具破坏性和创新性的Java之一，因为它已经在Java中引入了“ Functional Programming ”。借助Lambda和Streaming之类的概念，Java最终达到了函数式编程领域，同时保持了其传奇而全面的向后兼容性。 Java Functional Programming函数式编程概念（Lambda，Streams，Functional Interface，Parallel Streaming等）的小而有用的示例。 编码挑战类书籍 地址：https://github.com/careercup/CtCI-6th-Edition/tree/master/Java 介绍: 本书涵盖了所有类型和种类的编码挑战，包括算法复杂性，数学和逻辑难题，动态编程，排序和搜索，多线程等等。 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/其他的学习网站.html":{"url":"Books/Interview/其他的学习网站.html","title":"其他学习网站","keywords":"","body":"各方面的学习网站，比如买房等 各种相关 2017杭州买房经验 地址：https://github.com/houshanren/hangzhou_house_knowledge 介绍: openstack 地址：https://www.openstack.org/ 介绍: OpenStack是一个开源的云计算管理平台项目，是一系列软件开源项目的组合。由NASA(美国国家航空航天局)和Rackspace合作研发并发起，以Apache许可证（Apache软件基金会发布的一个自由软件许可证）授权的开源代码项目。 [1] OpenStack为私有云和公有云提供可扩展的弹性的云计算服务。项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台 地址：ChromeAppHeroes 介绍: 谷粒-Chrome插件英雄榜, 为优秀的Chrome插件写一本中文说明书, 让Chrome插件英雄们造福人类~ 地址：学习文章 介绍: java技术文章 《自学是门手艺》 地址：weekly-reading 地址：GitHub Trending 地址：李笑来Github 介绍: 一个介绍技术的博客 地址：技术学习博客 介绍: 地址：Java教程 介绍: 地址：慕课网 介绍:比较不错的编程视频教学网站，可以找到比较体系的东西，当然，有些内容要花钱就是了。 地址：中国大学MOOC 介绍: 有很多名校的课程，当然不止CS。 地址：LeetCode 介绍: 经典的刷题网站，主要是算法题。 地址：LintCode 介绍: 和LeetCode类似,经典的刷题网站，主要是算法题。 地址：牛客网 介绍: 一个联网求职学习交流社区。 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Interview/学习.html":{"url":"Books/Interview/学习.html","title":"待学习","keywords":"","body":"训练营第一天 1、synchronized关键字的字节码原语 2、volatile关键字的字节码原语 3、synchronized与volatile的硬件级实现 4、无锁、偏向锁、轻量级锁、重量级锁的升级过程 5、内存屏障的基本概念 6、JVM规范如何要求内存屏障 7、硬件层级内存屏障如何帮助java实现高并发 8、面试第4题（线程间通讯）的8种解法 9、作业 训练营第二天 1、线程池的学与思 2、使用线程池的好与不好 3、为什么阿里开发手册建议自定义线程池 4、自定义线程池的最佳实践 5、常见线程池类型与应用场景 1）CachedPool 2）FixedThreadPool 3）ScheduledPool 4）WorkStealingPool 5）ForkJoinPool 6、比线程更牛X的线程，压测结果展现纤程的威力 7、总结 一个小伙伴最近参加某个一线互联网公司的面试，被问了以下问题，看看大家能否答出来： （1）synchronized的CPU原语级别是如何实现的？ （2）一千万个数，如何高效求和。 （3）不用数学库，求2开平方的值，精确到小数点儿后10位。 （4）线程A不断打印1-10的数字，打印到第5个数字时通知线程B，请完成编码。 （5）下列三种业务，应该如何使用线程池： 高并发、任务执行时间短的业务 并发不高、任务执行时间长的业务 并发高、业务执行时间长的业务 （6）你如何来设计12306网站，能够撑住最高百万级别TPS（淘宝最高54万TPS）？ 微软 Microsoft Azure谷歌云平台 Google Cloud Platform （GCP）亚马逊Amazon Web Services (AWS)阿里云Google Kubernetes Engine（GKE） 加解密、填充对齐等，证书等，参考网上在线加解密参数算法设计模式操作系统linux、shell、go、c++、python Ruby on Rails（官方简称为 Rails，亦简称为 RoR），是一个使用 Ruby 语言写的开源 Web 应用框架，严格按照 MVC 结构开发。https://rubyonrails.org/ 狼人杀麻将、健身常识医学常识看手机上的待办事项 IPU网址http://www.aiipu.com/doc Jupyter Notebook 有个 斯蒂芬周都博客，里面全是mac主流软件都破解版京东的网关 Java面试视频链接：https://pan.baidu.com/s/1OTzaoG456DtwqB-dGPZmMg提取码：8nm1这是我们的免费直播每天晚上八点到十点都有直播课程https://ke.qq.com/course/384333?tuin=2f51f3e9点击一下即可报名，报名成功截图给我下哦 工作流https://www.flowable.org/https://github.com/flowable/flowable-engine 好文章https://github.com/doocshttps://github.com/apachecn/awesome-algorithm Spring Cloud第一代和第二代的组件组合汇总，如下表所示。Spring Cloud第一代 Spring Cloud第二代网关 Spring Cloud Zuul Spring Cloud Gateway注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper客户端软负载均衡 Ribbon spring-cloud-loadbalancer熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel 【【【每天学习的知识点】】】 Tomcat生产部署：配置详解、启动参数调优及JVM参数优化缓存热点Key、大Value数据库分页重复和分页实现数据库深度分页优化Java泛型的类型擦除和Java语法糖（12个）多线程，到底该设置多少个线程？参考Redis、Nginx；为什么他们会那么快呢jetty的使用 各种编码ASCII、GB2312、GBK、unicode、utf-8ASCII流程图 Linux命令：du、df、tar、awk等SSH、SCP、sftp等动态代理和静态代理热部署和热加载SSO实现OpenID和OAuth 1、SSO实现OPenID和OAuth2、各种编码详解-ASCII、GB2312、UTF-83、ASCII流程图四种授权类型（authorization grant），即四种颁发令牌的方式：1、授权码（authorization code）方式、2、隐藏式（implicit）、3、密码式（password）、4、客户端凭证（client credentials） G1和CMS区别对比逃逸分析与TLAB、内存泄漏AQS(AbstractQueuedSynchronizer)：一个int状态位和一个有序队列来配合完成直接内存详解：分配和回收 Linux探秘之用户态与内核态 数据库：范式、索引、优化、锁、oracle、mysql、mybatis设计模式quickstart-design-pattern数据结构和算法：树的类型、复杂度、排序算法、查找算法分布式：分布式事务与一致性算法.md、分布式锁，分布式缓存、分布式主键、分布式事务、对CAP理论、Paxos/Raft算法、高可用架构HTTP：OSI七层、TCP、http连接、Https 限流：高并发流量限制（计数器、漏桶、令牌桶）：限流（过载保护）BloomFilter布隆过滤器（是BitMap位图的变形）（变形CountingBloomFilter ）CuckooFilter布谷鸟哈希缓存算法（页面置换算法）-FIFO、LFU、LRU 3672234979杨子付 5、常用框架消息：消息：Activemq、Rocketmq、kafka、MQTT缓存：Redis、memcached、什么是缓存击穿 如何避免，注册中心的：zookeeper、consul、etcd容器相关：docker、kubernetes、istio通讯：nettyrpc微服务框架：Dubbo、SpringCloudSpring：Springframe、Springboot、SpringCloud数据库：mybatis、hibernate分布式：分布式事务与一致性算法.md、分布式锁，分布式缓存、分布式主键惊群问题：定义，解决：计算机常见专业名词.mdlinux熟悉：进程、线程和轻量级进程：计算机常见专业名词.md线程切换、内核线程和用户线程、零拷贝等解释：https://blog.csdn.net/tianyue168/article/details/7403693 6、开发项目：自己做过的项目：网关gateway、消息组件、配置中心amber、缓存aicahe，查看示例代码 7、加解密单向加密和双向加密（对称加密和非对称加密）单向加密(信息摘要)：MD5、SHA对称加密：DES、3DES、AES非对称加密：RSA、DSA、ECDSA查看项目quickstart-crypto 10、WebSocket和WebService 17、SSO实现OpenID和OAuth.md 其他框架：字节码框架asm、设计模式、disruptor、fastdfs、guava、jvm序列化框架、yaml框架、xml框架、webString字符串压缩、reflect反射、reactivex、quartz、proxy代理、logging框架、linux相关、json、jfinal、javase、uuid、文档、 消息特性jmx锁负载均衡 1.TCP/IP 三次握手 四次挥手2.Http的格式说明3.状态码说明4.进程间通讯方式（IPC）5.数据库隔离级别，索引类别，oracle的SID 实例6.启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 首先java.exe 会帮助我们找到 JRE ，接着找到位于 JRE 内部的 jvm.dll ，这才是真正的 Java 虚拟机器 , 最后加载动态库，激活 Java 虚拟机器。虚拟机器激活以后，会先做一些初始化的动作，比如说读取系统参数等。一旦初始化动作完成之后，就会产生第一个类加载器―― Bootstrap Loader 1.加载字节码（启动类加载器，扩展类，应用程序类，自定义加载器） 2.验证格式 3.准备（分配内存） 4.解析（解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程） 5.初始化整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。 7.双亲委派 8.classloader的功能和工作模式 9.synchronized和lock的用法区别 各自底层原理synchronized：对象级别的同步块，底层包含monitorenter和monitorexit指令方法级别同步，底层是 ACC_SYNCHRONIZED 标识来判断Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。lock： 10.分布式锁11.如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源12.spring中的transactional注解，requestMapping注解的实现原理13.springMvc原理 如何集成web14.什么是缓存击穿 如何避免15.自己做的项目对自己帮助很大的方面 成长的方面16.如何排查oom 问题：Redis Bitmap是什么？HikariCP连接池（号称性能最好的JDBC连接池:HikariCP）？springboot自动启动类?spring常用的接口和类，实现原理（在什么时候初始化，什么时候注入，什么时候调用）？GC，问怎么标记回收对象的，从GCROOT不可达的对象（根据四种引用关系，强软弱虚），GCROOT哪里来的(哪些可以是GCROOT)？java提供finalize()方法？GC和finalize()方法都是不可靠的 什么时候一个对象会被GC？为什么要在这个时候对象才会被GC？GC策略都有哪些分类？这些策略分别都有什么优劣势？都适用于什么场景？给你举个实际的场景，让你选择一个GC的策略？为什么要选择这个策略？什么是gc，什么是cms算法？cms算法实现原理？整个过程是怎么样的？怎么避免full gc？java g1垃圾收集器？ 类加载机制的相关问题：java的类加载器都有哪些？每个类加载器都加载哪些类？这些类加载器之间的父子关系是怎么样的？回答的时候可能会提到双亲委派模型，双亲委派模型是什么？java的类加载器为什么要使用双亲委派模型？如何自定义自己的类加载器？自己的类加载器和java自带的类加载器关系如何处理？bootstrapExtendappself defined 内存的相关问题：内存分为哪几部分？这些部分分别都存储哪些数据？一个对象从创建到销毁都是怎么在这些部分里存活和转移的？内存的哪些部分会参与GC的回收？java的内存模型是怎么设计的？为什么这么设计？ java线程、java线程池、java集合、java队列、java正则表达式、java native方法、JAVA泛型jdk和jre的区别java、Spring中的ServletContext相关Spring的DispacherServlet和ContextLoaderListener中的WebApplicationContext的关系获取spring的ApplicationContext几种方式：直接创建（2种），工具类WebApplicationContextUtils，extends或者implements（ApplicationObjectSupport就是实现ApplicationContextAware）java nio的selector 和linux的epoll select，类似与epoll或者java里面的selectorZeroCopy和mmap思想集合重写写equals，就必须重写hashCode？使用hash表的时候需要重写 Java基础：概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO与文件、多线程、反射 1.项目介绍，从业务出发，自顶向下，模块职责清晰，确保面试官能听懂，反映出对业务的抽象总结2.项目亮点，体现业务价值，解决方法包括但不限于抽象建模、方法论、工具等，如果涉及技术要展示出你对这项技术的理解，反应你的学习热情与计算机基础，如多线程、缓存、索引、事务等3.基础知识，通用的东西要掌握好，如java集合、多线程、jvm几乎是必考，如果简历重点提了某项组件最好了解下原理，比如mysql，把索引、事务、锁的原理了解好4.工程实践，缓存、可用性、微服务、高并发、扩展性、性能优化、幂等、质量保证等问题，如果没有思路可以从自己系统出发5.系统设计，让你设计一种常见的系统，其实也是反映了你在1、2的能力，leetcode上有一道系统设计题可以搜下它的结题思路，总结好思路自己尝试设计微信抢红包、电商秒杀、餐厅点餐、直播等系统，这种问题大概率会问道6.算法，刷题练手，注意代码风格、边界条件的判断7.二三面大概率会问到，你对什么感兴趣、最近在学习什么，然后让你介绍 面试题：1、nio、Bio，aio的区别，大概机制，接口2、数据库，innobd，隔离级别，行级锁3、分布式4、类加载器和双亲委派机制，何时破坏双亲委派机制5、几种垃圾回收器6、java8新特性，lamda，函数接口7、多线程：创建线程池，两个线程一个初始化，一个循环，改变一个值，并发包下接口类8、java虚拟机的内存模型，内存工作方式9、spring 、aop、ioc10、二叉树算法11、MySQL的事务级别，mybatis一个mapper实现两个sql12、多线程，100个子线程，执行完成，将结果返回主线程13、如何在大量数据中查找某一段的数据，不用limit14、dubbo的原理，结构15、整体介绍负载均衡架构16、多线程的好处？一定能加快运行速度么？因为线程切换也是需要时间的，就跟自旋锁和互斥锁的效率一样，线程睡眠和唤醒也是需要时间和消耗资源的。17、Integer和int类型，哪个放在堆内存？哪个在栈内存？18、堆里面和栈内存，分别是什么时候回收？19、outofmemory的问题，怎么定位？20、常用有哪些设计模式？21、一致性hash的实现原理22、数据库索引和主键的区别： 对MySQL的了解，和oracle的区别对设计模式的看法和认知有哪些设计模式如何实现分布式缓存多线程如何避免死锁关于树的算法题-二叉树的锯齿形层次遍历：二叉树的锯齿形层次遍历http://www.lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/Java的垃圾回收机制对Runtime的了解 如何进行自学阅读过那些书籍 第一个项目：项目最终实现效果项目具体部分使用的设计模式并简述选择理由项目有何需改进之处并初拟改进方案第二个项目：项目运行过程中成员是否曾就某一点发生争执？作为Leader你是如何解决的？具体事例？ 数据库的范式JVM内存模型及调优浏览器的缓存机制如何解决高并发问题？是否进行过相应程序的编写？LintCode 算法题 - 最小子串覆盖。原题链接：最小子串覆盖http://www.lintcode.com/zh-cn/problem/minimum-window-substring/想问的问题 应用容器：Spring-Boot、Docker方向，自诊断、开发效率、模块化· RPC链路：链路跟踪、服务治理、动态流量管理、分布式调度 · 高可用方向：异地容灾、环境隔离/切换 hql学习Zuul代码netty使用：常用的编解码RXjava学习，RxJava是基于响应式编程思想，实现并扩展了观察者模式，可以进行异步操作的库completablefuture原理解析，异步编程类Lambda表达式和函数式接口，Lambda表达式3种，函数式接口JDK8内置4类StreamsAPI，创建、转换、聚合ReduceRP、FP、FRP区别，反应式编程、函数式编程、函数反应式编程Fork/Join框架restful接口是什么边缘计算guice，DI注入管理lettuce，Redis客户端异步反应式编程caffeine，本地JVM缓存guava，本地JVM缓存android的webview 免费的程序书籍https://github.com/EbookFoundation/free-programming-books Head First」编程系列丛书 有赞 https://tech.youzan.com/youzan-service-regression-test-platform/ https://www.guru99.com/java-tutorial.html https://howtodoinjava.com/security/aes-256-encryption-decryption/ Github装逼指南——Travis CI 和 Codecov https://segmentfault.com/a/1190000004415437 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/English/英语学习.html":{"url":"Books/English/英语学习.html","title":"英语学习","keywords":"","body":"1、i.e. vs e.g. 2、 3、 4、 5、 6、 7、 8、 9、 10、 i.e. vs e.g. i.e.是拉丁文id est的缩写，它的意思就是that is.被用来近一步描述一个已经被提及过的东西。 而e.g.是拉丁文 exempli gratia的缩写, 意思是“for the sake of example”，更通俗的说就是 “for example.” 它被用来引出之前陈述过的内容的例子。 我们可以把 i.e. 当中的 i 记成是“in other words.”这就意味着接下来我们要准备补充说明或者重新解释我们刚刚提到的部分。 e.g. 就把它当作是“example”的简单形式。 两倍：Double 三倍：Triple VS Treble 四倍：Quadruple 四分之一：Quarter Triple VS Treble triple是多个不同的东西形成的三倍、三个部分的：比如triple-sized； treble是多个同样的东西形成的三倍、乘以三的：比如treble nine（999）； Triple means in threesTriple chocolate cookies have three types of chocolateTreble means it has three parts, or happens three times, like 000 would be treble zero Some people use them in place of each other, which is non-standard, but still understandable. Quarter vs Quadruple The quarter, short for quarter dollar, is a United States coin worth 25 cents, one-quarter of a dollar. quarter：25美分，1美元的四分之一，相等的四个部分之一*一季度“””小时; 一个“四分之一”世纪；“四分之一”注；四分之一磅。 quadruple 长度是东西的四倍，大或多。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/English/英语单词.html":{"url":"Books/English/英语单词.html","title":"英语单词","keywords":"","body":" motto 座右铭 maxim 格言 model 模型，偶像 example 例子 motto(maxim) Dream as if you would live forever, live as if you would die today! model(example) Albert Einstein The time is passing! rat n. 老鼠，耗子；公贼、叛徒、告密者、讨厌鬼、可耻的人 the Year of the OX principal n.校长 fragile adj.易碎的；脆弱的 affection n.恋爱，喜爱 affectionate adj. 充满深情的，有爱心的 precede vt.vi 在...之前，先于 patent 专利证书，专利发明 abrupt adj.突然的，意外的 valid adj.有效的，确凿的 accumulate vt.积累，累积，聚积 procedure n.程序，步骤，手续 abundant adj.丰富的，充裕的 tutor n.家庭教师，导师，助教 acknowledge vt.承认，确认，答谢 loan n.贷款，借出物 catalogue n.目录 absurb adj.荒谬的，可笑的 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/English/计算机专业英语.html":{"url":"Books/English/计算机专业英语.html","title":"计算机专业英语","keywords":"","body":" https://github.com/guanpengchn/awesome-pronunciation http://www.heycode.com/book/art/13642.html https://www.shanbay.com/wordlist/3004/28126/ https://github.com/HurleyJames/Computer-English-Words https://github.com/qomumu/JEnglish/blob/master/unit-1/1.md https://github.com/EarsEyesMouth/computerese-cross-referencesgi Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/medicine/医学常识.html":{"url":"Books/medicine/医学常识.html","title":"医学常识","keywords":"","body":"头孢类药物 发烧和感冒区别 消炎药和抗生素 常用药物功效 自己的病： 2020年2月1号开始胸口疼，血压高 2019年12月份耳鸣 2019年2月份肛周脓肿 医学书籍 通风是很么？吃海鲜排不出来就通风？ 消炎药和抗生素 消炎药包括抗生素，抗生素更霸道 消炎药： 左氧氟沙星片.可乐必妥：用于治疗成年人大于18岁，由下列细菌的敏感菌株所引起的下列轻、中、重度感染（详见说明书） 阿莫西林胶囊和阿奇霉素分散片都是抗生素的，都是可以起到消炎效果的 消炎药:青霉素类，阿莫西林（西林），头孢（四代），（罗等*）红霉素，（）沙星， 可以吃头孢类药物，参考【头孢类药物】 发烧和感冒区别： 发烧（一般感冒），细菌，容易治疗 感冒（病毒感冒），病毒，不容易杀死，比如SARS，2019冠状病毒 病毒感染，细菌感染以及支原体感染。生病一定要抽血化验查找原因，只有找到反复感染的原因，才能对症治疗，从根本上解决问题。 没有细菌感染就不要用抗生素。 病毒感冒药，快克， 发烧感冒药：扑热息疼 感冒:连花清瘟教堂，快克，阿莫西林， 头孢类药物 头孢：各种球菌，杆菌引起的炎症，好多部位的各种炎症，扁桃体，咽炎，肺炎，中耳炎，脓疱病，创伤感染等，属于烈性消炎药，要注意是不是过敏才能吃，不能跟其他消炎药一起吃，更不能喝酒吸烟， 头孢类药物有好几代 头孢类抗生素。头孢目前主要有四代： 头孢氨苄是第一代， 第二代主要是头孢克洛，头孢呋辛，头孢孟多等。 第三代是目前最常用的，有头孢噻肟钠，头孢哌酮，头孢他啶，头孢曲松，头孢匹胺，头孢泊肟酯，头孢地嗪等。 第四代为最新，有头孢吡肟，头孢匹罗，头孢唑南等，应用不是太多。 头孢类药物有很多，通常按照产出的先后顺序分为：一代、二代、三代、四代、五代。 那么一代头孢，对革兰氏阳性菌效果比较好，代表药物有头孢氨苄，头孢唑啉。 第二代头孢，代表的药物有头孢克洛，头孢丙烯。 第三代头孢，代表的药物有头孢哌酮，头孢他啶。 第四代，代表药物有头孢吡肟。 不同的类型的头孢类的药物，那么其针对的一些细菌谱是不一样的。再比如，第四代第五代的头孢，对革兰氏阴性菌的效果很好，第五代的头孢，对革兰氏阳性菌阴性菌的效果都是很好的。 申洛.头孢克洛缓释胶囊：消炎药 天立威.头孢克肟片（肟[wò]） 常用药物功效： 小伤口：碘伏处理，纱布， 大伤口：双氧水， 医用酒精（75%酒精），主要是打针消毒 神经痛药物： 甲钴胺片，适用神经病变， 怡神保.甲钴胺片：肌肉痛 麦拓.甲钴胺片 高血压药： 硝苯地平控释片，适用高血压，冠心病，慢性稳定型心绞痛， 年轻人高血压：吃沙坦类降压药，比如安内喜.氯沙坦钾氢氯噻嗪片 欣然.硝苯地平缓释片：高血压药 止痛药： 布洛芬 及通安.氨酚曲马多片：本品用于中度至重度急性疼痛的治疗 可普芬.洛芬待因片：中等强度疼痛止痛，适用于术后痛和中度癌痛止痛 止疼药:阿司匹林，布洛芬，扑热息痛，罗非昔布， 耳鸣药： 金纳多.银杏叶提取物滴剂：耳鸣眩晕， 左拂.盐酸左氧氟沙星滴耳液：治疗敏感菌引起的外耳道炎、中耳炎 2020年2月1号开始胸口疼，血压高： 肩下面，乳房下侧，乳房周围，还有十字中心疼，喝热水也微痛，坐着有轻微呼吸困难， 从2月1号开始，吃了八天药了， 趴下床上，甚至侧着身子，有挤压就疼， 1月29或者30号开始的。 2月2号中午吃药 在诊所买了药，包括复方三七胶囊，阿莫西林胶囊，扑热息疼等 敏使朗.甲磺酸倍他司汀片 久联.萘普生胶囊 吃了没有什么效果 2月10号左右去宋集镇医院： 拍了CT和心电图，都没有什么异常，就让买活血止痛胶囊吃 没有什么作用 2月14号去县医院看病： 本来挂了心血管科，到了又直接去看的急诊科，结果是高中同班同学帮我看的 血压150多，心电图无异常，拍了胸部CT无异常，血检结果显示细菌感染，类似感冒 申洛.头孢克洛缓释胶囊：消炎药 怡神保.甲钴胺片：肌肉痛 欣然.硝苯地平缓释片：高血压药 吃了有点效果，后来就自己买药，没买到同牌子的，就买了下面两种替代 天立威.头孢克肟片 麦拓.甲钴胺片 康恩贝.甲钴胺片 3月5号到江苏省人民医院： 看了胸心外科（王伟专家号）：说是正常的，问有没有什么肌肉痛的检查，说没有，就拍了胸部CT，后来说出没有问题 看了心血管内科（钱卫冲专家号）：测量了两次血压，一次151-80多，一次148-88，医生让先暂停吃降压药，让回家早上测量一次，晚上睡觉前测量一次，每次测量三次，每次间隔一分钟，连续测试一周，然后再决定做什么检查或者使用什么药，说年轻人应该使用吃沙坦类降压药，不应该使用硝苯地平这类的降压药 复方三七胶囊，阿莫西林胶囊，扑热息疼，活血止痛胶囊， 阿莫西林胶囊和阿奇霉素分散片都是抗生素的，都是可以起到消炎效果的，所以这两个药物是可以使用的 消炎药包括抗生素，抗生素更霸道 2019年12月份耳鸣： 做了耳朵听力测试，没有问题，就给开了下面这两个药 金纳多.银杏叶提取物滴剂：耳鸣眩晕， 左拂.盐酸左氧氟沙星滴耳液：治疗敏感菌引起的外耳道炎、中耳炎 2019年2月份肛周脓肿： Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Stock/股票Stock和基金学习.html":{"url":"Books/Stock/股票Stock和基金学习.html","title":"股票","keywords":"","body":" 躺赢计划 场内与场外的区别 场内基金与场外基金的区别 基金的开放封闭 ETF基金 联接基金 LOF基金 套利 股票、基金、证券、债券、信托、期货、国债、外汇 股票 基金 证券 债券 信托 期货 外汇 市盈率（静态市盈率，动态市盈率，TTM市盈率） 躺赢计划 【躺赢计划】是一个以指数基金为主要投资对象，以定投为投资方式，以低估买入、中估持有、高估卖出为投资策略，长期投资收益目标为年化15%的财富计划。 计划具体细节如下： 1.每周二午间进行定投，若遇节假日，顺延到下一个周二。 2.定投金额以300元一周为基准，市场越低估定投金额越大，越高估则金额越小。基准根据普通上班族一月工资6000的20%即1200设定，这是一个基本不影响生活的比例。 3.买入对象主要是场外的指数基金，若无低估品种可买则会买入货币基金，等有低估品种出现，再卖出货币基金买入。 4.股市有波动，短期买入有下跌风险，若无长期持有打算，或者3年~5年内需要用到的钱，请不要投入股市。 作者：躺赢君 链接：https://xueqiu.com/6943090400/127326199 来源：雪球 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。 市值=股价×总股本 在不同的地方上市，根据不同的地方股价计算，市值不同 总市值=A股市值+H股市值 总股本:225.78亿 港股本:158.82亿 股价13.260 总市值:2993.79亿 港市值:2106.01亿 一手：一手是证券市场的一个交易的最低限额，每个市场的规定不一样。 A股买卖交易规则以100股的整数倍为单位，也说以手为单位，即一手是100股。每次买进都只能是100股的整数，或是说一手的整数倍。 集合竞价、连续竞价、交易时间 股票振幅：股票振幅就是股票开盘后的当日最高价和最低价之间的差的绝对值与前日收盘价的百分比，它在一定程度上表现股票的活跃程度。 市盈率＝每股市价／每股盈利，反映市盈率偏低，股票价值被低估，一般来说，市盈率极高（如大于100倍）的股票，其股息收益率为零。因为当市盈率大于100倍，表示投资者要超过100年的时间才能回本，股票价值被高估，没有股息派发。 股票的市净率＝每股市价／每股净资产，市净率指的是每股股价与每股净资产的比率。 市净率可用于股票投资分析，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低 周转率(换手率)＝(某一段时期内的成交量)/(发行总股数)x100%，“换手率”也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。 量比=（现成交总手数 / 现累计开市时间(分) ）/ 过去5日平均每分钟成交量，量比的数值越大，表明了该股当日流入的资金越多，市场活跃度越高；反之，量比值越小，说明了资金的流入越少，市场活跃度越低。我们可以从量比曲线与数值与曲线上，可以看出主流资金的市场行为，如主力的突发性建仓，建完仓后的洗盘，洗盘结束后的拉升，这些行为可以让我们一目了然！ 内盘（空方急于卖出的能量大小）、外盘（主动性买盘）这两个数据大体可以用来判断买卖力量的强弱。 若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。 10. 各种指数 各种交易所 各种板块、行业 新经济公司将“回A股” 发行的CDR到底是什么？ 场外暗盘交易：暗盘交易只局限于有限的范围。交易时间，比较短暂，一般为新股正式上市日前一个营业日下午4时15分至6时30分的两个多小时的时间。 新股破发：最新的股票跌破发行价，新股破发中的发，是指股票的发行价格。新股破发是指股票发行上市当日就跌破发行价，在一级市场申购中签的股民也是要赔钱的。在股市中，当股价跌破发行价时即为破发。而普遍情况，特别在牛市行情中比较少见，在市场徘徊期常见到。 交易时间 周一至周五 (法定休假日除外) 上午9：30 --11：30 下午13：00 -- 15：00 竞价成交 (1) 竞价原则：价格优先、时间优先。价格较高的买进委托优先于价格较低买进委托，价格较低卖出委托优先于较高的卖出委托；同价位委托，则按时间顺序优先。 (2) 竞价方式：上午9：15--9：25进行集合竞价；上午9：30--11：30、下午13：00--15：00进行连续竞价 (对有效委托逐笔处理)。 什么是市值？ 一般来说，市值是指一家上市公司的发行股份按市场价格计算出来的股票总价值，公式表达就是“市值=股价×总股本”，这个概念几乎没有分歧。 1、站在上市公司的角度：市值=股价×总股本=净利润×市盈率 2、站在财务（外部）投资人的角度：市值=未来合宜的净利润水平÷预期回报率 严格的说，一家公司的股票其实不是“同时”在内地和香港上市，而是“一部分在香港一部分在内地”上市。比方说一亿股股票，不是在内地上市一亿、在香港也上市一亿。而是内地上市8000万，香港上市2000万。在内地上市的部分不可以在香港市场交易，在香港上市的部分也不可以在内地股市交易（除非经过复杂手续退出香港市场重新在内地股市上市）。所以两地上市也没什么冲突的，一边一部分而已。【引自《A＋H股公司总市值怎么算》】 中国上海证券交易所和深圳证券交易所的规定中，一手等于100股；香港一手可能是100股、200股、400股或20000股，每家公司都不一样。一手是证券市场的一个交易的最低限额，每个市场的规定不一样。 分为以下两种情况： 1、A股一手是100股。A股主要指的沪A（上海交易所上市的股票）与深A（深圳交易所上市的股票）。A股买卖交易规则以100股的整数倍为单位，也说以手为单位，即一手是100股。每次买进都只能是100股的整数，或是说一手的整数倍。 2、港股交易跟国内的股票交易不一样，它交易的每手股数是不固定的，不同的股票规定数是不同的，具体在股票的详情页能看到。有400股为一手、1000股为一手、2000股为一手、4000股为一手等。 股票振幅： （当日最高点的价格－当日最低点的价格）/昨天收盘价×100%=振幅 或者：最高点的幅度 - 最低点的幅度 = 振幅 数据分析编辑 股票振幅的数据分析，对考察股票有较大的帮助，一般可以预示几种可能： 1、可能是庄家高度控盘，散户手中流动的筹码很少，数量不多的成交量就会对股价形成很大波动。 2、可能是庄家通过大幅拉高或杀跌进行吸筹或出货的操作。 3、处于多空明显分歧的阶段，如某股票在连续上涨或者涨停后，打开涨停或跌停时，就会出现较大的价格波动。 股票的市盈率（Price-to-Earning Ratio，P/E或PER），又称为市盈率，指每股市价除以每股盈利（Earnings Per Share，EPS），通常作为股票是便宜抑或昂贵的指标（通货膨胀会使每股收益虚增，从而扭曲市盈率的比较价值）。市盈率把企业的股价与其制造财富的能力联系起来。 每股盈利的计算方法，一般是以该企业在过去一年的净利润除以总发行已售出股数。市盈率越低，代表投资者能够以相对较低价格购入股票。假设某股票的市价为24元，而过去一年的每股盈利为3元，则市盈率为24/3=8。该股票被视为有8倍的市盈率，即在假设该企业以后每年净利润和去年相同的基础上，如果不考虑通货膨胀因素，回本期为8年，折合平均年回报率为12.5%，投资者每付出8元可分享1元的企业盈利。但上市公司通常只会把部分盈利用来派发股息，其余用来作进一步发展，所以市盈率的倒数不等于股息率。 股息收益率 上市公司通常会把部分盈利派发给股东作为股息。上一年度的每股股息除以股票现价，是为现行股息收益率。如果股价为50元，去年股息为每股5元，则股息收益率为10%，此数字一般来说属于偏高，反映市盈率偏低，股票价值被低估。 一般来说，市盈率极高（如大于100倍）的股票，其股息收益率为零。因为当市盈率大于100倍，表示投资者要超过100年的时间才能回本，股票价值被高估，没有股息派发。 市盈率所代表的意义： 如果某股票有较高市盈率，则有可能因以下原因： 市场预测未来的盈利增长速度快。 该企业一向录得可观盈利，但在前一个年度出现一次过的特殊支出，降低了盈利。 出现泡沫，该股被以超过其内在价值的价格在交易。 该企业有特殊的优势，保证能在低风险情况下持久录得盈利。 市场上可选择的股票有限，在供求定律下，股价将上升。这令跨时间的市盈率比较变得意义不大。 如果某股票有较低市盈率，则有可能因以下原因： 市场预测该企业和去年相比较，盈利将减少，企业价值将下降。 该企业在去年出现过一次性的特殊收入，暂时提高了去年的盈利。 该股的价格被市场低估。 股票的供给超过了市场上资金的投资需求。 ※值得一提，如果某股票的市盈率为零，即代表股票去年是在于亏损状态。 股票的市净率（Price-to-Book Ratio, PBR, P/B），又名市账率、股價淨值比，指每股市价除以每股净资产，通常作为股票孰贱孰贵的指标之一。 市净率指的是每股股价与每股净资产的比率。 市净率可用于股票投资分析，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低；但在判断投资价值时还要考虑当时的市场环境以及公司经营情况、盈利能力等因素。 每股净资产 每股净资产是指股东权益与总股数的比率。其计算公式为：每股净资产= 股东权益 / 总股数。这一指标反映每股股票所拥有的资产现值。每股净资产越高，股东拥有的每股资产价值越多；每股净资产越少，股东拥有的每股资产价值越少。通常每股净资产越高越好。 在基本分析（Fundamental Analysis ）的各种指标中，每股净资产是判断企业内在价值最重要的参考指标之一。 什么是换手率 “换手率”也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。 换手率(Turnover Rate) 是以百分比衡量的一年内股票的成交量占股票总数的比例。以样本总体的性质不同有不同的指标类型，如交易所所有上市股票的总换手率、基于某单个股票发行数量的换手率、基于某机构持有组合的换手率。 换手率的计算公式 换手率的计算公式为： 周转率(换手率)＝(某一段时期内的成交量)/(发行总股数)x100% 换手率的实质意义 换手率的高低往往意味着这样几种情况： (l)股票的换手率越高，意味着该只股票的交投越活跃，人们购买该只股票的意愿越高，属于热门股；反之，股票的换手率越低，则表明该只股票少人关注，属于冷门股。 (2)换手率高一般意味着股票流通性好，进出市场比较容易，不会出现想买买不到、想卖卖不出的现象，具有较强的变现能力。然而值得注意的是，换手率较高的股票，往往也是短线资金追逐的对象，投机性较强，股价起伏较大，风险也相对较大。 (3) 将换手率与股价走势相结合，可以对未来的股价做出一定的预测和判断。某只股票的换手率突然上升，成交量放大，可能意味着有投资者在大量买进，股价可能会随之上扬。如果某只股票持续上涨了一个时期后，换手率又迅速上升，则可能意昧着一些获利者要套现，股价可能会下跌。 量比是衡量相对成交量的指标。它是指股市开市后平均每分钟的成交量与过去5个交易日平均每分钟成交量之比。其计算公式为：量比=（现成交总手数 / 现累计开市时间(分) ）/ 过去5日平均每分钟成交量 [1] 。 量比这个指标所反映出来的是当前盘口的成交力度与最近五天的成交力度的差别，这个差别的值越大表明盘口成交越趋活跃，从某种意义上讲，越能体现主力即时做盘，准备随时展开攻击前蠢蠢欲动的盘口特征。因此量比资料可以说是盘口语言的翻译器，它是超级短线临盘实战洞察主力短时间动向的秘密武器之一。它更适用于短线操作。 量比反映出的主力行为从计算公式中可以看出，量比的数值越大，表明了该股当日流入的资金越多，市场活跃度越高；反之，量比值越小，说明了资金的流入越少，市场活跃度越低。我们可以从量比曲线与数值与曲线上，可以看出主流资金的市场行为，如主力的突发性建仓，建完仓后的洗盘，洗盘结束后的拉升，这些行为可以让我们一目了然！ 内盘外盘，股市术语。内盘常用S（取英文 sell [sel] 卖出 的首字母S）表示，外盘用B（取英文buy [baɪ] 买入 的首字母B）表示。 内盘：以买入价格成交的数量，即卖方主动以低于或等于当前买一、买二、买三等价格下单卖出股票时成交的数量，用绿色显示。内盘的多少显示了空方急于卖出的能量大小。 外盘：以卖出价格成交的数量，即买方主动以高于或等于当前卖一、卖二、卖三等价格下单买入股票时成交的数量，用红色显示。外盘的多少显示了多方急于买入的能量大小。 内盘：以买一、买二、买三等价格成交的交易，买入成交数量统计加入内盘。 外盘：以卖一、卖二、卖三等价格成交的交易。卖出成交数量统计加入外盘。 内盘、外盘这两个数据大体可以用来判断买卖力量的强弱。若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。 参考 https://www.jianshu.com/p/d333c2873153 https://baike.baidu.com/item/%E8%82%A1%E7%A5%A8/22647 场内与场外的区别 场内场外的“场”指的是证券交易所。 通常在股票账户内买卖就是场内交易，在支付宝天天基金等平台申购赎回就是场外。 场内买卖交易，就可以看成是像咸鱼这样的二手市场，和其他投资人进行二手买卖。 场外申购赎回，就是我们直接向厂家（基金公司）进货或退货 我们把基金份额看做是一种商品，基金公司就是生产这种商品的厂家。 场内的价格实时变动，交易相对灵活，但是场内交易需要花更多的时间精力去操作。 场外3点前按当天的净值，3点后按下一个交易日的净值，比较省心省事。 场内基金与场外基金的区别 场内交易是指通过证券交易所进行的买卖活动。 用场内交易方式进行买卖的基金，就是场内基金，最典型的场内基金就是ETF。 只要不是场内交易的基金，全都是场外基金。比如我们用支付宝，蛋卷申购赎回的就是场外基金。 场内与场外基金的区别有几点： 交易价格不一样。场外基金所有的申购赎回都是按照当天统一的净值进行确认，一天只有一个价格。 而场内基金价格收市场涨跌影响，买卖价格是随时变化的。 场外基金未知价原则。 场外基金申购赎回是未知价原则，申购赎回时不知道净值多少，收盘后按照当天最终净值来确认。 场内交易，买卖时价格多少，就按什么价格清算。 交易时间不同 场内基金只有交易时间才能买卖，早上9点15到11点半，下午1点到3点。 场外基金随时可以委托，但是3点前委托按照当天的净值确认，3点后委托按照第二天的净值确认。 买卖的确认时间不同。 场内基金今天买入，明天就可以卖出。今天卖出的钱，当天就可以继续买入。 场外基金，一般周一买入，周三才能赎回。赎回的到账时间也比较长，一般都要几天时间才到账。 参考：场内基金与场外基金的区别 场内场外，傻傻分不清楚 基金的开放封闭 开放基金就是开放给投资者，可以在场外申购赎回的基金，故而基金的规模也是随时在变化的； 封闭基金就是发行完毕后，就不能申购赎回的基金。申购赎回期过后，投资者只能通过场内买卖，故而基金的规模是固定的。 ETF基金 ETF的全称为Exchange Traded Funds，是一种在交易所上市交易的、基金份额可变的一种指数基金。中文名叫“交易型开放基金”。是一种场内场外都可以交易的基金。 而且场内场外的份额可以互通。场外申购的可以在场内卖出；场内购买的，也可以在场外赎回。 不过ETF的申购门槛比较高，一般100万起步。所以我们普通投资者想买ETF，就只能到场内进行买卖，操作和买卖股票一样 联接基金 因为ETF的申购门槛较高，而场内买卖需要股票账户，而且需要手动操作，不能设置自动扣款定投等原因，于是有基金公司成立了联接基金。 联接基金就是买ETF的基金。买了联接基金，就等于买了对应的ETF。只不过联接基金是场外交易，方便没有股票账户的投资者和想要设置自动定投的投资者。 它的管理费和托管费一般和对应的ETF一致，不再额外多收费。只不过申购赎回费会比场内买卖的买卖佣金贵。 LOF基金 LOF基金是Listed Open-Ended Fund的缩写，称为上市开放式基金。 LOF和ETF类似，也是场内场外均可交易、场内场外份额互通的基金。 和ETF不同的是它的申购门槛较低，一般1000元起申购。所以我们普通投资者也可以在场外申购 ETF：场内买卖的指数基金 ETF链接：主要投资于ETF的开放式指数基金。 LOF：同时可以场内买卖和场外申购赎回的基金，可以是指数基金，也可以是普通的开放式基金。 套利 由于ETF和LOF都是场内场外均可交易，且份额互通，所以就会存在套利。 套利是什么呢？简单来说就是倒买倒卖。 比如香港的苹果手机比内地便宜，就会有很多代购从香港买了拿到内地卖，赚差价，这就叫套利。 基金也是一样。当同一只基金场内场外的价格出现价差，比如场内价格比场外便宜，就会有投资者买入场内的基金份额，拿去场外卖。 而一般ETF的交易量较大，报价比较实时，几分钟一次，所以场内外价差都比较小；而LOF的交易量较小，几小时甚至一天才报一次价，场内外价差一般较大。 买卖ETF和LOF时，一定要注意场内外的价差，在价格便宜的地方买，价格贵的地方卖。 参考：小白指数基金课：三分钟搞懂场内场外、开放封闭、ETF、联接、LOF什么是ETF，ETF链接，LOF？ 股票、基金、证券、债券、信托、期货、国债、外汇 股票 股票（stock）或是资本存货（capital stock）是一种有价证券，股份公司将其所有权借由这种有价证卷进行分配。因为股份公司需要筹集资金，因此将股票发给投资者作为公司资本部分所有权的凭证，成为股东以此获得股息（股利），并分享公司成长或交易市场波动带来的利润；但也要共同承担公司运作错误所带来的风险。 基金 通过发行基金份额，将众多资金集合成独立资产，由基金托管人（例如银行）托管，由专业的基金管理公司管理和运作，以投资组合的方式进行证券投资的一种利益共享、风险共担的投资方式。间接参与投资。 证券 证券（Securities）是有价证券的简称，是一种表示财产权的有价凭证，持有者可以依据此凭证，证明其所有权或债权等私权的证明文件。例如：股票、债券、权证和股票价款缴纳凭证等。 债券 债券，是发行者为筹集资金发行的、在约定时间支付一定比例的利息，并在到期时偿还本金的一种有价证券。 信托 信托是委托人基于对受托人的信任，将其财产权委托给受托人，由受托人按委托人的意愿以自己的名义，为受益人的利益或特定目的，进行管理和处分的行为。 期货 期货合约（Futures contract），简称期货（Futures），是一种跨越时间的交易方式。买卖双方透过签订合约，同意按指定的时间、价格与其他交易条件，交收指定数量的现货。通常期货集中在期货交易所，以标准化合约进行买卖，但亦有部分期货合约可透过柜台交易进行买卖，称为场外交易合约。交易的资产通常是商品或金融工具。双方同意购买和出售资产的预定价格被称为远期价格。未来的指定时间 - 即交付和付款发生时 - 称为交货日期。因为它是标的资产的函数，期货合约是衍生产品。 外汇 外汇是货币行政当局（中央银行、货币机构、外汇平准基金组织及财政部）以银行存款、财政部库券、长短期政府证券等形式所保有的在国际收支逆差时可以使用的债权。 股票，股票就是作为公司股东的一个凭证，证明股东的身份。需要关注的点是股东可以定期享受公司的盈利分红，可以去参与公司的一些管理。如果公司效益不好，也有可能会负担公司的亏损，你相当于是公司的所有者，公司的盈亏都和你有关。（市面小散户一般不参与公司管理） 债券，债券相当于是一个借款证明，公司为了筹集资金向社会公众发行债券，会写明到期日以及利息的支付，将来到期不管公司财务状况如何，都要支付本金和利息，所以如果你买债券，相当于是把自己的钱借给公司用，你到时候收固定的本金和利息，在这期间不会参与公司的管理、享受分红。公司的亏损也不需要你负责 基金，基金就是大家买了基金的钱会统一由基金公司来运作，由他们的基金经理去投资买股票、债券等，然后根据这些股票的收益来计算基金的收益 参考：【通俗理解】股票、基金、证券、债券、信托、期货、国债、外汇 股票分类 按票面形式，可分为记名股票、无记名股票和有面额股票。 按股东权利，分为优先股和普通股。 按流通状况，分为流通股和非流通股。 按上市交易所和买卖主体，可分为 A股：人民币普通股票。境内、港、澳、台居民均可开立A股账户。 B股：人民币特种股票。以人民币标明面值，以外币认购和买卖，在境内（上海及深圳）证券交易所上市交易的股票。准许持有合法外汇的境内居民自由开户买卖B股。 H股：境外上市外资股，是境内上市公司在境外发行上市的股份。 N股 S股 L股 我国上市公司的股票有A股、B股、H股、N股和S股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。 1、A股的正式名称是人民币普通股票。它是由我国境内的公司发行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票。 2、B股的正式名称是人民币特种股票，它是以人民币标明面值，以外币认购和买卖，在境内（上海、深圳）证券交易所上市交易的。 它的投资人限于：外国的自然人、法人和其他组织，香港、澳门、台湾地区的自然人、法人和其他组织，定居在国外的中国公民。中国证监会规定的其他投资人。现阶段B股的投资人，主要是上述几类中的机构投资者。B股公司的注册地和上市地都在境内。只不过投资者在境外或在中国香港，澳门及台湾。 3、H股，即注册地在内地、上 市地在香港的外资股。香港的英文是HOngKOng，取其字首，在港上市外资股就叫做H股。依此类推，纽约的第一个英文字母是N，新加坡的第一个英文字母 是S纽约和新加坡上市的股票就分别叫做N股和S股。 4、N股，是指那些在中国大陆注册、在纽约（New York）上市的外资股。在我国股市中，当股票名称前出现了N字，表示这只股是当日新上市的股票，字母N是英语New(新)的缩写。看到带有N字头的股票 时，投资者除了知道它是新股，还应认识到这只股票的股价当日在市场上是不受涨跌幅限制的，涨幅可以高于10％，跌幅也可深于10％。这样就较容易控制风险和把握投资机会。 如N北化、N建行、N石油等。 A股的正式名称是人民币普通股票。它是由我国境内的公司发行,供境内机构、组织或个人(不含台、港、澳投资者)以人民币认购和交易的普通股股票。 B股的正式名称是人民币特种股票。它是以人民币标明面值,以外币认购和买卖,在境内(上海、深圳) 证券交易所上市交易的股票。在2001年2月前,B股的投资人仅限于: 外国的自然人、法人和其他组织,香港、澳门、台湾地区的自然人、法人和其他组织,定居在国外的中国公民,以及中国证监会规定的其他投资人。2001年2月19日之后,中国证监会宣布对内开放B股市场,准许持有合法外汇的境内居民自由开户买卖B股。 H股又称境外上市外资股,是境内上市公司在境外发行上市的股份。 红筹股： 红筹股：在中华人民共和国境外注册，在香港上市的股票称为红筹股。红筹股已经成为除B股及H股外，内地企业进入国际资本市场筹资的一条重要渠道。 按公司业绩，可分为绩优股和垃圾股。 红筹股是指在中国境外注册、在香港上市的带有中国大陆概念的股票。“带有中国大陆概念”主要指中资控股和主要业务在中国大陆。 早期的红筹股，主要是一些中资公司收购香港中小型上市公司后改造而形成的，如“中信泰富”等。近年来出现的红筹股，主要是内地一些省市将其在香港的窗口公司改组并在香港上市后形成，如“上海实业”、“北京控股”等。 蓝筹股： 蓝筹股是指稳定的现金股利政策对公司现金流管理有较高的要求，通常将那些经营业绩较好，具有稳定且较高的现金股利支付的公司股票称为“蓝筹股”。蓝筹股多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱。 “蓝筹”一词源于西方赌场。在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱，红色筹码次之，白色筹码最差，投资者把这些行话套用到股票。 龙头股： 指的是某一时期在股票市场的炒作中对同行业板块的其他股票具有影响和号召力的股票，它的涨跌往往对其他同行业板块股票的涨跌起引导和示范作用。 黑马股： 黑马原本指在赛马场上本来不被看好的马匹，却能在比赛中成为出乎意料的获胜者。反映到股市上，黑马股是指投资者本来不看好，却能够异军突起，价格可能脱离过去的价位而在短期内大幅上涨的个股。 白马股： 是指长期绩优、回报率高并具有较高投资价值的股票，具有成长性，但是还没成为蓝筹权重的股票称为白马股。 白菜股： 指股票单价偏低的个股，没有确切的衡量标准的股票。白菜股不代表是烂股，有一部分银行股、钢铁股也是白菜股。 妖股： 股市上通常把那些股价走势奇特、怪异的股票称为“妖股”。 什么是ST股和PT股 ST股 根据证监会规定:当一个公司连续两年亏损或者净资产低于股票面值的时候，在股票名称前就会加上“ST”，表示“特殊处理”的意思。 沪深证券交易所在1998年4月22日宣布,根据1998年实施的股票上市规则,将对财务状况或其它状况出现异常的上市公司的股票交易进行特别处理,由于“特别处理”的英文是Special treatment（缩写是“ST”）,因此这些股票就简称为ST股。 ST股票每天的涨跌都不得超过5%。用于警示投资者注意投资风险和防止庄家恶意炒作。 如果在第三年，公司的经营未有改善，依旧处于亏损状态，股票名称前除“ST”外还会加上“”，即“ST”，意为有退市风险。 上述财务状况或其它状况出现异常主要是指两种情况, 一是上市公司经审计连续两个会计年度的净利润均为负值, 二是上市公司最近一个会计年度经审计的每股净资产低于股票面值。 在上市公司的股票交易被实行特别处理期间,其股票交易应遵循下列规则： （1）股票报价日涨跌幅限制为5％； （2）股票名称改为原股票名前加“ST”,例如“ST辽物资”； （3）上市公司的中期报告必须审计。 PT股 “PT”的英语 Particular Transfer（意为特别转让）的缩写。这是旨在为暂停上市股票提供流通渠道的“特别转让服务”。对于进行这种特别转让的股票,沪深交易所在其简称前冠以“PT”,称之为“PT股” 。 根据《公司法》和证券法的规定,上市公司出现连续三年亏损等情况,其股票将暂停上市。沪深交易所从1999年7月9日起,对这类暂停上市的股票实施“特别转让服务”。第一批这类股票有“PT双鹿”,“PT农商社”,“PT苏三山”和“PT渝太白”。 PT即特别转让。依据《公司法》和《证券法》规定，上市公司出现连续三年亏损等情况，其股票将暂停上市。沪深交易所对这类暂停上市的股票实施特别转让服务，并在其简称前冠以PT，称之为PT股票。 PT股票在历史上曾经出现过几只，它与正常的股票也存在着很大的区别。 PT股票和正常股票的区别： 1、交易时间不同。PT股票仅限于每周五的开市时间内进行，而非交易日持续交易。 2、跌幅限制不同。PT股票申报价不得超过上一次转让价格的上下5％，这个和ST股票的日涨跌幅相同。 3、撮合方式不同。PT股票是交易所于收市后一次性对该股票当天所有有效申报按集合竞价方式进行撮合，产生唯一的成交价格，所有符合成交条件的委托盘均按此价格成交。 4、交易性质不同。PT股票不是上市交易，因此，这类股票不计入指数计算，成交数不计入市场统计，其转让信息也不在交易所行情中显示，只由指定报刊设专栏在次日公告。 在目前，PT股票已经被停止交易，仅供大家了解此概念。 红筹股、蓝筹股、 龙头股、黑马股、白马股、白菜股、妖股有什么区别什么是ST股和PT股金融100问：什么是ST股、PT股？ 常见股票术语 开盘价、收盘价、最高价、最低价、压力线、支撑线、K线、美国线、牛市、熊市、多头、空头、除息、除权、买空、卖空 日KDJ，周KDJ，月KDJ同时低价金叉。 K线就是指将各种股票每日、每周、每月的开盘价、收盘价、最高价、最低价等涨跌变化状况， 那么，为什么叫“K线”呢？实际上，在日本的“K”并不是写成“K”字，而是写做“罫”(日本音读kei)，K线是“罫线”的读音，K线图称为“罫线”，西方以英文第一个字母“K”直译为“K”线，由此发展而来。 K线的支撑线、压力线和趋势线 压力线(Resistance Line)、、 将两个或两个以上的相对低点连成一条直线即得到支撑线。 将两个或两个以上的相对高点连成一条直线即得到阻力线。 支撑线又称为抵抗线。当股价跌到某个价位附近时，股价停止下跌，甚至有可能还有回升。这个起着阻止股价继续下跌或暂时阻止股价继续下跌的价格就是支撑线所在的位置。 压力线又称为阻力线。当股价上涨到某价位附近时，股价会停止上涨，甚至回落。这个起着阻止或暂时阻止股价继续上升的价位就是压力线所在的位置。 支撑线与压力线相互转化 一条支撑线如果被跌破，那么这个支撑线将成为压力线；同理，一条压力线被突破，这个压力线将成为支撑线。这说明支撑线和压力线的地位不是一成不变的，而是可以改变的，条件是它被有效的足够强大的股价变动突破。 k线中支撑线、压力线、趋势线的画法分析 常见股票指数 我们常提到的股票指数（如沪深300、中证50等），是一种以股票价格为对象的价格指数。价格指数指的是统计学里的动态相对数，能够表现出当前指数价格相对于基期的涨跌变化。 国内 上海证券交易所综合股价指数（上证综指） 深圳证券交易所成份股价指数（深证成指） 沪深300指数 创业版指数 我们比较常看到的上证50、沪深300、中证500指数等就是按照规模分类的指数。 上证50就是上海市场市值前50的公司组成的指数，沪深300就是沪深两市市值前300的公司组成的指数。 但也有一些特殊的情况：比如中证500是沪深两市排名从301开始到800的这500只股票，而不是排名从1到500；中证1000是从801到1800这1000只股票。 富时中国A50指数 富时中国A50指数，是由全球四大指数公司之一的富时指数有限公司(现名为富时罗素指数)为满足中国国内投资者以及合格境外机构投资者需求所推出的实时可交易指数。富时中国A50指数是沪深交易所市值排名前50的A股公司的实时可交易指数，其总市值占A股总市值的33%，是最能代表中国A股市场的指数，是投资中国内地A股市场的一个基准，也是富时中国指数系列的旗舰指数。 道琼斯指数 道琼斯指数其实是一系列指数的统称，但通常指其中的道琼斯工业平均指数。道琼斯工业平均指数是根据美国股票市场上30只可靠而且重要的蓝筹股的加权平均数计算出来的，这30只股票来自不同的领域，目前包括美国运通、迪士尼、维萨、3M、苹果、微软、英特尔、IBM、思科、威瑞森、埃克森美孚、雪佛龙、陶氏杜邦、家得宝、沃尔玛、耐克、宝洁、强生、波音、卡特彼勒、可口可乐、麦当劳、辉瑞、默克制药、高盛、摩根大通、旅行者保险、联合健康保险、联合技术、沃尔格林博姿联合公司。 标普500指数 标准普尔指数是美国最大的证券研究机构即标准·普尔公司编制的股票价格指数。最初采选了230种股票，编制两种股票价格指数。从1976年7月1日开始，改为 400种工业股票，20种运输业股票，40种公用事业股票和40种金融业股票。几十年来，虽然有股票更迭，但始终保持为500种。标普500指数覆盖的是最受欢迎、持有者最多的美国股票，代表性很强。 纳斯达克指数 通常说的纳斯达克指数指纳斯达克综合指数，是以在NASDAQ市场上市的、所有本国和外国的上市公司的普通股为基础计算的。其中代表性的是纳斯达克100指数。 纳斯达克100指数做为纳斯达克的主要指数，其100只成分股均具有高科技、高成长和非金融的特点，可以说是美国科技股的代表。值得一提的是，纳斯达克100指数里，这些高成长性股票的良好业绩，都是各自内生性的高成长带来的，特别是创新业务，而非例如资产注入等外延式的增长。 从纳斯达克100指数十大权重成分股来看，他们主要为高科技企业，其中计算机行业的公司居多，目前权重最大的为苹果(Apple)，另外包括微软(Microsoft)、谷歌(Google)、思科(Cisco)、英特尔(Intel)等诸多知名公司。 罗素2000指数 美股市场的三大股指是指道琼斯指数、标普500指数和纳斯达克指数。除此之外，还有一个追踪小盘股的罗素2000指数。罗素2000指数是代表市场上的中、小型股的市值指标，在市场上总市值只有8100亿美元，不及标普500的十分之一。 香港恒生指数 恒生指数，由香港恒生银行全资附属的恒生指数服务有限公司编制，是以香港股票市场中的50家上市股票为成分股样本，以其发行量为权数的加权平均股价指数，是反映香港股市价幅趋势最有影响的一种股价指数。 恒生指数的成份股具有广泛的市场代表性，其总市值占香港联合交易所市场资本额总和的90%左右。为了进一步反映市场中各类股票的价格走势，恒生指数于1985年开始公布四个分类指数，把33种成份股分别纳入工商业、金融、地产和公共事业四个分类指数中。 日经指数 日经指数是日本代表性的股票指数，是代表日本股市或资本市场是好是坏的晴雨表，也是反映日元价值的因素之一，因此会对日元在外汇市场上的汇率造成相关的影响。日元目前是七大工业国的货币也是外汇市场上交投最活跃的外汇之一，而日经指数的升跌的影响可谓举足轻重。日经指数因延续时间较长，具有很好的可比性，成为考察日本股票市场股价长期演变及最新变动最常用和最可靠的指标，传媒日常引用的日经指数，指的是日经225指数。 全球最著名的16个股票指数，你知道几个？国内常见的股票指数，你知道多少 市盈率（静态市盈率，动态市盈率，TTM市盈率） PE（TTM）、PE（静）、PE（动） 市盈率（Priceearnings ratio，即P/E）也称“本益比”，理论上的计算方法是每股股价除以每股收益，但是股价/每股市盈率=总市值/净利润，通常为了方便就用当前总市值除以一年的总净利润来计算，是反映该股票估值水平的重要指标。 市盈率（Priceearnings ratio，即P/Eratio）是某种股票每股市价与每股盈利的比率，最直接地表达投资者的投入与产出的关系。简单的公式为，市盈率=当前股价÷每股收益率，或者市盈率=当前股票总市值÷上年度净利润 如果PE=15，意味着按现价买入该股票，假如该公司保持不变的盈利能力，需要15年时间公司所赚的净利润按照你所持有的股权份额计算，刚好等于初始投入买股票的钱。说通俗一点就是持有该股票15年才能收回你的投入成本。以常见的房产投资为例，假设房租15年回本，我们可以理解为该套房产现在的PE就是15。 静态市盈率 静态市盈率，简称PE LYR，计算方式：当前总市值除以去年一年的总净利润。但是这种方法就会出现一个问题，如果说2018年3月想要参考PE的时候,很有可能出现这家公司年报还没更新出来（年度报告由上市公司在每个会计年度结束之日起4个月内编制完成），那么我就无法得知2017年的总净利润了，数据还是需要统计的，所以一般的炒股软件都是以2016年的数据来填充。那么就是说，大家看到的是市盈率(静态)=2018年3月的当前总市值/2016年的总净利润，时隔两年，这种误差可想而知！所以就有了PE TTM 滚动市盈率(TTM市盈率) 滚动市盈率，简称PE TTM，计算方式：当前总市值除以前面四个季度的总净利润。“去年一年”和“前面四个季度”有什么区别，我就不需要多加解释了，简单点想就是PE TTM要比PE LYR更加准确一点，数据来得更新一些。那么PE TTM就是我们常见的PE（动）吗？很肯定地说“不是”，这个教滚动市盈率，区别等等下面讲PE（动）的时候你就知道了。一般PE TTM用在比较严谨的期刊、研报等地方，讲究数据的准确性，不用PE（动）的原因也就是其中的计算数据是“虚”的 TTM市盈率又称为滚动市盈率，与静态市盈率不同，其分母为最近四个季度（仍以一年为周期）的净利润之和。滚动市盈率也叫市盈率TTM(Trailing Twelve Month)，是以最近报告的12个月(四个季度)的净利润或者每股收益为基础来计算的，我们分别用PE3和PE4来表示：滚动市盈率(PE3)=当前股价÷最近4个季度基本每股收益之和，或者是：滚动市盈率(PE4)=当前市值÷最近4个季度归属于上市公司股东的净利润。 动态市盈率 动态市盈率，简称PE（动），计算方式：当前总市值除以预估今年全年总净利润。注意这个“预估今年全年总净利润”，说得难听点这就是“虚”的，这个数据具体怎么来的也不得而知，总是会有他的一套计算方式，据说是以6个月内券商预测的净利润取平均数 动态市盈率的计算公式分母为未来一年的预测净利润，计算的公式也稍微要复杂一点点 比如说该股票已经发布第一季度财报，这时我们的公式分母就要×4，半年度财报，这时我们的公式分母就要×2，三季度财报，这时我们的公式分母就要×4/3。 如果说静态市盈率看的股票的过去，那么动态市盈率则是预测该股票的未来 如果动态市盈率＞静态市盈率说明这只股票该季度或者一段时间公司的净利润降低了，公司发展有些担忧。 市盈率作为最常见的价值投资指标，经常给投资人的决策带来了许多盲点和误区。市盈率研究的核心是：如果我按照当前股价买入股票，那么我几年后才能回本？一般来说市盈率是多少，那就是几年后能回补，其实中里面就存在着两个致命的误区。 第一，没有考虑净利润的变动，不可能用企业一年的净利润来判断今后几年，甚至几十年的净利润，净利润是动态的，所以还需要结合净利润增加率来做进一步的判断 第二，“回本”是什么意思？光同净利润来算本金，而完全不考虑公司本身的净资产，这本身就是不合理的。 市盈率（静态市盈率，动态市盈率，TTM市盈率）你了解吗？市盈率如何找低估？PE（TTM）、PE（静）、PE（动）傻傻分不清 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Stock/经济名词.html":{"url":"Books/Stock/经济名词.html","title":"经济名词","keywords":"","body":"银行抽贷 银行贷款给企业，在还未到协议规定的还款期限期间，银行认为企业经营出现问题了，要提前收回贷款的行为叫“抽贷”或“银行抽贷”。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/文人/王勃.html":{"url":"Books/fiction/文人/王勃.html","title":"王勃","keywords":"","body":"Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/文人/苏轼.html":{"url":"Books/fiction/文人/苏轼.html","title":"苏轼","keywords":"","body":"Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/文人/毛泽东诗词.html":{"url":"Books/fiction/文人/毛泽东诗词.html","title":"毛泽东诗词","keywords":"","body":"《忆秦娥·娄山关》 西风烈， 长空雁叫霜晨月。霜晨月， 马蹄声碎， 喇叭声咽。 雄关漫道真如铁，而今迈步从头越。从头越，苍山如海，残阳如血。 《菩萨蛮·黄鹤楼》 茫茫九派流中国， 沉沉一线穿南北。 烟雨莽苍苍， 龟蛇锁大江。 黄鹤知何去？剩有游人处。把酒酹滔滔，心潮逐浪高！ 《贺新郎·别友》 挥手从兹去。更那堪凄然相向，苦情重诉。眼角眉梢都似恨，热泪欲零还住。知误会前番书语。过眼滔滔云共雾，算人间知己吾和汝。人有病，天知否？ 今朝霜重东门路，照横塘半天残月，凄清如许。汽笛一声肠已断，从此天涯孤旅。凭割断愁丝恨缕。要似昆仑崩绝壁，又恰象台风扫寰宇。重比翼，和云翥。 《浪淘沙·北戴河》 大雨落幽燕，白浪滔天，秦皇岛外打鱼船。一片汪洋都不见，知向谁边？ 往事越千年，魏武挥鞭，东临碣石有遗篇。萧瑟秋风今又是，换了人间。 《采桑子·重阳》 人生易老天难老，岁岁重阳，今又重阳，战地黄花分外香。 一年一度秋风劲，不似春光，胜似春光，廖廓江天万里霜。 《清平乐·六盘山》 天高云淡，望断南飞雁。不到长城非好汉，屈指行程二万。 六盘山上高峰，红旗漫卷西风。今日长缨在手，何时缚住苍龙？ 《蝶恋花·答李淑一》 我失骄杨君失柳，杨柳轻扬直上重霄九。问讯吴刚何所有，吴刚捧出桂花酒。 寂寞嫦娥舒广袖，万里长空且为忠魂舞。忽报人间曾伏虎，泪飞顿作倾盆雨。 《减字木兰花·广昌路上》 漫天皆白，雪里行军情更迫。头上高山，风卷红旗过大关。 此行何处？赣江风雪迷漫处。命令昨颁，十万工农下吉安。 《沁园春·长沙》 独立寒秋，湘江北去，橘子洲头。 看万山红遍，层林尽染；漫江碧透，百舸争流。 鹰击长空，鱼翔浅底，万类霜天竞自由。 怅寥廓，问苍茫大地，谁主沉浮？ 携来百侣曾游，忆往昔峥嵘岁月稠。 恰同学少年，风华正茂；书生意气，挥斥方遒。 指点江山，激扬文字，粪土当年万户侯。 曾记否，到中流击水，浪遏飞舟！ 《卜算子·咏梅》 风雨送春归，飞雪迎春到。已是悬崖百丈冰，犹有花枝俏。 俏也不争春，只把春来报。待到山花烂漫时，她在丛中笑。 《清平乐·会昌》(东方欲晓，莫道君行早) 东方欲晓，莫道君行早。踏遍青山人未老，风景这边独好。 会昌城外高峰，颠连直接东溟。战士指看南粤，更加郁郁葱葱。 《菩萨蛮·大柏地》(赤橙黄绿青蓝紫，谁持彩练当空舞？) 赤橙黄绿青蓝紫，谁持彩练当空舞？雨后复斜阳，关山阵阵苍。 当年鏖战急，弹洞前村壁，装点此关山，今朝更好看。 《水调歌头·游泳》(才饮长沙水，又食武昌鱼) 才饮长沙水，又食武昌鱼。 万里长江横渡，极目楚天舒。 不管风吹浪打，胜似闲庭信步，今日得宽馀。 子在川上曰：逝者如斯夫！ 风樯动，龟蛇静，起宏图。 一桥飞架南北，天堑变通途。 更立西江石壁，截断巫山云雨，高峡出平湖。 神女应无恙，当惊世界殊。 《沁园春·雪》 北国风光，千里冰封，万里雪飘。 望长城内外，惟余莽莽；大河上下，顿失滔滔。 山舞银蛇，原驰蜡象，欲与天公试比高。 须晴日，看红妆素裹，分外妖娆。 江山如此多娇，引无数英雄竞折腰。 惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。 一代天骄，成吉思汗，只识弯弓射大雕。 俱往矣，数风流人物，还看今朝。 《七律·长征》 红军不怕远征难，万水千山只等闲。 五岭逶迤腾细浪，乌蒙磅礴走泥丸。 金沙水拍云崖暖，大渡桥横铁索寒。 更喜岷山千里雪，三军过后尽开颜。 《七律·人民解放军占领南京》 钟山风雨起苍黄，百万雄师过大江。 虎踞龙盘今胜昔，天翻地覆慨而慷。 宜将剩勇追穷寇，不可沽名学霸王。 天若有情天亦老，人间正道是沧桑。 《水调歌头·重上井冈山》 久有凌云志，重上井冈山。 千里来寻故地，旧貌变新颜。 到处莺歌燕舞，更有潺潺流水，高路入云端。 过了黄洋界，险处不须看。 风雷动，旌旗奋，是人寰。 三十八年过去，弹指一挥间。 可上九天揽月，可下五洋捉鳖，谈笑凯歌还。 世上无难事，只要肯登攀。 《七律·到韶山》 别梦依稀咒逝川，故园三十二年前。 红旗卷起农奴戟，黑手高悬霸主鞭。 为有牺牲多壮志，敢叫日月换新天。 喜看稻菽千重浪，遍地英雄下夕烟。 《七律·将革命进行到底》 古今多少苍茫事，前车历历未能忘。 鸿门宴上宽纵敌，乌江边头何仓惶！ 秀全空坐失良机，天京终于烟灰场。 急世英雄行大劫，莫顾尘界百创伤。 参考如果《沁园春·雪》写在两宋，能排在什么档次？「毛泽东」诗词全集(89)首) Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/古诗词/满江红·写怀.html":{"url":"Books/fiction/古诗词/满江红·写怀.html","title":"满江红·写怀","keywords":"","body":"满江红·写怀 宋·岳飞怒发冲冠，凭栏处，潇潇雨歇。抬望眼、仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲、白了少年头，空悲切。靖康耻，犹未雪。臣子恨，何时灭？驾长车踏破，贺兰山缺。壮志饥飧胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，朝天阙。 满江红为一词牌名，此调为双调93字，前阕4仄韵，后阙5仄韵，前阕5、6句、后阕7、8句要对仗。后阕3字4字也可对仗。 白话译文我怒发冲冠登高倚栏杆，一场潇潇细雨刚刚停歇。抬头放眼四望辽阔一片，仰天长声啸叹。壮怀激烈，三十年勋业如今成尘土，征战千里只有浮云明月。莫虚度年华白了少年头，只有独自悔恨悲悲切切。靖康年的奇耻尚未洗雪，臣子愤恨何时才能泯灭。我只想驾御着一辆辆战车踏破贺兰山敌人营垒。壮志同仇饿吃敌军的肉，笑谈蔑敌渴饮敌军的血。我要从头彻底地收复旧日河山，再回京阙向皇帝报捷。 [5] 词句注释⑴满江红：词牌名，又名“上江虹”“念良游”“伤春曲”等。双调九十三字。⑵怒发（fà）冲冠：气得头发竖起，以至于将帽子顶起。形容愤怒至极。⑶凭阑：身倚栏杆。阑，同“栏”。⑷潇潇：形容雨势急骤。⑸长啸：大声呼叫。啸，蹙口发出的叫声。⑹壮怀：奋发图强的志向。⑺“三十”句：谓自己已经三十岁了，得到的功名，如同尘土一样微不足道。三十，是约数。功名，或指岳飞攻克襄阳六郡以后建节晋升之事。⑻“八千”句：形容南征北战、路途遥远、披星戴月。八千，是约数，极言沙场征战行程之远。⑼等闲：轻易，随便。⑽空悲切：即白白的痛苦。⑾靖康耻：宋钦宗靖康二年（1127），金兵攻陷汴京，虏走徽、钦二帝。靖康，宋钦宗赵桓的年号。⑿贺兰山：贺兰山脉，位于宁夏回族自治区与内蒙古自治区交界处，当时被金兵占领。一说是位于邯郸市磁县境内的贺兰山。⒀胡虏：对女真贵族入侵者的蔑称。⒁匈奴：古代北方民族之一，这里指金入侵者。⒂朝天阙：朝见皇帝。天阙，本指宫殿前的楼观，此指皇帝居住的地方。明代王熙书《满江红》词碑作“朝金阙”。 译文我愤怒得头发竖了起来，帽子被顶飞了。独自登高凭栏远眺，骤急的风雨刚刚停歇。抬头远望天空，禁不住仰天长啸，一片报国之心充满心怀。三十多年来虽已建立一些功名，但如同尘土微不足道，南北转战八千里，经过多少风云人生。好男儿，要抓紧时间为国建功立业，不要空空将青春消磨，等年老时徒自悲切。靖康之变的耻辱，至今仍然没有被雪洗。作为国家臣子的愤恨，何时才能泯灭！我要驾着战车向贺兰山进攻，连贺兰山也要踏为平地。我满怀壮志，打仗饿了就吃敌人的肉，谈笑渴了就喝敌人的鲜血。待我重新收复旧日山河，再带着捷报向国家报告胜利的消息！ 注释 怒发冲冠：气得头发竖起，以至于将帽子顶起。形容愤怒至极，冠是指帽子而不是头发竖起。 潇潇：形容雨势急骤。 长啸：感情激动时撮口发出清而长的声音,为古人的一种抒情举动。 三十功名尘与土：年已三十，建立了一些功名，不过很微不足道。 八千里路云和月：形容南征北战、路途遥远、披星戴月。 等闲：轻易，随便。 靖康耻：宋钦宗靖康二年（1127年），金兵攻陷汴京，虏走徽、钦二帝。 贺兰山：贺兰山脉位于宁夏回族自治区与内蒙古自治区交界处。 胡虏（lǔ）：秦汉时匈奴为胡虏,后世用为与中原敌对的北方部族之通称。 朝天（阙）：朝见皇帝。天阙：本指宫殿前的楼观，此指皇帝生活的地方。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/古诗词/满江红·登黄鹤楼有感.html":{"url":"Books/fiction/古诗词/满江红·登黄鹤楼有感.html","title":"满江红·登黄鹤楼有感","keywords":"","body":"满江红·登黄鹤楼有感 宋·岳飞遥望中原，荒烟外、许多城郭。想当年、花遮柳护，凤楼龙阁。万岁山前珠翠绕，篷壶殿里笙歌作。到而今、铁骑满郊畿，风尘恶。兵安在？膏锋锷。民安在？填沟壑。叹江山如故，千村寥落。何日请缨提锐旅，一鞭直渡清河洛。却归来、再续汉阳游，骑黄鹤。 满江红为一词牌名，此调为双调93字，前阕4仄韵，后阙5仄韵，前阕5、6句、后阕7、8句要对仗。后阕3字4字也可对仗。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/名言名句.html":{"url":"Books/fiction/名言名句.html","title":"名言名句","keywords":"","body":"横渠四句 “横渠四句”出自张载《横渠语录》，原文如下： “为天地立心，为生民立命，为往圣继绝学，为万世开太平。” 译文：为天地确立起生生之心，为百姓指明一条共同遵行的大道，继承孔孟等以往的圣人不传的学问，为天下后世开辟永久太平的基业。 横渠四句，即“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，为北宋大家张载的名言。当代哲学家冯友兰将其称作“横渠四句”。由于其言简意宏，一直被人们传颂不衰。 张载（1020-1077）字子厚，北宋大儒，哲学家，理学创始人之一，理学支脉“关学”创始人，封先贤，奉祀孔庙西庑第38位。 《西铭》又名《订顽》，是张载作品《正蒙•乾称篇》中的一篇文章。在四库全书中为子部儒家类。提出“民吾同胞，物吾与也”。 “为天地立心，为生民立命，为往圣继绝学，为万世开太平”（张子四句）。作为儒学的经典文献之一，张载的《西铭》在传统社会即备受赞誉而传诵不绝，其根本原因在于，这篇铭文虽然仅有250余字，但却为人们安身立命构筑了一个共同的精神家园，而且为社会理想蓝图的构建提供了一个弘阔的境界。 北宋张载著。原为《正蒙·乾称篇》的一部分。作者曾于学堂双牖各录《乾称篇》的一部分《砭愚》和《订顽》分别悬挂于书房的东、西两牖，作为自己的座右铭。程颐见后，将《砭愚》改称《东铭》、《订顽》改称《西铭》。 [1] 文中提出“民胞物与”的思想，把宇宙看作一个大家族，说明个人的道德义务，宣扬“存，吾顺事，没，吾宁也”的乐天顺命思想。 [2] Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/近现代小说.html":{"url":"Books/fiction/近现代小说.html","title":"《近现代小说》","keywords":"","body":"近现代武侠小说 网络小说 鬼吹灯 盗墓笔记 《盗墓笔记》是中国作家南派三叔于2006年6月26日首发于鬼吹灯百度贴吧的网络小说，并同年7月6日在起点中文网连载。单行本全9卷。《盗墓笔记》的完结篇于2011年12月19日上市。 南派三叔作品《盗墓笔记》中提到的老长沙的九个盗墓世家，称为老九门，又称九门提督。《老九门》是《盗墓笔记》的前传，即讲述吴邪等人祖辈的故事，以平和简短的风格，讲述各自人物的日常片段，最早发表于《超好看》。 科幻小说 三体 黑暗森林法则 费米悖论 赡养人类 刘慈欣作品： 三体：三体 ( 2006) ▪ 三体Ⅱ：黑暗森林 ( 2008) ▪ 三体Ⅲ：死神永生 ( 2010) ▪ 赡养上帝 ( 2005) ▪ 赡养人类 ( 2005) 流浪地球 ( 2000) 三体 三体 ( 2006) ▪ 三体Ⅱ：黑暗森林 ( 2008) ▪ 三体Ⅲ：死神永生 ( 2010) 《三体》是中国大陆作家刘慈欣于2006年5月至12月在《科幻世界》杂志上连载的一部长篇科幻小说，出版后成为中国大陆最畅销的科幻长篇小说之一[1]。2008年，该书的单行本由重庆出版社出版。 本书是三体系列（系列原名为：地球往事三部曲）的第一部，该系列的第二部《三体II：黑暗森林》已经于2008年5月出版。2010年11月，第三部《三体III：死神永生》出版发行。 2011年，“地球往事三部曲”在台湾陆续出版。小说的英文版获得美国科幻奇幻作家协会2014年度“星云奖”提名[2]，并荣获2015年雨果奖最佳小说奖。 黑暗森林法则 黑暗森林法则：一旦某个文明被发现，就必然遭到其他文明的打击。 点评：一旦被发现，能生存下来的是只有一方，或者都不能生存。 解析：可以从地球中的国家间文明发展，以小看大分析宇宙文明发展方向。 宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼：他必须小心，因为林中到处都有与他一样潜行的猎人，如果他发现了别的生命，能做的只有一件事：开枪消灭。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭，这就是宇宙文明的图景，这就是对费米悖论的一种解释。 黑暗森林法则，科幻小说作家刘慈欣在《三体II 黑暗森林》引入的法则。罗辑（三体2中的主人公）在人类当前的科技水平和社会状况下，受到叶文洁启发，从两条不证自明的基本公理出发，借由引入两个重要概念——猜疑链和技术爆炸，从理论上建立起的一套关于描述当前宇宙社会大图景的大体系的一门学科——宇宙社会学。 黑暗森林法则在《三体》系列中共有四个版本，分别为：叶文洁-罗辑理论、咒语实验理论、概率理论、宇宙战争理论。 费米悖论 黑暗森林法则的相关内容。 1950年的一天，诺贝尔奖获得者、物理学家费米在和别人讨论飞碟及外星人的问题时，突然冒出一句：“他们都在哪儿呢？”这句看似简单的问话，就是著名的“费米悖论”。 “费米悖论”隐含的意思是，从理论上讲，人类能用100万年的时间飞往银河系的各个星球，那么，外星人只要比人类早进化100万年，就应该已经来到地球了。换言之，“费米悖论”表明了这样的逻辑悖理：A.外星人是存在的——科学推论可以证明，外星人的进化要远远早于人类，他们应该已经来到地球并存在于某处了；B.外星人是不存在的——迄今为止，人类并未发现任何有关外星人存在的蛛丝马迹。 “费米悖论”自成，在天文学界就有着相当的影响，因为它是基于科学探知的事实：古老的银河系，已有约100多亿年的年龄，而银河系的空间直径却只有大约10万光年，就是说，即使外星人仅以光速的千分之一翱翔太空，他们也不过只需1亿年左右的时间就可以横穿银河系——这个时间远远短于银河系的年龄。而且仅从数学概率上分析，在浩瀚的宇宙里，应该有着众多的类似地球的适合于生命存在的星体。并且这其中，有些星体的年龄要远远大于地球，因此，它们上面的生命进化，也要远远早于地球上的人类。 “费米悖论”生成几十年来，人类对太空的探索已有长足的进展。宇宙飞船已经参观或探测了太阳系中绝大部分的行星及其主要卫星，天文学家还追踪了成千上万颗星球发出的微波信号。但是，这些搜寻行动一无所获，人类并没有发现能够证明外星人存在的生命信号。“费米悖论”的实质就是否定外星文明的存在：既然我们至今还未发现外星人的蛛丝马迹，为什么还要相信它呢？ “费米悖论”在天文学界广有市场，许多著名的科学家对此持赞成的态度。 赡养人类 首先，我们要清楚大刘的《赡养人类》是作为《赡养上帝》的续集而存在的。 先来个书中预言与现实对比。 在我曾祖父的时代，第一地球60%的财富掌握在一千万人手中；在爷爷的时代，世界财富的80%掌握在一万人手中；在爸爸的时代，财富的90%掌握在四十二人手中。 ——《赡养人类》2005年作品 《赡养人类》里第一地球有20亿人口，曾祖父时代1000万人，即0.5%人口掌握60%财富。 现实中：地球目前是前1%人口掌握50%财富。（【更新数据】2017年前1%人口掌握全球82%财富，已经符合书中数据了。） 刘慈欣短篇小说剧情梳理——《赡养人类》 新武侠四大宗师 新武侠四大宗师（金、古、梁、温） 金庸,查良镛，GBM ，OBE（英语：Louis Cha Jing-yong，1924年3月10日－2018年10月30日） 古龙（1938年6月7日－1985年9月21日），原名熊耀华 梁羽生（本名陈文统，1924年4月5日－2009年1月22日） 温瑞安（原名温凉玉） 金庸 射雕三部曲 射雕三部曲是作家金庸所著的武侠小说中最先发表的三部长篇小说的统称[1]。这三部中角色与情节有一定的连贯性，依背景时间顺序分别是： 《射雕英雄传》（南宋宋宁宗年间） 《神雕侠侣》（南宋宋理宗年间） 《倚天屠龙记》（元末元顺帝年间） 而有人认为应当包括到创作较晚但时代较早的姐妹作，背景时间为北宋宋哲宗年间的《天龙八部》称为射雕四部曲。 温瑞安 《四大名捕》系列 《神州奇侠》系列 《说英雄，谁是英雄》系列 逆水寒 (电视剧) 逆水寒是2004年上映的中国大陆电视剧，由鞠觉亮执导，温豪杰编剧，张智霖、锺汉良、李小冉、于娜、宋佳等主演，改编自温瑞安的同名武侠小说，讲述了北宋时期江湖大侠戚少商蒙冤逃亡，在神捕铁手、昔日情敌霹雳堂主雷巻...等义士的帮助下，冤案得雪的故事。共40集，每集40分钟。 逆水寒 (游戏) 《逆水寒》以温瑞安《四大名捕》、《说英雄谁是英雄》、《神州奇侠》三大系列小说为游戏背景，讲述北宋末年一段惨烈的大追捕，并牵扯出江湖恩怨、朝堂纷争、帮派仇杀、感情纠葛、市井百态等北宋生活画卷。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/鬼吹灯.html":{"url":"Books/fiction/鬼吹灯.html","title":"《鬼吹灯》","keywords":"","body":"《鬼吹灯》是一部中国的网络小说，主要内容是盗墓寻宝，作者为天下霸唱。第一部小说包括四卷，分别是《精绝古城》、《龙岭迷窟》、《云南虫谷》和《昆仑神宫》。随后作者继续创作鬼吹灯第二部，内容涉及陈瞎子和鹧鸪哨（杨雪莉之外公）之盗墓往事。第二部包括四卷，分别是《黄皮子坟》、《南海归墟》、《怒晴湘西》和《巫峡棺山》，全八卷简体中文版由安徽文艺出版社发行，但对原书中部分“封建迷信”、“恐怖灵异”的内容进行删改。 本书在台湾由高宝国际出版集团出版繁体中文版，每卷分配内容进度与简体中文版略有不同，在第二部将《巫峡棺山》分成《不死地仙》及《巫峡棺山》。 盗墓派系 1、摸金校尉：摸金的雏形始于战国时期，精通“寻龙诀”和“分金定穴”。门人有摸金符。 2、发丘将军：又名发丘中郎将、发丘天官、发丘灵官。到了后汉才有，与摸金同出一脉，其手段和摸金校尉几乎完全一样，只是多了一枚铜印“发丘印”。 3、搬山道人：始于西域孔雀河双黑山流域，其辈皆同宗同族。本为扎格拉玛后人，搬山者善独门“搬山分甲术”，此术可细分为“搬山填海术”并“分山掘子甲”两门，合称“搬山之术”。平时用道士的身份伪装，以“搬山道士”自居，以寻找“雮尘珠”为己任。 4、卸岭力士：始自汉末农民军盗发帝陵，众力取利，分赃聚义，人数少则成百、多可千数。平日分散，各自为匪为盗或为官军，盗墓者中半官半匪者皆属此辈，彼此间有消息相通，中有盗魁，一呼百应，逢古墓巨冢，则聚众以图之。其行事不计后果，大铲大锄、牛牵马拽、药石土炮，无所不用其极，其辈所盗发之冢，即便斩山做廊、穿石为藏、土坚如铁、墓墙铜灌金箍，亦皆以外力破之。 5、观山太保：少数人组成的不为人知的盗墓门派，起源于明代。 鬼吹灯之精绝古城 鬼吹灯之龙岭迷窟 鬼吹灯之云南虫谷 鬼吹灯之昆仑神宫 鬼吹灯之黄皮子坟 鬼吹灯之南海归墟 鬼吹灯之怒晴湘西 鬼吹灯之巫峡棺山 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/三国演义.html":{"url":"Books/fiction/三国演义.html","title":"《三国演义》","keywords":"","body":"《三国演义》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/上帝的指纹.html":{"url":"Books/fiction/上帝的指纹.html","title":"《上帝的指纹》","keywords":"","body":"《上帝的指纹（God's fingerprint）》 作者： 葛瑞姆·汉卡克(Graham Hancock) 科幻小说 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/地球编年史.html":{"url":"Books/fiction/地球编年史.html","title":"《地球编年史》","keywords":"","body":"《地球编年史》:共七册 《第十二个天体》ISBN：9787229006747 《通往天国的阶梯》ISBN：9787229011659 《众神与人类的战争》ISBN：9787229013752 《失落的国度》ISBN：9787229018153 《当时间开始》ISBN：9787229026677 《宇宙密码》ISBN：9787229035945 《完结日》ISBN：9787229046576 《地球编年史指南》ISBN：9787229046873 作者： 撒迦利亚·西琴（俄语：Заха́рия Си́тчин；英语：Zecharia Sitchin，1920年7月11日－2010年10月9日） 科幻小说不属算伪科学 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/橘子不是唯一的水果.html":{"url":"Books/fiction/橘子不是唯一的水果.html","title":"《橘子不是唯一的水果》","keywords":"","body":"《橘子不是唯一的水果》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/fiction/红楼梦.html":{"url":"Books/fiction/红楼梦.html","title":"红楼梦","keywords":"","body":"《红楼梦》 石头记、情僧录、风月宝鉴、金陵十二钗、金玉缘 1987年首播的央视版《红楼梦》贾宝玉---欧阳奋强林黛玉---陈晓旭薛宝钗---张莉 《红楼梦》故事主线为贾宝玉、林黛玉及薛宝钗三人的爱情与婚姻悲剧，以及贾宝玉亲戚贾府、史家、王家、薛家等四大家族的兴衰。 女娲炼石补天，用了三万六千五百颗石头，剩一块石未用，是为顽石，顽石经过修炼已经有了灵性。 一僧一道携它变幻为美玉带入尘世，变成“通灵宝玉”。 适逢神瑛侍者对一株绛珠仙草有浇灌之恩，又动了凡心下凡游历人间。绛珠仙草后修炼成女体，闻讯亦随之下凡，打算把一生所有的眼泪还他。 神瑛侍者浇灌绛珠草使其化为绛珠仙子，而神瑛侍者动了凡心要去凡间，绛珠仙子为报答恩情，就也要求去凡间，用自己的眼泪来报答神瑛侍者的灌溉之情。石头被夹带于中，跟随神瑛、绛珠等经历“花柳繁华”、“温柔富贵”。于是，神瑛侍者化为贾宝玉，绛珠仙子化为林黛玉，那块顽石化成为贾宝玉口中的那块美玉。 所以全书把她和贾宝玉的关系称为“木石前盟”。“还泪”之说则预示了宝黛爱情的悲剧结局。 生来口中就含有一块通灵宝玉（补天顽石）的孙儿贾宝玉（神瑛侍者） 林黛玉（绛珠仙草） 贾雨村，甑士隐（假语存真事隐） 假作真时真亦假； 无为有处有还无。--曹雪芹撰 太虚幻境联 满纸荒唐言，一把辛酸泪！都云作者痴，谁解其中味？ 一个是阆苑仙葩，一个是美玉无暇。若说没奇缘，今生偏又遇着他。若说有奇缘，如何心事终虚化？——第五回 苦绛珠魂归离恨天，病神瑛泪洒相思地。 世事洞明皆学问，人情练达即文章。--曹雪芹对王熙凤的评价 好了歌世人都晓神仙好，只有功名忘不了！古今将相在何方，荒冢一堆草没了！世人都晓神仙好，只有金银忘不了！终朝只恨聚无多，及到多时眼闭了！世人都晓神仙好，只有娇妻忘不了！君生日日说恩情，君死又随人去了！世人都晓神仙好，只有儿孙忘不了！痴心父母古来多，孝顺子孙谁见了！ 葬花吟---林黛玉尔今死去侬收葬，未卜侬身何日丧？侬今葬花人笑痴，他年葬侬知是谁？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Java/Effective Java中文版.html":{"url":"Books/Book/Java/Effective Java中文版.html","title":"《Effective Java中文版》","keywords":"","body":"《Effective Java中文版》 《Effective Java》 本书的源代码 https://github.com/jbloch/effective-java-3e-source-code Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Java/Java多线程编程核心技术.html":{"url":"Books/Book/Java/Java多线程编程核心技术.html","title":"《Java多线程编程核心技术》","keywords":"","body":"《Java多线程编程核心技术》 代码参考 https://github.com/loveincode/java-multi-thread-programming Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Java/Java编程思想.html":{"url":"Books/Book/Java/Java编程思想.html","title":"《Java编程思想》","keywords":"","body":"《Java编程思想》 https://github.com/xbtlin/thinking-In-Java Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Java/深入理解Java虚拟机JVM高级特性与最佳实践.html":{"url":"Books/Book/Java/深入理解Java虚拟机JVM高级特性与最佳实践.html","title":"《深入理解Java虚拟机JVM高级特性与最佳实践》","keywords":"","body":"《深入理解Java虚拟机JVM高级特性与最佳实践》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Java/Java程序性能优化.html":{"url":"Books/Book/Java/Java程序性能优化.html","title":"《Java程序性能优化》","keywords":"","body":"《Java程序性能优化》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/DB/深入浅出MyBatis技术原理与实战.html":{"url":"Books/Book/DB/深入浅出MyBatis技术原理与实战.html","title":"《深入浅出MyBatis技术原理与实战》","keywords":"","body":"《深入浅出MyBatis技术原理与实战》 代码 https://github.com/johnnywong233/mybatis_all Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/DB/高性能MySQL.html":{"url":"Books/Book/DB/高性能MySQL.html","title":"《高性能MySQL》","keywords":"","body":"《高性能MySQL》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/HTTP/图解HTTP.html":{"url":"Books/Book/HTTP/图解HTTP.html","title":"《图解HTTP》","keywords":"","body":"《图解HTTP》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/HTTP/TCPIP详解：卷一.html":{"url":"Books/Book/HTTP/TCPIP详解：卷一.html","title":"《TCPIP详解：卷一》","keywords":"","body":"《TCPIP详解：卷一》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Linux/鸟哥的Linux私房菜.html":{"url":"Books/Book/Linux/鸟哥的Linux私房菜.html","title":"《鸟哥的Linux私房菜》","keywords":"","body":"《鸟哥的Linux私房菜》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Netty/Netty权威指南.html":{"url":"Books/Book/Netty/Netty权威指南.html","title":"《Netty权威指南》","keywords":"","body":"《Netty权威指南》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Python/Python之禅.html":{"url":"Books/Book/Python/Python之禅.html","title":"Python之禅","keywords":"","body":"《Python之禅》（The Zen of Python） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/JavaScript/JavaScript语言精粹.html":{"url":"Books/Book/JavaScript/JavaScript语言精粹.html","title":"JavaScript语言精粹","keywords":"","body":"《JavaScript语言精粹》（JavaScript: The Good Parts） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/数据结构算法/大话数据结构.html":{"url":"Books/Book/数据结构算法/大话数据结构.html","title":"大话数据结构","keywords":"","body":"Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/分布式/从PAXOS到ZOOKEEPER分布式一致性原理与实践.html":{"url":"Books/Book/分布式/从PAXOS到ZOOKEEPER分布式一致性原理与实践.html","title":"从PAXOS到ZOOKEEPER分布式一致性原理与实践","keywords":"","body":"《从PAXOS到ZOOKEEPER分布式一致性原理与实践》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/并发/Java并发编程的艺术.html":{"url":"Books/Book/并发/Java并发编程的艺术.html","title":"Java并发编程的艺术","keywords":"","body":"Java 并发编程的艺术 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/并发/Java并发编程之美.html":{"url":"Books/Book/并发/Java并发编程之美.html","title":"Java并发编程之美","keywords":"","body":"Java并发编程之美 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/并发/Java并发编程实战.html":{"url":"Books/Book/并发/Java并发编程实战.html","title":"Java并发编程实战","keywords":"","body":"Java并发编程实战 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/并发/七周七并发模型.html":{"url":"Books/Book/并发/七周七并发模型.html","title":"七周七并发模型","keywords":"","body":"七周七并发模型 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/并发/多处理器编程的艺术.html":{"url":"Books/Book/并发/多处理器编程的艺术.html","title":"多处理器编程的艺术","keywords":"","body":"多处理器编程的艺术.md Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/代码整洁之道.html":{"url":"Books/Book/架构设计/代码整洁之道.html","title":"《代码整洁之道》","keywords":"","body":"《代码整洁之道》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/重构.html":{"url":"Books/Book/架构设计/重构.html","title":"《重构》","keywords":"","body":"《重构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/亿级网站架构核心技术.html":{"url":"Books/Book/架构设计/亿级网站架构核心技术.html","title":"《亿级网站架构核心技术》","keywords":"","body":"《亿级网站架构核心技术》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/可伸缩服务架构.html":{"url":"Books/Book/架构设计/可伸缩服务架构.html","title":"《可伸缩服务架构》","keywords":"","body":"《可伸缩服务架构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/大型网站技术架构-核心原理与案例分析.html":{"url":"Books/Book/架构设计/大型网站技术架构-核心原理与案例分析.html","title":"《大型网站技术架构-核心原理与案例分析》","keywords":"","body":"《大型网站技术架构-核心原理与案例分析》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/大型网站系统与Java中间件实践.html":{"url":"Books/Book/架构设计/大型网站系统与Java中间件实践.html","title":"《大型网站系统与Java中间件实践》","keywords":"","body":"《大型网站系统与Java中间件实践》 高可用：分布式、主备 volatile和synchronize效果类似，但是volatile不保证原子性，synchronize是原子性的 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/Design of Design.html":{"url":"Books/Book/架构设计/Design of Design.html","title":"《Design of Design》","keywords":"","body":"《Design of Design, The: Essays from a Computer Scientist 1st Edition》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/人月神话-软件项目管理之道.html":{"url":"Books/Book/架构设计/人月神话-软件项目管理之道.html","title":"《人月神话-软件项目管理之道》","keywords":"","body":"《人月神话：软件项目管理之道》（英语：The Mythical Man-Month: Essays on Software Engineering） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/微服务架构设计模式.html":{"url":"Books/Book/架构设计/微服务架构设计模式.html","title":"《微服务架构设计模式》","keywords":"","body":"微服务架构设计模式 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/深入浅出设计模式.html":{"url":"Books/Book/架构设计/深入浅出设计模式.html","title":"《深入浅出设计模式》","keywords":"","body":"《深入浅出设计模式》（ Head First Design Patterns） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/面向模式的软件架构.html":{"url":"Books/Book/架构设计/面向模式的软件架构.html","title":"《面向模式的软件架构》","keywords":"","body":"《面向模式的软件架构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/没有银弹-软件工程的本质性与附属性工作.html":{"url":"Books/Book/架构设计/没有银弹-软件工程的本质性与附属性工作.html","title":"《没有银弹-软件工程的本质性与附属性工作》","keywords":"","body":"《没有银弹：软件工程的本质性与附属性工作》（英语：No Silver Bullet—Essence and Accidents of Software Engineering） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/架构设计/设计模式-可复用面向对象软件的基础.html":{"url":"Books/Book/架构设计/设计模式-可复用面向对象软件的基础.html","title":"《设计模式-可复用面向对象软件的基础》","keywords":"","body":"《设计模式：可复用面向对象软件的基础》（ Design Patterns: Elements of Reusable Object-Oriented Software） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Interview/剑指Offer.html":{"url":"Books/Book/Interview/剑指Offer.html","title":"《剑指Offer》","keywords":"","body":"《剑指Offer》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Interview/程序员面试宝典.html":{"url":"Books/Book/Interview/程序员面试宝典.html","title":"《程序员面试宝典》","keywords":"","body":"《程序员面试宝典》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/Interview/程序员面试金典.html":{"url":"Books/Book/Interview/程序员面试金典.html","title":"《程序员面试金典》","keywords":"","body":"《程序员面试金典》 Java代码实现 https://github.com/Wang-Jun-Chao/Cracking-the-Coding-Interview 第五版Python代码 https://github.com/panxl6/cc150 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/其他的/具体数学.html":{"url":"Books/Book/其他的/具体数学.html","title":"具体数学","keywords":"","body":"《具体数学》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/其他的/人类网络·社会位置决定命运.html":{"url":"Books/Book/其他的/人类网络·社会位置决定命运.html","title":"人类网络·社会位置决定命运","keywords":"","body":"《人类网络·社会位置决定命运》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/其他的/性能之巅.html":{"url":"Books/Book/其他的/性能之巅.html","title":"性能之巅","keywords":"","body":"《性能之巅》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/其他的/浪潮之巅.html":{"url":"Books/Book/其他的/浪潮之巅.html","title":"浪潮之巅","keywords":"","body":"《浪潮之巅》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/其他的/编写可读代码的艺术.html":{"url":"Books/Book/其他的/编写可读代码的艺术.html","title":"编写可读代码的艺术","keywords":"","body":"《编写可读代码的艺术》（《The Art of Readable Code》） https://github.com/trekhleb/state-of-the-art-shitcode/blob/master/README.zh-CN.md 《代码整洁之道》 1、命名规范：变量、方法（方法名+形参）、类 2、代码逻辑上的优化 3、函数级别的代码组织优化。 4、 5、 6、 7、 命名规范：变量、方法（方法名+形参）、类 如： 一般用词 更加丰富多义的词语 send deliver, dispatch, announce, distribute, route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add, new 命名可以加入什么信息： 单位 命名的长度 1、丢弃无用词汇 2、短范围配短名字 3、使用经典的缩写 缩写 完整 str string doc document eq equal 一般常量都是以大写 + 下划线来命名的 命名的歧义 filter()、select()、 exclude() clip、clipTail、clipTo 如果要有个表示上下限变量，max/min 前缀是个好选择。 如果是表示 [n, m] 这个区间，用 first/last 比较好。 如果是表示 [n, m) 这个区间，用 begin/ending,end 比较好。 命名一个布尔值变量，善用 can, is, has 等修饰。同时，否定意味的词，例如 disable_ssl，noSync 尽量不用。 由于一些约定俗成的规则，阅读者还是容易对一个词产生惯性思维。例如 get(), List::size()，会传递一个 轻量操作 的错误信息。 我们可以使用 computeXXX()、 allocateXXX() 、fetchxxx() 修改命名，告诉阅读者函数的意图。同时也可以修改函数实现来贴合这些约定俗成的规则。 代码逻辑上的优化 条件语句组织顺序大致三种： 简单先行 错误先抛 正先否后 尽量使用 提前 return 的思想。 拆分过长的表达式：利用 变量 来简化表达式，以提升代码可读性。 逻辑关系之变化 1、德摩根律 2、短路逻辑不要滥用 3、取反：正想逻辑过于复杂，可以用：反向逻辑 再取反（其实就是德摩根律）：当发现一个判断条件参数过多，就要考虑它的反逻辑，也许更加简洁。 变量多，那就减少：无价值的临时变量 作用域太大，那就缩小：变量对尽量少的代码可见 压缩变量作用域，我们可以在使用变量的逻辑前，再声明变量，将变量的作用域就固定在变量被使用的几行代码内 变量在越少 不同 的地方被使用、赋值，定位它的变化就越容易。 奥古斯都·德·摩根首先发现了在命题逻辑中存在着下面这些关系： 非(P 且 Q) = (非 P) 或 (非 Q) 非(P 或 Q) = (非 P) 且 (非 Q) 函数级别的代码组织优化。 专注于函数的目的：我们需要将对于目的而言 相关性较小的子问题 抽取出来，变成一个独立的函数，甚至是库。这个取决于这个子问题使用的范围是一个文件，还是一整个项目。 一次只做一件事：让代码 保持单纯，抽取不相干子问题，让代码段尽量一次只做一件事 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/medicine/人体使用手册.html":{"url":"Books/Book/medicine/人体使用手册.html","title":"《人体使用手册》","keywords":"","body":"《人体使用手册》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/medicine/普通生物学.html":{"url":"Books/Book/medicine/普通生物学.html","title":"《普通生物学》","keywords":"","body":"《普通生物学》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/国史大纲.html":{"url":"Books/Book/history/国史大纲.html","title":"《国史大纲》","keywords":"","body":"《国史大纲》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/明朝那些事儿.html":{"url":"Books/Book/history/明朝那些事儿.html","title":"《明朝那些事儿》","keywords":"","body":"《明朝那些事儿》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/万历十五年.html":{"url":"Books/Book/history/万历十五年.html","title":"《万历十五年》","keywords":"","body":"《万历十五年》 《万历十五年》（英语：1587, a Year of No Significance: The Ming Dynasty in Decline）是美籍华裔历史学家黄仁宇最出名、也是体现其“大历史观”的一部明史研究专著。 内容概要： 明朝第十三代皇帝是明神宗朱翊钧，年号万历（1572－1620年），万历十年（1582年）六月二十日，内阁首辅张居正去世，明神宗开始亲政，他贪财征税，沉湎于酒色之中（一说是染上鸦片烟瘾），又因立太子之事与内阁争执长达十余年，国本之争使他以不上朝及怠政作为与大臣的对抗。 万历十四年（1586年）后，神宗开始连续不上朝，期间长达三十年，史称万历怠政。万历中期后虽然不上朝，但是也没有宦官、外戚干政，也没有严嵩这样的奸臣，朝内党争也有所控制，万历朝鲜之役、女真入侵辽东和梃击案，神宗都有反应及参与，表示他还有看奏章，并透过一定的方式控制朝局。 一般史家认为的明朝灭亡之起点，如万历十年（1582年）张居正去世，万历二十年（1592年）长达六年的援朝鲜之战，万历三十一年间的“妖书案”，接下来万历四十三年（1615年）起的“三大案”（梃击案、红丸案、移宫案），万历四十七年（1619年）的萨尔浒之战等。与这些年份相比，万历十五年（1587年）虽然有海瑞、戚继光的去世，但终究只是无足轻重的一年，也即如其英文版的书名：无关紧要的1587年（1587, a Year of No Significance）。 但黄仁宇提出与其他史学者不同的看法，指出此一年似是天下盛平，无重大动荡，实际上可能却是明朝发展至尽头而步向灭亡的一年。黄仁宇引用典籍，特别是《神宗实录》，就此年中发生的立储之争和一连串使万历帝感到大为不快的问题作分析，研究发生在万历帝身上的变化。黄仁宇指出，虽然最后万历帝在种种问题上妥协，但他由此怠政三十三年，可能是他对抗无效之后，对文官集团的一种报复方式。由此可以理解，明朝的皇帝表面上是有至高无上的绝对权力，但终归也要受到传统文化和文官集团的掣肘。 另外书中还提到海瑞、戚继光、李贽等人，也是受到传统文化的掣肘，而得不到有意义的发展。对海瑞，黄仁宇形容“他虽然被人仰慕，但没有人按照他的榜样办事，他的一生体现了一个有教养的读书人服务于公众而牺牲自我的精神，但这种精神的实际作用却至为微薄。”；对戚继光，黄仁宇评“戚继光的求实精神，表现于使革新不与传统距离过远。”；而对李贽，黄仁宇也评说李贽不过是反映明朝在儒家伦理文化趋于僵化下，思想界的苦闷和困局。 万历怠政 万历怠政，是指明朝明神宗当政期间的怠政现象[1][2][3]。明神宗的长期怠政主要是执政中后期，因其对政事心灰意懒，加上久病不愈无法处理政事，造成了其长达30年的怠政。数十年的怠政造成当时明政府政务废弛的现象，在女真族兴起并侵占明朝东北领土、扩张势力的同时，明神宗依然称疾不上朝，是导致明朝逐步步向灭亡的原因之一[4]。 楚宗之乱，是明神宗万历年间的四次政治案件，是一场由于国本之争引起的一连串东林党争事件，即两次妖书案，两次楚藩案，又称二书二楚。 楚藩案，是明朝万历年间楚国（楚藩）发生的两次事件，即“楚太子案”、“楚宗劫杠案”，学者常认为这是妖书案斗争的一部分，细节可分为“二书二楚”四大案，即“第一次妖书案”、“第二次妖书案”、“楚太子案”、“楚宗劫杠案”等四案。 明末三案 明末三案，是中国明朝末期宫廷中发生的梃击案、红丸案、移宫案的总称。这三起事件引发了满朝士大夫互相侵轧，故有“三大案”之称。事实上早在三大案之前，明神宗万历年间还有二书二楚四案，即两次妖书案，两次楚藩案，这些案件表面上的问题都是所谓的“国本之争”，但实际上是激烈的东林党争，直到南明灭亡为止。 东林党争 东林党争是指明末东林党与阉党以及其他政坛派别之间的争斗，“言事者益裁量执政，执政日与枝柱，水火薄射，讫于明亡。”[1]东林党是明末以江南士大夫为主的政治集团。在东林党之外，还有浙党、齐党、楚党、昆党、宣党等，统称为齐楚浙党（后多加入阉党），东林党争几乎是东林党与全国朋党集团之争。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/中国通史.html":{"url":"Books/Book/history/中国通史.html","title":"《中国通史》","keywords":"","body":"《中国通史》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/第二次世界大战战史.html":{"url":"Books/Book/history/第二次世界大战战史.html","title":"《第二次世界大战战史》","keywords":"","body":"《第二次世界大战战史》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/世界史：从史前到21世纪全球文明的互动.html":{"url":"Books/Book/history/世界史：从史前到21世纪全球文明的互动.html","title":"《世界史：从史前到21世纪全球文明的互动》","keywords":"","body":"《世界史：从史前到21世纪全球文明的互动》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/history/全球通史：从史前史到21世纪.html":{"url":"Books/Book/history/全球通史：从史前史到21世纪.html","title":"《全球通史：从史前史到21世纪》","keywords":"","body":"《全球通史：从史前史到21世纪》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Stock/炒股的智慧.html":{"url":"Books/Stock/炒股的智慧.html","title":"《炒股的智慧》","keywords":"","body":"《炒股的智慧》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/others/上帝掷骰子吗.html":{"url":"Books/Book/others/上帝掷骰子吗.html","title":"《上帝掷骰子吗》","keywords":"","body":"《上帝掷骰子吗》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/others/我不是教你诈.html":{"url":"Books/Book/others/我不是教你诈.html","title":"《我不是教你诈》","keywords":"","body":"《我不是教你诈》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/others/拆掉思维力的墙.html":{"url":"Books/Book/others/拆掉思维力的墙.html","title":"《拆掉思维力的墙》","keywords":"","body":"《拆掉思维力的墙》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/others/最优输运理论专题.html":{"url":"Books/Book/others/最优输运理论专题.html","title":"《最优输运理论专题》","keywords":"","body":"《最优输运理论专题》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"},"Books/Book/others/说话之道.html":{"url":"Books/Book/others/说话之道.html","title":"《说话之道》","keywords":"","body":"《说话之道》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2021-09-20 10:17:54 最后修改: yangzl 2021-09-20 10:17:15创建: yangzl 2021-09-20 10:17:15"}}