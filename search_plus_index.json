{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 程序猿玄微子 个人读书学习笔记 在线阅读请点此 或者 更好的样式请点此 也可以 点此关注作者,不迷路 友情链接 B站 CSDN 知乎 思否 掘金 简书 开源中国 博客园 Github 51CTO博客 InfoQ 腾讯云社区 阿里云社区 GitChat A站 如果你觉得对你有帮助，可以请作者喝一杯咖啡 ^_^ Alipay Donation(通过支付宝捐赠) 或者 WeChat Pay Donation(通过微信捐赠) https://github.com/youngzil/notes/tree/master/ + 目录 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Java/JavaSE/JavaSE.html":{"url":"docs/tech/Java/JavaSE/JavaSE.html","title":"Java","keywords":"","body":" 1、Java基础学习 2、JVM学习 3、Java并发和多线程 4、 5、 Java基础学习 Java基础：IO、集合、多线程、反射字节流和字符流BIO和NIO集合多线程：进程，线程和协程的区别 并发工具类SPIJDK、JDK7、JDK8java agent零拷贝：减少内核态和用户态时的数据重复拷贝，java.nio.channel.FileChannel的transferTo()，transferFrom()方法内存映射文件：mmap()方法java热部署、模块化：jarslink泛型：泛型上限通配符extends与泛型下限通配符super反射初始化环形缓冲区的实现原理（ring buffer）quickstart-disruptorjava锁1、synchronized和lock的用法区别 各自底层原理3、如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源4、java基础：Object有方法java常见的异常Comparable与Comparator的区别Runtime类：获取jvm信息，执行程序什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？java进程间通讯方式（IPC）：Socket，RMI、RPC，共享内存内存泄漏，现象，排查oom的可能原因，排查惊群问题(The \"thundering herd\" problem) Java线程的5种状态及切换Java 语法糖 hashmap数据结构 volidate关键字作用：线程可见性、有序性，不保证原子性 直接内存详解 4、集合：java集合.mdList、Set、Map、Queue并发集合：ConcurrentHashMap、ConcurrentSkipListSet、CopyOnWriteArrayList等 6、反射、java agent，反射初始化：java反射和agent.mdRTTI和反射机制区别反射的使用：获取类、构造方法，成员变量，成员方法、注解、泛型 7、Java的简单类型及其封装器类8、Object类的方法，和Thread类方法的区别9、String StringBuffer,StringBuilder原理：底层的数据结构是 字符数组 char[]10、sleep、wait notyfi都干啥的，sycnized怎么用的，concurrent包下面的锁用过哪些，怎么实现的 33、volatile原理34、数据结构：堆和树35、Queue队列的常用方法36、数组、链表，队列 ，栈，散列表，树，图38、Linux探秘之用户态与内核态39、java进程CPU过高问题如何排查？40、Java8中用sun.misc.Contended避免伪共享(false sharing)41、动态代理和静态代理 23、负载均衡.md:负载均衡算法24、java热部署、模块化：jarslink25、SPI和JDK、JDK7、JDK826、一致性哈希算法(consistent hashing)27、java常见异常28、Comparable与Comparator的区别29、对Runtime的了解:Runtime类30、什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？31、java进程间通信(IPC interProcess communication)：32、如何实现分布式缓存 18、分布式锁实现.md：数据库、redis、zookeeper19、加解密.md：加解密的分类和实现20、单例模式有三种实现方式21、图片加载缓慢优化.md：22、泛型通配符extends与super的区别.md：泛型：泛型上限通配符extends与泛型下限通配符super12、图的遍历，深度广度啊13、内存溢出，内存泄露，，怎么调优，类加载14、BloomFilter 与 CuckooFilter JVM学习 JVM结构、垃圾回收、类加载机制、内存泄露排查 linux系统工具能利用工具排查CPU、内存和网络IO问题排查JVM优化技术JVM参数javaGC、内存模型 jvm诊断命令堆怎么区分的？为什么分代？对象回收，内存等怎么判断是否回收？哪些类型的对象？java中一个类加载过程？主要考虑类加载器过程，加载过程，双亲委派模型oom怎么排查，堆dump、线程dump怎么查看JVM内存模型：五个区域和各自保存的对象，会抛出什么异常：年轻代、年老代、持久代（方法去）、堆外内存（直接内存） 计算机内存模型和CPU缓存一致性协议MESI： 缓存伪共享、 零拷贝：transTo、transFrom、map mmap：安全、高效（zero copy）、gc CPU缓存分类：CPU三级缓存：CPU、L1、L2、L3、主内存 缓存一致性协议：MESI 伪共享(False Sharing)：缓存行进行字节填充，保证头尾加载到不同的缓存行，避免出入对互斥，不能并发，成为伪共享。jdk8中Contended注解 缓存系统中是以缓存行（cache line）为单位存储的：现在64byte，早期32byte，范围32-128byte 缓存段竞争：导致总线风暴 volatile字段：使用内存屏障，保证可见性和有序性，不保证原子性 MESI－CPU缓存一致性协议、JVM内存模型、内存结构 类加载机制（双亲委派），类加载过程 垃圾回收：垃圾收集算法、垃圾收集器，对象存活方式判断，GC Roots包括，类回收条件，堆（年轻代、年老代），java对象的引用（强引用，软引用，弱引用，虚引用） 垃圾回收、内存调优、常见参数 jdk的命令行工具 1、启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 2、JVM类加载机制，哪几种类加载器，类加载之间的父子关系是怎样的？每个类加载器都加载哪些类？classloader的功能和工作模式 3、jvm内存模型： 4、GC策略，GC过程，GCROOTs哪里来的(哪些可以是GCROOTs)，常见的垃圾回收器， 5、oom怎么排查，jvm诊断命令堆dump、线程dump怎么查看 6、jvm类加载机制 内存模型 GC类型、算法、回收机制， jvm诊断命令 jvm学习.md JVM GC日志分析工具： GCHisto、GCViewer JVM内存结构，和Java虚拟机的运行时区域有关。Java内存模型，和Java的并发编程有关。Java对象模型，和Java对象在虚拟机中的表现形式有关。 JAVA中的内存泄露：堆区不断增长，最后不断触发FullGC, 甚至crashjdk的命令行工具：jps、jinfo + jstat 、jmap（-dump、jhat）、jstack堆外内存：原因、场景、使用：存活时间长，大内存的 java对象的引用包括：强引用，软引用，弱引用，虚引用Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。 .java 编译到.class过程？类加载过程java文件编译成class文件的过程类加载过程：校验，加载-双亲委派模型，初始化，卸载等 Java并发和多线程 Java线程的5种状态及切换 java基础：多线程的概念能不能介绍一下线程同步的常见问题，以及怎么处理？ 死锁、饥饿、活锁、 Java线程的5种状态及切换java进程和Linux线程的关系多线程概念：线程同步（两种锁、特殊变量volatile、线程变量ThreadLocal、并发工具类）、线程间通信、线程死锁、线程控制（挂起、停止和恢复）Unsafe类的使用java线程的创建和分类Linux进程间通信线程池：查看ThreadPool.md 线程状态切换的代价 ThreadPoolExecutor或者Executors工具类（4种）来创建 参数：7个 创建线程流程和销毁线程流程 提交任务：execute() 和 submit() execute()：FutureTask（ExecutorCompletionService） submit()：Callable接口、Future接口 RejectedExecutionHandler策略 其他方法：beforeExecute、afterExecute、 ThreadLocal使用：以线程为单位进行隔离，因为WeakReference不会导致内存泄漏，线程复用的时候没有remove可能会导致后面的任务取到前面任务存进去的值，导致程序出错 concurrent包并发、并发工具类：java并发包concurrent和并发工具类.md java并发包concurrent：1、Atomic原子类型：Long、Integer、Boolean、Refrence等2、并发锁Lock锁：ReentrantLock、ReentrantReadWriteLock等3、线程池：Callable接口、Future接口、FutureTask（ExecutorCompletionService）、Executors、ExecutorService、ThreadPoolExecutor、ThreadFactory、4、并发集合：ConcurrentHashMap、ConcurrentSkipListSet、CopyOnWriteArrayList和CopyOnWriteArraySet等5、并发工具类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、ForkJoinPool等Java并发工具类：并发开始：同步屏障CyclicBarrier并发结束：等待多线程完成的CountDownLatch并发控制：控制并发线程数的Semaphore并发交换：两个线程进行数据交换的Exchanger 并发类，如ThreadLocal 、volatile并发编程中的三个概念：原子性，可见性，有序性，和volatile关键字的两层语义java线程状态转换和线程并发Unsafe类的CAS操作java并发基础AQS类.md 在那些场景用了哪些多线程的什么接口 blockqueue中获取数据流程？lock方法？condationconcurrenthashmap并发工具类 多线程用过的一个场景，用了哪些jdk的接口线程池的参数使用，接收任务的流程？执行的流程？线程池中线程空闲销毁原理？等待知道超时销毁？blockqueue从里面去任务，阻塞知道取出任务，源码查看过吗？lock方法？candition怎么使用？并发工具类：四个，concurrenthashmap， 泛型通配符extends与super 1、 泛型上限通配符，只能用于方法返回，只能返回T和T子类型 2、泛型下限通配符，只能用于限定方法入参，只能传入T和T的父类型 3、? 既不能用于入参也不能用于返参 hash冲突解决java读取文件方式javaagentJMXjava内部类 了Java的基础知识，容器类，线程安全和非安全的，多线程相关基础知识，实现方式，死锁的检查与排查1.String， StringBuffer， StringBuilder 的区别，为什么String 不可改变，StringBuilder可以改变？ 3.什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？ Throwable、Error、Exception、RuntimeException 区别和联系各是什么checked exception 和 unchecked exception的区别是什么？volatile的特性是什么？ 可以完美解决多线程同步问题吗？threadlocal有什么用？ 多线程使用有什么需要注意的地方？ 使用完后为什么要remove？synchronized和reentrantlock的底层原理各是什么？ 有什么优缺点？JVM加载class文件的原理机制？为什么要用双亲委托模型？ 如何打破双亲委托模型？职业规划如何？ 为什么要加入蚂蚁金服？ 对未来的期待怎么样？ Java基础：IO、集合、多线程、并发、反射 虚拟机了解多少？服务器上只有jre没有jdk，怎么看文件，启动参数设置oom打印日志 JVM崩溃Log日志和GC日志https://blog.csdn.net/warship_f/article/details/78078945https://blog.csdn.net/Me_ZH/article/details/78700671 JVM 发生OOM的四种情况https://www.cnblogs.com/baizhanshi/p/6704731.html?utm_source=itdadao&utm_medium=referralhttps://blog.csdn.net/pbuzhidaol/article/details/72871898 javaOOM类型.md https://www.cnblogs.com/gdpuzxs/p/7044963.htmlhttps://www.cnblogs.com/ITtangtang/p/3978102.html重写classloader：（1）继承ClassLoader （2）重写findClass（）方法 （3）调用defineClass（）方法 http://www.cnblogs.com/aspirant/p/7200523.html(1)阿里的面试官问我，可以不可以自己写个String类答案：不可以，因为 根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了; (2)能否在加载类的时候，对类的字节码进行修改答案：可以，使用Java探针技术，可以参考：Java探针-Java Agent技术-阿里面试题 什么是类加载器类加载器与类的”相同“判断类加载器种类双亲委派模型类加载过程自定义类加载器JAVA热部署实现 SPI和Class.forName()：SPI使用的是本类加载器，是AppClassLoader，后者使用的Bootstrap ClassLoader 何时触发初始化1、为一个类型创建一个新的对象实例时（比如new、反射、序列化）2、调用一个类型的静态方法时（即在字节码中执行invokestatic指令）3、调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式4、调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）5、初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）6、JVM启动包含main方法的启动类时。 热部署步骤：1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；2、更新class3、使用新的ClassLoader去加载class JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）： 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法 详解Javac将java文件编译为class文件的过程https://blog.csdn.net/shaozengwei/article/details/38659569http://wiki.jikexueyuan.com/project/java-vm/polymorphism.htmlhttp://www.voidcn.com/article/p-dzpxhmqt-bnx.html Java 代码编译和执行的整个过程包含了以下三个重要的机制：1、Java 源码编译机制2、类加载机制3、类执行机制 Java 源码编译由以下三个过程组成：1、分析和输入到符号表2、注解处理3、语义分析和生成 class 文件 最后生成的 class 文件由以下部分组成：1、结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息。2、元数据。对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。3、方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。JVM 的类加载是通过 ClassLoader 及其子类来完成的：双亲委派模型1）Bootstrap ClassLoader负责加载$JAVA_HOME中jre/lib/rt.jar里所有的 class，由 C++ 实现，不是 ClassLoader 子类。 2）Extension ClassLoader负责加载Java平台中扩展功能的一些 jar 包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的 jar 包。 3）App ClassLoader负责记载 classpath 中指定的 jar 包及目录中 class。 4）Custom ClassLoader属于应用程序根据自身需要自定义的 ClassLoader，如 Tomcat、jboss 都会根据 J2EE 规范自行实现 ClassLoader。 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从 Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 Classloader 已加载就视为已加载此类，保证此类只所有 ClassLoade r加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 验证：验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。 初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 类执行机制JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。 编译过程java文件---》class文件：源代码、词法分析、语法分析、语法树、语义分析器、注解抽象语法树、字节码生成器，JVM字节码 Java 语法糖语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 https://my.oschina.net/hosee/blog/618953https://blog.csdn.net/u013256816/article/details/84917112https://blog.csdn.net/varyall/article/details/81283231https://blog.csdn.net/u010454030/article/details/82458413https://blog.csdn.net/qq_27093465/article/details/52279473 hashmap数据结构：线程不安全的，操作丢失put、remove等，扩容造成链表的闭环所致CPU 100%等线程不安全的，安全的有：hashtable、concurrenthashmapjdk7数组+链表，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式jdk8中链表变为红黑树结构，便于查询，JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看红黑树）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。JDK8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树因为在hash冲突严重的情况下，链表的查询效率是O(n），所以JDK8做了优化对于单个链表的个数大于8的链表，会直接转为红黑树结构算是以空间换时间，这样以来查询的效率就变为O(logN) 这个Entry应该放在数组的哪一个位置上（这个位置通常称为位桶或者hash桶，即hash值相同的Entry会放在同一位置，用链表相连），是通过key的hashCode来计算的。当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。 总结一下map.put后的过程：当hashCode 值相同时候，在本链表使用equals方法进行比较，都不相同时才放入数组中，并且next指向之前的链表当向 HashMap 中 put 一对键值时，它会根据 key的 hashCode 值计算出一个位置， 该位置就是此对象准备往数组中存放的位置。如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否是否值相同，map不允许键值对重复)， 如果此链上有对象的话，再去使用 equals方法进行比较，如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。值得注意的是，当key为null时，都放到table[0]中 ConcurrentHashMap扩容：默认16个Segment，在JDK7里面最大并发个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的，简化了并发设计，不足之处在于并发的粒度稍粗在JDK8里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的table元素的读写，好处在于并发的粒度更细，影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像JDK7中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点 如何实现一个并发情况下线程安全性的方案？加锁、排队、线程变量，原子变量threadlocal实现原理？如何实现线程安全？线程为单位隔离，是否会造成内存溢出？ https://blog.csdn.net/hellorichen/article/details/71107594java中一个线程等待另一个线程执行完后再执行：1.notify、wait方法，Java中的唤醒与等待方法，关键为synchronized代码块，参数线程间应相同，也常用Object作为参数2.CountDownLatch类：重要方法为countdown()与await()；一个同步辅助类，常用于某个条件发生后才能执行后续进程。给定计数初始化CountDownLatch，调用countDown(）方法，在计数到达零之前，await方法一直受阻塞。3.join方法：将线程B加入到线程A的尾部，当A执行完后B才执行。4.线程共享一个变量，根据变量状态来判断，类似CountDownLatch类的作用 http://www.importnew.com/14958.htmlhttps://blog.csdn.net/u012050154/article/details/50903326yield()方法：线程的优先权（高中低，1-10，并不是一定的，由调度程序决定哪一个线程被执行，相同优先级通常受时间片管制，但这并不是Java的要求。）：一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。join()方法：线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。 1、sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；2、sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；3、sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态； java基础知识掌握程度一般，对于Java 引用，堆外内存不了解，对于HashMap，线程池了解一点；对于LRU算法实现没有清晰思路；对于并发问题接触较少。 nio的代码，三个标识虚拟机：使用，看问题只有jre，没有jdk，可以设置dumpoutlog 如何快速定位JVM中消耗CPU最多的线程？1、首先我们可以通过top -Hp 来看这个进程里所有线程的 CPU 消耗情况，得到类似下面的数据。可以看到 cpu 最高的线程是 pid 为 18250 的线程，占了 99.8%：2、接着我们可以通过 jstack的输出来看各个线程栈：线程栈我们注意到 nid 的值其实就是线程 ID，它是十六进制的3、我们将消耗 CPU 最高的线程18250，转成十六进制0X47A，然后从上面的线程栈里找到nid=0X47A的线程，然后可以查看其堆栈信息 熟悉IO、多线程、集合理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发;4、熟悉多线程编程，熟练使用java并发包下的各项常用基础设施;5、熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务; 熟悉java concurrent包 ，熟悉高并发，分布式通信，存储等相关技术 扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术；1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；1、Java基础：概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO网络与文件、多线程、concurrent包并发、反射 SOA、环形缓冲区的实现原理（ring buffer）quickstart-disruptor 垃圾回收：垃圾收集算法、垃圾收集器，对象存活方式判断，类回收条件，堆（年轻代、年老代），java对象的引用（强引用，软引用，弱引用，虚引用）方法区垃圾回收：废弃常量、无用的类 finalize()方法不可靠表现2方面判断对象是否存活一般有两种方式、GC Roots包括 内存调优：减少youngGC的频率和fullGC的次数常见参数：废弃类回收的控制参数、堆参数（初始大小，最大大小、年轻代和年老代比例）、设置GC回收器，GC打印格式和文件、HeapDump日志路径、并行收集器设置查看垃圾回收和内存问题定位工具和步骤 类加载机制和双亲委派机制，类加载过程，java创建一个对象的流程类加载机制（双亲委派）：安全、缓存、高效，类加载过程：加载、验证、准备、初始化、卸载，4中类加载器，重写findClass是符合双拼委派机制，重写loadclass是破坏的， ClassLoader可以实现的功能：1、自定义加载类，实现切面功能、方法调用链、代码保护加解密等，如切面log日志，切面其他功能、2、系统开发模块化，比如阿里的jarslink、支付宝的sofaArk3、热部署功能、热加载 2、IO网络与文件BIO是面向流、阻塞IO，顺序读 NIO面向缓冲、非阻塞IO、选择器Selector，可以使用position等跳跃读 AIO 字节流和字符流 输入流、输出流 Channels：4种 Buffers：1+2+3+1 Selectors：4个事件 Buffer分配：3种 方法：常用的读写切换、定位等 buffer读写方法 Buffer的capacity,position和limit https://blog.csdn.net/Big_Blogger/article/details/77654240https://blog.csdn.net/Big_Blogger/article/details/77654240直接内存详解：分配和回收 直接内存：不受young gc的影响，只有full gc的时候回收，当众多的DirectByteBuffer对象从新生代被送入老年代后触发了 full gc才会会释放回收，MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。 （1）直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。（2）直接内存不是分配在JVM堆中。并且直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。（3）MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。 直接内存回收： 1、GC之后，“触发”调用Cleaner.clean() 方法，进而调用Deallocator.run() 在run方法中调用unsafe.freeMemory(long var1)释放堆外内存。 2、当然我也找到一种不需要GC回收由程序员自己回收的方式，不推荐使用((DirectBuffer)buffer).cleaner().clean(); 3、Unsafe进行分配和回收 网络： SocketChannel:创建连接，读写数据，从channel到buffer，从buffer到channel ServerSocketChannel:监听连接，默认是阻塞模式，可以设置为非阻塞模式（while循环） 零拷贝( zero-copy ) 文件IO：通过mmap实现的零拷贝I/O，内存映射文件：mmap()方法 网络IO：FileChannel.transferTo 和 FileChannel.transferFrom方法 零拷贝：减少内核态和用户态时的数据重复拷贝，java.nio.channel.FileChannel的transferTo()，transferFrom()方法 17、synchronized的缺陷：不中断，不并发读，不知道有没有成功获取到锁 Lock和synchronized对比：可重入，不中断，不公平，lock可中断、可公平，并发读，手动释放，是接口类 锁的分类和升级：可升不可降 sleep和wait区别：sleep不会释放对象锁，wait释放对象锁 线程的状态切换 总的来说, Lock + Condition + await()/signal/signalAll ≈ Synchronized + Object.wait()/notify/signalAll Condition原理：线程放入等待链表,可以实现“选择性通知”，而notify由JVM随机选择的 Java8中用sun.misc.Contended避免伪共享(false sharing)：https://blog.csdn.net/aigoogle/article/details/415183691、long padding来避免伪共享2、jdk8新特性，Contended注解避免false sharing：需要在jvm启动时设置-XX:-RestrictContended 动态代理和静态代理.md动态代理：cglib、jdk静态代理：javassist、AspectJ java se：单例锁的种类：可重入锁，阻塞锁，自旋锁：在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。关键字synchronized与wait()和notify()/notifyAll()方法相结合可以实现等待/通知模式。 Lock、Condition+await+signal/signalAllServlet、Filter、Listener线程池的参数、队列、流程、超时原理ExecutorService（ThreadPoolExecutor）：submit()、execute()Callable、Future、FutureTask、ExecutorCompletionService工具类Executorsunsafe的使用：直接内存分配、cas、park线程挂起和恢复ThreadLocal、InheritableThreadLocal GC日志分析工具：GCHistojava对象的引用包括：强引用，软引用，弱引用，虚引用Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。finalize()方法不可靠表现2方面判断对象是否存活一般有两种方式GC Roots包括？内存模型分代：年轻代（一个Eden区，两个Survivor区）、年老代、持久代（java8，元空间，本地内存）young GC、full GC垃圾收集算法：Copying（复制）、Mark-Sweep（标记-清除）、Mark-Compact（标记-整理）、Generational Collection（分代收集）垃圾收集器：串行Serial/Serial Old、Parallel、Parallel Old、并发标记CMS，G1CMS流程：初始标记、并发标记、重新标记、并发清楚，并发重置初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。其中的1，3两个步骤需要暂停所有的应用程序线程的 一致性哈希算法(consistent hashing)http://blog.csdn.net/cywosp/article/details/23397179/https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368https://blog.csdn.net/thinkmo/article/details/26833565一致性hash算法1、使用的MurMurHash算法，是非加密HASH算法，性能很高， 比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免） 等HASH算法要快很多，而且据说这个算法的碰撞率很低. http://murmurhash.googlepages.com/2、使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 把机器和对象使用相同的hash均衡分散到hash环上，对象顺时针放在距离自己最近的机器节点上平衡性：使用虚拟节点来保证，新增或者删除机器节点，对象平衡分散被影响，并且之后的对象依然平衡分散单调性：新增或者删除机器节点，只是影响相邻的部分对象，但按照顺时候移动，可能出现不平衡问题（使用虚节点）分散性：节点hash后分散 Object类的方法getClasshashcodeequalclone()toStringwaitnotifynotifyAllfinalize() Thread类：start、run、sleep、stopObject类：wait、notify、notifyAll，这三个方法都依赖锁对象，所对象可以是任意对象，所以定义在Object中 start()和run()的区别start():启动线程并调用线程中的run()方法。run():执行该线程对象要执行的任务 sleep()和wait()的区别sleep():不释放锁对象，释放CPU使用权在休眠的时间内，不能唤醒。wait():释放锁对象，释放CPU释放权，在等待时间内能被唤醒。 一个英文字母(不分大小写)或者符号占一个字节的空间，一个中文汉字或者符号占两个字节的空间． 字节(Byte):通常将可表示常用英文字符8位二进制称为一字节。 1字节(Byte） = 8位(bit) java常见异常http://blog.csdn.net/qq635785620/article/details/7781026NullPointerException - 空指针引用异常ClassCastException - 类型强制转换异常。IllegalArgumentException - 传递非法参数异常。ArithmeticException - 算术运算异常ArrayStoreException - 向数组中存放与声明类型不兼容对象异常IndexOutOfBoundsException - 下标越界异常NegativeArraySizeException - 创建一个大小为负数的数组错误异常NumberFormatException - 数字格式异常SecurityException - 安全异常UnsupportedOperationException - 不支持的操作异常 RuntimeException当应用程序试图在需要对象的地方使用 null 时，抛出NullPointerException异常当试图将对象强制转换为不是实例的子类时，抛出该异常（ClassCastException)指示索引或者为负，或者超出字符串的大小，抛出StringIndexOutOfBoundsException异常 Throwable、Error、Exception、RuntimeException 区别和联系各是什么 1.Throwable类是 Java 语言中所有错误或异常的超类。它的两个子类是Error和Exception；2.Error是Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。3.Exception类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件4.RuntimeException类是Exception类的子类。RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明。它是Exception的子类。 Exception：1．可以是可被控制(checked) 或不可控制的(unchecked)2．表示一个由程序员导致的错误3．应该在应用程序级被处理 Error：1．总是不可控制的(unchecked)2．经常用来表示系统错误或低层资源的错误3．如何可能的话，应该在系统级被捕捉 Java 中定义了两类异常：　　1) Checked exception: 这类异常都是Exception的子类 。异常的向上抛出机制进行处理，假如子类可能产生A异常，那么在父类中也必须throws A异常。可能导致的问题：代码效率低，耦合度过高。　　2) Unchecked exception: 这类异常都是RuntimeException的子类，虽然RuntimeException同样也是Exception的子类，但是它们是非凡的，它们不能通过client code来试图解决，所以称为Unchecked exception 。您应该知道的是Java 提供了两种Exception 的模式，一种是执行的时候所产生的Exception (Runtime Exception)，另外一种则是受控制的Exception (Checked Exception)。　　所有的Checked Exception 均从java.lang.Exception 继承而来，而Runtime Exception 则继承java.lang.RuntimeException 或java.lang.Error (实际上java.lang.RuntimeException 的上一层也是java.lang.Exception)。 因此从程序的运作机制上看，Runtime Exception与Checked Exception 不一样，然而从逻辑上看，Runtime Exception 与Checked Exception 在使用的目的上也不一样。　　一般而言，Checked Exception 表示这个Exception 必须要被处理，也就是说程序设计者应该已经知道可能会收到某个Exception(因为要try catch住) ，所以程序设计者应该能针对这些不同的Checked Exception 做出不同的处理。　　而Runtime Exception 通常会暗示着程序上的错误，这种错误会导致程序设计者无法处理，而造成程序无法继续执行下去。 讲一下 RunTimeException 的造成的原因「非检查型异常」，并说一下为什么不处理 RunTimeException？ RuntimeException是Exception子类。而Exception还有其它类型的异常，我们统一称为非Runtime异常。 RuntimeException的特点是非检查型异常，也就是Java系统中允许可以不被catch，在运行时抛出。而其它定非运行时异常如果抛出的话必须显示的catch，否则编译不过。 RuntimeException常见异常： 1 NullPointerException，空指针异常。 2 NumberFormatException，字符串转化成数字时。 3 ArrayIndexOutOfBoundsException， 数组越界时。 4 StringIndexOutOfBoundsException， 字符串越界时。 5 ClassCastException，类型转换时。 6 UnsupportedOperationException，该操作不支持，一般子类不实现父类的某些方法时。 7 ArithmeticException，零作为除数等。 8 IllegalArgumentException，表明传递了一个不合法或不正确的参数 运行时出现错误，说明你的代码有问题，程序已经无法继续运行，所以对RuntimeException的处理时不必要的。之所以不处理，目的就是要是程序停止，修正代码。 参考 http://blog.csdn.net/liuj2511981/article/details/8524418http://blog.csdn.net/kingzone_2008/article/details/8535287http://blog.csdn.net/kwu_ganymede/article/details/51382461 Comparable与Comparator的区别http://www.importnew.com/17434.htmlComparable：bean实现该接口，//Collections.sort(list)（Arrays.sort）; 两种方式都可以，此种方式源码中就是调用的list.sort(null)Comparator：bean不需要实现该接口，直接当做实现传递给Collections.sort(list)（Arrays.sort）Collections.sort(list, new Comparator() { @Override public int compare(Employee o1, Employee o2) { return o1.getSalary() - o2.getSalary(); } }); 一、Comparator强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。接口方法： int compare(Object o1, Object o2); 二、Comparable强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。接口方法： int compareTo(Object o);Comparable的用法一般来说，Comparable是为了对某个类的集合进行排序，所以此时一般都是这个需要排序的类本身去实现Comparable接口。换句话说，如果某个类实现了Comparable接口，那么这个类的数组或者说List就可以进行排序了。 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用：1、类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身2、可以使用多种排序标准，比如升序、降序等 Comparable & Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序， Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。 对Runtime的了解:Runtime类Runtime:运行时，是一个封装了JVM的类。每一个JAVA程序实际上都是启动了一个JVM进程，每一个JVM进程都对应一个Runtime实例，此实例是由JVM为其实例化的。所以我们不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。查看官方文档可以看到，Runtime类中没有构造方法，本类的构造方法被私有化了， 所以才会有getRuntime方法返回本来的实例化对象，这与单例设计模式不谋而合public static Runtime getRuntime() 注意：Runtime类本身就是单例设计模式的一种应用，因为整个JVM中只存在一个Runtime类的对象，可以使用Runtime类取得JVM的系统信息，或者使用gc()方法释放掉垃圾空间，还可以运行本机的程序run.exec(\"notepad.exe\")exec()方法的返回值是Process类，Process类也有一些方法可以使用，比如结束一个进程，通过destroy()结束 什么是线程死锁？如何避免线程死锁？如何加一个线程死锁检查机制？http://blog.csdn.net/ls5718/article/details/51896159死锁检测：http://blog.csdn.net/littleschemer/article/details/47449911https://www.cnblogs.com/lovedesy123/p/7752077.html死锁的定义多线程以及多进程改善了系统资源的利用率并提高了系统 的处理能力。然而，并发执行也带来了新的问题——死锁。所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 互斥锁(mutex)Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。 二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。 死锁产生的原因产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。1、互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。2、不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。3、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。4、循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有，如图2-15所示。 如何避免死锁在有些情况下死锁是可以避免的。三种用于避免死锁的技术：1、加锁顺序（线程按照一定的顺序加锁）【破坏循环等待条件】2、加锁时限、或 一次加锁所有的资源（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题【破坏请求保持条件】3、使用锁等待机制：Java 显示锁支持通知(notify/notifyall)和等待(wait)【破坏不可剥夺条件】3、死锁检测一个简单的死锁检测算法每个进程、每个资源制定唯一编号设定一张资源分配表，记录各进程与占用资源之间的关系设置一张进程等待表，记录各进程与要申请资源之间的关系 死锁恢复打破死锁有两种方法：（1）简单地终止一个或多个进程以打破循环等待。——进程终止（2）从一个或多个死锁进程那里抢占一个或多个资源。——资源抢占进程终止有以下两中方法：（i）终止所有死锁进程。（II)一次只终止一个进程直到取消死锁循环为止。如果选择资源抢占，那么将必须考虑三个问题：（i）选择一个牺牲品（II）回滚（III）饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品） jstack可以看到Found one Java-level deadlockpstack： 功能是打印输出此进程的堆栈信息。可以输出所有线程的调用关系栈jstack：jstack是java虚拟机自带的一种堆栈跟踪工具，所以仅适用于java程序，功能跟pstack一样，但是更强大，可以提示哪个地方可能死锁了。 pstack和jstack判断死锁，都需要多执行几次命令，观察每次的输出结果，才能推测是否死锁了。 java进程间通信(IPC interProcess communication)：除了上面提到的Socket之外，当然首选的IPC可以使用Rmi，或者Corba也可以。另外Java nio的MappedByteBuffer也可以通过内存映射文件来实现进程间通信(共享内存)。远程过程调用（Remote Procedure Call, RPC）远程方法调用（Remote Method Invocation, RMI） 在java中主要的通信方式有以下几种：1、socket通信2、RMI（远程方法调用）3、消息队列（第三方框架Kafka，ActiveMQ等）4、JMX（java management extensions）java扩展管理5、文件共享，文件锁（一个进程向文件中写文件，一个负责读文件）6、信号 7、信号量 java进程CPU过高问题如何排查？一般JAVA进程CPU过高主要是程序中出现了死循环，死循环会导致两种情况：第一种，死循环本身不需要耗费太多CPU时间，但会不停创建对象，从而导致java堆内存溢出，但有时候内存快占满了，没有报内存移除错误，JVM在不停的做FGC，从而出现CPU使用超过100%；第二种情况，就是死循环内有请求资源或者网络连接等操作； 第一种情况需要dump出当前jvm内存对象进行分析，找到导致JVM频繁做FGC的对象，再结合业务代码定位具体代码位置；第二种情况需要查找占用cpu时间的线程，根据线程代码提示定位具体出问题的代码。 第一种情况分析方法： 通过top命令查看当前系统CPU使用情况，定位CPU使用率超过100%的进程ID； jstat -gc pid time 命令查看JVM垃圾回收情况，time参数是统计频率，一般1-3秒都可以，若出现频繁的FGC，则需要进一步分析内存情况； 用命令jmap -dump:format=b,file=test.dump pid导出当前进程内存信息，然后用MAT工具进行分析，即可找出问题； 第二种情况的分析方法： 通过top命令查看当前系统CPU使用情况，定位CPU使用率超过100%的进程ID； 通过ps aux | grep PID命令进一步确定具体的线程信息； 通过ps -mp pid -o THREAD,tid,time命令显示线程信息列表，然后找到耗时的线程ID； 将需要的线程ID转换为16进制格式：printf \"%x\\n\" tid 最后找到线程堆栈信息：jstack pid |grep tid -A 30,其中tid是上面转换后的16进制的线程ID这样就找到了最终导致CPU100%的代码了，然后就是对具体的代码分析原因。 volatile原理：http://blog.csdn.net/opensure/article/details/46669337Java中Volatile底层原理与应用：内存屏障http://blog.csdn.net/u012465296/article/details/53020676volatile是一种“轻量级的锁”，它能保证锁的可见性，但不能保证锁的原子性。 http://ifeve.com/memory-barriers-or-fences/内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。Java内存模型中volatile变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。 缓存一致性：http://www.infoq.com/cn/articles/cache-coherency-primerhttp://www.infoq.com/cn/articles/atomic-operations-and-contentionMESI－CPU缓存一致性协议：http://blog.csdn.net/realxie/article/details/7317630volatile使用场景：Double-Check Locking，缓存对象的map等（不保证原子性，使用在并发环境下的原子操作情况下）一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。3）并发编程中的三个概念：原子性，可见性，有序性，volatile只保证可见性和有序性，不保证原子性1、CPU的三级缓存，volatile的缓存失效是指的cpu的二级缓存，CPU的三级缓存：一级在CPU内部，容量小，速度快，二级是在CPU和内存之间的，当线程需要读取数据时候，先读取缓存，不存在才读取内存数据，三级缓存是对二级缓存的补充。2、普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前可以立即从内存刷新，即一个线程修改了某个变量的值，其它线程读取的话肯定能看到新的值；3、Lock前缀指令会引起处理器缓存回写到内存。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。1）将当前处理器缓存行的数据会写回到系统内存。它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。2）这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。关键点：其实相当于线程 像缓存行写数据的时候，会锁住缓存行，是其他线程不能读，写完后失效缓存行，其他线程便可以从内存读到共享变量的最新值了；4、如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 当CPU看到一条读内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段。如果没有，它会把整个缓存段从内存（或者从更高一级的缓存，如果有的话）中加载进来。是的，一次加载整个缓存段，这是基于这样一个假设：内存访问倾向于本地化（localized），如果我们当前需要某个地址的数据，那么很可能我们马上要访问它的邻近地址。一旦缓存段被加载到缓存中，读指令就可以正常进行读取。 如果我们只处理读操作，那么事情会很简单，因为所有级别的缓存都遵守以下规律，我称之为：基本定律：在任意时刻，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。一旦我们允许写操作，事情就变得复杂一点了。这里有两种基本的写模式：直写（write-through）和回写（write-back）。 直接模式更简单，但是回写模式有它的优势：它能过滤掉对同一地址的反复写操作，并且，如果大多数缓存段都在回写模式下工作，那么系统经常可以一下子写一大片内存，而不是分成小块来写，前者的效率更高。 不同的级别缓存可能使用不同的写策略，所以缓存行大小也可能不同。 MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。MESI协议（译者注：MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态失效（Invalid）缓存段、共享（Shared）缓存段、独占（Exclusive）缓存段、已修改（Modified）缓存段，属于脏段只有E、M状态下的缓存才能写，也就是在写之前，先申请独占，使其他的CPU的同段缓存失效 1、缓存行：所谓缓存行就是缓存中可以分配的最小存储单位。一般是64字节，老的是32字节如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽缓存是分“段”（line）的，一个段对应一块存储空间，大小是32（较早的ARM、90年代/2000年代早期的x86和PowerPC）、64（较新的ARM和x86）或128（较新的Power ISA机器）字节。我们会看到有CPU的一级缓存是32字节，而二级缓存却有128字节。2、缓存伪共享：因为对于英特尔酷睿i7，酷睿， Atom和NetBurst， Core Solo和Pentium M处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，导致一个缓存行加载多个共享变量，一个处理器锁定时，锁定该缓存行时候，多锁定了对象，导致其他处理器处理不了，变为锁的互斥性，导致不能并发，成为伪共享如JDK7的并发包里新增一个队列集合类LinkedTransferQueue（它使用一个内部类类型来定义队列的头队列（Head）和尾节点（tail）），JDK加载时候会把头尾分别进行字节填充，保证头尾加载到不同的缓存行，避免出入对互斥，不能并发，成为伪共享。Java8中用sun.misc.Contended避免伪共享(false sharing)：https://blog.csdn.net/aigoogle/article/details/415183691、long padding来避免伪共享2、jdk8新特性，Contended注解避免false sharing：需要在jvm启动时设置-XX:-RestrictContended3、CPU处理器的缓存三级：L1、L2、L3，最早CPU和L1通信，L1和内存通信，现在CPU--》L1--》L2--》内存L1　Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，容量小L2 Cache 都在CPU中L3　Cache(三级缓存)，分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。降低内存延迟和提升大数据量计算能力对游戏都很有帮助。4、缓存一致性协议MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。MESI协议（译者注：MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态失效（Invalid）缓存段、共享（Shared）缓存段、独占（Exclusive）缓存段、已修改（Modified）缓存段，属于脏段只有E、M状态下的缓存才能写，也就是在写之前，先申请独占，使其他的CPU的同段缓存失效 缓存段竞争：要产生缓存段竞争，我们需要多个处理器频繁访问同一缓存段，并且其中部分的访问是写操作。如果两个或多个处理器频繁地访问相同的缓存段，那么这些缓存段的内容必须保持同步。如果想更新其中一个缓存段的内容，必须先获得独占权，这意味着其他所有处理器必须先丢弃它们缓存中的同一缓存段的拷贝。这带来的结果是，下一次有另外一个处理器要访问这个缓存段，它的内容必须先通过总线来加载。所以结果就是缓存失效率（对于其他处理器来说）和总线上额外的通讯流量都增加了。这种多个处理器访问一个频繁被更新的缓存段的现象，叫做“缓存（段）竞争”。如果你想在多个处理器共用内存的环境中拖慢一个并行的程序，这也许是最简单的方法。总线风暴：总线上额外的通讯流量增加很多 数据结构：堆和树http://blog.csdn.net/juanqinyang/article/details/51418629http://blog.csdn.net/leex_brave/article/details/51490647堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。堆优先顺序就是大的元素排在前面，小的元素排在后面，这样得到的堆称为最大堆。最大堆中堆顶的元素是整个堆中最大的，并且每一个分支也可以看成一个最大堆。同样的，我们可以定义最小堆， 树：树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。http://blog.jobbole.com/111680/http://blog.csdn.net/HaoDaWang/article/details/78065162?locationNum=2&fps=1 1二叉树：每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。2满二叉树：一个深度为k(>=-1)且有2^(k+1) - 1个结点的二叉树称为满二叉树。3完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。4平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。平衡查找树之AVL树平衡二叉树之红黑树B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。B+树是B树的变体，也是一种多路搜索树，叶子节点指向下一个叶子节点B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。 Queue队列的常用方法Queue方法：add、remove、element 抛异常offer、poll、peek 返回booleanput、take 阻塞 队列：FIFO，栈：FILO 数组、链表，队列 ，栈，散列表，树，图：http://blog.csdn.net/mz454619501/article/details/46652317http://blog.csdn.net/hhu1506010220/article/details/52128383http://blog.csdn.net/wei78008023/article/details/50735415http://blog.csdn.net/qq_15654993/article/details/75267581http://blog.csdn.net/RodeStillFaraway/article/details/50530142常用数据结构的时间复杂度：http://blog.csdn.net/CloudyBird/article/details/51206789数组Array：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的链表Linked List：非连续非顺序的存储结构，循环链表和单链表、双向链表，链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。队列Queue：FIFO，顺序队列和循序队列栈Stack：FILO散列表Hash表:树Tree：树（tree）是包含n（n>0）个结点的有穷集堆Heap：图Graph： 访问数组中第 n 个数据的时间花费是 O(1) 但是要在数组中查找一个指定的数据则是 O(N)。当向数组中插入或者删除数据的时候，最好的情况是在数组的末尾进行操作，时间复杂度是O(1) ，但是最坏情况是插入或者删除第一个数据，时间复杂度是 O(N) 。在数组的任意位置插入或者删除数据的时候，后面的数据全部需要移动，移动的数据还是和数据个数有关所以总体的时间复杂度仍然是 O(N) 。 在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ，但是插入和删除数据的时间复杂度是 O(1) ，因为只需要调整指针就可以 基本概念 程序 = 算法 + 数据结构 数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。 常见数据结构 集合：set，multiset 线性结构：数组、链表、队列、栈 树形结构：二叉树及其变型，线段树 图形结构：各种图 数据结构体系图： Java线程的5种状态及切换(透彻讲解)https://www.cnblogs.com/nwnu-daizh/p/8036156.htmlhttp://blog.csdn.net/pange1991/article/details/53860651 新建-->就绪-->运行-->死亡（start(),获取cpu时间片,run/main结束）运行-->阻塞-->就绪-->运行（sleep、t2.join、等用户输入，3中阻塞条件结束，获取cpu时间片）运行-->等待队列-->锁池队列-->就绪（wait()+notify/notifyAll、synchronized(obj) ）运行-->就绪（yield()、时间片用完） 在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，让出cpu该其他线程，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 Linux探秘之用户态与内核态 https://blog.csdn.net/qq_39823627/article/details/78736650https://blog.csdn.net/qq_42022528/article/details/87860311https://www.jianshu.com/p/85e931636f27https://www.cnblogs.com/xuhj001/p/3374440.html用户态和内核态的理解和区别： 执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。比如linux进程有4GB地址空间，可能0G-3G是用户空间，3G-4G大部分是共享的，是内核态的地址空间。这里存放整个内核的代码和所有的内核模块以及内核所维护的数据。 用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。 用户态和内核态的区别：1、特权等级不同，安全2、集中管理，减少有限资源的访问和使用冲突 内核态：硬盘读取数据, 网络数据发送、或者从键盘获取输入等CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序 用户态只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 :用户态 和 内核态 用户态和内核态的切换：当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果 用户态切换到内核态的3种方式：系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。（1）系统调用：fork（）等（2）异常：如缺页异常（3）外围设备的中断 Linux探秘之用户态与内核态https://www.cnblogs.com/bakari/p/5520860.htmlhttps://www.cnblogs.com/yuyang0920/p/7278446.htmlhttp://blog.csdn.net/benjamin721/article/details/51316596http://blog.csdn.net/ljlstart/article/details/51279184http://blog.csdn.net/u014142287/article/details/51934940 Linux零拷贝zero-copy技术：减少数据在内核和用户空间之间拷贝次数https://www.jianshu.com/p/fad3339e3448https://www.cnblogs.com/metoy/p/4033366.htmlhttp://blog.csdn.net/hzrandd/article/details/51025341http://blog.csdn.net/linsongbin1/article/details/77650105当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上。 减少拷贝次数的一种方法是调用mmap()来代替read调用应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。 内存映射文件File Mapping在大文件或者非常频繁的文件操作中内存映射文件性能较高的原因http://blog.csdn.net/whoamiyang/article/details/53365385https://www.oschina.net/translate/10-things-to-know-about-memory-mapped-file-in-javahttps://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6 内存映射文件的效率原因是read()是系统调用，其中进行了数据 拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，如图2中过程1，然后再将这些数据拷贝到用户空间，如图2中过程2，在这个过程中，实际上完成 了两次数据拷贝 ；而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 一次数据拷贝 。因此，内存映射的效率要比read/write效率高。 数据共享编辑文件数据共享这种数据共享是让两个或多个进程映射同一文件映射对象的视图，即它们在共享同一物理存储页。这样，当一个进程向内存映射文件的一个视图写入数据时，其他的进程立即在自己的视图中看到变化。注意，对文件映射对象要使用同一名字。访问方法这样，文件内的数据就可以用内存读/写指令来访问，而不是用ReadFile和WriteFile这样的I/O系统函数，从而提高了文件存取速度。 为什么使用缓冲区读取文件会比不使用快:原因是每次进行IO操作,都要从用户态陷入内核态,由内核把数据从磁盘中读到内核缓冲区,再由内核缓冲区到用户缓冲区,如果没有buffer，读取都需要从用户态到内核态切换，而这种切换很耗时，所以，采用预读，减少IO次数，如果有buffer,根据局部性原理,就会一次多读数据,放到缓冲区中,减少了IO次数. pageCachehttps://blog.csdn.net/iter_zc/article/details/44195731https://blog.csdn.net/kisimple/article/details/42559779 String StringBuffer,StringBuilder原理 String对象有final修饰，是不可变的，也可以理解为常量，显然是线程安全的。 StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。 　　抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。 　　StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。 　　最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 因为StringBuilder是线程不安全的，直接调用了父类的方法，而StringBuffer中每个方法都加了synchronized，保证了线程安全，其他全部一样。 StringBuffer与Stringbuilder用法完全相同，但是StringBuffer的线程是安全的，执行速度慢，StringBuilderd执行速度快，线程不安全，遇到多线程时，用StringBuffer。 StringBuffer与StringBilder使用时都不改变字符串的地址。 String使用时改变字符串地址。 因为String是一个不可变的字符串，每次追加会生成一个新字符串，在最新的jdk中 + 也是调用StringBuilder来实现的 而StringBuffer和StringBuilder是在原基础上追加。 本身都是通过字符数组来存储，对象内部定义字符数组String：new是放在堆区，+或者substring都是通过改变字符数组生成新的字符数组来实现一个是非同步的StringBuilder，一个是同步的StringBuffer（synchronized在方法上），都是字符数组，append时先扩容，把字符数组拷贝到一个新的大的字符数组，再进行拼接，还是拼接拷贝到一个新的字符数组， https://blog.csdn.net/qq_42022528/article/details/87860311 线程状态切换的代价： 因为线程切换也是需要时间的，就跟自旋锁和互斥锁的效率一样，线程睡眠和唤醒也是需要时间和消耗资源的。 java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。 synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。所以明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Java/JVM/GraalVM.html":{"url":"docs/tech/Java/JVM/GraalVM.html","title":"GraalVM","keywords":"","body":"GraalVM GraalVM介绍 GraalVM官网 GraalVM 简介 GraalVM文档 GraalVM Github 解密新一代 Java JIT 编译器 Graal 官网的描述 High Performanсe. Cloud Native. Polyglot. 高性能。云原生。多语种。 它的口号: GraalVM: Run Programs Faster Anywhere 🚀 GraalVM is a high-performance JDK distribution designed to accelerate the execution of applications written in Java and other JVM languages along with support for JavaScript, Ruby, Python, and a number of other popular languages. GraalVM 是一个高性能 JDK 发行版，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时支持 JavaScript、Ruby、Python 和许多其他流行语言。 GraalVM为 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 除了运行 Java 和基于 JVM 的语言之外，GraalVM 的语言实现框架 (Truffle)使得在 JVM 上运行 JavaScript、Ruby、Python 和许多其他流行语言成为可能。借助 GraalVM Truffle，Java 和其他支持的语言可以直接互操作，并在同一内存空间中来回传递数据。 2018年4月，Oracle Labs新公开了一项黑科技：Graal VM，从它的口号“Run Programs Faster Anywhere”就能感觉到一颗蓬勃的野心，这句话显然是与1995年Java刚诞生时的“Write Once，Run Anywhere”在遥相呼应。 Graal VM被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用，这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等等。Graal VM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。 参考 Graal VM：云原生时代的Java LLVM项目 LLVM项目是模块化、可重用的编译器以及工具链技术的集合。 LLVM是一套编译器基础设施项目，为自由软件，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种程式语言而写成的程式，利用虚拟技术创造出编译时期、链结时期、执行时期以及“闲置时期”的最佳化。 它最早以C/C++为实作对象，而目前它已支援包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Crystal、Rust、Scala[1]以及C#[2]等语言。 深入浅出让你理解什么是LLVM LLVM官网 LLVM Github LLVM 维基百科 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Java/JavaSE/IO.html":{"url":"docs/tech/Java/JavaSE/IO.html","title":"I/O","keywords":"","body":"I/O BIO,NIO,AIO 总结 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Java/JavaSE/Java8.html":{"url":"docs/tech/Java/JavaSE/Java8.html","title":"Java8","keywords":"","body":"Java8 Java 8 新特性总结 Java 8 学习资源推荐 Java8 forEach 指南 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/阿里巴巴Java开发手册.html":{"url":"docs/tech/others/阿里巴巴Java开发手册.html","title":"阿里巴巴Java开发手册","keywords":"","body":"《阿里巴巴Java开发手册》 官网 阿里代码规范检测工具 阿里代码开发规范 四、安全规约 【强制】用户请求传入的任何参数必须做有效性验证。 说明:忽略参数校验可能导致: ⚫ page size 过大导致内存溢出 ⚫ 恶意 order by 导致数据库慢查询 ⚫ 任意重定向 ⚫ SQL 注入 ⚫ 反序列化注入 ⚫ 正则输入源串拒绝服务 ReDoS 说明:Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻 击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 【强制】表单、AJAX提交必须执行CSRF安全验证。 说明:CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用 /网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中 用户参数进行相应修改。 五、MySQL 数据库 (二) 索引规约---------再看一遍 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Java/JavaSE/读书和笔记.html":{"url":"docs/tech/Java/JavaSE/读书和笔记.html","title":"读书和笔记","keywords":"","body":"读书和笔记 Java 编程规范以及优雅 Java 代码实践总结 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Framework/Framework.html":{"url":"docs/tech/Framework/Framework.html","title":"常用框架","keywords":"","body":"常用框架 1、 2、 3、 4、 5、 Disruptor 无锁队列Disruptor Guava Guava工具类 apache-commons框架 apache-commons学习.md Servlet Servlet3异步NIO Guice 依赖注入框架 Crypto 加解密工具 字节码框架ASM 字节码修改工具 jOOQ Object Oriented QueryingjOOQ面向对象查询 quickstart-jool jOOλ，Java lambdas和Stream APIquickstart-joor jOOR - 更好地进行Java反射。quickstart-joou jOOU - 无符号整数，Object Oriented Unsigned无符号的quickstart-joox jOOX - 应用于W3C DOM的jQuery的强大功能 logging框架 日志框架：logback、log4j2、log4j、jul JSON框架 json工具：fastjson、Gson、jackson等 Reflect反射 Java反射框架：reflections等 YAML框架 yaml文件解析 XML框架 quickstart-xbean java XML解析 quickstart-xml quickstart-xmlbeans JVM序列化框架 JVM序列化工具：jdk、fst、kryo、hession、thrift等 String字符串压缩 字符串压缩 FastDFS FastDFS是一个开源的分布式文件系统 Quartz Quartz是一个开源的作业调度框架 JFinal JAVA 极速WEB+ORM框架 JFinal UUID UUID工具类 Objenesis框架 Objenesis是一个专用于在创建对象时绕过构造函数的库。在任何JVM上都有。 Proxy代理 动态代理和静态代理，Java Agent，字节码工具等 Java和Kotlin、Groovy、Scala的代码和相互调用 其他语言： Java和Kotlin、Groovy、Scala的代码和相互调用 /Users/yangzl/git/quickstart-framework/quickstart-kotlin quickstart-groovy quickstart-kotlin quickstart-scala 其他框架 quickstart-lombok lombok框架 quickstart-elastic-job Elastic-Job 是一个分布式调度解决方案 quickstart-hppc Java集合类扩展 quickstart-websocket websocket协议使用 quickstart-velocity Velocity是一个基于Java的模板引擎 quickstart-jgit Java git工具 quickstart-jython Jython是一种完整的语言，而不是一个Java翻译器或仅仅是一个Python编译器，它是一个Python语言在Java中的完全实现。 quickstart-jctools JCTools是一款对jdk并发数据结构进行增强的并发工具，主要提供了map以及queue的增强数据结构。 quickstart-machine-learning 机器学习相关 quickstart-mnemonic Apache Mnemonic 是一个面向非易失性混合内存存储的库，它提出了一个非易失性/持久的 Java 对象模型和持久的计算服务，能显着提高了海量实时数据处理/分析的性能。 quickstart-web JavaWeb框架 quickstart-proguard Java混淆器 ProGuard，我们通常说的proguard包括四个功能，shrinker（压缩）, optimizer（优化）,obfuscator（混淆）,preverifier（预校验）。 lintcode等： quickstart-code lintcode等刷题、剑指Offer 微服务、Web框架 quickstart-dropwizard Dropwizard与Spring Boot类似，也是构建微服务可选的工具 quickstart-plexus Plexus——Spring之外的IoC容器 quickstart-servicecomb ServiceComb 是华为开源的一套包含代码框架生成，服务注册发现，负载均衡，服务可靠性（容错熔断，限流降级，调用链追踪）等功能的微服务框架。 apache-commons学习.md 常用刷题网站和博客.md 剑指Offer学习 2、Disruptor学习.md 无锁队列Disruptor 3、Guava学习.md 4、javaSE基础知识点 quickstart-javase 5、JSON框架学习 quickstart-json 6、Linux学习 quickstart-linux 7、日志框架 quickstart-logging 8、Lua学习.md 9、java代理学习 quickstart-proxy 动态代理和静态代理的区别 静态代理优缺点 动态代理优缺点 cglib和Jdk动态代理的区别 10、java Servlet学习 quickstart-servlet 11、javaWeb学习 quickstart-web 12、 熟悉分布式、缓存、消息队列等中间件技术熟悉常用设计模式熟悉并对javaEE、SOA、spring、osgi等技术潮流保持关注，有数据库、分布式、性能优化、高并发、高可用性系统设计开发经验 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Framework/serializer/序列化和反序列化.html":{"url":"docs/tech/Framework/serializer/序列化和反序列化.html","title":"序列化和反序列化","keywords":"","body":"序列化和反序列化 什么是序列化？ 序列化是将数据结构或对象状态转换为二进制或文本形式以通过网络传输数据或存储在某些持久存储上的过程。一旦数据通过网络传输或从持久存储中检索，它需要再次反序列化。序列化称为编组，反序列化称为解组。 数据序列化有两个目标 用于持久存储 通过网络传输数据 Java中的序列化 Java 提供了一种称为对象序列化的机制，其中对象可以表示为字节序列，其中包括对象的数据以及有关对象类型和存储在对象中的数据类型的信息。 序列化对象写入文件后，可以从文件中读取并反序列化。也就是说，表示对象及其数据的类型信息和字节可用于在内存中重新创建对象。 ObjectInputStream和ObjectOutputStream类分别用于在 Java 中序列化和反序列化对象。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Framework/serializer/Avro.html":{"url":"docs/tech/Framework/serializer/Avro.html","title":"Avro","keywords":"","body":"要通过网络传输数据或其持久存储，您需要序列化数据。在Java 和 Hadoop 提供的序列化 API之前，我们有一个特殊的实用程序，称为Avro，这是一种基于模式的序列化技术。 Apache Avro 是一种语言中立的数据序列化系统。它是由 Hadoop 之父 Doug Cut 开发的。由于 Hadoop 可写类缺乏语言可移植性，Avro 变得非常有用，因为它处理可以由多种语言处理的数据格式。Avro 是在 Hadoop 中序列化数据的首选工具。 Avro 有一个基于模式的系统。独立于语言的模式与其读写操作相关联。Avro 序列化具有内置架构的数据。Avro 将数据序列化为紧凑的二进制格式，可以被任何应用程序反序列化。 Avro 使用 JSON 格式来声明数据结构。目前，它支持 Java、C、C++、C#、Python 和 Ruby 等语言。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Framework/Quartz/Linux、Spring、Quartz%20定时任务表达式格式说明.html":{"url":"docs/tech/Framework/Quartz/Linux、Spring、Quartz%20定时任务表达式格式说明.html","title":"Linux Java(Spring) Java(Quartz) 定时任务表达式格式说明，对比","keywords":"","body":"Linux Java(Spring) Java(Quartz) 定时任务表达式格式说明，对比 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:50:24 "},"docs/tech/MQ/MQ消息.html":{"url":"docs/tech/MQ/MQ消息.html","title":"MQ消息组件","keywords":"","body":"MQ消息 MQ消息 1、RocketMQ 2、ActiveMQ 3、Kafka 4、RabbitMQ 5、MQTT 6、OpenMessaging activemq-apollo 支持STOMP协议，已经废弃 RocketMQ 消息类型： 从通讯方式：同步、异步、oneway 普通消息tag消息顺序消息事务消息延时消息（定时消息）优先级消息（activemq） RocketMQ系统部署架构：Namesrv 和 Broker（Master、Slave）RocketMQ生产者模型、消费者模型RocketMQ存储模型:offset-->commitlog-->mmap 生产者发送流程发送普通消息负载发送顺序消息发送事务消息 Broker：broker消息存储过程、创建文件机制、刷盘机制broker查找消息过程如果想把一台broker下掉，但不能影响线上消息。RocketMQ的文件 主题和消息：消息发送到消费流程消息重复原因和消费幂等的必要性线上关闭Topic自动创建事务消息流程 消费者问题：1、多个消费者只有一个消费者消费：instanceId相同的问题2、全新的消费组第一次上线，设置从尾部开始消费，但是实际从头开始消费，如果是老的消费组重新上线，就从上次消费过的位置继续消费3、消费组中的消费者负载均衡4、 RocketMQ和kafka的区别RocketMQ和ActiveMQ的区别常见问题 ActiveMQ JMS的基本组成：ConnectionFactory，Connection，Session，Destination（queue，topic），Producer，Consumer，Message（TextMessage、MapMessage、BytesMessage、StreamMessage和ObjectMessage） JMS规范JMS消息组成：JMS消息由3部分组成：消息头、属性和消息体 Activemq的同步和异步消息ActiveMQ顺序消息：consumer之独有消费者（exclusive consumer）、 Message Groups特性 activemq开启jmx监控ActiveMQ的共享文件方式部署手册LevelDB部署 Kafka Kafka生产、保存、消费流程Kafka在zk上注册的节点Producer和Consumer说明.mdkafka架构内部原理查找消息同一分区消息乱序 RabbitMQ MQTT OpenMessaging 参考消息分类ActiveMQ学习RocketMQ学习Kafka学习 Rocketmq原理https://blog.csdn.net/wuzhengfei1112/article/details/78076718 Activemq和Rocketmq：实现的协议：存储消息的方式和处理：生产端和消费端 activemq、Rocketmq、rabbitmq、 自己做的消息组件框架的封装模式？为什么这么做？封装了哪些消息中间件，各个消息中间件的原理，区别？主题、队列等怎么统一适配？封装了哪些功能？服务端？客户端？一般用什么消息组件？为什么？遇到有什么问题？rocketmq数据存储方式：数据头+消息体，根据消息头判断读取多大的消息体先读取固定长度的消息头，消息头中含有消息体的大小，再从消息头开始往后读取消息体大小的数据作为消息体内容内存映射文件作用：效率，安全不丢失 消息中间件：openmq、zeromq、hivemq、hornetq、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Pulsar.html":{"url":"docs/tech/MQ/Pulsar.html","title":"Pulsar","keywords":"","body":"Pulsar Pulsar是一个分布式pub-sub消息平台，具有非常灵活的消息传递模型和直观的客户端API。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Kafka/Kafka部署.html":{"url":"docs/tech/MQ/Kafka/Kafka部署.html","title":"Kafka部署","keywords":"","body":"Kafka部署 参考 quickstart-kafka Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Kafka/Kafka命令.html":{"url":"docs/tech/MQ/Kafka/Kafka命令.html","title":"Kafka命令","keywords":"","body":"Kafka命令 Kafka操作命令 查看kafka的zookeeper上的数据 Kafka操作命令 启动 bin/zookeeper-server-start.sh config/zookeeper.properties & bin/kafka-server-start.sh config/server.properties & 或者 nohup sh bin/zookeeper-server-start.sh config/zookeeper.properties & nohup sh bin/kafka-server-start.sh config/server.properties & 停止 bin/zookeeper-server-stop.sh bin/kafka-server-stop.sh 创建主题Topic #replication-factor 表示该topic需要在不同的broker中保存几份, partitions为几个分区 现在我们要创建一个含有6个Partition分区，每个分区3个备份的topic： bin/kafka-topics.sh --create --partitions 6 --replication-factor 3 --topic topic03 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 老的版本使用zookeeper地址 bin/kafka-topics.sh --create --partitions 6 --replication-factor 3 --topic localhost.test.topic --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka 列出主题列表 bin/kafka-topics.sh --list --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-topics.sh --list --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka 查看主题详细信息 bin/kafka-topics.sh --describe --topic topic03 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 一次查询多个topic bin/kafka-topics.sh --describe --topic k2.tomcat.log,k2.tomcat.log2 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-topics.sh --describe --topic topic03 --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka 一次查询多个topic bin/kafka-topics.sh --describe --topic topic01,topic02,topic03 --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka Topic:dream PartitionCount:5 ReplicationFactor:2 Configs: Topic: topic01 Partition: 0 Leader: 1 Replicas: 1,2 Isr: 1,2 Topic: topic01 Partition: 1 Leader: 2 Replicas: 2,3 Isr: 2,3 Topic: topic01 Partition: 2 Leader: 3 Replicas: 3,1 Isr: 3,1 Topic: topic01 Partition: 3 Leader: 1 Replicas: 1,3 Isr: 1,3 Topic: topic01 Partition: 4 Leader: 2 Replicas: 2,1 Isr: 2,1 leader:负责处理消息的读和写，leader是从所有节点中随机选择的. Replicas:列出了所有的副本节点，不管节点是否在服务中. Lsr:是正在服务中的节点. 查看topic指定分区offset的最大值或最小值 --time，为毫秒值，-time=-1时表示最大值latest，为-2时表示最小值earliest。该offset值是所写时间戳之后的第一条数据。结果为： 具体的时间戳 bin/kafka-run-class.sh kafka.tools.GetOffsetShell -topic topicName --time 1656643531770 --broker-list broker1:9092,broker2:9092 查询offset的最大值 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --topic topic03 --time -1 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --topic topic03 --time -1 --partitions 0 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 查询offset的最小值 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --topic topic03 --time -2 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 修改主题配置 bin/kafka-configs.sh --alter --topic topic03 --add-config max.message.bytes=20480000 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 # 这个是错误的语法，已经改成上面的kafka-configs.sh这种方式了 bin/kafka-topics.sh --alter --topic topic03 --config max.message.bytes=102400000 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-topics.sh --alter --topic topic03 --config max.message.bytes=102400000 --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka 为topic增加分区(不支持减partition) 为topic增加partition bin/kafka-topics.sh --alter --topic topic03 --partitions 3 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-topics.sh --alter --topic topic03 --partitions 6 --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka 如何增加__consumer_offsets的副本数？其他Topic主题也是一样 可使用kafka-reassign-partitions.sh来增加__consumer_offsets的副本数，方法如下： 构造一JSON文件reassign.json： { \"version\":1, \"partitions\":[ {\"topic\":\"__consumer_offsets\",\"partition\":0,\"replicas\":[1,2,3]}, {\"topic\":\"__consumer_offsets\",\"partition\":1,\"replicas\":[2,3,1]}, {\"topic\":\"__consumer_offsets\",\"partition\":2,\"replicas\":[3,1,2]}, {\"topic\":\"__consumer_offsets\",\"partition\":3,\"replicas\":[1,2,3]}, ... {\"topic\":\"__consumer_offsets\",\"partition\":100,\"replicas\":[2,3,1]} ] } 然后执行： bin/kafka-reassign-partitions.sh --reassignment-json-file reassign.json --execute --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 “[1,2,3]”中的数字为broker.id值。 删除主题 bin/kafka-topics.sh --delete --topic topic03 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-topics.sh --delete --topic topic03 --zookeeper 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/kafka kafka删除topic方法 1) bin/kafka-topics.sh --delete --zookeeper master:2181 --topic DreamTopic 如果删除后查看topic显示为:marked for deletion 则需要在每一台机器中的 config/server.properties 文件加入 delete.topic.enable=true，然后重启kafka 2) 删除kafka存储目录（server.properties文件log.dirs配置，默认为\"/tmp/kafka-logs\"）相关topic目录删除zookeeper \"/brokers/topics/\"目录下相关topic节点 生产者Producer发送消息 bin/kafka-console-producer.sh --topic topic03 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-console-producer.sh --topic topic03 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 消费者Consumer消费主题 bin/kafka-console-consumer.sh --topic topic03 --from-beginning --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-console-consumer.sh --topic topic03 --from-beginning --group test.group --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 1) 从头开始 bin/kafka-console-consumer.sh --topic test --from-beginning --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-console-consumer.sh --topic test --offset earliest --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 2) 从尾部开始(默认) bin/kafka-console-consumer.sh --topic test --offset latest --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 3) 指定分区 bin/kafka-console-consumer.sh --topic test --offset latest --partition 1 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 4) 取指定个数 bin/kafka-console-consumer.sh --topic test --offset latest --partition 1 --max-messages 1 --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 5) 新消费者（ver>=0.9） bin/kafka-console-consumer.sh --topic test --new-consumer --from-beginning --consumer.config config/consumer.properties --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 查看有哪些消费者Group 2) API方式（新） bin/kafka-consumer-groups.sh --list --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 1) 分ZooKeeper方式（老） bin/kafka-consumer-groups.sh --list --zookeeper 127.0.0.1:2181/kafka 查看Group详情，查看消费者消费偏移量 bin/kafka-consumer-groups.sh --list --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-consumer-groups.sh --group testgroup --describe --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 bin/kafka-consumer-groups.sh --list --zookeeper 10.1.128.60:2181,10.1.128.61:2181,10.1.128.62:2181 bin/kafka-consumer-groups.sh --group testgroup --describe --zookeeper 10.1.128.60:2181,10.1.128.61:2181,10.1.128.62:2181 获取指定Consumer Group的位移信息(新的2.x的版本不能使用) 需consumer.properties中设置exclude.internal.topics=false： 1) 0.11.0.0版本之前： bin/kafka-simple-consumer-shell.sh --topic __consumer_offsets --partition 11 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 --formatter \"kafka.coordinator.GroupMetadataManager\\$OffsetsMessageFormatter\" 2) 0.11.0.0版本以后(含)： bin/kafka-simple-consumer-shell.sh --topic __consumer_offsets --partition 11 --broker-list 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 --formatter \"kafka.coordinator.group.GroupMetadataManager\\$OffsetsMessageFormatter\" 修改消费组的offset 设置为最初偏移量： bin/kafka-consumer-groups.sh --group testgroup --topic topic03 --reset-offsets --to-earliest --execute --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 设置最近偏移量 bin/kafka-consumer-groups.sh --group testgroup --topic topic03 --reset-offsets --to-latest --execute --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 设置任意偏移量： bin/kafka-consumer-groups.sh --group lengfeng.consumer.group --topic kafka_flink_mysql --reset-offsets --to-offset 3 --execute --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 查看内部主题__consumer_offsets（保存Consumer Group消费位移信息的Topic） 需consumer.properties中设置exclude.internal.topics=false： 1) 0.11.0.0之前版本 bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper localhost:2181 --formatter \"kafka.coordinator.GroupMetadataManager\\$OffsetsMessageFormatter\" --consumer.config config/consumer.properties --from-beginning 2) 0.11.0.0之后版本(含) bin/kafka-console-consumer.sh --topic __consumer_offsets --formatter \"kafka.coordinator.group.GroupMetadataManager\\$OffsetsMessageFormatter\" --consumer.config config/consumer.properties --from-beginning --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 老的版本使用zookeeper查询 bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper localhost:2181 --formatter \"kafka.coordinator.group.GroupMetadataManager\\$OffsetsMessageFormatter\" --consumer.config config/consumer.properties --from-beginning 如何增加__consumer_offsets的副本数？其他Topic主题也是一样 可使用kafka-reassign-partitions.sh来增加__consumer_offsets的副本数，方法如下： 构造一JSON文件reassign.json： { \"version\":1, \"partitions\":[ {\"topic\":\"__consumer_offsets\",\"partition\":0,\"replicas\":[1,2,3]}, {\"topic\":\"__consumer_offsets\",\"partition\":1,\"replicas\":[2,3,1]}, {\"topic\":\"__consumer_offsets\",\"partition\":2,\"replicas\":[3,1,2]}, {\"topic\":\"__consumer_offsets\",\"partition\":3,\"replicas\":[1,2,3]}, ... {\"topic\":\"__consumer_offsets\",\"partition\":100,\"replicas\":[2,3,1]} ] } 然后执行： kafka-reassign-partitions.sh --zookeeper localhost:2181/kafka --reassignment-json-file reassign.json --execute “[1,2,3]”中的数字为broker.id值。 __consumer_offsets __consumer_offsets是kafka内置的Topic，在0.9.0.0之后的Kafka，将topic的offset 信息由之前存储在zookeeper上改为存储到内置的__consumer_offsets中。 server.properties中的配置项num.partitions和default.replication.factor对__consumer_offsets无效，而是受offsets.topic.num.partitions和offsets.topic.replication.factor两个控制。 设置修改Consumer Group的offset 执行zkCli.sh进入zookeeper命令行界面，假设需将group为testgroup的topic的offset设置为2018，则：set /consumers/testgroup/offsets/test/0 2018 如果kakfa在zookeeper中的根目录不是“/”，而是“/kafka”，则： set /kafka/consumers/testgroup/offsets/test/0 2018 另外，还可以使用kafka自带工具kafka-run-class.sh kafka.tools.UpdateOffsetsInZK修改，命令用法： kafka.tools.UpdateOffsetsInZK$ [earliest | latest] consumer.properties topic 从用法提示可以看出，只能修改为earliest或latest，没有直接修改zookeeper灵活。 删除Group 老版本的ZooKeeper方式可以删除Group，新版本则自动删除，当执行： kafka-consumer-groups.sh --group test --delete --bootstrap-server 127.0.0.1:9092 输出如下提示： 查看新消费者详情 # 仅支持offset存储在zookeeper上的： kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zkconnect localhost:2181 --group test bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --broker-info --group CONSUMER_TOPICTEST_ALL_MSGTEST_CLUSTER_GROUP --topic topicTest --zookeeper 10.1.243.23:52181 查看broker的配置 bin/kafka-configs.sh --describe --all --broker 0 --bootstrap-server localhost:9092 新增修改broker的配置 bin/kafka-configs.sh --alter --add-config k3=v3 --broker 0 --bootstrap-server localhost:9092 bin/kafka-configs.sh --alter --add-config 'log.cleaner.threads.config=50' --entity-default --entity-type brokers --bootstrap-server localhost:9092 查看kafka的zookeeper上的数据 1) 查看Kakfa在zookeeper的根目录 ls /kafka 2) 查看brokers ls /kafka/brokers 3) 查看有哪些brokers（214和215等为server.properties中配置的broker.id值）： ls /kafka/brokers/ids 4) 查看broker 214，下列数据显示该broker没有设置JMX_PORT： get /kafka/brokers/ids/214 5) 查看controller，下列数据显示broker 214为controller： get /kafka/controller 6) 查看kafka集群的id： get /kafka/cluster/id 7) 查看有哪些topics： ls /kafka/brokers/topics 8) 查看topic下有哪些partitions： ls /kafka/brokers/topics/__consumer_offsets/partitions 9) 查看“partition 0”的状态： get /kafka/brokers/topics/__consumer_offsets/partitions/0/state 如何增加consumer_offsets的副本数？ 可使用kafka-reassign-partitions.sh来增加consumer_offsets的副本数，方法如下： 构造一JSON文件reassign.json： { \"version\":1, \"partitions\":[ {\"topic\":\"consumer_offsets\",\"partition\":0,\"replicas\":[1,2,3]}, {\"topic\":\"consumer_offsets\",\"partition\":1,\"replicas\":[2,3,1]}, {\"topic\":\"consumer_offsets\",\"partition\":2,\"replicas\":[3,1,2]}, {\"topic\":\"consumer_offsets\",\"partition\":3,\"replicas\":[1,2,3]}, ... {\"topic\":\"__consumer_offsets\",\"partition\":100,\"replicas\":[2,3,1]} ] } 然后执行： kafka-reassign-partitions.sh --zookeeper localhost:2181/kafka --reassignment-json-file reassign.json --execute “[1,2,3]”中的数字为broker.id值。 consumer_offsets consumer_offsets是kafka内置的Topic，在0.9.0.0之后的Kafka，将topic的offset 信息由之前存储在zookeeper上改为存储到内置的__consumer_offsets中。 server.properties中的配置项num.partitions和default.replication.factor对__consumer_offsets无效，而是受offsets.topic.num.partitions和offsets.topic.replication.factor两个控制。 kafka不支持topic修改副本数量： bin/kafka-topics.sh --alter --topic db.192_168_5_14_3319_wac_trinity.position --replication-factor 3 --partitions 1 --bootstrap-server 172.16.48.182:9011,172.16.48.182:9012,172.16.48.183:9011 Option \"[replication-factor]\" can't be used with option \"[alter]\" Kafka常用命令收录Kafka操作命令 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Kafka/Kafka运维问题.html":{"url":"docs/tech/MQ/Kafka/Kafka运维问题.html","title":"Kafka运维问题","keywords":"","body":"Kafka运维问题 客户端的Consumer加入consumer group失败，因为未验证的member id Join group failed with org.apache.kafka.common.errors.MemberIdRequiredException: The group member needs to have a valid member id before actually entering a consumer group 会重新尝试的，只是打印了一下日志， 详情查看kafka 的KIP（ Kafka Improvement Proposals）KIP-394: Require member.id for initial join group request consumer poll timeout has expired consumer poll timeout has expired. This means the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms, which typically implies that the poll loop is spending too much time processing messages. You can address this either by increasing max.poll.interval.ms or by reducing the maximum size of batches returned in poll() with max.poll.records. 二次poll的时间间隔超过了max.poll.interval.ms设置 这个报错也只跟两次poll的时间间隔是不是大于max.poll.interval.ms有关，而且这个告警也是会自动恢复的 当你的两次poll时间小于配置后，也会自动恢复 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Jafka.html":{"url":"docs/tech/MQ/Jafka.html","title":"Jafka","keywords":"","body":"Jafka 一个快速，简单的分布式发布-订阅消息系统（mq） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/InLong.html":{"url":"docs/tech/MQ/InLong.html","title":"InLong","keywords":"","body":"InLong官网InLong Github Apache InLong（应龙）是一个一站式海量数据集成框架，提供自动、安全、可靠和高性能的数据传输能力，同时支持批和流，方便业务构建基于流式的数据分析、建模和应用。 InLong(应龙)，中国神话故事里的神兽，引流入海，借喻 InLong 系统提供数据集成能力。 Apache InLong（应龙）是一站式的海量数据集成框架，提供自动、安全、可靠和高性能的数据传输能力，方便业务构建基于流式的数据分析、建模和应用。 InLong 项目原名 TubeMQ ，专注于高性能、低成本的消息队列服务。为了进一步释放 TubeMQ 周边的生态能力，我们将项目升级为 InLong，专注打造一站式海量数据集成框架。 Apache InLong 依托 10 万亿级别的数据接入和处理能力，整合了数据采集、汇聚、存储、分拣数据处理全流程，拥有简单易用、灵活扩展、稳定可靠等特性。 该项目最初于 2019 年 11 月由腾讯大数据团队捐献到 Apache 孵化器，2022 年 6 月正式毕业成为 Apache 顶级项目。目前 InLong 正广泛应用于广告、支付、社交、游戏、人工智能等各个行业领域，为多领域客户提供高效化便捷化服务。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/OpenMessaging.html":{"url":"docs/tech/MQ/OpenMessaging.html","title":"OpenMessaging","keywords":"","body":"OpenMessaging 云原生，与供应商无关的开放式规范，用于分布式消息传递 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/OpenMQ.html":{"url":"docs/tech/MQ/OpenMQ.html","title":"OpenMQ","keywords":"","body":"OpenMQ Open-MQ 是一个开源的消息中间件，类似IBM的 WebSphere MQ(MQSeries)，采用 C++ 和 Qt 库编写的，支持Windows、Unix 以及 Mac OS 平台，支持 JMS。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/ZeroMQ.html":{"url":"docs/tech/MQ/ZeroMQ.html","title":"ZeroMQ","keywords":"","body":"ZeroMQ ZeroMQ（简称ZMQ）是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/HiveMQ.html":{"url":"docs/tech/MQ/HiveMQ.html","title":"HiveMQ","keywords":"","body":"HiveMQ HiveMQ的MQTT代理使以高效，快速和可靠的方式轻松地在连接的设备之间来回移动数据。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/HornetQ.html":{"url":"docs/tech/MQ/HornetQ.html","title":"HornetQ","keywords":"","body":"HornetQ HornetQ是一个开放源代码项目，用于构建多协议，可嵌入，非常高性能的集群异步消息传递系统。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Artemis.html":{"url":"docs/tech/MQ/Artemis.html","title":"Artemis","keywords":"","body":"Artemis 高性能，无阻塞的体系结构，用于下一代事件驱动的消息传递应用程序。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/MQ/Nanomsg.html":{"url":"docs/tech/MQ/Nanomsg.html","title":"Nanomsg","keywords":"","body":"Nanomsg nanomsg是一个消息通信组件 - zeromq的作者之一用C语言重写的通信框架， Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/RPC/Remoting和RPC框架.html":{"url":"docs/tech/RPC/Remoting和RPC框架.html","title":"远程通讯和RPC框架","keywords":"","body":"Remoting和RPC框架 远程通讯和RPC框架 远程通讯RPC 1、Netty框架 2、Dubbo框架 3、 Netty框架 Java NIO的实现，文件和内存的读写，网络IO的实现 看过nio的源码吗？bytebuffer的使用，写读容量参数 Netty学习 netty概念和常用类：group、channel、handler、optionnetty执行流程：拆包、解码、封装对象Server端Boss线程和worker线程比较：boss设置为1，监听端口的netty两种线程模型和JDK线程池模型比较Netty的高性能及NIO的epoll空轮询bug：判定和解决：重建selectorTCP粘包/拆包与Netty解决方案：4种：分隔符，回车换行分隔符，定长报文，消息头和消息体netty的网络创建在哪里java nio的selector 和linux的epoll select netty小对象、大对象的管理 netty执行流程Server端Boss线程和worker线程比较：boss设置为1，我猜测是为了减少线程切换，因为处理事情比较简单，不耗费时间netty两种线程模型和JDK线程池模型比较Netty的高性能及NIO的epoll空轮询bugTCP粘包/拆包与Netty解决方案：netty的网络创建在哪里java nio的selector 和linux的epoll selectJava异步NIO框架Netty实现高性能高并发： netty高性能 传输：异步非阻塞通信、零拷贝（直接内存和transferTo）、线程池、灵活的TCP参数配置能力（option参数的设置） 协议：Protobuf的支持、Thrift的 线程：高效的Reactor线程模型、无锁化的串行设计理念：Netty的NioEventLoop是单线程的 Java异步NIO框架Netty实现高性能高并发：netty高性能传输：异步非阻塞通信、零拷贝（直接内存和transferTo）、灵活的TCP参数配置能力（option参数的设置）协议：多种序列化协议，Protobuf的支持、Thrift的线程：高效的Reactor线程模型、线程池、无锁化的串行设计理念：Netty的NioEventLoop是单线程的内存：内存池化，各种不同大小对象管理：三种大小对象类型 Netty实现原理netty的相关所有，使用的协议hession用来干嘛的：Hessian本身即是基于Http的RPC实现Java序列化和Hessian序列化的区别netty的相关，管道是什么设计模式：责任链模式 或者 管道设计模式 Netty零拷贝Netty内存管理：堆外内存池 使用Handler的注意事项 netty的Channel的ID值可以通过调用 Channel.id() 获取Channel的ID值。 全局唯一的channel ID每个 Channel 都会有一个全局唯一的ID，生成规则如下：MAC 地址(EUI-48 or EUI-64)，最好是全局唯一的当前进程IDSystem#currentTimeMillis()System#nanoTime()32-bit的随机integer序列化递增的32-bit integer. netty框架的了解？boss线程，work线程数主要接口有哪些？源码使用流程？ Dubbo框架 dubbo的长连接池，如果出现网络抖动，会怎么处理？Dubbo超时机制导致的雪崩连接 1、remoting：netty、mina、grizzy、xsocketrpc：dubbo、grpc、 RPC框架：dubbo、grpc、finagle、single-jdk实现、thrift、jupiter、tars、远程调用：grizzly、hessian、mina、netty、t-io网关：kong、litte-proxy、nginx、tengine 远程通讯调用框架/Users/yangzl/git/quickstart-remoting/docs quickstart-netty quickstart-mina quickstart-hessian quickstart-t-io quickstart-xsocketquickstart-grizzly /Users/yangzl/git/quickstart-rpc/docs/Users/yangzl/git/quickstart-remoting/docs/netty/Netty学习.md 2、调用链的TraceID是怎么传递的？怎么串起来的？放在请求头中：TraceID，SpanID，ParentSpanID，是否抽样Sampled（设置百分比）等3、评论系统的数据库设计？4、dubbo访问超时是怎么处理的？超时自动重试， 如何实现负载均衡,有哪些算法可以实现?http://blog.csdn.net/zgwangbo/article/details/51533657https://www.cnblogs.com/szlbm/p/5588555.htmlhttp://blog.csdn.net/mengdonghui123456/article/details/53981976http://blog.csdn.net/zhoudaxia/article/details/23672319 均衡算法主要解决将请求如何发送给后端服务。经常会用到以下四种算法：随机法（Random）、轮询法（Round Robin）、一致哈希（consistent-hash）和主备（master-slave）。、加权随机（Weight Random）法、、加权轮询（Weight Round Robin）法、源地址哈希（Hash）法、最小连接数（Least Connections）法、 对于RPC应用高性能的三个主题永远是IO模型、数据协议、线程模型。 netty介绍http://blog.csdn.net/haoyuyang/article/details/53243785http://ifeve.com/netty5-user-guide/ Netty IO模型netty是一个流行的NIO的框架JDK1.4提供了对非阻塞IO（NIO）的支持，JDK1.6版本使用epoll替代了传统的select/poll，极大的提升了NIO通信的性能 在*nix中将IO模型分为5类。Blocking I/ONonblocking I/OI/O Multiplexing (select and poll)Signal Driven I/O (SIGIO)Asynchronous I/O (the POSIX aio_functions) TCP粘包、拆包问题解决方案：①消息定长，例如每个报文的大小固定为200个字节，如果不够，空位补空格。②在包尾部增加特殊字符进行分割，例如加回车等。③将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理。 Netty中解决TCP粘包/拆包的方法：①分隔符类：DelimiterBasedFrameDecoder（自定义分隔符）②定长：FixedLengthFrameDecoder Netty高性能之Reactor线程模型Reactor模式是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler Netty是一个高性能的NIO通信框架，提供异步的、事件驱动的网络编程模型。使用Netty可以方便用户开发各种常用协议的网络程序。例如：TCP、UDP、HTTP等等。 netty的线程模型http://blog.csdn.net/u010853261/article/details/62043709http://blog.csdn.net/zxhoo/article/details/17634683http://blog.csdn.net/zxh87/article/details/73467873http://blog.csdn.net/u012495483/article/details/747476011 Reactor单线程模型2 Reactor多线程模型3 Reactor主从多线程模型 Netty 的服务器端的 acceptor 阶段, 没有使用到多线程, 因此上面的 主从多线程模型 在 Netty 的服务器端是不存在的. NioEventLoopGroup实际上就是个线程池NioEventLoopGroup在后台启动了n个NioEventLoop来处理Channel事件每一个NioEventLoop负责处理m个ChannelNioEventLoopGroup从NioEventLoop数组里挨个取出NioEventLoop来处理Channel BossEventLoopGroup通常是一个单线程的EventLoop，EventLoop维护着一个注册了ServerSocketChannel的Selector实例，BossEventLoop不断轮询Selector将连接事件分离出来，通常是OP_ACCEPT事件，然后将accept得到的SocketChannel交给WorkEventLoopGroup，WorkerEventLoopGroup会由next选择其中一个EventLoopGroup来将这个SocketChannel注册到其维护的Selector并对其后续的IO事件进行持续的处理。在Reactor模式中BossEventLoopGroup主要是对多线程的扩展，而每个EventLoop的实现涵盖IO事件的分离，和分发(Dispatcher)。 Rocketmq的BossEventLoopGroup是单线程的，WorkEventLoopGroup是serverSelectorThreads个线程，DefaultEventExecutorGroup是serverWorkerThreads个线程 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/CloudNative/Container容器.html":{"url":"docs/tech/CloudNative/Container容器.html","title":"容器","keywords":"","body":"Container容器 容器学习 1、Docker学习 2、Kubernetes学习 3、Istio学习 3、Serverless学习 4、Pouch框架 5、其他辅助框架 Docker学习 Docker概念，组件，命令Dockerfile指令docker-compose部署复杂容器服务 把tar文件镜像导入本地镜像仓库 Kubernetes学习 Kubernetes概念、组件kubectl命令 K8s部署流程 k8s配置文件：如网关等，实际项目的配置，kind种类有哪些 Istio学习 Istio概念、组件Istio的部署 go语言 Serverless学习 Serverless最佳实践原则 Pouch框架 其他辅助框架 consul使用raft协议，raft协议是什么？etcd的使用 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/DaoCloud公司.html":{"url":"docs/tech/others/DaoCloud公司.html","title":"Docker镜像站国内网站","keywords":"","body":"Docker镜像站国内网站 DaoCloud公司 DaoCloud官网DaoCloud GithubDaoCloud Docker hub配置DaoCloud Docker镜像站DaoCloud Services开放API 2011年 中国最早接触容器技术的开发团队，前CloudFoundry Core Dev Team。 2015年 一月 公司成立。 2015年 二月 推出Docker Hub Mirror服务。 2015年 三月 公有云DaoCloud上线。 2015年 四月 提供基于Docker的持续构建与发布SaaS服务。 2015年 五月 提供对Github，Bitbucket，Coding和Gitcafe的全接入，并用时支持UCloud，Azure，AWS，QingCloud和阿里云。 2015年 六月 Docker主机管理SaaS服务上线，并推出了容器混合云解决方案。 2015年 六月底 受邀代表中国Docker社区参加旧金山DockerConf，并做主题演讲。 2015年 七月 会有什么大招？ 使用daocloud加速docker pullDocker - 加速镜像下载（使用DaoCloud镜像服务） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Reactive/Reactive响应式编程.html":{"url":"docs/tech/Reactive/Reactive响应式编程.html","title":"Reactive响应式编程","keywords":"","body":"Reactive响应式编程 反应式编程 响应式编程是一种处理异步数据流的规范 响应式为数据流的转换和聚合以及数据流的控制管理提供了工具支持 响应式编程的基础：数据流的概念、Observable 类和它的各种操作以及通过工厂方法创建静态和动态的 Observable 对象。 Observable 是事件的源头，Observer 提供了一组简单的接口，并通过订阅事件源来消费 Observable 的事件。 Observable 通过 onNext 向 Observer 通知事件的到达，后面可能会跟上 onError 或 onComplete 来表示事件的结束。 Reactive Streams（以下简称为 RS）是“一种规范，它为基于非阻塞回压的异步流处理提供了标准”。它是一组包含了 TCK 工具套件和四个简单接口（Publisher、Subscriber、Subscription 和 Processor）的规范，这些接口将被集成到 Java 9. 响应式框架： 1、Java 8 Stream API 和 CompletableFuture RxJava 选择了 Java 6，而 Java 6 里没有 java.util.function 包，RxJava 也就无法利用这个包下面的 Functino 类和 Consumer 类，所以它必须创建很多类似 Func1、Func2、Action0、Action1 这样的类。 2、RxJava2 使用类似 Reactor 2 的方式把这些类作为 java.util.function 的镜像，因为它还得支持 Java 7。 3、Reactor 是基于 Java 8 的，所以在大部分情况下，Stream API 已经能够满足需求了。 Reactive Programming(RP),响应式编程 /Users/yangzl/git/quickstart-reactive/docs quickstart-reactivex quickstart-reactor quickstart-reactive-streams quickstart-rsocket quickstart-spring-webflux quickstart-akka quickstart-springboot-rsocket quickstart-ratpack Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/ArchitectureDesign/ArchitectureDesign架构和设计.html":{"url":"docs/tech/ArchitectureDesign/ArchitectureDesign架构和设计.html","title":"架构和设计","keywords":"","body":"ArchitectureDesign架构和设计 1、DesignPattern设计模式 设计模式 quickstart-design-pattern 设计模式和代码示例 设计模式学习.md 设计模式的六大原则 设计模式：23种 创建型模式设计模式详解 结构型设计模式详解 行为型设计模式详解 DesignPattern设计模式 1、创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 创建型模式：Factory Method、Abstract Factory、Singleton、Builder、Prototype2、结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式 结构型模式：Adapter、Decorator、Proxy、Facade、Bridge、Composite、Flyweight3、行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 行为型模式：Strategy、Template Method、Observer、Iterator、Chain of Responsibility、Command、Memento、State、Visitor、Mediator、Interpreter 其他的：还有两类：并发型模式和线程池模式。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/ArchitectureDesign/TDD、BDD和DDD.html":{"url":"docs/tech/ArchitectureDesign/TDD、BDD和DDD.html","title":"TDD、BDD和DDD","keywords":"","body":"TDD、BDD和DDD TDD测试驱动开发 : Test-driven development,即测试驱动开发 BDD行为驱动开发 : Behavior-driven development,即行为驱动开发 DDD领域驱动设计 : Domain-drive Design,领域驱动设计 测试驱动开发（TDD）是一种开发软件的过程，其中在编写代码之前先编写测试。一旦完成，开发人员将努力编写足够的代码以通过测试，然后开始重构。 域驱动设计（DDD）是一种将实现与不断发展的模型联系在一起的开发方法。将项目的重点放在核心领域（知识领域），背后的逻辑上，并迫使技术和非技术方面之间进行协作以改进模型。 行为驱动开发（BDD）是对TDD和DDD的改进，旨在通过缩小沟通差距，增进对客户的了解并实现持续沟通来简化开发。简而言之，BDD是将业务需求与代码结合在一起的一种方式，使您能够从业务/最终用户的角度了解系统的行为。 Hybrid Practice混合实践 TDD Test-driven development,即测试驱动开发。一种开发过程中应用方法。其思想为先根据需求抽象接口，先编写测试用例，然后在开始编写开发代码。TDD的本意就是通过测试来推动整个开发的进行。 TDD说白了就是先写一小段功能的测试代码，测试失败后再写实现代码，测试成功后接着迭代下一个功能。 TDD的优点： 提高功能的可测性 测试比较灵活 测试用例覆盖率比较高 缺点： 由于是单元测试代码验证，非技术人员看不懂代码，比较难验证功能是否贴合需求 先写单元测试代码，测试用例需要经常调整，增加了开发人员的工作量和降低了开发效率 BDD Behavior-driven development,即行为驱动开发。其目的是鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。是从用户的需求出发，强调系统行为。通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法,使用混合了领域中统一的语言的母语语言来描述他们的代码的目的,让开发者得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度的减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价. 目前主流的BDD测试框架为Cucumber ，支持多种编程语言。 cucumber支持的关键字： feature | \"功能\" | background | \"背景\" | scenario | \"场景\", \"剧本\" | scenario outline | \"场景大纲\", \"剧本大纲\" | examples | \"例子\" | given | \"* \", \"假如\", \"假设\", \"假定\" | when | \"* \", \"当\" | then | \"* \", \"那么\" | and | \"* \", \"而且\", \"并且\", \"同时\" | but | \"* \", \"但是\" | given (code) | \"假如\", \"假设\", \"假定\" | when (code) | \"当\" | then (code) | \"那么\" | and (code) | \"而且\", \"并且\", \"同时\" | but (code) | \"但是\" | 编程是通过使用以上的关键字来描述应用的功能，使非开发人员能快速便捷的了解代码的功能。 DDD Domain-drive Design,领域驱动设计。其目的是以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型，再有该模型驱动软件设计和开发。 领域模型 领域模型是是对具有某个边界的领域的一个抽象，反映了领域内用户需求的本质 领域模型只反映业务，和技术无关 领域模型可以反映领域中的实体和过程 领域模型确保业务逻辑都在一个模型中，有助于提高应用的维护性和可重用性 领域模型可以让开发人员相对平滑地将业务知识转换为软件架构 领域模型贯穿软件分析、设计，以及开发的整个过程 建立正确的领域模型需要领域专家、设计、开发人员积极沟通共同努力，是大家对领域内的业务不断深入，从而不断细化和完善领域模型 领域模型的表达方式有多种 领域模型是整个软件的核心，设计足够精良且符合业务需求的领域模型能够更快速的响应需求变化 领域驱动设计的分成架构 用户界面/表现层 应用层 领域层 - 表达业务概念，业务信息和业务规则 基础设施层 业务对象的职责和策略： 实体（Entities）：具备唯一ID，能够被持久化，具备业务逻辑，对应业务对象 值对象（Value objects）：不具有唯一ID，由对象的属性描述，一般为内存中的临时对象，可以用来传递参数或对实体进行补充描述。 工厂（Factories）：主要用来创建实体，目前架构实践中一般采用IOC容器来实现工厂的功能 仓库（Repositories）：用来管理实体的集合，封装持久化框架 服务（Services）：为上层建筑提供可操作的接口，负责对领域对象进行调度和封装，同时可以对外提供各种形式的服务 DDD对构建企业级应用开发平台和大型核心业务系统的作用是相当大的，无论是在产品的稳定性、扩展性、可维护性、生命周期等方面都有良好的表现 参考The Value at the Intersection of TDD, DDD, and BDDHybrid Development: The Value at the Intersection of TDD, DDD, and BDD BDD vs TDD vs ATDD : Key DifferencesDifferences between TDD, ATDD and BDD Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/ArchitectureDesign/接口幂等性设计.html":{"url":"docs/tech/ArchitectureDesign/接口幂等性设计.html","title":"接口幂等性设计","keywords":"","body":"接口幂等性设计 什么是幂等性 多次请求某一个资源对于资源本身应该具有同样等结果,也就是说,其任意多次执行对资源本身所产生等影响的结果均与第一次执行的影响的结果相同。（多次请求的资源都是相同的导致数据库存储脏数据） 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用 产生幂等性场景 总结一句话就是重复 浏览器重复的HTTP请求：页面重复刷新、使用浏览器后退按钮重复之前的操作、用户双击提交按钮、用户重复操作、使用浏览器历史记录重复提交表单 网络波动, 可能会引起重复请求 应用使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等) 重复消息，定时任务重复执行 幂等性解决方案 不是所有的业务都需要解决：天然就是幂等性的 幂等性一定是有时效性质的：成本等太高，也没必要 唯一值的设计：比如金额扣减，连续两笔不重复的请求就是扣减相同的金额 幂等性解决： 前端控制 按钮只可操作一次，按钮Disable、按钮置灰，隐藏，不可点击等方式 应用层控制 Redis的SETNX 或者 数据库防重表insert【前端的token或者业务唯一ID】 报文或者的待操作数据的MD5或hash 数据库层控制 Select、Delete本身就是幂等性 新增：使用数据库主键 修改： 把表中id为XXX的记录的A字段值设置为1,这种操作不管执行多少次都是幂等的 把表中id为XXX的记录的A字段值增加1,这种操作就不是幂等的 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/ArchitectureDesign/权限设计.html":{"url":"docs/tech/ArchitectureDesign/权限设计.html","title":"权限设计","keywords":"","body":"权限设计 RBAC权限模型 RBAC权限模型 在业界接受度较高的功能权限模型是 RBAC（Role-Based Access Control）模型，其基本理念是将「角色」这个概念赋予用户，在系统中用户与权限之间通过角色进行关联，以这样的方法来实现灵活配置。 用户User（用户组） 角色Role（角色组） 权限Permission（权限组） 用户--------角色---------权限 \\ / \\ / \\ / \\ / 用户组 权限组 权限一般的权限由页面权限、操作权限和数据权限构成 页面权限： 操作权限：增删改查等 数据权限： 参考 https://www.jianshu.com/p/179d6299bdd1 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式.html":{"url":"docs/tech/Distributed/分布式.html","title":"分布式","keywords":"","body":"分布式理论 1、分布式理论 2、 分布式理论 分布式理论单机：ACID，分布式：2PC、3PC分布式设计原则：CAP、BASE分布式一致性：Paxos、Raft、ZABRaft：拉票类型的，由Leader-->FollowerZAB:投票类型的，由LeaderZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段一致性模型：强一致、弱一致性、最终一致性（一段时间达到一致性）一致性模型、XA分布式协议，补偿事务（TCC）（TCC编程（Try、Confirm、Cancel））XA规范：应用程序（ AP ）、事务管理器（ TM、是交易中间件 ）、资源管理器（ RM。是数据库 ）、通信资源管理器（ CRM，是消息中间件 ） Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增) 怎么实现全局递增的唯一ID？(讲了TDDL的一次取一批ID，然后再本地慢慢分配的做法) 分布式事务一致性/Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/分布式事务与一致性算法.md 问题 @所有人 [跳跳]阿里人现身说法：最全面的分布式事务解决方案 🌵全面剖析阿里面试套路 🌵分布式事务来龙去脉 🌵两阶段提交协议 🌵三阶段提交协议 🌵TCC（Try Confirm Cancel）解决方案 🌵LCN（Lock Confirm Notify）解决方案 🌵阿里巴巴分布式事务框架：Seata 🌵消息队列+本地事件表方案 🌵可靠消息服务方案 🌵最大努力通知方案 👉戳此进直播间：https://ke.qq.com/course/399017?taid=10348929858541225&tuin=a982d3d7 [疑问]如何用消息队列解决分布式事务 [玫瑰]分布式事务介绍 [玫瑰]常用分布式事务解决方案 [玫瑰]消息队列解决分布式事务流程 [玫瑰]手敲代码实战落地。 [勾引]戳此进直播间啦：https://ke.qq.com/course/399017?taid=10179983024985769&tuin=6c381156 @所有人 [嘿哈]大行其道的微服务中，分布式事务该如何解决？ 分布式事务的场景。 分布式事务中CAP,BASE理论。 2PC、3PC 提交协议。 基于消息队列的分布式解决方案。 [勾引]戳此进直播间啦：https://ke.qq.com/course/399017?taid=9800909211440809&tuin=6c381156 @所有人 [机智]纯干货分享#分布式事务#Seata落地实战 🎈分布式事务介绍。 🎈常用分布式事务解决方案。 🎈Seata原理。 🎈Seata实战落地。 🔔戳此进直播间啦：https://ke.qq.com/course/399017?taid=10228292817131177&tuin=6c381156 @所有人 [炸弹]纯干货分享#分布式事务#LCN落地实战 🌟分布式事务介绍。 🌟2PC，3PC原理介绍。 🌟LCN原理。 🌟LCN事务实战落地。 👉戳此进直播间啦：https://ke.qq.com/course/399017?taid=9800909211440809&tuin=6c381156 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式算法.html":{"url":"docs/tech/Distributed/分布式算法.html","title":"分布式算法","keywords":"","body":"分布式算法 Gossip协议:Redis集群服务端通讯协议 DHT实现：Kademlia算法 分布式系统算法：Paxos、Raft、ZAB 两军问题与拜占庭将军问题 Gossip协议:Redis集群服务端通讯协议 Consensus Algorithm—— Gossip协议 Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。 gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在分布式系统中被广泛使用，比如我们可以使用 gossip 协议来确保网络中所有节点的数据一样。 Gossip 协议的执行过程： Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。 Gossip 的特点（优势） 可扩展性（Scalable） 去中心化 容错（Fault-tolerance） 健壮性（Robust） 最终一致性（Convergent consistency） Gossip 的缺陷 1）消息的延迟 2）消息冗余 Gossip 有两种类型： Anti-Entropy（反熵）：以固定的概率传播所有的数据 Rumor-Mongering（谣言传播）：仅传播新到达的数据 Redis Cluster 是一个可以在多个 Redis 节点之间进行数据共享的分布式集群，在服务端，通过节点之间的特殊协议进行通讯，这个特殊协议就充当了中间层的管理部分的通信协议，这个协议称作Gossip流言协议。 Gossip协议的使用 Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型： 1、Meet 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。 2、Ping 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。 3、Pong 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。 4、Fail 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。 由于去中心化和通信机制，Redis Cluster 选择了最终一致性和基本可用。 基于Gossip协议的故障检测 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此交换各个节点状态信息，检测各个节点状态：在线状态、疑似下线状态PFAIL、已下线状态FAIL。 自己保存信息：当主节点A通过消息得知主节点B认为主节点D进入了疑似下线(PFAIL)状态时,主节点A会在自己的clusterState.nodes字典中找到主节点D所对应的clusterNode结构，并将主节点B的下线报告添加到clusterNode结构的fail_reports链表中，并后续关于结点D疑似下线的状态通过Gossip协议通知其他节点。 一起裁定：如果集群里面，半数以上的主节点都将主节点D报告为疑似下线，那么主节点D将被标记为已下线(FAIL)状态，将主节点D标记为已下线的节点会向集群广播主节点D的FAIL消息，所有收到FAIL消息的节点都会立即更新nodes里面主节点D状态标记为已下线。 最终裁定：将 node 标记为 FAIL 需要满足以下两个条件： 1、有半数以上的主节点将 node 标记为 PFAIL 状态。 2、当前节点也将 node 标记为 PFAIL 状态。 也就是说当前节点发现其他结点疑似挂掉了，那么就写在自己的小本本上，等着通知给其他好基友，让他们自己也看看，最后又一半以上的好基友都认为那个节点挂了，并且那个节点自己也认为自己挂了，那么就是真的挂了，过程还是比较严谨的。 参考 https://zhuanlan.zhihu.com/p/41228196 https://www.jianshu.com/p/133560ef28df https://www.jianshu.com/p/de7b026f4997 https://blog.csdn.net/b6ecl1k7BS8O/article/details/86653449 https://hyperledger-fabric.readthedocs.io/zh_CN/latest/gossip.html 集群版Redis和Gossip协议 https://zhuanlan.zhihu.com/p/72629038 https://juejin.im/post/5dd65d676fb9a05a9a22ac6f DHT实现：Kademlia算法 Kademlia是分布式哈希表/散列表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。 Kademlia算法是一种分布式存储及路由的算法。 分布式哈希表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。 使用场景： 分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。 算法的三个参数：keyspace，k和α keyspace -- 即ID有多少位 -- 决定每个节点的通讯录有几层 k -- 每个一层k-bucket里装k个node的信息，即 -- 每次查找node时，返回k个node的信息 -- 对于某个特定的data，离其key最近的k个节点被会要求存储这个data α -- 每次向其他node请求查找某个node时，会向α个node发出请求 节点的指令 Kademlia算法中，每个节点只有4个指令 PING -- 测试一个节点是否在线 STORE -- 要求一个节点存储一份数据 FIND_NODE -- 根据节点ID查找一个节点 FIND_VALUE -- 根据KEY查找一个数据，实则上跟FIND_NODE非常类似 k-bucket的维护及更新机制 每个bucket里的节点都按最后一次接触的时间倒序排列 每次执行四个指令中的任意一个都会触发更新 当一个节点与自己接触时，检查它是否在K-bucket中 -- 如果在，那么将它挪到k-bucket列表的最底（最新） -- 如果不在，PING一下列表最上面（最旧）的一个节点 -- a) 如果PING通了，将旧节点挪到列表最底，并丢弃新节点 -- b) 如果PING不通，删除旧节点，并将新节点加入列表 该机制保证了任意节点加入和离开都不影响整体网络。 总结 Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。 在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。 DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。 Kademlia算法在2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。Kademlia可以作为信息安全技术的奠基之一。 Kademlia的优点在于： 1、对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要n步搜索即可找到目标节点； 2、K-bucket的更新机制一定程度上保持了网络的活性和安全性。 参考 https://www.jianshu.com/p/f2c31e632f1d https://colobu.com/2018/03/26/distributed-hash-table/ https://zhuanlan.zhihu.com/p/40286711 https://azhuge233.com/kademlia%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/ https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式事务与一致性算法.html":{"url":"docs/tech/Distributed/分布式事务与一致性算法.html","title":"分布式事务与一致性算法","keywords":"","body":"分布式事务与一致性算法 传统数据库事务:ACID， 老的方式分布式数据库：2PC、3PC 一致性算法：分布式CAP、BASE模型、柔性事务（补偿事务（TCC）（TCC编程（Try、Confirm、Cancel））） 分布式事务解决方案，包括强一致性的两阶段提交协议，三阶段提交协议，以及最终一致性的可靠事件模式、补偿模式，阿里的 TCC 模式。 刚性事务：XA分布式协议:2PC、3PC、 柔性事务：BASE模型、TCC、 分布式系统算法：Paxos、Raft、ZAB 两军问题与拜占庭将军问题 2PC/3PC用于保证多个数据分片上事务的原子性 Paxos协议用于保证同一个数据分片在多个副本的一致性 Paxos（分布式一致性算法）：Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 由proposer/acceptor/learner组成 Basic Paxos：提案阶段 投票阶段， 对一个值达成一致 Multi Paxos：统一由leader发起提议，可节省prepare步骤，连续多个paxos instance来对多个值达成一致 Raft 算法：Leader、Follower、Candidate候选人 选举流程：Candidate候选人向所有的服务器邀请投票给自己，如果收到大多数的Server的同意，就当选为Leader，其他的Server为Follower，如果一轮没有选出，则在一定的timeout后重新发起投票，直到选出Leader 使用流程：Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，然后再向所有 Follower 发出提交通知 Raft：拉票类型的，由Leader-->Follower ZAB:投票类型的，由Leader ZAB 协议 ( Zookeeper Atomic Broadcast) 原子广播协议：保证了发给各副本的消息顺序相同 两种角色+一种角色：Leader和Follower两个角色 + Observer 三种状态：Looking、Following、Leading 选举流程：初始化时候，故障恢复时候（选举和同步数据）、正常广播时候 传统事务:ACID 老的方式实现分布式事务是通过两阶段提交来实现的:2PC、3PC、 在分布式领域基于CAP理论以及BASE理论，有人就提出了 柔性事务 的概念 柔性事务（遵循BASE理论）是指相对于ACID刚性事务而言的。 支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。 1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。 2、补偿型：TCC型事务（Try/Confirm/Cancel）可以归为补偿型。 3、异步确保型，将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。 4、最大努力型，PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试） 柔性事务针对分布式事务的解决方法： 1、记录日志+补偿 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。 2、消息 多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。 3、“无锁”设计 放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。 https://github.com/dotnetcore/CAP 1、分布式领域CAP理论， Consistency(一致性), 数据一致更新，所有数据变动都是同步的 Availability(可用性), 好的响应性能 Partition tolerance(分区容忍性) 可靠性 数据一致性(consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性(strong consistency) (又叫原子性 atomic、线性一致性 linearizable consistency) 服务可用性(availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待 分区容错性(partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务 CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性： 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效) 可用性(Availability) ： 每个操作都必须以可预期的响应结束 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成 C、A、P三者最多只能满足其中两个，和FLP定理一样，CAP定理也指示了一个不可达的结果(impossibility result)。 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 2、关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区： Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。 Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。 Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。 Durability. 一旦事务完成，就不能返回。 3、BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库) Soft state软状态 状态可以有一段时间不同步，异步。 Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。 这个时候有同学可能会把数据库的2PC（两阶段提交）搬出来说话了。OK，我们就来看一下数据库的两阶段提交。 对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。 MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段： 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。 一致性模型 强一致 弱一致性 最终一致性（一段时间达到一致性） XA协议由Tuxedo首先提出的，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准。目前，Oracle、Informix、DB2和Sybase等各大数据库厂家都提供对XA的支持。XA协议采用两阶段提交方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。XA协议包括两套函数，以xa开头的及以ax开头的。 X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。这个思想在java 平台里面到处都是。 XA规范： 应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ） Application Transcation Manage Rosource Manage Communication Resource Manage 常见的事务管理器（ TM ）是交易中间件 常见的资源管理器（ RM ）是数据库 常见的通信资源管理器（ CRM ）是消息中间件 https://www.jianshu.com/p/ab1a1c6b08a1 柔性事务针对分布式事务的解决方法： 1、记录日志+补偿 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。 2、消息 多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。 3、“无锁”设计 放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。 https://blog.csdn.net/cxzhq2002/article/details/46892211 https://www.zhihu.com/question/31813039 柔性事务（遵循BASE理论）是指相对于ACID刚性事务而言的。 支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。 1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。 这是分布式环境下事务处理的典型模式。 2、补偿型： TCC型事务（Try/Confirm/Cancel）可以归为补偿型。 3、异步确保型 将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。 4、最大努力型 PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试） 1、2PC和3PC 二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做) 跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。 3PC (three phase commit) 与两阶段提交不同的是，三阶段提交有两个改动点。 1、引入超时机制。同时在协调者和参与者中都引入超时机制。 2、在第一阶段分为询问阶段，具体操作两个阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。最后提交阶段如果RM超时未收到TM的commit请求，就默认提交（根据概率来的，正常应该是commit的） 也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。 因为有了准备提交(prepare to commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。 TCC编程模式 所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。 补偿事务（TCC） TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段： Try 阶段主要是对业务系统做检测及资源预留 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 2、Paxos（分布式一致性算法） Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 Paxos协议用于解决多个副本之间的一致性问题。 2PC/3PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性 由proposer/acceptor/learner组成 Paxos算法描述：经过上面的推导，我们总结下Paxos算法的流程。 提案询问阶段（Prepare阶段）：如果提案版本号N大于该Acceptor已经响应过的所有Prepare请求的编号，就接收，并承诺不再接收比N小的提案（prepare步骤+acceptor的promise） 提案投票阶段：发送一个针对[N,V]提案，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案 Paxos算法分为两个阶段。具体如下： 阶段一：提案阶段 (a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。 (b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。 阶段二：投票阶段 (a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。 (b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。 Basic Paxos：上面理论 Multi Paxos：proposer leader在Multi Paxos中还有助于提升性能，常态下统一由leader发起提议，可节省prepare步骤(leader不用问询acceptor曾接受过的ID最大的提议、只有leader提议也不需要acceptor进行promise)直至发生leader宕机、重新选主。 Paxos是对一个值达成一致，Multi-Paxos是连续多个paxos instance来对多个值达成一致，这里最核心的原因是multi-paxos协议中有一个Leader。Leader是系统中唯一的Proposal，在lease租约周期内所有提案都有相同的ProposalId，可以跳过prepare阶段，议案只有accept过程，一个ProposalId可以对应多个Value，所以称为Multi-Paxos。 Paxos协议数据同步方式相对于基于传统1主N备的同步方式有啥区别？ 一般情况下，传统数据库的高可用都是基于主备来实现，1主1备2个副本，主库crash后，通过HA工具来进行切换，提升备库为主库。在强一致场景下，复制可以开启强同步，Oracle和Mysql都是类似的复制模式。但是如果备库网络抖动，或者crash，都会导致日志同步失败，服务不可用。为此，可以引入1主N备的多副本形式，我们对比都是3副本的情况，一个是基于传统的1主2备，另一种基于paxos的1主2备。传统的1主两备，进行日志同步时，只要有一个副本接收到日志并就持久化成功，就可以返回，在一定程度上解决了网络抖动和备库crash问题。但如果主库出问题后，还是要借助于HA工具来进行切换，那么HA切换工具的可用性如何来保证又成为一个问题。基于Paxos的多副本同步其实是在1主N备的基础上引入了一致性协议，这样整个系统的可用性完全有3个副本控制，不需要额外的HA工具。而实际上，很多系统为了保证多节点HA工具获取主备信息的一致性，采用了zookeeper等第三方接口来实现分布式锁，其实本质也是基于Paxos来实现的。 3、Raft 算法也是一种少数服从多数的算法（脑裂问题也是可以解决的） 一致性算法：最初的状态都是Follower，任意一个Server都可以申请成为Candidate并申请所有的Server投票给自己，如果收到大多数的Server的同意，就当选为Leader，其他的Server为Follower，如果一轮没有选出，则在一定的timeout后重新发起投票，直到选出Leader Leader挂掉后，集群重新选主，老的Leader恢复后自动成为Follower 当因为网络原因发生脑裂，拥有大多数的一方重新选主，Client发过来的请求都可以成功，少数派的一方接收到的Client请求都是失败的，重新加入后少数派的Server自动成为Follower Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。 在任何时候一个服务器可以扮演以下角色之一： Leader：负责 Client 交互 和 log 复制，同一时刻系统中最多存在一个，处理所有客户端交互，日志复制等，一般一次只有一个Leader. Follower：被动响应请求 RPC，从不主动发起请求 RPC， 类似选民，完全被动 Candidate候选人 : 由Follower 向Leader转换的中间状态，类似Proposer律师，可以被选为一个新的领导人。 Raft：拉票类型的，由Leader-->Follower ZAB:投票类型的，由Leader 4、ZAB 协议 ( Zookeeper Atomic Broadcast) 原子广播协议：保证了发给各副本的消息顺序相同 两种角色+一种角色：Leader和Follower两个角色 + Observer 三种状态：Looking、Following、Leading ZAB 中的节点有三种状态 following：当前节点是跟随者，服从 leader 节点的命令 leading：当前节点是 leader，负责协调事务 election/looking：节点处于选举状态 阶段 ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段 选举（Election） election阶段必须确保选出的Leader具有highestZXID，否则在Recovery阶段没法保证数据的一致性，Recovery阶段Leader要求Follower向自己同步数据没有Follower要求Leader保持数据同步，所有选举出来的Leader要具有最新的ZXID； 在选举的过程中会对每个Follower节点的ZXID进行对比只有highestZXID的Follower才可能当选Leader； 恢复（Recovery） ：数据同步 在election阶段选举出来的Leader已经具有最新的ZXID，所有本阶段的主要工作是根据Leader的事务日志对Follower节点数据进行更新； 数据更新：复制，回滚 广播(Broadcast)：类似2PC提交，只是2PC是接收全部的参与者同意，ZAB只需要超半数同意即可 客户端提交事务请求时Leader节点为每一个请求生成一个事务Proposal，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交 协议状态 ZAB协议中存在着三种状态，每个节点都属于以下三种中的一种： Looking ：系统刚启动时或者Leader崩溃后正处于选举状态 Following ：Follower节点所处的状态，Follower与Leader处于数据同步阶段； Leading ：Leader所处状态，当前集群中有一个Leader为主进程； ZAB中的三种角色：Leader、Follower、Observer Leader、负责发起事务 Follower、负责读写和响应leader的提议 Observer：只负责读取服务 选举流程 https://blog.csdn.net/luonanqin/article/details/78314096 https://zhuanlan.zhihu.com/p/27335748 https://dbaplus.cn/news-141-1875-1.html 初始化时候：初始化epoch和lastzxid一样，serverid最大的作为候选leader 故障恢复时候： 故障选举： 1、每个server的epoch自增，并且将自己的新的epoch发送给其他server， 2、每个server对比自己的新的epoch和接受的epoch比较，把自己的新更新较大的那个epoch 3、依次比较epoch、zxid、serverid，哪个都是最大的就成为leader 故障同步数据： 1、leader给每个follower建立一个handler线程和一个事务队列 2、每个follower给leader发送lastzxid等信息，leader和自身的max/minzxid进行比较 3、如果lastzxidmaxzxid，就删除大于maxzxid数据 正常广播时候： 1、leader发送议案给follower，超过半数的follower回复ack， 2、Leader将再次向集群内Follower广播Commit信息，Commit为将之前的Proposal提交; Leader： Leader作为整个ZooKeeper集群的主节点，负责响应所有对ZooKeeper状态变更的请求。它会将每个状态更新请求进行排序和编号，以便保证整个集群内部消息处理的FIFO。 这里补充一下ZooKeeper的请求类型。对于exists，getData，getChildren等只读请求，收到该请求的zk服务器将会在本地处理，因为由第一讲的ZAB理论可知，每个服务器看到的名字空间内容都是一致的，无所谓在哪台机器上读取数据，因此如果ZooKeeper集群的负载是读多写少，并且读请求分布得均衡的话，效率是很高的。对于create，setData，delete等有写操作的请求，则需要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为一个事务（transaction）。 Follower Follower的逻辑就比较简单了。除了响应本服务器上的读请求外，follower还要处理leader的提议，并在leader提交该提议时在本地也进行提交。Follower处理提议的过程已经在ZAB一章中描述过了。 另外需要注意的是，leader和follower构成ZooKeeper集群的法定人数，也就是说，只有他们才参与新leader的选举、响应leader的提议。 Observer 如果ZooKeeper集群的读取负载很高，或者客户端多到跨机房，可以设置一些observer服务器，以提高读取的吞吐量。Observer和Follower比较相似，只有一些小区别：首先observer不属于法定人数，即不参加选举也不响应提议；其次是observer不需要将事务持久化到磁盘，一旦observer被重启，需要从leader重新同步整个名字空间。 ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议；ZAB可以说是在Paxos算法基础上进行了扩展改造而来的，ZAB协议设计了支持崩溃恢复，ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求，采用ZAB协议将服务器数状态以事务形式广播到所有Follower上；由于事务间可能存在着依赖关系，ZAB协议保证Leader广播的变更序列被顺序的处理，：一个状态被处理那么它所依赖的状态也已经提前被处理；ZAB协议支持的崩溃恢复可以保证在Leader进程崩溃的时候可以重新选出Leader并且保证数据的完整性; 处理过程： 在ZooKeeper中所有的事务请求都由一个主服务器也就是Leader来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal分发给集群中其他所有的Follower，然后Leader等待Follwer反馈，当有 过半数（>=N/2+1） 的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit为将之前的Proposal提交; ZooKeeper启动时所有节点初始状态为Looking，这时集群会尝试选举出一个Leader节点，选举出的Leader节点切换为Leading状态；当节点发现集群中已经选举出Leader则该节点会切换到Following状态，然后和Leader节点保持同步；当Follower节点与Leader失去联系时Follower节点则会切换到Looking状态，开始新一轮选举；在ZooKeeper的整个生命周期中每个节点都会在Looking、Following、Leading状态间不断转换； 状态切换图 ：Leader在超时时间内接收不到超半数的Follower发过来的心跳或TCP连接断开，那Leader会结束当前周期的领导，切换到Looking状态，所有Follower节点也会放弃该Leader节点切换到Looking状态，然后开始新一轮选举 选举出Leader节点后ZAB进入原子广播阶段，这时Leader为和自己同步的每个节点Follower创建一个操作序列，一个时期一个Follower只能和一个Leader保持同步，Leader节点与Follower节点使用心跳检测来感知对方的存在；当Leader节点在超时时间内收到来自Follower的心跳检测那Follower节点会一直与该节点保持连接；若超时时间内Leader没有接收到来自过半Follower节点的心跳检测或TCP连接断开，那Leader会结束当前周期的领导，切换到Looking状态，所有Follower节点也会放弃该Leader节点切换到Looking状态，然后开始新一轮选举； ZAB 协议的核心：定义了事务请求的处理方式。 　　所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader服务器，而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一个客户端事务请求转换成一个事务proposal（提议），并将该 Proposal分发给集群中所有的Follower服务器。之后 Leader 服务器需要等待所有Follower 服务器的反馈,一旦超过半数的Follower服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower服务器分发Commit消息，要求其将前一个proposal进行提交。 如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）的事务 Proposal,那么就可以保证这个新选举出来的 Leader —定具有所有已经提交的提案。同时，如果让具有最高编号事务 Proposal 的机器来成为 Leader, 就可以省去 Leader 服务器检查 Proposal 的提交和丢弃工作的这一步操作。 数据同步 　　Leader 服务器会为每一个 Follower 服务器都准备一个队列，并将那些没有被各 Follower 服务器同步的事务以 Proposal 消息的形式逐个发送给 Follower 服务器，并在每一个 Proposal 消息后面紧接着再发送一个 Commit 消息，以表示该事务已经被提交。等到 Follower 服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应用到本地数据库中后， Leader 服务器就会将该 Follower 服务器加入到真正的可用 Follower 列表中，并开始之后的其他流程。 　　下面来看 ZAB 协议是如何处理那些需要被丢弃的事务 Proposal 的。在 ZAB 协议的事务编号 ZXID 设计中， ZXID 是一个 64 位的数字，低 32 位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求， Leader 服务器在产生一个新的事务 Proposal 的时候，都会对该计数器进行加1操作；高 32 位代表了 Leader 周期 epoch 的编号，每当选举产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务 Proposal 的 ZXID ,并从该 ZXID 中解析出对应的 epoch 值，然后再对其进行加1操作，之后就会以此编号作为新的 epoch, 并将低 32 位置0来开始生成新的 ZXID 。 　　基于这样的策略，当一个包含了上一个 Leader 周期中尚未提交过的事务 Proposal的服务器启动加入到集群中，发现此时集群中已经存在leader，将自身以Follower 角色连接上 Leader 服务器之后， Leader 服务器会根据自己服务器上最后被提交的 Proposal来和 Follower 服务器的 Proposal进行比对，发现follower中有上一个leader周期的事务Proposal时，Leader 会要求 Follower 进行一个回退操作——回退到一个确实已经被集群中过半机器提交的最新的事务 Proposal 。 主从架构下，leader 崩溃，数据一致性怎么保证？leader 崩溃之后，集群会选出新的 leader，然后就会进入恢复阶段，新的 leader 具有所有已经提交的提议，因此它会保证让 followers 同步已提交的提议，丢弃未提交的提议（以 leader 的记录为准），这就保证了整个集群的数据一致性。 选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？这是通过 Fast Leader Election 实现的，leader 的选举只需要超过半数的节点投票即可，这样不需要等待所有节点的选票，能够尽早选出 leader。 paxos 算法与 raft 算法的差异 raft强调是唯一leader的协议，此leader至高无上 raft：新选举出来的leader拥有全部提交的日志，而 paxos 需要额外的流程从其他节点获取已经被提交的日志，它允许日志有空洞 相同点：得到大多数的赞成，这个 entries 就会定下来，最终所有节点都会赞成 分布式事务的作用是保证跨节点事务的原子性，涉及事务的节点要么都提交(执行成功)，要么都不提交(回滚)。分布式事务的一致性通常通过2PC来保证(Two-Phase Commit, 2PC)，2PC的最大问题是，协调者是单点(需要有一个备用节点)，另外协议是阻塞协议，任何一个参与者故障，都需要等待(可以通过加入超时机制)。 Paxos协议用于解决多个副本之间的一致性问题。 2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性，所以两者可以是互补的关系，绝不是替代关系。对于2PC协调者单点问题，可以利用Paxos协议解决，当协调者出问题时，选一个新的协调者继续提供服务。 raft协议和zab协议区别： 第一次写答案.最近正在实现raft协议, zab协议没看过,就刚才粗略地现看了下ZooKeeper Internals和论文, 所以下面的回答只是我自己的一些拙见,欢迎大牛们斧正.因为raft比zab出来晚点,可能raft 里面的有些东西会借鉴zab协议.其实两个协议差不到哪里去,本质上都是维护一个replicated log. 相同点(不全,没有实现过zab): 1、都使用timeout来重新选择leader. 2、采用quorum来确定整个系统的一致性(也就是对某一个值的认可),这个quorum一般实现是集群中半数以上的服务器,zookeeper里还提供了带权重的quorum实现. 3、都由leader来发起写操作. 4、都采用心跳检测存活性. 5、leader election都采用先到先得的投票方式. 不同点(不全,没有实现过zab): 1、zab用的是epoch和count的组合来唯一表示一个值, 而raft用的是term和index. 2、zab的follower在投票给一个leader之前必须和leader的日志达成一致,而raft的follower则简单地说是谁的term高就投票给谁. 3、raft协议的心跳是从leader到follower, 而zab协议则相反.4、raft协议数据只有单向地从leader到follower(成为leader的条件之一就是拥有最新的log), 而zab协议在discovery阶段, 一个prospective leader需要将自己的log更新为quorum里面最新的log,然后才好在synchronization阶段将quorum里的其他机器的log都同步到一致. BTW, raft实现起来比zab会简单很多. CAP原理和BASE思想 http://www.jdon.com/37625 http://www.cnblogs.com/bangerlee/p/5328888.html FLP Impossibility http://blog.csdn.net/chen77716/article/details/27963079 关于分布式事务、两阶段提交协议、三阶提交协议 http://blog.jobbole.com/95632/ https://www.cnblogs.com/binyue/p/3678390.html 分布式事务与一致性算法Paxos & raft & zab http://blog.csdn.net/followmyinclinations/article/details/52870418 raft协议和zab协议有啥区别？ https://www.zhihu.com/question/28242561 Paxos算法 https://www.cnblogs.com/linbingdong/p/6253479.html https://www.cnblogs.com/cchust/p/5617989.html http://blog.csdn.net/xiaqunfeng123/article/details/51712983 https://www.cnblogs.com/bangerlee/p/5655754.html https://yq.aliyun.com/articles/156281 分布式系统的Raft算法： http://www.jdon.com/artichect/raft.html http://www.cnblogs.com/mindwind/p/5231986.html https://raft.github.io/ http://www.infoq.com/cn/articles/raft-paper ZAB协议： http://blog.csdn.net/wangyangzhizhou/article/details/52698555 http://blog.jobbole.com/104985/ https://www.cnblogs.com/jian-xiao/p/5821675.html ZAB中的三种角色：Leader、Follower、Observer https://blog.csdn.net/mayp1/article/details/52026797 拜占庭问题与两军问题 http://blog.csdn.net/wulinjun777/article/details/59012687 2PC是指Oracle的两阶段提交协议（Two-Phase Commit protocol）。 2PC用于确保所有分布式事务能够同时提交（Commit）或者回滚（Rollback），以便使的数据库能够处于一致性状态（consistent state）。 分布式事务可以通过DBA_2PC_PENDING 和 DBA_2PC_NEIGHBORS 字典视图查看。 分布式事务处理是指一个事务可能涉及多个数据库操作 分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务必须产生一致的结果（全部提交或全部回滚）。 XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议，XA被许多数据库（如Oracle和DB2）和中间件等工具(如CICS 和 Tuxedo).本地支持 。 X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）、通信资源管理器（CRM）四部分。在这个模型中，通常事务管理器（TM）是交易中间件，资源管理器（RM）是数据库，通信资源管理器（CRM）是消息中间件。 一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个DTP环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。 XA就是X/Open DTP定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。XA接口函数由数据库厂商提供。通常情况下，交易中间件与数据库通过XA 接口规范，使用两阶段提交来完成一个全局事务，XA规范的基础是两阶段提交协议。 在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。 在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式事务框架.html":{"url":"docs/tech/Distributed/分布式事务框架.html","title":"分布式事务框架","keywords":"","body":"分布式事务框架 现有分布式处理方案 分布式事务中间件Seata的设计原理 JDTX是由京东数科的数据研发团队倾力打造的分布式事务中间件 分布式事务：中间件方案 现有分布式处理方案 一致性理论基石： ACID本地事务 XA协议：2PC、3PC CAP理论 BASE理论 数据一致性分为三个种类型：强一致性，弱一致性以及最终一致性 一致性模型，数据的一致性模型可以分成以下3类： 强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。 最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。 数据库实现的就是强一致性，能够保证在写入一份新的数据库，立即使其可见。 最终一致性是弱一致性的强化版，系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。 微服务作为分布式系统，同样受 CAP[1] 原理的制约，在 CAP 理论中， C：Consistency、A：Availability、P：Partition tolerance 三者不可同时满足，而服务化中，更多的是提升 A 以及 P，在这个过程中不可避免的会降低对 C 的要求，因此，BASE 理论随之而来。 BASE[2] 理论来源于 ebay 在 2008 年 ACM 中发表的论文，BASE 理论的基本原则有三个：Basically Available，Soft state，Eventually consistent，主要目的是为了提升分布式系统的可伸缩性，论文同样阐述了如何对业务进行调整以及折中的手段，BASE 理论的提出为分布式事务的发展指出了一个方向。 在最终一致性的实现过程中，最基本的操作就是保证事务参与者的幂等性，所谓的幂等性，就是业务方能够使用相关的手段，保证单个事务多次提交依然能够保证达到同样的目的。 ACID本地事务：强一致性 现有成熟的分布式解决方案包括XA两阶段提交、可靠消息与TCC模式等类型。XA两阶段提交属于强一致事务，可靠消息与TCC模式属于柔性事务。 XA协议：2PC、3PC：XA两阶段提交，2PC两阶段提交（2PC, Two-phase Commit）方案、三阶段提交协议 3PC---强一致性 2PC二阶段提交方案：强一致性 3PC三阶段提交 TCC事务,TCC模式（Try-Confirm-Cancel）补偿模式---最终一致性 可靠本地消息表：最终一致性 MQ事务：最终一致性 Saga事务：最终一致性 saga的具体实现分为两种：Choreography（编排）以及 Orchestration（编配） 参考关于分布式事务，XA协议的学习笔记RocketMQ 4.3正式发布，支持分布式事务 编制（orchestration）和编排（choreography）是常用于描述“合成Web服务的两种方式”的术语。 虽然它们有共同之处，但还是有些区别的。 Web服务编制（Web Services Orchestration，WSO）指为业务流程（business processes）而进行Web服务合成， 而Web服务编排（Web Services Choreography，WSC）指为业务协作（business collaborations）而进行Web服务合成。 SOA中的两个概念：编制（orchestration）和编排（choreography）WS中Orchestration和Choreography的含意Choreography vs Orchestration编配和编排的定义之争Web服务聚合中的Orchestration和ChoreographyMicroservices Choreography vs Orchestration: The Benefits of Choreography微服务协调与编排：协调的好处 事务的隔离级别： 数据库的四种隔离级别：脏读、不可重复读、幻读 Read uncommitted 读未提交 在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。 因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。 Read committed 读提交 在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。 Repeatable read 重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。 Serializable 序列化 该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。 分布式事务中间件Seata的设计原理 https://seata.io/zh-cn/ https://github.com/seata/seata https://github.com/seata/seata-samples https://seata.io/zh-cn/docs/overview/what-is-seata.html https://github.com/seata/seata/wiki/%E6%A6%82%E8%A7%88 Fescar 的发展历程 阿里是国内最早一批进行应用分布式（微服务化）改造的企业，所以很早就遇到微服务架构下的分布式事务问题。 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast & EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 TXC/GTS/Fescar 一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。 参考 https://www.sofastack.tech/blog/seata-distributed-transaction-deep-dive/ http://jm.taobao.org/2017/04/27/20170427/ https://juejin.im/post/5d2616256fb9a07eef6a3619 https://cloud.tencent.com/developer/article/1463287 https://www.kubernetes.org.cn/5603.html https://yq.aliyun.com/articles/334238 JDTX是由京东数科的数据研发团队倾力打造的分布式事务中间件 参考 http://blog.itpub.net/31556440/viewspace-2662840/ 分布式事务：中间件方案 TX-LCNhttps://www.txlcn.org/zh-cn/ atomikoshttps://www.atomikos.com/ 开源类事务管理器 GTS https://www.aliyun.com/aliware/txc?spm=5176.8142029.388261.386.a72376f4lqvQxv 全局事务服务（Global Transaction Service ，简称GTS）用于实现分布式环境下高性能事务一致性。 FESCAR （推荐）现在改名字，是分布式事务中间件Seata https://github.com/wxbty/meepo http://www.iocoder.cn/categories/TCC-Transaction/ 可靠消息分布式事务中间件 https://gitee.com/silk7/shine-mq 参考 https://blog.csdn.net/fly910905/article/details/87356755 https://www.zhihu.com/question/64921387 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/常见分布式集群选举机制总结.html":{"url":"docs/tech/Distributed/常见分布式集群选举机制总结.html","title":"常见分布式集群选举机制总结","keywords":"","body":"常见分布式集群选举机制总结 Zookeeper选举 Kafka选举 Redis选举 Eureka选举 RocketMQ选举 Zookeeper选举 参考 https://www.jianshu.com/p/49ce02abc7ba Kafka选举 Kafka Controller控制器的选举：kafka集群的controller选举 分区leader的选举 消费者相关的选举 Kafka Controller控制器的选举 在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。比如当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。再比如当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。 Kafka Controller的选举是依赖Zookeeper来实现的，在Kafka集群中哪个broker能够成功创建/controller这个临时（EPHEMERAL）节点他就可以成为Kafka Controller。 Kafka Controller的选举其实就是创建临时节点，这和Zookeeper分布式锁的实现原理基本相同。 分区leader的选举： 分区leader副本的选举由Kafka Controller 负责具体实施。当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的leader副本下线，此时分区需要选举一个新的leader上线来对外提供服务）的时候都需要执行leader的选举动作。 基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。 消费者相关的选举： 组协调器GroupCoordinator需要为消费组内的消费者选举出一个消费组的leader，这个选举的算法也很简单，分两种情况分析。 1、如果消费组内还没有leader，那么第一个加入消费组的消费者即为消费组的leader。 2、如果某一时刻leader消费者由于某些原因退出了消费组，那么会重新选举一个新的leader， 在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member_id，而value是消费者相关的元数据信息。 leaderId表示leader消费者的member_id，它的取值为HashMap中的第一个键值对的key，这种选举的方式基本上和随机无异。 总体上来说，消费组的leader选举过程是很随意的。 Kafka选举参考 https://blog.csdn.net/u013256816/article/details/89369160 https://www.jianshu.com/p/49ce02abc7ba Redis选举 redis集群的主从切换 redis没有类似Zookeeper的选举机制。redis的master挂掉以后，redis集群是通过主从切换来保证高可用性的。 redis主从切换有2种方式：手动切换和自动切换。 这里我们讨论自动切换，redis主从自动切换需要哨兵模式的支持，哨兵模式简单来说就是：监控master和slave，在master出现故障的时候，自动将slave切换成master，master恢复以后，作为新master的slave对外提供服务。 参考 https://www.jianshu.com/p/49ce02abc7ba Eureka选举 Eureka集群的相互复制 准确的来说，Eureka集群中的各节点之间不存在主从关系。Eureka集群中的节点的关系是对等的，其他3种集群则都存在主从关系，这是Eureka集群的一个特色。 Eureka集群的各个server之间通过相互注册的方式来实现集群的高可用性。数据同步的方式是增量备份，这样可以保证每个server都是最新最全的数据。从而保证集群的高可用性。这样即使某个server挂了，集群还可以对外提供服务。 总结： Eureka server集群不存在选举机制，Eureka server集群各节点的关系是对等的，Eureka server通过相互复制来保证高可用性。 参考 https://www.jianshu.com/p/49ce02abc7ba RocketMQ选举 NameServ之间都是全量的数据，没有选举 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式锁实现.html":{"url":"docs/tech/Distributed/分布式锁实现.html","title":"分布式锁实现","keywords":"","body":" 分布式锁实现原理 DB数据库乐观锁 基于Redis的分布式锁 基于ZooKeeper的分布式锁 分布式锁实现 分布式锁实现原理 在同一个jvm进程中时，可以使用JUC提供的一些锁来解决多个线程竞争同一个共享资源时候的线程安全问题，但是当多个不同jvm进程中的线程共同竞争同一个共享资源时候，juc包的锁就无能无力了，这时候就需要分布式锁了。 常见的有使用zk的最小版本，redis的set函数，数据库锁来实现 首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： 1、互斥性。在任意时刻，只有一个客户端能持有锁。 2、不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 3、具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。 4、解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 针对分布式锁的实现目前有多种方案：互斥、超时、可重入等 1、基于数据库实现分布式锁：获取锁插入一条记录，释放锁就删除记录 2、基于缓存（redis，memcached）实现分布式锁 3、基于Zookeeper实现分布式锁 分布式锁实现 DB memcached(add) Redis(setnx) zookeeper(临时有序节点) 代码org.quickstart.javase.distributed.lock 使用数据库悲观锁实现不可重入的分布式锁 使用Redis单实例实现不可重入的分布式锁 使用zookeeper序列节点实现不可重入的分布式锁 分布式锁实现： https://www.cnblogs.com/yuyutianxia/p/7149363.html http://blog.csdn.net/x_i_y_u_e/article/details/50864205 http://www.importnew.com/27477.html?utm_source=tuicool&utm_medium=referral DB数据库乐观锁 DB数据库： 使用select * from lock where uid = 1 for update的拍他锁，设置不自动提交，先执行该SQL，然后执行业务，然后提交 数据库实现缺点：数据库单点问题 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。 非阻塞的？搞一个while循环，直到insert成功再返回成功。 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。 memcached(add) 基于Redis的分布式锁 利用setnx+expire命令 (错误的做法)setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。 使用set+expire+事务 或者 使用setnx+Lua脚本（包含setnx和expire两条指令）说道Redis分布式锁大部分人都会想到：setnx+lua，或者知道set key value px milliseconds nx。 这种实现方式有3大要点（也是面试概率非常高的地方）： set命令要用set key value px milliseconds nx； value要具有唯一性； 释放锁时要验证value值，不能误解锁； 事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况： 在Redis的master节点上拿到了锁； 但是这个加锁的key还没有同步到slave节点； master故障，发生故障转移，slave节点升级为master节点； 导致锁丢失。 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法) EX seconds – 设置键key的过期时间，单位时秒 PX milliseconds – 设置键key的过期时间，单位时毫秒 NX – 只有键key不存在的时候才会设置key的值 XX – 只有键key存在的时候才会设置key的值 Redlock算法与Redisson实现（Redisson实现了Redlock算法） the Redlock algorithm在Redis的分布式环境中，Redis 的作者提供了RedLock 的算法来实现一个分布式锁。 基于Redis的分布式锁实现Redlock：Redis分布式锁最牛逼的实现使用Redis的分布式锁Redis分布式锁背后的原理 Redis： 使用SetNX，设置过期时间，过期时间太小会出现业务没有做完锁就释放了 还可以设置超过多少次没有获取就等待，随机生成一个等待时间，等时间到后在进行重试，升级成重量级锁 基于缓存： redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。 使用缓存实现分布式锁的优点: 性能好，实现起来较为方便。 使用缓存实现分布式锁的缺点: 通过超时时间来控制锁的失效时间并不是十分的靠谱。 基于ZooKeeper的分布式锁 基于ZK的方式： 基于zookeeper临时有序节点可以实现的分布式锁。大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的 瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导 致的锁无法释放，而产生的死锁问题。 锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（ Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。 非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。 不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的 时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。 单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。 使用zookeeper实现分布式锁 首先我们先来看看使用zk实现分布式锁的原理，在zk中是使用文件目录的格式存放节点内容，其中节点类型分为： 持久节点（PERSISTENT ）：节点创建后，一直存在，直到主动删除了该节点。 临时节点（EPHEMERAL）：生命周期和客户端会话绑定，一旦客户端会话失效，这个节点就会自动删除。 序列节点（SEQUENTIAL ）：多个线程创建同一个顺序节点时候，每个线程会得到一个带有编号的节点，节点编号是递增不重复的，如下图： 如上图，三个线程分别创建路径为/root/node的节点，可知在zk服务器端会在root下存在三个node节点，并且器编号唯一递增。 具体在节点创建过程中，可以混合使用，比如临时顺序节点（EPHEMERAL_SEQUENTIAL），这里我们就使用临时顺序节点来实现分布式锁。 分布式锁实现：创建临时顺序节点,比如/root/node，假设返回结果为nodeId。 获取/root下所有孩子节点，用自己创建的nodeId的序号与所有子节点比较，看看自己是不是编号最小的。如果是最小的则就相当于获取到了锁，如果自己不是最小的，则从所有子节点里面获取比自己次小的一个节点，然后设置监听该节点的事件，然后挂起当前线程。 当最小编号的线程获取锁，处理完业务后删除自己对应的nodeId，删除后会激活比自己大一号的节点的线程从阻塞变为运行态，被激活的线程应该就是当前node序列号最小的了，然后就会获取到锁。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式ID生成服务.html":{"url":"docs/tech/Distributed/分布式ID生成服务.html","title":"分布式ID","keywords":"","body":" 分布式ID的生成方案 分布式ID生成服务 分布式ID的生成方案 分布式ID的生成方案：分段 数据库自增长序列或字段：第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表 号段模式：我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。 Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现，可以利用Redis中的incr命令来实现原子性的自增与返回 UUID Twitter的snowflake雪花算法：snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图 其他框架 百度（uid-generator） ：uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。 美团（Leaf） ：美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。 滴滴Tinyid 分布式ID： 1、UUID 2、使用每个应用分一段序列号，请求的时候一次请求一段放在本地待使用，Zookeeper记录最大的Id 3、主要思路采用了MySQL自增长ID的机制(auto_increment + replace into)，以MySQL举例，利用给字段设置 auto_increment_increment 和 auto_increment_offset 来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。 4、CenterCode+AppCode+使用Redis的原子操作 INCR和INCRBY， 5、类snowflake方案：这种方案生成一个64bit的数字，64bit被划分成多个段，分别表示时间戳、机器编码、序号。 6、TDDL序列生成方式：按应用进行每次一个步长的增长，步长变动可以使用Zookeeper来通知 参考大型互联网公司分布式ID方案总结 https://www.jianshu.com/p/9d7ebe37215e https://tech.meituan.com/2017/04/21/mt-leaf.html https://www.cnblogs.com/haoxinyue/p/5208136.html https://github.com/beyondfengyu/SnowFlake https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect 分布式主键 数据库自增长序列或字段 UUID Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。 Twitter的snowflake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。 www.toutiao.com/i6682672464708764174分布式ID的生成方案 唯一ID的特性： 1、整个系统ID唯一 2、ID是数字类型，而且是趋势递增的 3、ID简短，查询效率快 1、UUID 2、MySQL主键自增 3、雪花snowflake算法 4、Redis生成方案 分布式ID的生成方案：分段 数据库自增长序列或字段 Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。 UUID Twitter的snowflake雪花算法 5、其他框架 美团 Leaf 滴滴 Tinyid 百度 UidGenerator 1、UUID 优点： 代码实现简单。 本机生成，没有性能问题 因为是全球唯一的ID，所以迁移数据容易 缺点： 每次生成的ID是无序的，无法保证趋势递增 UUID的字符串存储，查询效率慢 存储空间大 ID本事无业务含义，不可读 应用场景： 类似生成token令牌的场景 不适用一些要求有趋势递增的ID场景 2、MySQL主键自增：这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。 优点： 数字化，id递增 查询效率高 具有一定的业务可读 缺点： 存在单点问题，如果mysql挂了，就没法生成iD了 数据库压力大，高并发抗不住 3、MySQL多实例主键自增：这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长 每台的初始值分别为1,2,3...N，步长为N（这个案例步长为4） 可以自行定义max_id的起点，和step步长，保存在在数据库中，每次业务请求都去请求一段数据【max_id + 1，max_id+step】区间的ID保存在JVM本地缓存中 多个节点请求同一个业务的ID，可以使用事务的方式，把查询和更新max_id放在一个事务中 步长是可以随时修改的 因为会有一个线程，会观察什么时候去自动获取。两个buffer之间自行切换使用。就解决了突发阻塞的问题。 优点： 解决了单点问题 缺点： 一旦把步长定好后，就无法扩容； 而且单个数据库的压力大，数据库自身性能无法满足高并发 应用场景： 数据不需要扩容的场景 4、雪花snowflake算法 这个算法网上介绍了很多，老顾这里就不详细介绍。雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点： 此方案每秒能够产生409.6万个ID，性能快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点： 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。 5、Redis生成方案 利用redis的incr原子性操作自增，一般算法为： 年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增 优点： 有序递增，可读性强 缺点： 占用带宽，每次要向redis进行请求 每次都要去Redis去请求，有网络请求耗时，并发强依赖了Redis。这个设计是有风险的，一旦Redis挂了，整个系统不可用。考虑到ID安全性的问题，如：Redis方案中，用户是可以预测下一个ID号是多少，因为算法是递增的。 Leaf——美团点评分布式ID生成系统美团 Leaf：https://github.com/Meituan-Dianping/Leafhttps://github.com/zhuzhong/idleafhttps://tech.meituan.com/2019/03/07/open-source-project-leaf.htmlhttps://tech.meituan.com/2017/04/21/mt-leaf.html 滴滴 Tinyidhttps://github.com/didi/tinyid 百度 UidGeneratorhttps://github.com/baidu/uid-generator 分布式ID的实现方式：https://www.iteye.com/blog/uule-2420466https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect Twitter的snowflake雪花算法 最新的 https://twitter.github.io/twitter-server/ https://github.com/twitter/twitter-server 老的2010版本，已经淘汰了Snowflake的初始版本，已经迁移到twitter-server项目了 https://github.com/twitter-archive/snowflake/releases 参考https://www.kutu66.com/GitHub/article_103050https://github.com/zhongxunking/idcenterhttps://cloud.tencent.com/developer/article/1533454 Guide to UUID in Javacore-java-uuid源码 NanoID官网JNanoId Java版本 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式缓存.html":{"url":"docs/tech/Distributed/分布式缓存.html","title":"分布式缓存","keywords":"","body":"分布式缓存 参考 分布式缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式存储系统.html":{"url":"docs/tech/Distributed/分布式存储系统.html","title":"分布式存储系统","keywords":"","body":"分布式存储系统 一大批优秀的开源分布式存储系统，包括ceph、swift、Lustre和glusterfs等。 GlusterFS https://www.gluster.org https://github.com/gluster/glusterfs Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Distributed/分布式数据库.html":{"url":"docs/tech/Distributed/分布式数据库.html","title":"分布式数据库","keywords":"","body":"分布式数据库 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/DataStructure/数据结构与算法.html":{"url":"docs/tech/DataStructure/数据结构与算法.html","title":"数据结构与算法","keywords":"","body":"数据结构与算法 1、 2、 3、 4、 5、 3、数据结构和算法：树的类型 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/DataStructure/数据结构.html":{"url":"docs/tech/DataStructure/数据结构.html","title":"数据结构学习","keywords":"","body":"数据结构 Java集合数据结构 Collection ├─List │ ├─ArrayList │ ├─LinkedList │ ├─Vector ├─Stack │ ├─Set │ ├─HashSet │ ├─TreeSet Map ├─HashMap ├─TreeMap ├─LinkedHashMap 数据结构 线性表：数组（Array）和链表（linked list）等 队列（Queue） 栈（Stack） 树（tree） 图（Map） 一.什么是数据结构 答：数据结构是指数据存储的组织方式。大致上分为线性表、队列（Queue）、栈（Stack）、树（tree）、图（Map）。 二.线性表 线性表又细分为两大类，即数组（Array）和链表（linked list） 不同于内存Heap和Stack的区别 常见的数据结构：堆栈、队列、数组、链表和红黑树 数据存储的常用结构有： 队列queue：FIFO 栈stack：FILO 数组Array：数组是在内存中开辟一段连续的空间 链表LinkedList： 红黑树： 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点: 先进后出（存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。 栈的入口、出口的都是栈的顶端位置。 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。 队列的入口、出口各占一侧。 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。 每个结点包括两个部分： 一个是存储数据元素的数据域， 一个是存储下一个结点地址的指针域。 链表结构有单向链表与双向链表。 采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍。 参考 https://zhuanlan.zhihu.com/p/63138829 https://www.cnblogs.com/yinzhengjie/p/9244986.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/DataStructure/各种树的复杂度和原理.html":{"url":"docs/tech/DataStructure/各种树的复杂度和原理.html","title":"各种树的复杂度和原理","keywords":"","body":"各种树的复杂度和原理 二叉树：二叉排序树、满二叉树、完全二叉树、平衡二叉树 B树：平衡多路搜索树B树（B-tree）、B+Tree、红黑树 Trie树（Prefix Tree）介绍 二叉树：二叉排序树、满二叉树、完全二叉树、平衡二叉树 二叉树： 二叉排序树满二叉树、完全二叉树、平衡二叉树 树： 二叉树（Binary Tree）：是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 二叉树是树的一种特殊情形，是一种更简单而且应用更加广泛的树。 满二叉树：满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 一棵深度为k，且有2^（k-1）个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。 完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。 除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。 具有n个结点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^（k-1）个叶子结点，至多有2^k-1个结点。 平衡二叉树：平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 前中后指的是根节点的位置，都是先左再右： 前序遍历：是先访问根，再访问左子树，然后访问右子树后序遍历：是先访问左子树，再访问右子树，然后访问根中序遍历：是先访问左子树，再访问根，然后访问右子树层次遍历：即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同） 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 二叉排序树，又称为二叉查找树。二叉排序树或者是一棵空树，或者是具有以下性质的二叉树：若其左子树不为空，则左子树上的所有节点的值均小于它的根结点的值；若其右子树不为空，则右子树上的所有节点的值均大于它的根结点的值；左右子树又分别是二叉排序树。 一棵空树，或者是具有下列性质的二叉树： （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3）左、右子树也分别为二叉排序树； （4）没有键值相等的结点。 二叉排序树： https://blog.csdn.net/google19890102/article/details/54378628 B树：平衡多路搜索树B树、B+Tree、红黑树 B树：平衡多路搜索树B树（B-tree）、B+Tree、红黑树 1、阶的概念 对于一棵m阶B-tree，每个结点至多可以拥有m个子结点。 即遍观整棵树，子节点最多的个数是m，那么这棵树就是m阶树。 2、树的度 树的度就是树的高度，即树的层数。 B-树就是B树 英文名字叫做B-tree，中间的短线是英文连接符，只是翻译的时候将短线翻译成了减号。 全称Balance-tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B-tree有多条路，即父节点有多个子节点。 B-树用途 使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。 B+树的定义 B+树是B树的一种变形，它更适合实际应用中操作系统的文件索引和数据库索引。定义如下：（为和大多资料保持一致，这里使用阶数mmm来定义B+树，而不像之前的B树中，使用的是最小度ttt来定义） 根据B+树的结构，我们可以发现B+树相比于B树，在文件系统，数据库系统当中，更有优势，原因如下： 1、B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I/O读写次数也就降低了。 2、B+树的查询效率更加稳定 由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 3、B+树更有利于对数据库的扫描 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能。 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。 红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。 参考 https://blog.csdn.net/u010916338/article/details/86134334 https://blog.csdn.net/guoziqing506/article/details/64122287 https://blog.csdn.net/v_JULY_v/article/details/6105630 Trie树（Prefix Tree）介绍 一、Trie树（Prefix Tree）介绍 Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。 Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 二、Trie树的优缺点 Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点 1、插入和查询的效率很高，都为O(m)O(m)，其中 mm 是待插入/查询的字符串的长度。 关于查询，会有人说 hash 表时间复杂度是O(1)O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。 2、Trie树中不同的关键字不会产生冲突。 3、Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。 4、Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。 5、Trie树可以对关键字按字典序排序。 缺点 1、当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。 2、空间消耗比较大。 三、Trie树的应用 1、字符串检索 2、词频统计 3、字符串排序 4、前缀匹配 5、作为其他数据结构和算法的辅助结构 1、字符串检索 检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较： 如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。 如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。 ``` struct trie_node { bool isKey; // 标记该节点是否代表一个关键字 trie_node *children[26]; // 各个子节点 }; ``` 2、词频统计 Trie树常被搜索引擎系统用于文本词频统计 。 ``` struct trie_node { int count; // 记录该节点代表的单词的个数 trie_node *children[26]; // 各个子节点 }; ``` 思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。 注意：第一、第二种应用也都可以用 hash table 来做。 3、字符串排序 Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。 4、前缀匹配 例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a->b->开头的路径上的关键字即可。 trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 5、作为其他数据结构和算法的辅助结构 如后缀树，AC自动机等。 参考 https://blog.csdn.net/lisonglisonglisong/article/details/45584721 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/常见算法学习.html":{"url":"docs/tech/Algorithm/常见算法学习.html","title":"常见算法","keywords":"","body":"常见算法学习 排序算法：十种 查找算法：七种 其他查找算法 树的数据结构和复杂度（时间和空间） 图：有向图、无向图、图的出度和入度 缓存淘汰算法：缓存算法（页面置换算法）-FIFO、LFU、LRU 排序算法：复杂度（时间、空间） 排序算法：十种 十种常见排序算法可以分为两大类： 比较类排序： 1、冒泡排序（Bubble Sort）：冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 2、选择排序（Selection Sort）：选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 3、插入排序（Insertion Sort）：插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 4、希尔排序（Shell Sort）：1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 5、归并排序（Merge Sort）：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 6、快速排序（Quick Sort）：快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 7、堆排序（Heap Sort）：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 非比较类排序： 8、计数排序（Counting Sort）：计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 9、桶排序（Bucket Sort）：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 10、基数排序（Radix Sort）：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 参考十大经典排序算法（动图演示）图解排序算法http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1面试中的 10 大排序算法总结 查找算法：七种 查找算法分类 1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。 查找性能：从快到慢： 顺序查找，时间复杂度O(N), 分块查找，时间复杂度O(logN+N/m); 二分查找，时间复杂度O(logN) Fibonacci查找，时间复杂度O(logN) 差值查找，时间复杂度O(log(logN)) 哈希查找，时间复杂度O(1) [Data Structure & Algorithm] 七大查找算法 顺序查找 二分查找（折半查找） 插值查找 斐波那契查找 树表查找： 二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树， 平衡查找树之2-3查找树（2-3 Tree） 平衡查找树之红黑树（Red-Black Tree） B树和B+树（B Tree/B+ Tree） 分块查找 哈希查找：哈希表法（散列表） 顺序查找：条件：无序或有序队列。 按顺序比较每个元素，直到找到关键字为止。 时间复杂度：O(n) 二分查找（折半查找） ：条件：有序数组 先跟中间比较，再跟较大或较小那一边比较 时间复杂度：O(logn) 插值查找 斐波那契查找 树表查找 分块查找：思想：顺序查找和二分查找的结合。 原理：将n个数据元素\"按块有序\"划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须\"按块有序\"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字； 而第2块中任一元素又都必须小于第3块中的任一元素，……。 然后使用二分查找及顺序查找。 时间复杂度：介于O(n) 和O(logn)之间。 哈希查找：哈希表法（散列表） 条件：先创建哈希表（散列表） 原理：根据键值方式(Key Value)进行查找，通过散列函数，定位数据元素。 时间复杂度：几乎是O(1)，取决于产生冲突的多少。 参考 https://www.cnblogs.com/maybe2030/p/4715035.html https://blog.csdn.net/guoweimelon/article/details/50906299 https://zhuanlan.zhihu.com/p/37440434 http://codingxiaxw.cn/2017/01/14/66-leetcode-find/ https://juejin.im/post/5c7e843351882546c20a8669 其他查找算法 参考 docs/SQL/数据库索引.md 查找算法： 1、最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。 数据结构：有序或无序队列 复杂度：O(n) 2、二分查找（binary search） 数据结构：有序数组 复杂度：O(logn) 3、二叉排序树的特点是： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 搜索的原理： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则搜索左子树；否则： 查找右子树。 数据结构：二叉排序树 时间复杂度： O(log2N) 4、哈希散列法(哈希表) 其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。 数据结构：哈希表 时间复杂度：几乎是O(1)，取决于产生冲突的多少，也就是链表长度，因为链表查找复杂度为O(n) 5、分块查找 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。 算法流程： 先选取各块中的最大关键字构成一个索引表； 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 6、平衡多路搜索树B树（B-tree） B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。 首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。 例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN) 由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质 7、B+Tree 其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。 树的数据结构和复杂度（时间和空间） 树的概念： 结点：指二叉树中一个个的点，就是下图中的0、1、2、3、4、5、6； 度：指父结点下面有几个孩子结点，举两个例子你就明白了。针对结点1，他下面有两个孩子3、4，所以说结点1的度为2；针对结点4，他下面一个孩子都没有，所以说结点4的度为0；叶子就是度为0的结点。 置于遍历有一点点麻烦，但要抓住以下要点就可以了（不管任何大小的树）： 前序：是先访问根，再访问左子树，然后访问右子树 后序：是先访问左子树，再访问右子树，然后访问根 中序：是先访问左子树，再访问根，然后访问右子树 完全二叉树，除了叶子结点这层外，其他层结点都是度为2的，所以这样的树高度应该最矮了。 以下图为例子： 前序序列：0134256后序序列：3415620中序序列：3140526 图：有向图、无向图、图的出度和入度 图论（离散数学）： 出度和入度可以把人与人之间为识的关系对应到一个图中。如果a认识b就a->b连一条边。有向图来说，结常与结点间的连接。V1到V2，V1到V3。说明V1的出度是2。V2到V1说明V1的入度是1 数据结构中入度出度分别用什么符号表示入度：ID in degree出度：OD out degree 有向图顶点集的度数是不是等于出度加入度在一个有向图中，所有顶点的入度之和等于所有顶点出度之和，一条边必有起点和终点，这是同时存在的，不存在一条边只有起点或者只有终点，所以所有顶点的入度之和等于所有顶点出度之和 在有向图中，入度高的点和出度高的点各自的含义是不同的。粗浅地说，出度高的点我们往往叫做Authority，就是那种权威性很好，所以对其他点影响力较强或者输出信息较多的点。而相应的，入度比较高的点称为Hub，即那种作为中介的，从别人那里获取信息比较多的点。当然，计算Authority和Hub更权威的方法有HITS算法等，往往并非单纯依赖出入度这么简单。 度数这个概念仅适用于无向图，即相邻的点的个数（或者说是连接的边的个数）。在有向图中，一般来说只分开考虑入度和出度，基本上见不到说把两者加起来记做度数的。 缓存淘汰算法 缓存淘汰算法：缓存算法（页面置换算法）-FIFO、LFU、LRU 链表+HashMap实现LRU算法 ：链表存储数据项的顺序，HashMap存储数据项 FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。双向链表：新来的数据放在链表尾部，淘汰时候删除头部 LRU：Least Recently Used，最近最少使用。链表+HashMap实现LRU算法：链表存储数据项的顺序，HashMap存储数据项 LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。链表实现 LRU和LFU侧重点不同， LRU主要体现在对元素的使用时间上, 而LFU主要体现在对元素的使用频次上。 LFU的缺陷是：在短期的时间内，对某些缓存的访问频次很高，这些缓存会立刻晋升为热点数据，而保证不会淘汰，这样会驻留在系统内存里面。而实际上，这部分数据只是短暂的高频率访问，之后将会长期不访问,瞬时的高频访问将会造成这部分数据的引用频率加快，而一些新加入的缓存很容易被快速删除，因为它们的引用频率很低。 参考 /Users/yangzl/git/quickstart-cache/docs/缓存学习.md https://www.cnblogs.com/wyq178/p/11790015.html 排序算法：复杂度（时间、空间） 这个简单。排序算法分为比较算法和非比较算法， 其中比较算法包括交换排序「冒泡和快排」、选择排序「简单选择排序和堆排序」、插入排序「直接插入排序、希尔排序」、归并排序「二路归并和多路归并」， 非比较排序有计数排序、桶排序、基数排序。「公式：不稳定的有：快些选堆」 1、冒泡排序。稳定的，平均时间复杂度为 O(n²)，最好时间复杂度那肯定就是一次循环 O(n)，最坏时间复杂度为 O(n²)。空间复杂度 O(1)。 2、快速排序。不稳定，平均时间复杂度为O(nlogn)，最好的时间复杂度为O(nlogn)，最坏就是选定的基准值在最边上，这样就是O(n²)，注意哦，快排的空间复杂度平均是 O(logn)，最差 O(n)。 3、简单选择排序。不稳定，平均、最好、最坏时间复杂度都为O(n²)。空间复杂度 O(1)。 4、堆排序。不稳定，平均、最好、最坏的时间复杂度为O(nlogn)。空间复杂度 O(1)。 5、直接插入排序。稳定。最好O(n)，平均、最坏时间复杂度O(n²)。空间复杂度 O(1)。 6、希尔排序。不稳定。最好O(n)，平均O(n1.3)，最坏肯定是O(n²)。空间复杂度O(1)。 7、归并排序。稳定。最好、最坏、最差时间复杂度O(nlogn)，空间复杂度O(n)。 8、计数排序。稳定，空间换时间。适合数比较集中在一起的，这样k就少了，时间复杂度为 O(n+k)，空间复杂度也为O(n+k)。「个人还是觉得其实空间复杂度为O(k)，因为我可以把值放回去的时候可以放到原数组上，所以是O(k)。」 9、桶排序，桶越多，时间复杂度很简单，为O(n+k)，空间复杂度最坏为O(n+k)，其中 n 是因为桶内部所有元素得排序， k 是指桶的数量。 10、基数排序，时间复杂度O(n*k)，k为最大数的位数，空间复杂度为O(n)。 堆排序的稳定性，如何实现堆排序，具体细节 我们知道堆的结构是节点i的孩子为2 i和2 i + 1节点， 大顶堆要求父节点大于等于其2个子节点， 小顶堆要求父节点小于等于其2个子节点。 堆排序。不稳定，平均、最好、最坏的时间复杂度为O(nlogn)。空间复杂度 O(1)。 由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N logN)。故堆排序的时间复杂度为O(N logN)。 归并排序的稳定性，如何实现归并排序，具体细节 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 平均时间复杂度、最好情况、最坏情况均为O(nlogn)，辅助空间O(n)。 归并排序。稳定。最好、最坏、最差时间复杂度O(nlogn)，空间复杂度O(n)。 归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(NlogN)。 因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(NlogN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。 说一下jdk自带的排序用到了哪些排序算法，展开讲一下 1、Arrays.sort() & Collections.sort() 2、JDK中的自带的排序算法实现原理精彩总结 jdk层面实现的sort总共是两类，一个是 Arrays.sort()， Collections.sort()； 1、Arrays.sort() a、如果数组内元素是基本数据类型，最主要采用的是双轴快速排序「其实就是三路快排一模一样的思路，只不过三路快排中间是 = pivot1，而双轴快速排序是（pivot1，pivot2），具体戳链接：https://www.cnblogs.com/nullzx/p/5880191.html 。 总结就是数组长度小于47的时候是用直接插入算法，大于47并且小于286是采用双轴快速排序，大于286如果连续性好「也就是元素大多有序，有一个flag专门用来记录数组元素的升降次数，代表这个数组的连续性」采用的是归并排序，否则还是依旧采用双轴快速排序。 b、如果数组内元素是对象，采用的是TimSort.sort()，跟 Collections.sort()一样，都是采用的这个函数，这是归并排序算法和插入排序的结合。 Collections.sort()，采用 TimSort.sort()。 TimSort.sort() 大概原理： 1、当待排序元素小于32个时，采用二分插入排序，是插入排序的一种改进，可以减少插入排序比较的次数。当找到插入位置时，直接利用System.copy()函数即可。 2、当待排序元素大于等于32个时，进行归并排序（和传统的归并不一样），首先将排序元素分区，每个分区的大小区间为[16,32)，然后依次对每个分区进行排序（具体实现依然是二分插入排序），排完序的分区压入栈（准确的说不是栈，而是一个数组，用来记录排序好的分区），当栈内的分区数满足条件时，进行分区合并，合并为一个更大的分区，当栈中只剩一个分区时，排序完成。 经典排序算法----堆与堆排序（不稳定） 经典排序算法----归并排序（稳定） https://blog.csdn.net/qianqin_2014/category_6339684.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/递归算法.html":{"url":"docs/tech/Algorithm/递归算法.html","title":"递归算法","keywords":"","body":"递归算法 什么是递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。 进一步剖析「递归」，先有「递」再有「归」， 「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解）， 「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,....,直到最开始的问题解决,文字说可能有点抽象，那我们就以阶层 f(6) 为例来看下它的「递」和「归」。 参考 https://mp.weixin.qq.com/s/Hew44D8rdXb3pf8mZGk67w Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/Top K之海量数据找出现次数最多或不重复的.html":{"url":"docs/tech/Algorithm/Top K之海量数据找出现次数最多或不重复的.html","title":"Top K 之海量数据找出现次数最多或，不重复的","keywords":"","body":"Top K之海量数据找出现次数最多或不重复的 1、海量数据 求最大的 K个数问题，如何解决？ 2、海量数据求中位数，如何解决？ 3、在海量数据中找出出现频率最高的前k个数 4、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 大概统计一下，海量数据求 TopK 的普遍方法 如何判断一个元素是否存在一个集合中？ 海量数据找出不重复的元素思路一：分治法 + HashMap (HashMap 不要局限在 Java 语言) 思路二：位图法 Bitmap(一个 bit 仅会是 0 或 1) 海量数据找出出现次数最多的 思路一：分治法 + HashMap 纯数字的可以考虑思路二：位图法 Bitmap 参考https://juejin.im/post/5aa0ee9f518825557c010bc0 海量数据 求最大的 K个数问题，如何解决？ 1、按位划分区域，可以尽快的缩小范围，比如最高位 0 分一堆，1 分成一堆而且不用排序，这是第一选择。 2、最经典的方法当然是 堆 了，比如要求前1000个最大的数，那就直接建一个 1000 大小的小根堆，然后遍历，只要发现后面的数比小根堆的根节点大，就把根节点和该数交换，重新调整堆，遍历完之后，堆中的数自然就是最大的 1000 个数了； 3、当然能使用堆排序的前提是内存中要能够放得下这个 K，如果放不下呢？那就只能外部排序了，排序完之后拿到第 K 大的数即可，当然排序前可以和方法一搭配一下。 海量数据求中位数，如何解决？ 1、可以按照位来分组，比如说最高位是0的一组，是 1 的一组，这样可以统计出那一组更少，这样就排除了一大半，然后继续这样排查，最终缩小范围后直接内部排序。 2、直接外部排序，然后取中间值，最笨的方法。 在海量数据中找出出现频率最高的前k个数 例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。 1、如果重复率很高，可以采用前缀树，因为 trie 树适用于数据量大，重复多，但是数据种类小必须得可以放入内存； 2、按照 hash 进行分组，这样就能避免相同的数分到不同区域去了，导致不好统计。hash 分组完毕后，然后用前缀树 或者 hashmap 来计算每个组的前 k 个频率最高的数，最后对各个组的前 k 个数进行统计即可。 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 1、这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。 2、然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找 3、再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 4、并将这两类分别写入到两个文件中，其中一个文件中数的个数=10亿（这相当于折半了）；与要查找的数的次最高位比较并接着进入相应的文件再查找。……. 以此类推，就可以找到了,而且时间复杂度为O(logn)。 大概统计一下，海量数据求 TopK 的普遍方法： 1、最快的不需要排序就能排除一大堆的数据的方法就是看 “位”，比如最高位为 0 的分一块，为 1 的分一块，这样迅速就分出一大块不需要的了，尤其适合找中位数，等分的差不多了就可以进行内部排序了。 2、堆排序，适用于求海量数据最大 K or 最小的 K 个数； 3、分治hash，适用于那些内存很小，数据很大，但是又想求最大的 K 个众数的问题，可以先 hash 到很多个组，然后在组内部使用 hashmap 或者 前缀树 「google等字符」，取到组内前 K 个众数，最后进行组间比较久okay了； 4、当然不能忘了万能法，那就是外部排序，然后再进行相应的处理。 如何判断一个元素是否存在一个集合中？ 先来看几个比较常见的例子 字处理软件中，需要检查一个英语单词是否拼写正确 在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上 在网络爬虫里，一个网址是否被访问过 yahoo, gmail等邮箱垃圾邮件过滤功能 这几个例子有一个共同的特点： 如何判断一个元素是否存在一个集合中？ 这里必须介绍一下 bitmap 这个方法了，例如我要从海量数据中找一个数是否出现过，就可以用位图的思路去做，如果数字是 7 ，那就在第 7 位 置 1，如果该位置已经是 1 了，那就代表出现过，不用更改。 如果问题变为从海量数据中找一个数是否出现过一次，那这个时候就得用 2 bitmap 来表示了，也就是一个数如果出现一次，置为 01 ，出现过两次，置为 10，然后再出现，都是10，这个时候如果我们只用一位，是不能表示出出现的次数的。 至于我们常说的布隆过滤器，其实也就是在bitmap之前进行一个hash，例如将字符串进行hash成数组，然后使用位图，解决这类问题。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/256M的内存如何对16g的数组进行排序.html":{"url":"docs/tech/Algorithm/256M的内存如何对16g的数组进行排序.html","title":"256M的内存如何对16g的数组进行排序","keywords":"","body":"256M的内存如何对16g的数组进行排序 参考 256M的内存如何对16g的数组进行排序 多路归并，因为没要求存储，只要求了内存，可以多路归并，加入每个元素都是 1M，则可以最多分成 256 组，然后进行归并。 具体描述：采用外部排序，先将16 g数组分成 256 M 一组，然后分别读入内存进行内部排序「比如说可以使用快排」，将这些组内元素全部排好序之后，然后运用败者树和置换-选择排序，进行多路归并，即可。 胜者树与败者树 胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。 不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。 胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。 在k路归并排序中经常用到。 胜者树与败者树参考 https://blog.csdn.net/whz_zb/article/details/7425152 http://c.biancheng.net/view/3453.html https://blog.csdn.net/FX677588/article/details/72471357 https://www.jianshu.com/p/b8faa1affe17 https://www.cnblogs.com/tonychen-tobeTopCoder/p/5797002.html https://blog.csdn.net/xiezhi123456/article/details/87632559 https://blog.csdn.net/life_liver/article/details/8554133 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/比较两个大文件的重复数据的算法.html":{"url":"docs/tech/Algorithm/比较两个大文件的重复数据的算法.html","title":"比较两个大文件的重复数据的算法","keywords":"","body":"比较两个大文件的重复数据的算法 思路1：使用bloom filter算法。 如果不考虑100%准确率，那么bloom filter将是很好的选择 思路2：hash hash的原理就不说了，这里主要使用“大而化小，分而治之”的策略。 遍历a（假如a是较大的文件），对a的每一行做hash运算，根据hash值将该行数据映射到一个小文件a1-a100文件中； 此时遍历b，做同样的hash算法，映射到b1-b100小文件中；（注意：两个字符串如果相同，那么他们经过同一hash算法得到的必然也是相等的） 逐个比较文件对，此时数据量够小，可以装载到hashmap中进行比对，最后得到结果。 参考https://www.zhihu.com/question/21827402/answer/387830719https://my.oschina.net/vdroid/blog/373439https://blog.csdn.net/qingdujun/article/details/82343756https://blog.csdn.net/tiankong_/article/details/77234726 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Algorithm/负载均衡原理、种类和算法.html":{"url":"docs/tech/Algorithm/负载均衡原理、种类和算法.html","title":"负载均衡原理、种类和算法","keywords":"","body":"负载均衡原理、种类和算法 负载均衡原理 负载均衡类型 负载均衡算法 负载均衡原理 随机、轮训、加权 源地址hash法、最小连接数、最快响应速度等 负载均衡(Load Balance，简称LB)是一种服务器或网络设备的集群技术。 负载均衡将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备，从而提高了业务处理能力，保证了业务的高可用性。 负载均衡基本概念有：实服务、实服务组、虚服务、调度算法、持续性等，其常用应用场景主要是服务器负载均衡，链路负载均衡。 负载均衡器主要分为硬件负载均衡和软件负载均衡两大类。 应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。 负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备） 负载均衡的作用（解决的问题）： 1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）； 2.提供故障转移，实现高可用； 3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）； 4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理） 负载均衡类型 根据实现技术不同，可分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等。 DNS负载均衡 HTTP负载均衡（Nginx,Haproxy） IP负载均衡：在网络层通过修改请求目标地址进行负载均衡。 链路层负载均衡：通信协议的数据链路层修改mac地址，进行负载均衡。 混合型负载均衡： 根据OSI模型可将负载均衡分为： 1）二层负载均衡（一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应）； 2）三层负载均衡（一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应）； 3）四层负载均衡（在三次负载均衡的基础上，用 ip+port 接收请求，再转发到对应的机器）； 4）七层负载均衡（根据虚拟的url或是IP，主机名接收请求，再转向相应的处理服务器）。 这其中，最常见的是四层和七层负载均衡 负载均衡算法 常用的负载均衡算法分为两类： 1）一种是静态负载均衡； 轮询法： 随机法： 源地址哈希法： 加权轮询法： 加权随机法： 键值范围法： 2）一种是动态负载均衡。 最小连接数法： 最快响应速度法： 观察模式法： 负载均衡算法： 常用的负载均衡算法有，轮询，随机，最少链接，源地址散列，加权等方式； 轮询（Round Robin，RR）：加权轮询（Weighted Round Robin，WRR） 将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。 优点：服务器请求数目相同； 缺点：服务器压力不一样，不适合服务器配置不同的情况； 随机（Random） 请求随机分配到各个服务器。 优点：使用简单； 缺点：不适合机器配置不同的场景； 最少连接（Least Connections）：加权最少链接（Weighted Least Connections）简称WLC 将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。 优点：根据服务器当前的请求处理情况，动态分配； 缺点：算法实现相对复杂，需要监控服务器请求连接数； Hash源地址散列（Source hashing） 根据IP地址进行Hash计算，得到IP地址。 优点：4将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。 缺点：目标服务器宕机后，会话会丢失； 加权 在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。 优点：根据权重，调节转发服务器的请求数目； 缺点：使用相对复杂； 参考 https://blog.csdn.net/Kim_Weir/article/details/80550133 https://www.jianshu.com/p/215b5575107c https://www.jianshu.com/p/7bb52818b8a9 https://blog.51cto.com/7346473/1597135 https://segmentfault.com/a/1190000019026606 https://blog.csdn.net/a724888/article/details/80775778 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Gateway/Gateway网关.html":{"url":"docs/tech/Gateway/Gateway网关.html","title":"网关","keywords":"","body":"Gateway网关 Gateway网关 1、 2、 3、 4、 5、 网关、微服务[quickstart-gateway] 代理服务器 流量网关 或者 代理服务器 或者 负载均衡 API服务网关 /Users/yangzl/git/quickstart-gateway/docs 1、 网关之降级、熔断、限流、隔离、幂等性验证、超时重试机制的相关知识简单整理 1、微服务架构中没有接口限流，可能会遇到哪些问题？ 2、针对微服务接口限流，如何选择合适的限流算法？ 3、如何根据场景和性能要求权衡选择单机还是分布式限流？ 4、如何根据业务需求灵活的选择不同的限流熔断机制？ 5、如何对接口选择合适的限流时间粒度和最大限流值？ 6、如何验证微服务接口限流功能的有效性和正确性？ 7、如何打造高度容错、高 TPS、低延迟的限流框架？ 2、 高并发流量限制（计数器、漏桶、令牌桶）：限流（过载保护）采用漏桶算法和令牌桶算法实现限流技术(time limiting)令牌桶(Token Bucket)和漏桶(leaky bucket)是 最常用的两种限流的算法。令牌桶(Token Bucket)：可以突发流量，产生Token的速率（rate）+ 桶的大小【最大突发流量】 + 初始令牌个数漏桶(leaky bucket)：固定速率，桶大小+漏洞的大小(rate) 背景：通常在高并发访问的情况下，会通过限流的手段来控制流量问题，以保证服务器处于正常压力下，一般对超过的部分不做处理，即丢弃。限流的手段通常有计数器、漏桶、令牌桶。注意限流和限速（所有请求都会处理）的差别，视业务场景而定1、计数器：在一段时间间隔内（时间窗），处理请求的最大数量固定，超过部分不做处理2、漏桶：漏桶大小固定，处理速度固定，但请求进入速度不固定（在突发情况请求过多时，会丢弃过多的请求）3、令牌桶：令牌桶的大小固定，令牌的产生速度固定，但是消耗令牌（即请求）速度不固定（可以应对一些某些时间请求过多的情况）；每个请求都会从令牌桶中取出令牌，如果没有令牌则丢弃该次请求。 Google开源工具包Guava提供了限流工具类RateLimiter,该类基于令牌桶算法(Token Bucket)来完成限流 https://blog.csdn.net/peiwuyang/article/details/45066341https://blog.csdn.net/tianyaleixiaowu/article/details/74942405https://blog.csdn.net/collonn/article/details/72877812https://blog.csdn.net/I_will_try/article/details/77881188http://ifeve.com/guava-ratelimiter/https://my.oschina.net/hanchao/blog/1833612 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Modular/Modular模块化.html":{"url":"docs/tech/Modular/Modular模块化.html","title":"模块化和类隔离","keywords":"","body":"模块化 1、 2、 3、 4、 5、 [quickstart-modular] 模块化 Java9 java9模块化开发 JarsLink 阿里开源，已经合并到sofa-jarslink里面了 1、 模块化 /Users/yangzl/git/quickstart-modular Fat Jar学习.md 模块化.md 服务框架- Pandora sofa-jarslink：jarslink的最新版本 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/网络和HTTP.html":{"url":"docs/tech/Net/网络和HTTP.html","title":"网络和HTTP","keywords":"","body":"网络和HTTP 网络和HTTP 1、 2、 3、 4、 5、 1、熟悉常用网络协议，如TCP/IP, HTTP;ajax请求流程，ajax状态码，http状态码 OSI七层与TCP/IP五层网络架构 TCP/IP连接过程：三次握手四次挥手 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因 http连接过程：域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 存在的问题：不安全，被监听，被伪装，被篡改 https连接过程：+SSL层，过程是先非对称协商秘钥，然后进行加密传输 HTTP状态码 TCP粘包、拆包问题 2、网络： /Users/yangzl/git/quickstart-http/README.md CORS跨域请求.md HTTP、HTTPS、HTTP2、HTTP3.md http和http2的区别.md HTTP学习.md Http请求模拟工具.md TCPIP网络传输学习.md TCP和UDP的最完整的区别.md 淘宝全站HTTPS实践.pdf http和TCP http和http2的区别:http、https、spdy、http2 Socket和TCP/IP 3、 1、HTTP特点 2、HTTP1.0、HTTP1.1、HTTP2、HTTP3的区别 3、TCP的三次握手、四次挥手 4、https连接建立过程 4、 TCP三次握手四次挥手讲解： https://blog.csdn.net/hguisu/article/details/38700899 面试题目 https://hit-alibaba.github.io/interview/basic/network/TCP.html 1.TCP/IP 三次握手 四次挥手osi参考模型：tcp/ip四层概念模型：应用层（应用层、表现层、会话层）、传输层、网络层、数据链路层（数据链路层、物理层）（3 1 1 2） TCP/IP:协议的集合，代表性的有ip、tcp、http。ip:网络层。代表网际协议。tcp：传输层。tcp是可靠的，udp是不可靠的。http：应用层协议，主要解决如何包装数据。除了http还有ftp、telnet等等把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 tcp三次握手：建立tcp连接。client端发送一个数据包，server端确认收到连接并返回给client，client确认然后连接建立完成。随后client和server端可以开始传输数据。tcp四次握手：断开tcp连接。client端发送一个FIN请求，server收到一个FIN请求表示client这一端不在发送数据了，但是还能接收数据，此时tcp连接还没有关闭。直到server端再发送一个FIN请求，表示server端也不会再发送数据了；client端收到FIN后，给server一个ack响应，server端进入closed状态。 2.Http的格式说明request由请求行、请求头、请求体组成请求行（参考：GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1 请求类型 请求地址 协议版本）请求头（参考：HOST是主机地址，User-Agent是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送，等等Host: www.fishbay.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6）空行：请求头后面必须有一行空行请求数据：请求体 response由状态行、响应头、响应体组成。参考如下：HTTP/1.1 200 OK 状态行Server: nginx 响应头Date: Mon, 20 Feb 2017 09:13:59 GMTContent-Type: text/plain;charset=UTF-8Vary: Accept-EncodingCache-Control: no-storePragrma: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTCache-Control: no-cacheContent-Encoding: gzipTransfer-Encoding: chunkedProxy-Connection: Keep-alive 空行{\"res\":ok\"} 响应体 3.状态码说明200 OK 请求成功301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 资源未找到500 Internal Server Error 服务端内部错误502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 网络：1、TCP/IP 三次握手 四次挥手2、Http的格式说明、状态码说明3、进程间通信方式 OSI七层与TCP/IP五层网络架构详解http://network.51cto.com/art/201310/413853.htmhttp://blog.csdn.net/cc1949/article/details/79063439OSI七层模型7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 OSI中的层 功能 TCP/IP协议族应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet表示层 数据格式化，代码转换，数据加密 没有协议会话层 解除或建立与别的接点的联系 没有协议传输层 提供端对端的接口 TCP，UDP网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 (2)TCP/IP五层模型的协议五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。 传输层：四层交换机、也有工作在四层的路由器网络层：路由器、三层交换机数据链路层：网桥(现已很少使用)、以太网交换机(二层交换机)、网卡(其实网卡是一半工作在物理层、一半工作在数据链路层) 物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层 http、tcp/ip和socket的区别tcp/ip协议的详解http状态码 有两种缓存方法：让代理服务器进行缓存和让客户端浏览器进行缓存。Cache-Control 用于控制缓存的行为。Cache-Control: no-cache 有两种含义，如果是客户端向缓存服务器发送的请求报文中含有该指令，表示客户端不想要缓存的资源；如果是源服务器向缓存服务器发送的响应报文中含有该指令，表示缓存服务器不能对资源进行缓存。Expires 字段可以用于告知缓存服务器该资源什么时候会过期。当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。 TCPIP、Http、Socket的区别http://blog.csdn.net/lu123535884/article/details/43270041https://www.cnblogs.com/fuyuanming/articles/4848250.html 网络由下往上分为　　物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。　　IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。　　三者从本质上来说没有可比性。 socket则是对TCP/IP协议的封装和应用。　　也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，　　而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：　　“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。　　如果想要使传输的数据有意义，则必须使用到应用层协议。　　应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。　　WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”　　而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。　　通过Socket，我们才能使用TCP/IP协议。　　实际上，Socket跟TCP/IP协议没有必然的联系。　　所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，总结：socket是针对TCP/IP协议开放的API。自建socket等于废弃应用层的协议（例如http），自己新建应用层协议（所以 socket套接字要绑定端口，类似于http要一个端口）。再换句话说，http是用socket实现了TCP/IP。因为socket是针对TCP/IP协议开放的API，所以socket是有三次握手这样的特性的。 而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。 通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也 能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道 的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。网络有一段关于 socket和TCP/IP协议关系的说法比较容易理解：“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外 的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是 Socket编程接口。” HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。 TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上 保证了)保证了连接的可靠性;而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正 确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 HTTP协议http://www.blogjava.net/zjusuyong/articles/304788.html HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP状态码：https://www.cnblogs.com/hjxcode/p/5663830.htmlhttp://blog.csdn.net/ahzxj2012/article/details/52510491Type Reason-phrase Note1XX Informational 信息性状态码，表示接受的请求正在处理2XX Success 成功状态码，表示请求正常处理完毕3XX Redirection 重定向状态码，表示需要客户端需要进行附加操作4XX Client Error 客户端错误状态码，表示服务器无法处理请求5XX Server Error 服务器错误状态码，表示服务器处理请求出错 TCPIP：三次握手四次挥手，查看TCP连接状态数量：netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'http://blog.csdn.net/linux_ever/article/details/51136723http://blog.csdn.net/whuslei/article/details/6667471https://www.cnblogs.com/Jessy/p/3535612.html收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因有二：一、Client重发可能丢失的ACK报文：保证TCP协议的全双工连接能够可靠关闭,保证Server端收到ACK，如果Server端未收到ACK，会再次收到Server的FIN，可以再次发送ACK二、保证这次连接的重复数据段从网络中消失，下次相同IP和Port不会再接收本次连接滞留在网络中的数据，如果新建的连接和上次的port相同，之前关闭的连接的数据滞留在网络再次发送到Server，Server会认为是新的连接发送的，导致数据混淆 TCP连接需要三次握手分开需要四次挥手：TCP三次握手过程1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:\"我已收到回复,我现在要开始传输实际数据了 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 4次断开1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置13 由B 端再提出反方向的关闭请求,将FIN置14 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础 TCP状态码： 各个状态的意义如下：1、Client：发送SYN后SYN-SENT -在发送连接请求后等待匹配的连接请求；2、Server：接受到SYN，并且发送ACK后LISTEN - 侦听来自远方TCP端口的连接请求；SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；3、Clinet+Server：Clinet发送ACK后，Server接收到ACK后ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 1、Client发送FIN后FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 2、Server接收到FIN，并且返回ACKCLOSE-WAIT - 等待从本地用户发来的连接中断请求； 3、Client收到ACK后FIN-WAIT-2 - 从远程TCP等待连接中断请求； 4、Server发送FIN后LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； 5、Client接受FIN并且返回ACKTIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 6、Server接收到ACK和Client等待2个MSL(Max Segment Lifetime)后TimeOut超时CLOSED - 没有任何连接状态； CLOSING -等待远程TCP对连接中断的确认； SYN_RECV 状态：服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。 一般服务器都会设置net.ipv4.tcp_syncookies=1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。 CLOSE_WAIT状态发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。 http调用：feign、httpClient、okhttp、unirest、jdk、jersey-http Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议.html":{"url":"docs/tech/Net/HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议.html","title":"HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议","keywords":"","body":"HTTP和HTTPS、TCPIP、ajax、OSI七层协议、TCPIP四层协议 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)原因 http连接过程（5步）：域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 存在的问题：不安全，被监听，被伪装，被篡改 https连接过程(5步)：+SSL层，过程是先非对称协商秘钥，然后进行加密传输 加解密 单向加密和双向加密（对称加密和非对称加密） 单向加密(信息摘要)：MD5、SHA 对称加密：DES、3DES、AES 非对称加密：RSA、DSA、ECDSA 查看项目quickstart-crypto /Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/加解密.md Ajax请求流程 AJAX状态码 HTTP状态码 OSI七层与TCP/IP五层网络架构详解 TCP/IP连接过程：三次握手四次挥手 MTU和MSS区别 Ajax请求流程 xhr对象 【Ajax发送请求】这件事情并不是一句话带过就可以的，在Ajax中对整个请求从创建到发送都有一套严格的标准流程。在Ajax规则中，“请求”从创建到被发送需要至少经历如下几个步骤： 通过XMLHttpRequest类创建xhr对象 为xhr对象添加属性与回调方法 令xhr对象执行open()方法，指明请求被发往某处 4.令xhr对象执行send()方法，发出请求 AJAX状态码 一共有5中请求状态，从0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 // readyState值说明 // 0,初始化,XHR对象已经创建,还未执行open // 1,载入,已经调用open方法,但是还没发送请求 // 2,载入完成,请求已经发送完成 // 3,交互,可以接收到部分数据 // 4: 请求已完成，且响应已就绪 HTTP状态码 // status值说明 // 200:成功 // 404:没有发现文件、查询或URl // 500:服务器产生内部错误 1 信息，服务器收到请求，需要请求者继续执行操作 2 成功，操作被成功接收并处理 3 重定向，需要进一步的操作以完成请求 4 客户端错误，请求包含语法错误或无法完成请求，403 拒绝 404 not found 5** 服务器错误，服务器在处理请求的过程中发生了错误 readyState属性 值为0，对应常量UNSET：表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。 值为1，对应常量OPENED：表示send()方法还没有被调用，仍可以使用setRequestHeader()设定HTTP请求头 值为2，对应常量HEADERS_RECEIVED：表示send()方法已经执行，并且头信息和状态码已经收到。 值为3，对应常量LOADING：表示正在接收服务器传来的body部分的数据，如果responseType属性是text或者空字符串，responseText就会包含已经收到的部分信息。 值为4，对应常量DONE，表示服务器数据已经完全接收，或者本次接收已经失败了。 OSI七层与TCP/IP五层网络架构详解 http://network.51cto.com/art/201310/413853.htm http://blog.csdn.net/cc1949/article/details/79063439 OSI七层模型 7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 OSI中的层 功能 TCP/IP协议族 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 提供端对端的接口 TCP，UDP 网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 (2)TCP/IP五层模型的协议 五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。 传输层：四层交换机、也有工作在四层的路由器 网络层：路由器、三层交换机 数据链路层：网桥(现已很少使用)、以太网交换机(二层交换机)、网卡(其实网卡是一半工作在物理层、一半工作在数据链路层) 物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层 TCP/IP连接过程：三次握手四次挥手 TCPIP：三次握手四次挥手，查看TCP连接状态数量：netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' http://blog.csdn.net/linux_ever/article/details/51136723 http://blog.csdn.net/whuslei/article/details/6667471 https://www.cnblogs.com/Jessy/p/3535612.html 收到server的FIN之后会进入TIME_WAIT状态将持续2个MSL(Max Segment Lifetime) 原因有二： 一、Client重发可能丢失的ACK报文：保证TCP协议的全双工连接能够可靠关闭,保证Server端收到ACK，如果Server端未收到ACK，会再次收到Server的FIN，可以再次发送ACK 二、保证这次连接的重复数据段从网络中消失，下次相同IP和Port不会再接收本次连接滞留在网络中的数据，如果新建的连接和上次的port相同，之前关闭的连接的数据滞留在网络再次发送到Server，Server会认为是新的连接发送的，导致数据混淆 TCP连接需要三次握手分开需要四次挥手： TCP三次握手过程 1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段, 主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我. 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事: 我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:\"我已收到回复,我现在要开始传输实际数据了 采用三次握手是：为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误 4次断开 1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1 3 由B 端再提出反方向的关闭请求,将FIN置1 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束. 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础 TCP状态码： 1、Client：发送SYN后 SYN-SENT -在发送连接请求后等待匹配的连接请求； 2、Server：接受到SYN，并且发送ACK后 LISTEN - 侦听来自远方TCP端口的连接请求； SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； 3、Clinet+Server：Clinet发送ACK后，Server接收到ACK后 ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 1、Client发送FIN后 FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 2、Server接收到FIN，并且返回ACK CLOSE-WAIT - 等待从本地用户发来的连接中断请求； 3、Client收到ACK后 FIN-WAIT-2 - 从远程TCP等待连接中断请求； 4、Server发送FIN后 LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； 5、Client接受FIN并且返回ACK TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 6、Server接收到ACK和Client等待2个MSL(Max Segment Lifetime)后TimeOut超时 CLOSED - 没有任何连接状态； CLOSING -等待远程TCP对连接中断的确认； SYN_RECV 状态： 服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。 一般服务器都会设置net.ipv4.tcp_syncookies=1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。 这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。 CLOSE_WAIT状态 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。 HTTP请求流程 域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户 Request URL: https://www.baidu.com/img/bd_logo1.png?where=super 请求的url Request Method: GET 请求的方法 请求的参数等 Request Version：HTTP/1.1 请求的http协议版本 Status Code: 200 OK Remote Address: 61.135.169.125:443 Referrer Policy: unsafe-url User-Agent： 客户端信息，用户代理信息等 Accept: 可以接受的MIME类型的所有类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cache-Control: no-cache Connection: keep-alive 连接时候使用keep-alive特性 Cookie: BAIDUID=CB8A67CFBD7637407BE94645AA5C2D39:FG=1; BIDUPSID=CB8A67CFBD7637407BE94645AA5C2D39; PSTM=1533969843; BD_UPN=123253; BDUSS=Q2SzZ2VXViaUtQdnNzSDlTRjR4YVQtbHBiVzVsZjVFOXNoUk43Nk9IQUxFYmhiQVFBQUFBJCQAAAAAAAAAAAEAAAAh1JYfeW91bmd6aWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuEkFsLhJBba2; delPer=0; BD_CK_SAM=1; BDRCVFR[C0p6oIjvx-c]=I67x6TjHwwYf0; H_PS_PSSID=1454_21106_20692_26350_22073; BD_HOME=1; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; pgv_pvi=262569984; pgv_si=s4821341184; ZD_ENTRY=baidu; MCITY=-%3A; PSINO=7; sugstore=1 Host: www.baidu.com 主机名 Pragma: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 HTTP Response响应头信息 Header 解释 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives... Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives... Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic http通信存在的问题 1、容易被监听 http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的 2、被伪装 http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。 3、被篡改 hacker中间篡改数据后，接收方并不知道数据已经被更改 HTTPS是一种协议，等于HTTP+TLS（由于历史原因，SSL3.0之后就被TLS1.0替代了）。 openssl是一套开源工具集，主要有两个特性： 1、实现了ssl2,ssl3，TLSv1，TLSv1.1，TLSv1.2协议。 2、实现目前常用的加密算法。 没有一个非常精准的方法来判断HTTPS是否使用openssl，但是根据网站返回的server类型，可以大致估计是否使用了openssl，比如如果使用apache或者nginx，那么肯定是使用了openssl。保守估计至少70%以上的网站是使用openssl的。而windows系列的服务器包括IIS，windows server等都是使用schannel，没有使用openssl，不会受heartbleed影响。 https连接过程： 1、客户端发送请求到服务器端，发送客户端支持的加密协议及版本，SSL、TLS 2、服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在，服务器从中筛选合适的加密协议，返回证书，证书中有公钥 3、客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端 4、服务器端使用私有密钥解密数据，并使用收到的共享密钥使用对称加密密钥加密数据，发送到客户端 5、客户端使用共享密钥解密数据、SSL加密建立……… HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的具体描述如下： 1.浏览器将自己支持的一套加密规则发送给网站。 2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 3.浏览器获得网站证书之后浏览器要做以下工作： a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 4.网站接收浏览器发来的数据之后要做以下的操作： a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 b) 使用密码加密一段握手消息，发送给浏览器。 5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 另外，HTTPS一般使用的加密与HASH算法如下： 非对称加密算法：RSA，DSA/DSS 对称加密算法：AES，RC4，3DES HASH算法：MD5，SHA1，SHA256 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS和HTTP的区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全。 HTTP协议的主要特点可概括如下： 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 2.2 HTTP协议的几个重要概念 1.连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。 2.消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。 3.请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号 4.响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。 5.资源(Resource)：由URI标识的网络数据对象或服务。 6.实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。 7.客户机(Client)：一个为发送请求目的而建立连接的应用程序。 8.用户代理(User agent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。 9.服务器(Server)：一个接受连接并对请求返回信息的应用程序。 10.源服务器(Origin server)：是一个给定资源可以在其上驻留或被创建的服务器。 11.代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 12.网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 13.通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 14.缓存(Cache)：反应信息的局域存储。 1.建立连接 连接的建立是通过申请套接字(Socket)实现的。客户打开一个套接字并把它约束在一个端口上，如果成功，就相当于建立了一个虚拟文件。以后就可以在该虚拟文件上写数据并通过网络向外传送。 2.发送请求 打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。 HTTP/1.0 请求消息的格式为： 请求消息=请求行(通用信息|请求头|实体头) CRLF[实体内容] 请求 行=方法 请求URL HTTP版本号 CRLF 方 法=GET|HEAD|POST|扩展方法 U R L=协议名称+宿主名+目录与文件名 请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下： 对象 GET的结果 文件 文件的内容 程序 该程序的执行结果 数据库查询 查询结果 HEAD——要求服务器查找某对象的元信息，而不是对象本身。 POST——从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。 一个请求的例子为： GET http://networking.zju.edu.cn/zju/index.htm HTTP/1.0 头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答 。 请求头——告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。 实体头——实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。 实体——请求或应答对象本身。 3.发送响应 服务器在处理完客户的请求之后，要向客户机发送响应消息。 HTTP/1.0的响应消息格式如下： 响应消息=状态行(通用信息头|响应头|实体头) CRLF 〔实体内容〕 状 态 行=HTTP版本号 状态码 原因叙述 状态码表示响应类型 1×× 保留 2×× 表示请求成功地接收 3×× 为完成请求客户需进一步细化请求 4×× 客户错误 5×× 服务器错误 响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。 4.关闭连接 客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话 SSL是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”，它是在上世纪90年代中期，由网景公司设计的（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）。 为啥要发明SSL这个协议捏？因为原先互联网上使用的HTTP协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改，发明SSL协议，就是为了解决这些问题。 到了1999年，SSL因为应用广泛，已经成为互联网上的事实标准，IETF就在那年把SSL标准化，标准化之后的名称改为TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。 HTTP和HTTPS的区别 https://www.cnblogs.com/bluestorm/p/5763533.html https://segmentfault.com/a/1190000011185129 https://juejin.im/entry/58d7635e5c497d0057fae036 TCP协议中的三次握手和四次挥手(图解) https://blog.csdn.net/whuslei/article/details/6667471 https://blog.csdn.net/qq_38950316/article/details/81087809 HTTP请求过程 https://www.linux178.com/web/httprequest.html https请求建立过程 https://blog.csdn.net/wangjun5159/article/details/51510594 https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html OSI七层协议和TCP/IP四层协议 https://blog.csdn.net/qq_18425655/article/details/52314970 MTU和MSS区别 MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小； 以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。 MSS：Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。 如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。 参考https://www.jianshu.com/p/3be7582ddf78 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/IP地址分类-内网IP.html":{"url":"docs/tech/Net/IP地址分类-内网IP.html","title":"IP地址分类-内网IP","keywords":"","body":"IP地址分类-内网IP InterNIC将IP地址分为五类: A类保留给ZF或大型企业， B类分配给中等规模的公司， C类分配给小公司或个人， D类用于组播， E类用于实验， 注：各类可容纳的地址数目不同。 在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。 这三个地址段分别位于A、B、C三类地址内： A类地址：10.0.0.0--10.255.255.255 B类地址：172.16.0.0--172.31.255.255 C类地址：192.168.0.0--192.168.255.255 IP地址范围：1.0.0.1——255.255.255.254 公网是不会使用者三类地址的，即使用这三类IP的一定在公司或者学校（组织）内网中，公网是看不到的。 装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。 另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。 NAT就是网络地址转换的英文缩写，在路由器上配置NAT服务，可提供公司内100~200人同时上网的服务。不需要Proxy Server，所有的服务都可顺利使用（除Netmeeting之类的服务），客户端无需做复杂设定，与应用程序无关。解决了使用Proxy Server带来的烦复的设置工作。NAT有三种类型：静态NAT（staticNAT）、NAT池（pooledNAT）和端口NAT（PAT）。 参考 https://blog.csdn.net/superit401/article/details/78246298 https://blog.csdn.net/sforiz/article/details/6417017 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/NAT和UDP穿孔打洞、HTTP隧道.html":{"url":"docs/tech/Net/NAT和UDP穿孔打洞、HTTP隧道.html","title":"NAT和UDP穿孔打洞、HTTP隧道","keywords":"","body":"NAT和UDP穿孔打洞、HTTP隧道 NAT(Network Address Translators)，网络地址转换：网络地址转换是在IP地址日益缺乏的情况下产生的，它的主要目的就是为了能够地址重用。 NAT分为两大类，基本的NAT和NAPT(Network Address/Port Translator)。 最开始NAT是运行在路由器上的一个功能模块。 一种是NAT再次创建一个Session，并且再次为这个Session分配一个端口号（比如：62001）。另外一种是NAT再次创建一个Session，但是不会新分配一个端口号，而是用原来分配的端口号62000。前一种NAT叫做Symmetric NAT，后一种叫做Cone NAT。 ClientA（内网10.0.0.1:1234）----》NATA（内网IP，公网IP）----》Server UDP用打洞技术穿透NAT的原理与实现： 那么我们如果想从外部发送一个数据报给内网的计算机有什么办法呢？首先，我们必须在内网的NAT上打上一个“洞”（也就是前面我们说的在NAT上建立一个Session），这个洞不能由外部来打，只能由内网内的主机来打。而且这个洞是有方向的，比如从内部某台主机（比如：192.168.0.10）向外部的某个IP(比如：219.237.60.1)发送一个UDP包，那么就在这个内网的NAT设备上打了一个方向为219.237.60.1的“洞”，（这就是称为UDP Hole Punching的技术）以后219.237.60.1就可以通过这个洞与内网的192.168.0.10联系了。（但是其他的IP不能利用这个洞）。 ClientA NAT-A Server NAT-B ClientB 总结一下这个过程：如果Client A想向Client B发送信息，那么Client A发送命令给Server S，请求Server S命令Client B向Client A方向打洞。 在NAT B上打一个方向为202.187.45.3（即Client A的外网地址）的洞，那么Client A发送到187.34.1.56:40000的信息,Client B就能收到了。 vpn工具禁用UDP加速功能，由于vpn工具使用了UDP穿孔技术，会导致NAT-遍历，影响性能，因此，此功能必须选中，否则无法正常拨号。 P2P技术： HTTP隧道是拿来穿防火墙的，跟穿透NAT是完全不同的概念 我要的是两个不同局域网之内的用户不通过服务器而交换数据（P2P），HTTP隧道，不可能达到此目的。 能否通过IP伪装来实现这一点？ NAT Loopback（NAT回环） HTTP： 在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。 HTTP中继的概念（原封不动的将HTTP消息和响应在Client 和 Web Server之间传输）； HTTP隧道技术 https://blog.csdn.net/nicehunt/article/details/44218775 https://blog.csdn.net/yangdelong/article/details/1584349 https://blog.csdn.net/u011995362/article/details/53729512 应用场景： 防火墙(只开放80)内的机器A 防火墙外部的机器B (http隧道服务器) 防火墙外部的机器C 如果A要通过某种非http协议访问C 应该不能访问 http隧道流程是 A上的软件需要用到非http协议访问外部机器时候 把本来的数据(包括数据、最终IP地址、原始协议等)打包放在一个http包中然后发给B, 这时候防火墙是可以通过的 .B上接收到数据包之后 分解数据形成原始的数据包 按照原协议发送给最终的IP,返回数据之后 打包成http 发送给A。A解释这个http包并且处理. 利用HTTP协议的缺陷来实现对防火墙的渗透，或者说现有的一些HTTP隧道技术的实现，是基于防火墙在对HTTP协议的报文进行识别与过滤时，往往只对其诸如POST、GET等命令的头进行识别，而放行其后的所有报文。 简单的说，HTTP隧道技术就是把所有要传送的数据全部封装到HTTP协议里进行传送，HTTP隧道技术几乎支持了所有的上网方式，如：拨号上网、ADSL、Cable Modem、NAT透明代理、HTTP的GET型和CONNECT型代理、SOCKS4代理、SOCKS5代理等。 另外HTTP隧道技术也用于木马的制作，如把HTTP数据包里Agent段设为IE，对外端口为80，然后把自己的小马注入IE进程，哪个防火墙能分辨出它是木马在发送数据？ HTTP隧道工具HTTPTunnel 在很多服务器上，防火墙会限制主机的出站流量，只允许80之类的端口。如果要使用其他端口，只能通过HTTP隧道方式实现。Kali Linux提供一款HTTP隧道工具HTTPTunnel。该工具可以将其他端口的数据以HTTP协议的方式进行发送和接受。该工具包括服务器端和客户端两部分。 渗透测试人员在公共网络运行服务端，监听80端口，接受和转发数据。然后，在被限制的主机上运行客户端，监听本地特定的应用端口（如12355），并以HTTP协议方式转发到服务器端的80端口。在被限制的主机上，直接执行其他程序，连接本地的12355端口，就可以规避防火墙的拦截了。 参考 https://blog.csdn.net/liujiayu2/article/details/46537313 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/DNS/DNS域名.html":{"url":"docs/tech/Net/DNS/DNS域名.html","title":"DNS域名","keywords":"","body":"DNS域名 DNS介绍和DNS查询方式 如何设计一个DNS HTTPDNS原理 域名防劫持 DNS介绍和DNS查询方式 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 开始时，域名的字符仅限于ASCII字符的一个子集。2008年，ICANN通过一项决议，允许使用其它语言作为互联网顶级域名的字符。使用基于Punycode码的IDNA系统，可以将Unicode字符串映射为有效的DNS字符集。因此，诸如“XXX.香港”、“XXX.台湾”的域名可以在地址栏直接输入并访问，而不需要安装插件。但是，由于英语的广泛使用，使用其他语言字符作为域名会产生多种问题，例如难以输入，难以在国际推广等。 域名必须以英文句号“.”结尾，DNS服务器已经可以自动补上结尾的句号 早期的域名必须以英文句号“.”结尾，例如，当用户访问 www.wikipedia.org 的HTTP服务时必须在地址栏中输入：http://www.wikipedia.org.，这样DNS才能够进行域名解析。如今DNS服务器已经可以自动补上结尾的句号。 域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。 域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。二级域名下面是三级域名，它位于二级域名的左侧。 例如，在zh.wikipedia.org中，顶级域名是org，wikipedia是二级域名，zh是三级域名 DNS通过允许一个名称服务器把他的一部分名称服务（众所周知的zone）“委托”给子服务器而实现了一种层次结构的名称空间。此外，DNS还提供了一些额外的信息，例如系统别名、联系信息以及哪一个主机正在充当系统组或域的邮件枢纽。 任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。尽管如此，当提到在公共的Internet DNS系统上实现的域名时，术语“域名”是最常使用的。 这是基于504个全球范围的“根域名服务器”（分成13组，分别编号为A至M）[2]。从这504个根服务器开始，余下的Internet DNS名字空间被委托给其他的DNS服务器，这些服务器提供DNS名称空间中的特定部分。 DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。 以查询 zh.wikipedia.org 为例： 1、客户端发送查询报文\"query zh.wikipedia.org\"至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。 2、如果记录老化或不存在，则： 1、DNS服务器向根域名服务器发送查询报文\"query zh.wikipedia.org\"，根域名服务器返回顶级域 .org 的权威域名服务器地址。 2、DNS服务器向 .org 域的权威域名服务器发送查询报文\"query zh.wikipedia.org\"，得到二级域 .wikipedia.org 的权威域名服务器地址。 3、DNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文\"query zh.wikipedia.org\"，得到主机 zh 的A记录，存入自身缓存并返回给客户端。 根DNS的名字和IP都是什么？ 在这个网址： https://www.internic.net/domain/named.root 打开可以看到，里面有13个根的名字和IP，其名字从A.root-servers.net到M.root-servers.net。 A开头那个简称A根，是主根，其他12个（B、C、D、E、F、G、H、I、J、K、L、M）是辅根。 参考https://cloud.tencent.com/developer/article/1683972 如何设计一个DNS 名词： 1、BGP 边界网关协议（Border Gateway Protocol）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。 2、EGP 外部网关协议（Exterior Gateway Protocol）是AS之间使用的路由协议，最初于1982年由BBN技术公司的EricC.Rosen及DavidL.Mills提出。其最早在RFC827中描述，并于1984年在RFC904中被正式规范。EGP是一种简单的（网络）可达性协议，其与现代的距离-矢量协议和路径-矢量协议不同，它仅限适用于树状拓扑的网络。 由于EGP存在很多的局限性，IETF边界网关协议工作组制定了标准的边界网关协议（BGP），当前被广泛使用。 3、AS 自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也被称为是一个路由选择域（routing domain）。一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号（ASN）。 https://www.infoq.cn/article/how-to-design-dns/ 参考 https://www.infoq.cn/article/how-to-design-dns/ https://github.blog/2017-05-31-dns-infrastructure-at-github/ HTTPDNS原理 HTTPDNS原理DNS与HTTPDNSHTTPDNS 域名防劫持 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 常见的DNS域名劫持方式及解决方法域名劫持原理与几种方法域名劫持 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Net/DNS/常用的DNS服务器.html":{"url":"docs/tech/Net/DNS/常用的DNS服务器.html","title":"常用的DNS服务器","keywords":"","body":"常用的DNS服务器 114DNS：★★★★★ 国内用户量巨大的DNS，访问速度快，各省都有节点，同时满足电信、联通、移动各运营商用户，可以有效预防劫持。 地址： 114.114.114.114 114.114.115.115 阿里DNS：★★★★ 国内新晋DNS，背靠阿里大数据，未来前途不可限量。鉴于运营时间短，数据有待完善，推荐做备用. 地址： 223.5.5.5 223.6.6.6 OneDNS：★★★★ 恶意网站实验室出品，专注网络安全。运行于云端的oneDNS和定期汇总生成的MWSL-hosts屏蔽文件，可有效屏蔽挂马、色情、赌博、低俗广告等多种类型的恶意网站，阻断病毒传播途径，保障冲浪安全。 地址： 112.124.47.27 114.215.126.16 DNS派：★★★ 国内小众DNS，专注绿色、安全、稳定。 地址： 101.226.4.6 123.125.81.6 OpenDNS：★★ 国际大牌，在中国有点水土不服，但胜在稳定和全面。 地址： 208.67.222.222 208.67.220.220 GoogleDNS：★★ 地址： 8.8.8.8 8.8.4.4 你懂的，国内基本残废了一半。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Cache和KV数据库.html":{"url":"docs/tech/Cache/Cache和KV数据库.html","title":"缓存和KV数据库","keywords":"","body":"Cache和KV数据库 缓存和KV数据库 缓存项目 1、Redis学习 2、Memcached学习 3、缓存学习 4、其他缓存框架 5、 Redis学习 RedisRedis默认端口6379安装启动：./redis-server redis.conf Redis部署模式：1、单节点模式2、单节点主从：单节点带有从节点模式（一主一从，一主多从， 树型主从结构（从节点还有子从节点））3、主从带Sentinel哨兵模式4、集群模式：Redis Cluster Redis集群模式搭建、扩缩容：手动 和 ruby脚本主从带Sentinel哨兵模式:Sentinel的工作方式Redis集群解决方案 Redis的最常被问到知识点总结.md Redis主从复制机制 Redis事务 Redis Bitmaps：批量字节操作主要有三个命令：BITOP，BITCOUNT，BITPOS批量字节操作Bitmap：setbit、getbit、bitcount Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。Redis的五种数据类型的实现是什么数据结构 Redis命令：Key（键）、String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、SortedSet（有序集合）、Pub/Sub（发布/订阅）、Transaction（事务） Redis中支持RDB和AOF这两种持久化机制redis提供6种数据淘汰策略缓存算法（页面置换算法）-FIFO、LFU、LRU 缓存淘汰算法之LRU Redis服务端处理流程：计算槽、槽节点查找、处理/ASK/MOVED Redis如何解决key冲突：使用redis的不同db（集群模式部署不行），key带上业务含义如何解决Redis的并发竞争key问题：Redis事务、分布式锁 Redis和Memcached区别：支持数据类型、持久化、数据备份恢复、路由规则、网络IO模型 Memcached学习 Memcached ：增删改查命令：add/set、replace、get、delete遍历memcached：statsMemcached 所有命令都是原子性的 memcached：命令：连接：telnetset、add、replace、get、delete 缓存学习 1、缓存热点Key、大Value 2、缓存一致性问题 3、Redis和Memcached的区别 4、分布式缓存和Redis Key设计技巧 5、缓存的作用和分类 6、缓存算法（页面置换算法）-FIFO、LFU、LRU 缓存淘汰算法之LRU 7、 8、 其他缓存框架 quickstart-caffeine框架Caffeine：1、Caffeine 的三种缓存填充策略：手动、同步加载和异步加载。2、Caffeine 有三个值回收策略：基于大小，基于时间和基于引用。3、刷新：（不同于过期）可以将缓存配置为在指定时间段后自动刷新条目。4、统计：Caffeine 有记录缓存使用情况的统计方式： ConcurrentLinkedHashMap框架ConcurrentLinkedHashMap提供一个基于权重管理容量的Map，有以下特性1、基于LRU（Least recently used，最近最少使用）算法来替换Map中的元素2、再高负载情况下，和ConrrentHashMap具有相同的性能3、Can bound by the size of the values (e.g. Multimap cache) （这条没看懂）4、提供元素移除的通知事件 guava-cache学习/Users/yangzl/git/quickstart-cache/quickstart-guava-cache/README.md jcache学习/Users/yangzl/git/quickstart-cache/quickstart-jcache/README.md jetcache学习：缓存统一的接口，类似slf4j/Users/yangzl/git/quickstart-cache/quickstart-jetcache/README.md ehcache hazelcast tair Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis运维命令.html":{"url":"docs/tech/Cache/Redis/Redis运维命令.html","title":"Redis运维命令","keywords":"","body":"Redis运维命令 Redis启动、连接命令 Redis集群批量删除key 删除当前数据库中的所有Key Redis运维常用命令 查看redisCluster集群中所有keys值的命令 Redis查询某个key的slot Redis的scan命令 Redis启动、连接命令 Redis支持五种数据类型： string（字符串）， hash（哈希）， list（列表）， set（集合） zset(sorted set：有序集合) 连接： 本机redis-cli 远程redis-cli -h host -p port -a password redis-cli -c -h 10.76.224.229 -p 6202 -a 密码 redis-cli -c -h 10.1.243.23 -p 7000 //集群方式登陆：-c说明以集群的方式登录 redis-cli --raw 防止中文乱码 PING 测试服务器是否正常 info 查看服务端信息和版本 cluster nodes 查看集群节点信息 redis集群操作 任意一个节点都可以创建key，或者查看key（演示） redis-trib.rb check 192.168.133.130:7000//检测集群状态 cluster nodes//列出节点 cluster info//查看集群信息 cluster meet ip port //添加节点 cluster forget node_id //移除某个节点 cluster replicate node_id//将当前节点设置为指定节点的从 cluster saveconfig//保存配置文件 如果是用apt-get或者yum install安装的redis，可以直接通过下面的命令停止/启动/重启redis /etc/init.d/redis-server stop /etc/init.d/redis-server start /etc/init.d/redis-server restart 如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redis 1.redis关闭 redis-cli -h 127.0.0.1 -p 6379 shutdown 2.redis启动 redis-server 如果上述方式都没有成功停止redis，则可以使用终极武器 kill -9 测试网络PING 设置密码： CONFIG get requirepass CONFIG set requirepass \"yiibai\" CONFIG get requirepass 客户端向Redis服务器验证自身，并检查服务器是否正在运行 AUTH \"password\" PING 获取有关服务器的所有统计信息和信息info 获取配置 CONFIG SET loglevel \"notice\" CONFIG GET loglevel CONFIG GET * 基准测试命令的基本语法redis-benchmark [option] [option value] 通过调用100000个命令检查Redis：redis-benchmark -n 100000 Redis基准实用程序中多个选项的使用redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 100000 -q 在Redis配置文件(redis.conf)中，有一个名称为maxclients的属性，它描述了可以连接到Redis的客户端的最大数量。 config get maxclients 将客户端的最大数目设置为100000，并启动服务器。 redis-server --maxclients 100000 1.redis命令 1 redis执行了make install后，redis的课执行文件都会自动复制到 /usr/local/bin 目录 2 redis-server redis服务器 3 redis-cli redis命令行客户端 4 redis-benchmark redis性能测试工具 5 redis-check-aof aof文件修复工具 6 redis-check-dump rdb文件检查工具 2.停止 redis 命令 # 停止Redis命令 redis-cli shutdown 只能一个节点一个节点的停止 http://doc.redisfans.com/server/shutdown.html 进来不要强制杀死进程，会丢失数据 #kill -9 10252 10257 10262 10267 10272 10294 #也可执行以下命令来关闭redis进程 #pkill -9 redis 怎样查看Redis的版本号 redis-server --version redis-server -v redis-cli -h 172.16.49.106 -p 6379 --version redis-cli -h 172.16.49.106 -p 6379 -v redis-cli -h 172.16.49.106 -p 6379 info 配置Redis的持久化配置 config set save \"900 1 300 10 60 10000\" config set \"dbfilename\" \"new_file.rdb\" config get save config get dbfilename config get dir #使配置更改永久化 config rewrite 所以实际执行下面这2个命令 config set save \"900 1 300 10 60 10000\" config rewrite [How To Change Redis's Configuration from the Command Line](https://www.digitalocean.com/community/cheatsheets/how-to-change-redis-configuration) Redis集群设置密码 # 每一台机器都执行下设置命令 redis-cli -h 127.0.0.1 -p 6379 config set requirepass 'XXX' redis-cli -h 127.0.0.1 -p 6380 config set requirepass 'XXX' redis-cli -h 127.0.0.1 -p 6381 config set requirepass 'XXX' redis-cli -h 127.0.0.1 -p 6382 config set requirepass 'XXX' # 使配置更改永久化 config rewrite # 要想去除密码设置 ./redis-cli -h 127.0.0.1 -p 6379 -a XXX config set requirepass '' ./redis-cli -h 127.0.0.1 -p 6380 -a XXX config set requirepass '' # 一样的，最后使配置更改永久化 config rewrite Redis客户端最大连接数查询与设置 可以在redis.conf配置文件中修改 maxclients 10000 CONFIG GET maxclients CONFIG GET max* info clients #Redis Client List 命令用于返回所有连接到服务器的客户端信息和统计数据。 CLIENT LIST 参考https://www.cnblogs.com/zt007/p/9510795.htmlRedis Client List 命令 - 获取连接到服务器的客户端连接列表 禁止一些高危命令 修改 redis.conf 文件，添加 rename-command FLUSHALL \"\" rename-command CONFIG \"\" rename-command EVAL \"\" # 重命名为其他名称 rename-command FLUSHALL rds_flushall rename-command FLUSHDB rds_flushdb rename-command KEYS rds_keys rename-command MONITOR rds_monitor 查看redisCluster集群中所有keys值的命令 这种方式只会查询单个节点的： redis-cli -c -h 172.16.48.179 -p 7000 172.16.48.179:7000> keys \"*lengfeng*\" (empty array) 172.16.48.179:7000> 这个可以查询整个集群的 redis-cli -c --cluster call 172.16.48.179:7000 keys \"*lengfeng.test3*\" Redis集群批量删除key 1、查看集群信息 redis-cli -c -h 20.26.37.179 -p 28001 -a password redis-cli -c -h 10.76.227.89 -p 6202 -a XXX cluster nodes 2、删除keys redis-cli -c -h 20.26.37.179 -p 28001 keys \"OAUTH2:TOKEN:*\" | xargs -t -n1 redis-cli -c -h 20.26.37.179 -p 28001 del 或者 redis-cli -c -h 20.26.37.179 -p 28001 -n 0 keys \"OAUTH2:TOKEN:*\" | xargs redis-cli -c -h 20.26.37.179 -p 28001 -n 0 del 删除当前数据库中的所有Key https://blog.csdn.net/iloveyin/article/details/46813427 删除redis所有KEY 如果要访问 Redis 中特定的数据库，使用下面的命令 //下面的命令指定数据序号为0，即默认数据库 redis-cli -h ip -p port -n 0 keys \"*\"| xargs redis-cli -h ip -p port -n 0 del 删除所有Key，可以使用Redis的flushdb和flushall命令 //删除当前数据库中的所有Key flushdb //删除所有数据库中的key flushall 注：keys 指令可以进行模糊匹配，但如果 Key 含空格，就匹配不到了，暂时还没发现好的解决办法。 Redis运维常用命令 info命令(可以查看Redis 服务器的各种信息和统计数值) config get xxx(可以查看redis配置属性值) client list(实时查看已经建立的连接) client kill IP:PORT（杀掉某个连接） slowlog get N 获取慢日志（查看redis慢查询） dbsize // 当前数据库的key的数量 参考Redis运维常用命令redis运维常用命令记录一下redis常用运维命令redis运维命令及参数整理Redis运维手册redis运维常用命令 Redis查询某个key的slot CLUSTER KEYSLOT 'client:prism:{mass-v2:sink:hll:cu}:app-version:hhh' Redis的scan命令 官网参考 redis 127.0.0.1:6379> scan 0 MATCH *11* 1) \"288\" 2) 1) \"key:911\" redis 127.0.0.1:6379> scan 288 MATCH *11* 1) \"224\" 2) (empty list or set) redis 127.0.0.1:6379> scan 224 MATCH *11* 1) \"80\" 2) (empty list or set) redis 127.0.0.1:6379> scan 80 MATCH *11* 1) \"176\" 2) (empty list or set) redis 127.0.0.1:6379> scan 176 MATCH *11* COUNT 1000 1) \"0\" 2) 1) \"key:611\" 2) \"key:711\" 3) \"key:118\" 4) \"key:117\" 5) \"key:311\" 6) \"key:112\" 7) \"key:111\" 8) \"key:110\" 9) \"key:113\" 10) \"key:211\" 11) \"key:411\" 12) \"key:115\" 13) \"key:116\" 14) \"key:114\" 15) \"key:119\" 16) \"key:811\" 17) \"key:511\" 18) \"key:11\" redis 127.0.0.1:6379> 判断key是否存在和计算key的值的数量 type key 和 llen key 都不能，不存在或者为空的时候，返回的是一样的，前者是none，后者是0 exists key 判断一个key是否存在 Redis Type 命令用于返回 key 所储存的值的类型。返回key 的数据类型，数据类型有： none (key不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) Key长度 STRLEN key（string） LLEN key（list） HLEN key（hash） SCARD key（set） zcard key（zset） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis为什么默认16个数据库.html":{"url":"docs/tech/Cache/Redis/Redis为什么默认16个数据库.html","title":"Redis为什么默认16个数据库","keywords":"","body":" 一、16个数据库的由来 二、正确理解Redis的“数据库”概念 三、集群情况下是否支持一个实例多个db 单节点版Redis 一、16个数据库的由来 Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。 这与在一个关系数据库实例中可以创建多个数据库类似（如下图所示），所以可以将其中的每个字典都理解成一个独立的数据库。 Redis默认支持16个数据库，可以通过调整Redis的配置文件redis/redis.conf中的databases来修改这一个值，设置完毕后重启Redis便完成配置。 客户端与Redis建立连接后会默认选择0号数据库，不过可以随时使用SELECT命令更换数据库。 在实际项目中则可以通过以Redis配置文件的形式指定数据库，如下图所示 二、正确理解Redis的“数据库”概念 由于Redis不支持自定义数据库的名字，所以每个数据库都以编号命名。开发者则需要自己记录存储的数据与数据库的对应关系。 另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么全部数据库都没有权限访问。 但是，要正确地理解Redis的“数据库”概念这里不得不提到一个命令： 清空一个Redis实例中所有数据库中的数据 redis 127.0.0.1:6379> FLUSHALL 该命令可以清空实例下的所有数据库数据，这与我们所熟知的关系型数据库所不同。 关系型数据库多个库常用于存储不同应用程序的数据 ，且没有方式可以同时清空实例下的所有库数据。所以对于Redis来说这些db更像是一种命名空间，且不适宜存储不同应用程序的数据。 比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。 Redis非常轻量级，一个空Redis实例占用的内在只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。 三、集群情况下是否支持一个实例多个db 要注意以上所说的都是基于单体Redis的情况。 而在集群的情况下不支持使用select命令来切换db，因为Redis集群模式下只有一个db0。 再扩展一些集群与单机Reids的区别，感兴趣的朋友可以去查阅相关的资料深入理解，这里就不做讨论了。 1、key批量操作支持有限：例如mget、mset必须在一个slot 2、Key事务和Lua支持有限：操作的key必须在一个节点 3、key是数据分区的最小粒度：不支持bigkey分区 4、不支持多个数据库：集群模式下只有一个db0 5、复制只支持一层：不支持树形复制结构 四、总结 Redis实例默认建立了16个db，由于不支持自主进行数据库命名所以以dbX的方式命名。 默认数据库数量可以修改配置文件的database值来设定。 对于db正确的理解应为“命名空间”，多个应用程序不应使用同一个Redis不同库，而应一个应用程序对应一个Redis实例，不同的数据库可用于存储不同环境的数据。 最后要注意，Redis集群下只有db0，不支持多db。 参考 https://www.toutiao.com/i6752317753866060299/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis端口由来和命令前缀PF由来.html":{"url":"docs/tech/Cache/Redis/Redis端口由来和命令前缀PF由来.html","title":"Redis端口由来和命令前缀PF由来","keywords":"","body":"Redis端口由来和命令前缀PF由来 Redis端口由来 Redis的数据类型HyperLogLogd的命令为什么是PF开头 Redis端口由来 今天来聊一个有意思的话题：Redis 的默认端口为什么是 6379 呢? Redis默认端口号的由来，Redis端口号为啥是6379？前几天Redis作者antirez同学在twitter上说将在下一篇博文中向大家解释为什么他选择6379作为默认端口号。而现在这篇博文出炉，在解释了Redis的LRU机制之后，如期向大家解释了采用6379作为默认端口的原因。 我之前也没有想过为什么Redis的默认端口是6379，估计是随便选的吧。然而今天偶然看到一篇帖子，原来不是随便选的，是有含义的。 文章地址 Is it a coincidence that it sounds not random enough? Actually not ;) I selected 6379 because of MERZ, and not the other way around. 听起来不够随机是一个巧合吗？实际上不是;）因为MERZ，所以我选择了6379，而不是相反。 Redis端口号6379是电话键盘上（九宫格）的MERZ。 而Merz全名Alessia Merz，是意大利的一位广告女郎 在Antirez看来，这个名字是愚蠢的代名词，所以就选了这个6379。我觉得还是有点侮辱人啊。不过这位姑娘应该也不会关心IT技术圈的事，反而会被广大程序员知道了。 Redis默认端口号的由来，Redis端口号为啥是6379？ Redis的数据类型HyperLogLogd的命令为什么是PF开头 PFADD key element [element ...] 添加指定元素到 HyperLogLog 中。 PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey ...] 将多个 HyperLogLog 合并为一个 HyperLogLog HyperLogLog其实是一种基数计数概率算法，并不是Redis特有的，Redis基于C语言实现了HyperLogLog并且提供了相关命令API入口。 Redis的作者Antirez为了纪念Philippe Flajolet对组合数学和基数计算算法分析的研究，所以在设计HyperLogLog命令的时候使用了Philippe Flajolet姓名的英文首字母PF作为前缀。 也就是说，Philippe Flajolet博士是HLL算法的重大贡献者，但是他其实并不是Redis中HyperLogLog数据类型的开发者。 遗憾的是Philippe Flajolet博士于2011年3月22日因病在巴黎辞世。这个是Philippe Flajolet博士的维基百科照片： Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/几款开源的图形化Redis客户端管理软件.html":{"url":"docs/tech/Cache/Redis/几款开源的图形化Redis客户端管理软件.html","title":"几款开源的图形化Redis客户端管理软件","keywords":"","body":"Redis是一个超精简的基于内存的键值对数据库（key-value），一般对并发有一定要求的应用都用其储存session，乃至整个数据库。 参见： node.js与redis结合使用。 不过它公自带一个最小化的命令行式的数据库管理工具，有时侯使用起来并不方便。不过Github上面已经有了很多图形化的管理工具，而且都针对REDIS做了一些优化，如自动折叠带schema的key等。 RedisView：一个个人开发的界面，还是比较方便的 https://github.com/cc20110101/RedisView/releases Redis Desktop Manager 一款基于Qt5的跨平台Redis桌面管理软件 支持: Windows 7+, Mac OS X 10.10+, Ubuntu 14+ 特点： C++ 编写，响应迅速，性能好。但不支持数据库备份与恢复。 项目地址： https://github.com/uglide/RedisDesktopManager Redis Client 项目简介：　使用Java编写，功能丰富，缺点是性能稍差，网络不好时，会不时断线。 项目地址：　https://github.com/caoxinyu/RedisClient Redis Studio 项目简介：　又一个C++编写的redis管理工具，仅支持windows平台，支持xp操作系统。 项目地址： https://github.com/cinience/RedisStudio ps: 后面两款为国人开发。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis数据类型.html":{"url":"docs/tech/Cache/Redis/Redis数据类型.html","title":"Redis数据类型","keywords":"","body":"Redis数据类型 Redis的数据类型的实现是什么数据结构 Redis支持七种数据类型的数据结构 跳跃表(SkipList)的原理的原理) 其他的4种特殊的数据类型 Redis的数据类型的实现是什么数据结构 目前Redis6.0官网上明确提出来的数据类型是9种 Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams 实际确认了下，是7种： String(字符串) List(列表) Set(集合) Sorted Set(有序集合) Hash(哈希) module（一个特殊的对象） Streams(流信息) 证据： 1、源码：t_(type)开头的，有且仅有6个：t_hash.c、t_list.c、t_set.c、t_stream.c、t_string.c、t_zset.c 2、type key命令查看key的类型：bitmaps和hyperloglogs是String，geospatial是zset，streams是stream 3、但是在源码server.h文件中有如下定义 /* The actual Redis Object */ #define OBJ_STRING 0 /* String object. */ #define OBJ_LIST 1 /* List object. */ #define OBJ_SET 2 /* Set object. */ #define OBJ_ZSET 3 /* Sorted set object. */ #define OBJ_HASH 4 /* Hash object. */ /* The \"module\" object type is a special one that signals that the object * is one directly managed by a Redis module. In this case the value points * to a moduleValue struct, which contains the object value (which is only * handled by the module itself) and the RedisModuleType struct which lists * function pointers in order to serialize, deserialize, AOF-rewrite and * free the object. * * Inside the RDB file, module types are encoded as OBJ_MODULE followed * by a 64 bit module type ID, which has a 54 bits module-specific signature * in order to dispatch the loading to the right module, plus a 10 bits * encoding version. */ #define OBJ_MODULE 5 /* Module object. */ #define OBJ_STREAM 6 /* Stream object. */ 参考 Redis支持七种数据类型的数据结构 String：字符串。byte 数组， 可以包含任何数据 Hash：哈希，字典，二维结构：数组+链表，第一维度:数组，第二维度:链表，哈希表作为字典的底层实现，哈希表使用链表来解决键冲突问题 List：列表，链表（双向链表）的实现 Set：集合，通过 hash table 实现的 Sorted Set（zset）：有序集合，Hash+跳跃表，在set的基础上增加了一个标识属性，它可以在set添加或修改元素时指定，每次指定，set会自动按标识调整顺序 module stream 一、字符串 Redis使用C语言编写，但是Redis的字符串并没有直接使用C语言传统的字符串，而是自己构建了一种名为简单动态字符串的抽象类型SDS，其本质是个 byte 数组,可以包含任何数据，是二进制安全的。 常用命令：get、set、incr、decr、mget等。 二、字典 Redis使用哈希表作为字典的底层实现，每个字典都有两个哈希表，一个平时使用，另一个仅在进行rehash时使用 哈希表使用链表来解决键冲突问题，被分配到同一个索引上的多个键值对会连接成一个单向链表 redis存入hash结构时, key, hkey, hvalue 均不能为null 常用命令：hget,hset,hgetall 等 三、列表 Redis构建了自己的链表的实现，其特性如下： 1、双端：链表节点提供有prev和next对象,获取某个节点的前置节点和下一个节点的速度为O(1). 2、无环：表头节点prev对象和表尾节点next对象都指向NULL,链表的访问都是以NULL访问为终点. 3、带有表头和表尾对象：通过list结构的head和tail，获取表头和表尾对象的速度为O(1). 4、带有长度计数器：获取链表长度的直接读取len字段值.速度为O(1). 5、多态：通过dup、free、match三个方法,实现链表的多态,保存不同类型的值 list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 常用命令：lpush（添加左边元素）,rpush,lpop（移除左边第一个元素）,rpop,lrange（获取列表片段，LRANGE key start stop）等。 四、集合 sorted sets with range queries 带范围查询的排序集合zset Redis 集合是 string 类型的无序集合。set 元素最大可以包含(2 的 32 次方)个元素。set 是通过 hash table 实现的，hash table 会随着添加或者删除自动的调整大小。调整 hash table 大小时候需要同步(获取写锁)会阻塞其他读写操作。 常用命令：sadd,spop,smembers,sunion 等。 五、有序集合 有序集合(sorted set) 在set的基础上增加了一个标识属性，它可以在set添加或修改元素时指定，每次指定，set会自动按标识调整顺序，set的每一个元素都会关联一个double类型的score。使用时往往我们把要排序的字段作为score存储，对象id则作为元素存储 常用命令：zadd,zrange,zrem,zcard等 实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 六、module Redis在4.0版本推出了 module 的形式，可以将 module 作为插件额外实现Redis的一些功能。官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module。 七、Streams(流信息)：stream（Redis5.0提供一种建模日志用的全新数据结构） Stream 是 Redis 5.0 版本引入的一个新的数据类型，支持消费者组，借鉴 Kafka 设计的支持多播的可持久化消息队列(支持 group，不支持 partition)。 Stream是Redis 5.0引入的一种新数据类型,是一个新的强大的支持多播的可持久化的消息队列。 相比于现有的PUB/SUB、BLOCKED LIST，其虽然也可以在简单的场景下作为消息队列来使用，但是Redis Stream无疑要完善很多。Redis Stream提供了消息的持久化和主备复制功能、新的RadixTree数据结构来支持更高效的内存使用和消息读取、甚至是类似于Kafka的Consumer Group功能。 它以更抽象的方式对日志数据结构进行建模，但是日志的本质仍然完好无损：像日志文件一样，通常实现为仅在追加模式下打开的文件， Redis流主要是仅追加数据结构。至少从概念上讲，由于Redis是流式传输在内存中表示的抽象数据类型，因此它们实现了更强大的操作，以克服日志文件本身的限制。 尽管数据结构本身非常简单，但Redis流却成为最复杂的Redis类型的原因在于它实现了其他非强制性功能：一组阻止操作，使消费者可以等待生产者将新数据添加到流中，此外还有一个称为“ 消费群体”的概念。 消费者群体最初是由流行的称为Kafka（TM）的消息传递系统引入的。Redis用完全不同的术语重新实现了一个类似的想法，但是目标是相同的：允许一组客户合作使用同一消息流的不同部分。 Redis stream使用场景：消息队列，和kafka, RocketMq ,RabbitMq等各种消息中间件要按照当前环境的情况和要求合理使用。 使用示例 > XADD mystream * sensor-id 1234 temperature 19.8 1518951480106-0 ##上面对XADD命令的调用使用自动生成的条目ID ##将一个条目添加sensor-id: 1234, temperature: 19.8到key流中mystream，该条目ID是该命令返回的，具体来说是1518951480106-0。 ##它以键名作为第一个参数mystream，第二个参数是标识流中每个条目的条目ID。 ## 获取Stream中的项目数： > XLEN mystream (integer) 1 Introduction to Redis StreamsRedis Stream教程 跳跃表(SkipList)的原理 想想你老家在世界地图中的位置：亚洲-->中国->安徽省->安庆市->枞阳县->汤沟镇->田间村->xxxx号，也是这样一个类似的结构。 「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于L0、L1和L2层，可以快速在不同层次之间进行「跳跃」。 定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问那新插入的元素如何才有机会「身兼数职」呢？ 跳跃列表采取一个随机策略来决定新元素可以兼职到第几层，首先L0层肯定是100%了，L1层只有50%的概率，L2层只有25%的概率，L3层只有12.5%的概率，一直随机到最顶层L31层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。 跳跃表的性质； 1、由很多层结构组成； 2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 3、最底层的链表包含了所有的元素； 4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）； 5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点； 跳跃表搜索的基本原理: 其基本原理就是从最高层的链表节点开始，如果比当前节点要大,比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 参考Redis实战 | 5种Redis数据类型详解redis的5种数据类型和数据结构Redis的五种数据结构Redis常用数据类型介绍、使用场景及其操作命令Redis几种数据类型及应用场景redis key和value数据类型Redis 数据类型介绍 Redis中的五种数据类型使用场景 原来Redis常用的五种数据类型底层结构是这样的 Redis命令五种数据类型常用命令 其他的4种特殊的数据类型 String(字符串)、List(列表)、Set(集合)、Sorted Set(有序集合)、Hash(哈希)、HyperLogLog(基数)、Bitmap(位集合)、Geospatial(地理空间索引)、Streams(流信息) 还有说还包括BloomFilter(布隆过滤器) 因为 BloomFilter 是 Redis 的扩展模块，所以需要额外下载，你可以使用 Docker 进行拉取。安装步骤我不做详细解释，你可以到它的github上学习怎么安装 特殊的4种数据类型的底层数据结构 HyperLogLog(基数)：String Bitmap(位集合)：String BloomFilter(布隆过滤器)：String（直接封装自Bitmap） Geospatial(地理空间索引)：Sorted Set 注： Bitmap 和 HyperLogLog是基于String类型，但是拓展了自己的语义 HyperLogLog 底层也是 String 实现，与其说 HyperLogLog 是一种单独的数据类型，倒不如说是对 String 数据类型做 API 封装的应用程序。 Redis中的四种特殊的数据结构 bitmap，hyperLogLog，bloomFilter，GeoHash 。这四种数据结构其实有点类似于算法层面了，比如 GeoHash 其实就是一个 zset，bitmap 就是 string，只是使用的方法不同导致了更多的功能。 所以与其说是新的特殊的5种单独的数据类型，倒不如说是对5种基础的数据类型做的API封装的应用程序， 或者说是5种基础的数据类型的实际应用 HyperLogLog(基数)：String HyperLogLogs（计算基数用的一种数据结构） 会存在误差的数据结构HyperLogLog(基数) Redis HyperLogLogs(HLL)属于一种概率算法，(LC,LLC,HLL)三种越来越节省内存，降低误差率。 HyperLogLog优点，在输入元素的数量或者体积非常大时。计算基数所需的空间总是固定很小的。每个HyperLogLog的键只需要花费12KB内存，在标准误差0.81%的前提下，就可以计算接近2^64个不同的基数。 用bitmap存储1一亿个统计数据大概需要12M内存；而在HLL中，只需要不到1K内存就能做到。 HyperLogLog只会根据输入元素来计算基数，而不会存储元素本身，所以不能返回各个元素。 HyperLogLog 计数较小时，采用稀疏矩阵存储，空间占用很小，计数超过了阈值时转变成稠密矩阵，占用 12KB 的空间。数据量大时性价比明显优于 set 结构。 一个 pf 项占用内存空间 12KB。 HyperLogLog 不储存元素本身，不能像 set 那样返回输入的元素。 HLL的使用场景：常用来统计一个集合中不重复的元素个数，例如网站PV，搜索关键词数量，数据分析、网络监控及数据库优化等领域。 HLL比 bitmap更节省内存，但有一定误差( 标准误差 0.81%) PFADD key element [element ...] 添加指定元素到 HyperLogLog 中。 PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey ...] 将多个 HyperLogLog 合并为一个 HyperLogLog 巧用 Redis Hyperloglog，轻松统计 UV 数据Redis HyperLogLogRedis HyperLogLog 用于记录独立总数玩转Redis-HyperLogLog统计微博日活月活初识Redis的数据类型HyperLogLogHyperLogLog&布隆过滤器Redis 中 HyperLogLog 讲解初识Redis的数据类型HyperLogLogRedis应用-HyperLogLogHyperLogLogs(HLL)的使用 Redis HyperLogLog命令 走近源码：神奇的HyperLogLog神奇的HyperLoglog解决统计问题 Bitmap(位集合)：String Bitmap介绍 BitMap位图 位图不是实际的数据类型，而是在String类型上定义的一组面向位的操作。 由于字符串是二进制安全的，最大长度是512MB,转换成位可以设置 2^32不同的位。 512MB = 2^9 2^3（byte） 2^10（kb） * 2^10(mb) = 2^32（bit） 位图的最大优点之一，存储信息时可以节省大量空间。 基本命令使用 setbit key index 0/1 设置某位的值 getbit key index 获取某位的值 bitcount key start end 获取指定范围内为1的数量 BloomFilter(布隆过滤器)：String（直接封装自Bitmap） 因为 BloomFilter 是 Redis 的扩展模块，所以需要额外下载，你可以使用 Docker 进行拉取。安装步骤我不做详细解释，你可以到它的github上学习怎么安装 Redis在4.0版本推出了 module 的形式，可以将 module 作为插件额外实现Redis的一些功能。官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module。 Java 语言的话，RedisBloom项目里有实现 JReBloom 安装完之后我们就可以愉快的使用啦。 bf.add key element 添加元素到布隆过滤器 bf.exists key element 判断元素是否在布隆过滤器 bf.madd key element1 element2 ... 批量添加，添加多个元素到布隆过滤器，bf.add只能添加一个 bf.mexists key element1 element2 ... 批量判断，判断多个元素是否在布隆过滤器 Redis 高级主题之布隆过滤器(BloomFilter)Redis 之布隆过滤器(BloomFilter)RedisBloom: Probabilistic Data Structures for Redis Redis Bloom Filters : Design for large scale uniqueness verification BloomFilter基于redis的实现 基于Redis的BloomFilter实现A distributed bloom filter implementation based on redis Geospatial(地理空间索引)：Sorted Set Redis Geospatial Indexes(地理空间索引) GeoHash 常用来计算 附近的人，附近的商店。 在Redis最新的3.2版本中加入了地理空间(geospatial)以及索引半径查询的功能，这在需要地理位置的应用上或许可以一展身手 将制定的地理空间位置(经度、纬度、名称)添加到指定的key中。这些数据将会存储到Sorted set中。目的是为了方便GEORADIUS或者GEORADIUSBYMEMBER命令对数据进行半径查询等操作。 sorted set使用一种称为Geohash的技术进行填充。经度和纬度的位是交错的，以形成一个独特的52位整数. 我们知道，一个sorted set 的double score可以代表一个52位的整数，而不会失去精度。 这种格式允许半径查询检查的1 + 8个领域需要覆盖整个半径，并丢弃元素以外的半径。通过计算该区域的范围，通过计算所涵盖的范围，从不太重要的部分的排序集的得分，并计算得分范围为每个区域的sorted set中的查询。 Geospatial indexes使用场景：这里假设地球是一个球体，因为使用的距离公式是Haversine公式。这个公式仅适用于地球，而不是一个完美的球体。当在社交网站和其他大多数需要查询半径的应用中使用时，这些偏差都不算问题。但是，在最坏的情况下的偏差可能是0.5%，所以一些地理位置很关键的应用还是需要谨慎考虑。 基本命令和使用实战 geoadd key longitude latitude element(后面可配置多个三元组) 添加元素 geodist key element1 element2 unit 计算两个元素的距离 geopos key element [element] 获取元素的位置 geohash key element 获取元素hash georadiusbymember key element distanceValue unit count countValue ASC/DESC [withdist] [withhash] [withcoord] 获取元素附近的元素 可附加后面选项[距离][hash][坐标] georadius key longitude latitude distanceValue unit count countValue ASC/DESC [withdist] [withhash] [withcoord] 和上面一样只是元素改成了指定坐标值 官方示例 ## 增加意大利西西里岛的两个城市坐标(Palermo和 卡塔尼亚) redis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\" (integer) 2 ## 返回两个给定位置之间的距离。(默认单位米) redis> GEODIST Sicily Palermo Catania \"166274.1516\" ## 以给定的经纬度为中心，返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。 ## 100m redis> GEORADIUS Sicily 15 37 100 km 1) \"Catania\" ## 200m redis> GEORADIUS Sicily 15 37 200 km 1) \"Palermo\" 2) \"Catania\" Redis地理空间(geospatial)介绍和简单使用 参考Redis5.0支持的九种数据类型及使用场景整理（Redis学习笔记）Redis不是只有5种基本数据类型？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis线程模型.html":{"url":"docs/tech/Cache/Redis/Redis线程模型.html","title":"Redis线程模型","keywords":"","body":"Redis线程模型 Redis为什么这么快 Redis6.0多线程 Redis 确实是单线程模型，指的是执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。 因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 一般来说 Redis 的瓶颈并不在 CPU，而在内存和网络。如果要使用 CPU 多核，可以搭建多个 Redis 实例来解决。 Redis 作者从设计之初，进行了多方面的考虑。最终选择使用单线程模型来处理命令。之所以选择单线程模型，主要有如下几个重要原因： 使用单线程模型也能并发的处理客户端的请求（多路复用 I/O）【主要原因】 Redis 操作基于内存，绝大多数操作的性能瓶颈不在 CPU 单线程模型，避免了线程间切换带来的性能开销 使用单线程模型，可维护性更高，开发，调试和维护的成本更低 Redis为什么这么快 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路I/O复用模型，非阻塞IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 1）绝大部分请求是纯粹的内存操作（非常快速） 2）采用单线程,避免了不必要的上下文切 换和竞争条件 3）非阻塞 IO 优点：1.速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间 复杂度都是 O(1) 其实，Redis 4.0 开始就有多线程的概念了，比如 Redis 通过多线程方式在后台删除对象、以及通过 Redis 模块实现的阻塞命令等。 在 Redis 4.0 之后的版本，情况就有了一些变动，新版的 Redis 服务在执行一些命令时就会使用『主处理线程』之外的其他线程，例如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC 等非阻塞的删除操作。 Redis6.0多线程 Redis6.0 引入的多线程部分，实际上只是用来处理网络数据的读写和协议解析，执行命令仍然是单一工作线程。 目前最新的 6.0 版本中，IO 多线程处理模式默认是不开启的，需要去配置文件中开启并配置线程数 多线程版本 Redis 6.0，单线程版本是 Redis 5.0.5。多线程版本需要新增以下配置: io-threads 4 # 开启 4 个 IO 线程 io-threads-do-reads yes # 请求解析也是用 IO 线程 理解Redis的线程IO模型 https://www.cnblogs.com/javastack/p/12848446.htmlhttps://my.oschina.net/doocs/blog/4486815https://draveness.me/whys-the-design-redis-single-thread/https://blog.csdn.net/tanswer_/article/details/70196139https://www.jianshu.com/p/ccae497c0ebbhttps://cloud.tencent.com/developer/article/1488118https://blog.nowcoder.net/n/f7333103347a44b6a85c4a8ed0816e94https://developer.aliyun.com/article/702124https://blog.csdn.net/qq_16681169/article/details/100905697https://blog.csdn.net/xlgen157387/article/details/79470556 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis集群规范.html":{"url":"docs/tech/Cache/Redis/Redis集群规范.html","title":"Redis集群规范","keywords":"","body":" Redis集群规范 Redis集群选举原理 集群选举原理分析 Redis哨兵模式选举机制 Redis集群方案对比 Redis集群规范 Redis集群规范Redis集群介绍 Redis集群规范中文版 Redis集群选举原理 在redis 3.0版本后，官方推出了redis cluster 分布式解决方案，当一个redis节点挂了可以快速地切换到另一个节点。当遇到单机内存、并发等瓶颈时，可以采用分布式方案要解决问题. 在cluster架构下，默认的，一般redis-master用于接收读写，而redis-slave则用于备份，当有请求是在向slave发起时，会直接重定向到对应key所在的master来处理。 但如果不介意读取的是redis-cluster中有可能过期的数据并且对写请求不感兴趣时，则亦可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。 其过程如下： 1.slave发现自己的master变为FAIL 2.发起选举前，slave先给自己的epoch（即currentEpoch）增一，然后请求其它master给自己投票。slave是通过广播FAILOVER_AUTH_REQUEST包给集中的每一个masters。 3.slave发起投票后，会等待至少两倍NODE_TIMEOUT时长接收投票结果，不管NODE_TIMEOUT何值，也至少会等待2秒。 4.master接收投票后给slave响应FAILOVER_AUTH_ACK，并且在（NODE_TIMEOUT*2）时间内不会给同一master的其它slave投票。 5.如果slave收到FAILOVER_AUTH_ACK响应的epoch值小于自己的epoch，则会直接丢弃。一旦slave收到多数master的FAILOVER_AUTH_ACK，则声明自己赢得了选举。 6.如果slave在两倍的NODE_TIMEOUT时间内（至少2秒）未赢得选举，则放弃本次选举，然后在四倍NODE_TIMEOUT时间（至少4秒）后重新发起选举。 Redis集群选举原理： redis集群是由一系列的主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。 Redis集群不需要 sentinel哨兵也能完成节点移除和故障转移的功能。 需要将每个节点设置成集群模式，这种集群模式没有中心节点，客户端通过CRC16算法对key进行hash得到一个值，来判断该key存储在哪个主从服务上面，因此就算是某一个主从整个宕机，redis集群也是部分可用的。 方便水平扩展，可以根据业务规模可以随时加减配置。据官方文档称可以线性扩展到上万个节点(但是官方推荐不超过1000个节点)。 redis集群的性能和高可用性均优于哨兵模式。 集群选举原理分析 选举流程：原理分析： 当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下： 1.slave发现自己的master变为FAIL 2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息 3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack 4.尝试failover的slave收集FAILOVER_AUTH_ACK 5.超过半数后变成新Master 6.广播Pong通知其他集群节点。 从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票 延迟计算公式： DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms 1 SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。 补充之前的一个问题： 跳转重定位 当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。 前面说到这种分片的集群模式的集群可以部分提供服务， 当 redis.conf的配置cluster-require-full-coverage为no时， 表示当一个小主从整体挂掉的时候集群也可以用，也是说 0-16383个槽位中，落在该主从对应的slots上面的key是用不了的，但是如果key落在其他的范围是仍然可用的。 Redis集群选举原理 https://www.cnblogs.com/nijunyang/p/12508098.html https://www.cnblogs.com/sunBinary/p/12433500.html https://blog.csdn.net/lzj3462144/article/details/71023725 https://www.jianshu.com/p/e6894713a6d5 https://stor.51cto.com/art/202004/614940.htm https://baijiahao.baidu.com/s?id=1662783818493463629&wfr=spider&for=pc Redis哨兵模式选举机制 哨兵模式中如果主从中master宕机了，是通过哨兵来选举出新的master，在这个选举切换主从的过程，整个redis服务是不可用的。 而且哨兵模式中只有一个主节点对外提供服务，因此没法支持更高的并发。 而且当个主节点的内存设置也不宜过大。否则会导致持久化文件过大，影响数据恢复或主从同步的效率。 redis集群选举机制 Redis集群方案对比 Redis的主要集群方案可以分为： 客户端分片 基于代理的分片（Twemproxy, codis） 路由查询（Redis Cluster-官方实现） A fast, light-weight proxy for memcached and redis Twemproxy Github地址 Redis的几种使用方式包括： Redis 单副本 Redis 多副本(主从) Redis Sentinel(哨兵) Redis Cluster Redis 自研 参考Redis集群最全方案对比【包括高可用等】Redis集群方案比较 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis数据文件解析和内存分析.html":{"url":"docs/tech/Cache/Redis/Redis数据文件解析和内存分析.html","title":"Redis数据文件解析和内存分析","keywords":"","body":"Redis数据文件解析和内存分析 Redis AOF文件格式解析 REdis AOF文件结构分析解析Redis持久化的AOF文件如何解析Redis AOF文件？ EOL or End of Line or newline ascii characterLearn what are EOL (End of Line) or LF (Line Feed) or NL (New Line) ascii characters (\\n\\r) and why there are two (\\n\\r) newline characters. Redis RDB文件格式解析 Redis持久化文件RDB的格式解析Redis RDB 文件格式Redis RDB文件格式全解析 RDB 文件结构说明Redis持久化之RDB文件格式 Redis内存分析方法 一般会采用 bgsave 生成 dump.rdb 文件，再结合 redis-rdb-tools 和 sqlite 来进行静态分析。 BGSAVE：在后台异步(Asynchronously)保存当前数据库的数据到磁盘。 BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。 生成内存快照:redis-rdb-tools 是一个 python 的解析 rdb 文件的工具，在分析内存的时候，主要用它生成内存快照。 Redis持久化的几种方式——RDB深入解析java-redis-rdbredis-rdb-toolsRedis内存分析方法Redis内存分析分析redis key大小的几种方法redis快照文件dump.rdb解析工具--redis-rdb-tools redis源码剖析（十三）—— dump.rdb文件分析 https://blog.csdn.net/csdn_kou/article/details/103400068 Redis 内存分析神器 https://zhuanlan.zhihu.com/p/99957693 Redis RDB 分析工具 rdbtools 说明 https://www.cnblogs.com/zhoujinyi/p/13276697.html Redis RDB文件格式解析Java实现 Redis replication tool. support sync, psync, psync2. can parse rdb, aof, mixed rdb and aof files. support redis-6.2 redis-replicator GitHub命令行工具redis-rdb-cli Github java-rdb-parserRCT (Redis Computed Tomography) include parse redis rdb , slowlog analyze and clientlist analyzejava-redis-rdb Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Bitmap介绍.html":{"url":"docs/tech/Cache/Redis/Bitmap介绍.html","title":"Bitmap介绍","keywords":"","body":"Bitmap介绍 Redis Bitmaps简介 批量字节操作主要有三个命令：BITOP，BITCOUNT，BITPOS Redis Bitmaps简介 Bitmaps并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。 字节操作可以分为两类：恒定时间的单个字节操作如将一个字节设置为1或者0、或者获取一个字节的值，和批量字节操作如在给定的字节范围内计算设置字节的数量。 bitmaps 的最大优势之一在存储信息时极其节约空间。例如，在一个以增量用户ID来标识不同用户的系统中，记录用户的四十亿的一个单独bit信息（例如，要知道用户是否想要接收最新的来信）仅仅使用512M内存。 最大长度是512M，最多2^32个不同字节 SETBIT key offset value GETBIT key offset BITCOUNT key [start end] # The number of bits set to 1. 我们可以使用SETBIT命令设置字节，使用GETBIT命令检索字节： setbit key 10 1 (integer) 1 getbit key 10 (integer) 1 getbit key 11 (integer) 0 SETBIT命令原型为： SETBIT key offset value 注：如果key不存，则创建key(赋于默认字符串)。key对应的字符串值的长度是可以增加的，以确保字符串可以在offset位置持有一个bit位，offset参数必须大于等于0，小于2^32。当offset值大于key对应字符串值长度时，字符串值长度增加，SETBIT返回值为0。 GETBIT命令原型为： GETBIT key offset 如果指定offset没有设置bit值，则通常返回0。 批量字节操作主要有三个命令：BITOP，BITCOUNT，BITPOS 批量字节操作主要有三个命令：BITOP，BITCOUNT，BITPOS，详细参看redis官方命令介绍 BITOP BITOP operation destkey key [key ...] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种： BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。 BITCOUNT BITCOUNT key [start] [end] 计算给定字符串中，被设置为 1 的比特位的数量。 BITPOS BITPOS key bit [start] [end] 可用版本： >= 2.8.7 时间复杂度： O(N)，其中 N 为位图包含的二进制位数量 返回位图中第一个值为 bit 的二进制位的位置。 BITPOS bits 0 第一个为0的位置 BITPOS bits 1 第一个为1的位置 redis的高级特性：bit位操作 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis集群客户端命令.html":{"url":"docs/tech/Cache/Redis/Redis集群客户端命令.html","title":"Redis集群客户端命令","keywords":"","body":"Redis集群客户端命令 Key（键） String（字符串） Hash（哈希表） List（列表） Set（集合） SortedSet（有序集合） Pub/Sub（发布/订阅） Transaction（事务） 1、Redis键(key)命令命令) 2、Redis字符串(String)命令命令) 3、Redis哈希(Hash)命令命令) 4、Redis列表(List)命令命令) 5、Redis集合(Set)命令命令) 6、Redis有序集合(sorted set)命令命令) 7、Redis发布订阅命令 8、Redis事务命令 9、Redis脚本命令 10、Redis连接命令 11、Redis服务器命令 12、Redis地理位置(geo)命令命令) 13、Redis HyperLogLog命令 Key（键）、String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、SortedSet（有序集合）、Pub/Sub（发布/订阅）、Transaction（事务） Key（键） DEL、EXISTS、Expire、Keys、TTL（Pttl毫秒）、Rename、Renamenx String（字符串） SET、Get、Del、Setex、Setnx、Incr、Decr、Decrby、Append Hash（哈希表） Hdel、Hget、Hgetall、Hset、Hsetnx、Hlen List（列表） Lset、Lrem、Lindex、Lpop、Lpush、Rpop、Rpush、、Blpop、Brpop Set（集合） Sadd、Srem、Sscan、Spop、Smove SortedSet（有序集合） Zadd、Zrem、Zscan、、 Pub/Sub（发布/订阅） Publish、Subscribe、Unsubscribe Transaction（事务） Multi、Exec、Discard、 三、集群客户端命令（redis-cli -c -p port） Key（键）、String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、SortedSet（有序集合）、Pub/Sub（发布/订阅）、Transaction（事务） http://doc.redisfans.com/ http://www.redis.net.cn/order/ Redis连接相关的一些基本命令 下表列出了与Redis连接相关的一些基本命令。 序号 命令 说明 1 AUTH password 使用给定的密码验证服务器 2 ECHO message 打印给定的字符串信息 3 PING 检查服务器是否正在运行 4 QUIT 关闭当前连接 5 SELECT index 更改当前连接的所选数据库 Redis集群相关的命令 集群 cluster info ：打印集群的信息 cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。 节点 cluster meet ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。 cluster forget ：从集群中移除 node_id 指定的节点。 cluster replicate ：将当前节点设置为 node_id 指定的节点的从节点。 cluster saveconfig ：将节点的配置文件保存到硬盘里面。 槽(slot) cluster addslots [slot ...] ：将一个或多个槽（ slot）指派（ assign）给当前节点。 cluster delslots [slot ...] ：移除一个或多个槽对当前节点的指派。 cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。 cluster setslot node ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给 另一个节点，那么先让另一个节点删除该槽>，然后再进行指派。 cluster setslot migrating ：将本节点的槽 slot 迁移到 node_id 指定的节点中。 cluster setslot importing ：从 node_id 指定的节点中导入槽 slot 到本节点。 cluster setslot stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。 键 cluster keyslot ：计算键 key 应该被放置在哪个槽上。 cluster countkeysinslot ：返回槽 slot 目前包含的键值对数量。 cluster getkeysinslot ：返回 count 个 slot 槽中的键 1、Redis键(key)命令,与键相关的一些基本命令 命令 描述 Redis DEL 命令 该命令用于在 key 存在是删除 key。 Redis Dump 命令 序列化给定 key ，并返回被序列化的值。 Redis EXISTS 命令 检查给定 key 是否存在。 Redis Expire 命令 seconds 为给定 key 设置过期时间。 Redis Expireat 命令 EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 Redis PEXPIREAT 命令 设置 key 的过期时间亿以毫秒计。 Redis PEXPIREAT 命令 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 Redis Keys 命令 查找所有符合给定模式( pattern)的 key 。 Redis Move 命令 将当前数据库的 key 移动到给定的数据库 db 当中。 Redis PERSIST 命令 移除 key 的过期时间，key 将持久保持。 Redis Pttl 命令 以毫秒为单位返回 key 的剩余的过期时间。 Redis TTL 命令 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 Redis RANDOMKEY 命令 从当前数据库中随机返回一个 key 。 Redis Rename 命令 修改 key 的名称 Redis Renamenx 命令 仅当 newkey 不存在时，将 key 改名为 newkey 。 Redis Type 命令 返回 key 所储存的值的类型。 下表列出了与键相关的一些基本命令。 编号 命令 描述 1 DEL key 此命令删除一个指定键(如果存在)。 2 DUMP key 此命令返回存储在指定键的值的序列化版本。 3 EXISTS key 此命令检查键是否存在。 4 EXPIRE key seconds 设置键在指定时间秒数之后到期/过期。 5 EXPIREAT key timestamp 设置在指定时间戳之后键到期/过期。这里的时间是Unix时间戳格式。 6 PEXPIRE key milliseconds 设置键的到期时间(以毫秒为单位)。 7 PEXPIREAT key milliseconds-timestamp 以Unix时间戳形式来设置键的到期时间(以毫秒为单位)。 8 KEYS pattern 查找与指定模式匹配的所有键。 9 MOVE key db 将键移动到另一个数据库。 10 PERSIST key 删除指定键的过期时间，得永生。 11 PTTL key 获取键的剩余到期时间。 12 RANDOMKEY 从Redis返回一个随机的键。 13 RENAME key newkey 更改键的名称。 14 PTTL key 获取键到期的剩余时间(以毫秒为单位)。 15 RENAMENX key newkey 如果新键不存在，重命名键。 16 TYPE key 返回存储在键中的值的数据类型。 2、Redis字符串(String)命令,用于在Redis中管理字符串String的基本命令 命令 描述 Redis SET 命令 设置指定 key 的值 Redis Get 命令 获取指定 key 的值。 Redis Getrange 命令 返回 key 中字符串值的子字符 Redis Getset 命令 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 Redis Getbit 命令 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 Redis Mget 命令 获取所有(一个或多个)给定 key 的值。 Redis Setbit 命令 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 Redis Setex 命令 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 Redis Setnx 命令 只有在 key 不存在时设置 key 的值。 Redis Setrange 命令 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 Redis Strlen 命令 返回 key 所储存的字符串值的长度。 Redis Mset 命令 同时设置一个或多个 key-value 对。 Redis Msetnx 命令 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 Redis Psetex 命令 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 Redis Incr 命令 将 key 中储存的数字值增一。 Redis Incrby 命令 将 key 所储存的值加上给定的增量值（increment） 。 Redis Incrbyfloat 命令 将 key 所储存的值加上给定的浮点增量值（increment） 。 Redis Decr 命令 将 key 中储存的数字值减一。 Redis Decrby 命令 key 所储存的值减去给定的减量值（decrement） 。 Redis Append 命令 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 下表列出了一些用于在Redis中管理字符串String的基本命令。 编号 命令 描述说明 1 SET key value 此命令设置指定键的值。 2 GET key 获取指定键的值。 3 GETRANGE key start end 获取存储在键上的字符串的子字符串。 4 GETSET key value 设置键的字符串值并返回其旧值。 5 GETBIT key offset 返回在键处存储的字符串值中偏移处的位值。 6 MGET key1 [key2..] 获取所有给定键的值 7 SETBIT key offset value 存储在键上的字符串值中设置或清除偏移处的位 8 SETEX key seconds value 使用键和到期时间来设置值 9 SETNX key value 设置键的值，仅当键不存在时 10 SETRANGE key offset value 在指定偏移处开始的键处覆盖字符串的一部分 11 STRLEN key 获取存储在键中的值的长度 12 MSET key value [key value …] 为多个键分别设置它们的值 13 MSETNX key value [key value …] 为多个键分别设置它们的值，仅当键不存在时 14 PSETEX key milliseconds value 设置键的值和到期时间(以毫秒为单位) 15 INCR key 将键的整数值增加1 16 INCRBY key increment 将键的整数值按给定的数值增加 17 INCRBYFLOAT key increment 将键的浮点值按给定的数值增加 18 DECR key 将键的整数值减1 19 DECRBY key decrement 按给定数值减少键的整数值 20 APPEND key value 将指定值附加到键 3、Redis哈希(Hash)命令,与哈希/散列Hash相关的一些基本命令 命令 描述 Redis Hdel 命令 删除一个或多个哈希表字段 Redis Hexists 命令 查看哈希表 key 中，指定的字段是否存在。 Redis Hget 命令 获取存储在哈希表中指定字段的值/td> Redis Hgetall 命令 获取在哈希表中指定 key 的所有字段和值 Redis Hincrby 命令 为哈希表 key 中的指定字段的整数值加上增量 increment 。 Redis Hincrbyfloat 命令 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 Redis Hkeys 命令 获取所有哈希表中的字段 Redis Hlen 命令 获取哈希表中字段的数量 Redis Hmget 命令 获取所有给定字段的值 Redis Hmset 命令 同时将多个 field-value (域-值)对设置到哈希表 key 中。 Redis Hset 命令 将哈希表 key 中的字段 field 的值设为 value 。 Redis Hsetnx 命令 只有在字段 field 不存在时，设置哈希表字段的值。 Redis Hvals 命令 获取哈希表中所有值 下表列出了与哈希/散列Hash相关的一些基本命令。 序号 命令 说明 1 HDEL key field2 [field2] 删除一个或多个哈希字段。 2 HEXISTS key field 判断是否存在散列字段。 3 HGET key field 获取存储在指定键的哈希字段的值。 4 HGETALL key 获取存储在指定键的哈希中的所有字段和值 5 HINCRBY key field increment 将哈希字段的整数值按给定数字增加 6 HINCRBYFLOAT key field increment 将哈希字段的浮点值按给定数值增加 7 HKEYS key 获取哈希中的所有字段 8 HLEN key 获取散列中的字段数量 9 HMGET key field1 [field2] 获取所有给定哈希字段的值 10 HMSET key field1 value1 [field2 value2 ] 为多个哈希字段分别设置它们的值 11 HSET key field value 设置散列字段的字符串值 12 HSETNX key field value 仅当字段不存在时，才设置散列字段的值 13 HVALS key 获取哈希中的所有值 4、Redis列表(List)命令,与列表List相关的一些基本命令 命令 描述 Redis Blpop 命令 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Brpop 命令 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Brpoplpush 命令 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Lindex 命令 通过索引获取列表中的元素 Redis Linsert 命令 在列表的元素前或者后插入元素 Redis Llen 命令 获取列表长度 Redis Lpop 命令 移出并获取列表的第一个元素 Redis Lpush 命令 将一个或多个值插入到列表头部 Redis Lpushx 命令 将一个或多个值插入到已存在的列表头部 Redis Lrange 命令 获取列表指定范围内的元素 Redis Lrem 命令 移除列表元素 Redis Lset 命令 通过索引设置列表元素的值 Redis Ltrim 命令 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 Redis Rpop 命令 移除并获取列表最后一个元素 Redis Rpoplpush 命令 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 Redis Rpush 命令 在列表中添加一个或多个值 Redis Rpushx 命令 为已存在的列表添加值 下表列出了与列表List相关的一些基本命令。 序号 命令 说明 1 BLPOP key1 [key2 ] timeout 删除并获取列表中的第一个元素，或阻塞，直到有一个元素可用 2 BRPOP key1 [key2 ] timeout 删除并获取列表中的最后一个元素，或阻塞，直到有一个元素可用 3 BRPOPLPUSH source destination timeout 从列表中弹出值，将其推送到另一个列表并返回它; 或阻塞，直到一个可用 4 LINDEX key index 通过其索引从列表获取元素 5 LINSERT key BEFORE/AFTER pivot value 在列表中的另一个元素之前或之后插入元素 6 LLEN key 获取列表的长度 7 LPOP key 删除并获取列表中的第一个元素 8 LPUSH key value1 [value2] 将一个或多个值添加到列表 9 LPUSHX key value 仅当列表存在时，才向列表添加值 10 LRANGE key start stop 从列表中获取一系列元素 11 LREM key count value 从列表中删除元素 12 LSET key index value 通过索引在列表中设置元素的值 13 LTRIM key start stop 修剪列表的指定范围 14 RPOP key 删除并获取列表中的最后一个元素 15 RPOPLPUSH source destination 删除列表中的最后一个元素，将其附加到另一个列表并返回 16 RPUSH key value1 [value2] 将一个或多个值附加到列表 17 RPUSHX key value 仅当列表存在时才将值附加到列表 5、Redis集合(Set)命令,与集合Set相关的一些基本命令 命令 描述 Redis Sadd 命令 向集合添加一个或多个成员 Redis Scard 命令 获取集合的成员数 Redis Sdiff 命令 返回给定所有集合的差集 Redis Sdiffstore 命令 返回给定所有集合的差集并存储在 destination 中 Redis Sinter 命令 返回给定所有集合的交集 Redis Sinterstore 命令 返回给定所有集合的交集并存储在 destination 中 Redis Sismember 命令 判断 member 元素是否是集合 key 的成员 Redis Smembers 命令 返回集合中的所有成员 Redis Smove 命令 将 member 元素从 source 集合移动到 destination 集合 Redis Spop 命令 移除并返回集合中的一个随机元素 Redis Srandmember 命令 返回集合中一个或多个随机数 Redis Srem 命令 移除集合中一个或多个成员 Redis Sunion 命令 返回所有给定集合的并集 Redis Sunionstore 命令 所有给定集合的并集存储在 destination 集合中 Redis Sscan 命令 迭代集合中的元素 下表列出了与集合Set相关的一些基本命令。 序号 命令 说明 1 SADD key member1 [member2] 将一个或多个成员添加到集合 2 SCARD key 获取集合中的成员数 3 SDIFF key1 [key2] 减去多个集合 4 SDIFFSTORE destination key1 [key2] 减去多个集并将结果集存储在键中 5 SINTER key1 [key2] 相交多个集合 6 SINTERSTORE destination key1 [key2] 交叉多个集合并将结果集存储在键中 7 SISMEMBER key member 判断确定给定值是否是集合的成员 8 SMOVE source destination member 将成员从一个集合移动到另一个集合 9 SPOP key 从集合中删除并返回随机成员 10 SRANDMEMBER key [count] 从集合中获取一个或多个随机成员 11 SREM key member1 [member2] 从集合中删除一个或多个成员 12 SUNION key1 [key2] 添加多个集合 13 SUNIONSTORE destination key1 [key2] 添加多个集并将结果集存储在键中 14 SSCAN key cursor []MATCH pattern [COUNT count] 递增地迭代集合中的元素 6、Redis有序集合(sorted set)命令 命令 描述 Redis Zadd 命令 向有序集合添加一个或多个成员，或者更新已存在成员的分数 Redis Zcard 命令 获取有序集合的成员数 Redis Zcount 命令 计算在有序集合中指定区间分数的成员数 Redis Zincrby 命令 有序集合中对指定成员的分数加上增量 increment Redis Zinterstore 命令 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 Redis Zlexcount 命令 在有序集合中计算指定字典区间内成员数量 Redis Zrange 命令 通过索引区间返回有序集合成指定区间内的成员 Redis Zrangebylex 命令 通过字典区间返回有序集合的成员 Redis Zrangebyscore 命令 通过分数返回有序集合指定区间内的成员 Redis Zrank 命令 返回有序集合中指定成员的索引 Redis Zrem 命令 移除有序集合中的一个或多个成员 Redis Zremrangebylex 命令 移除有序集合中给定的字典区间的所有成员 Redis Zremrangebyrank 命令 移除有序集合中给定的排名区间的所有成员 Redis Zremrangebyscore 命令 移除有序集合中给定的分数区间的所有成员 Redis Zrevrange 命令 返回有序集中指定区间内的成员，通过索引，分数从高到底 Redis Zrevrangebyscore 命令 返回有序集中指定分数区间内的成员，分数从高到低排序 Redis Zrevrank 命令 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 Redis Zscore 命令 返回有序集中，成员的分数值 Redis Zunionstore 命令 计算给定的一个或多个有序集的并集，并存储在新的 key 中 Redis Zscan 命令 迭代有序集合中的元素（包括元素成员和元素分值） 7、Redis发布订阅命令 命令 描述 Redis Pubsub 命令 查看订阅与发布系统状态。 Redis Publish 命令 将信息发送到指定的频道。 Redis Subscribe 命令 订阅给定的一个或多个频道的信息。 Redis Unsubscribe 命令 指退订给定的频道。 Redis Psubscribe 命令 订阅一个或多个符合给定模式的频道。 Redis Punsubscribe 命令 退订所有给定模式的频道。 8、Redis事务命令 命令 描述 Redis Multi 命令 标记一个事务块的开始。 Redis Exec 命令 执行所有事务块内的命令。 Redis Discard 命令 取消事务，放弃执行事务块内的所有命令。 Redis Watch 命令 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 Redis Unwatch 命令 取消 WATCH 命令对所有 key 的监视。 9、Redis脚本命令 命令 描述 Redis Eval 命令 执行 Lua 脚本。 Redis Evalsha 命令 执行 Lua 脚本。 Redis Script Exists 命令 查看指定的脚本是否已经被保存在缓存当中。 Redis Script Flush 命令 从脚本缓存中移除所有脚本。 Redis Script kill 命令 杀死当前正在运行的 Lua 脚本。 Redis Script Load 命令 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。 10、Redis连接命令 命令 描述 Redis Auth 命令 验证密码是否正确 Redis Echo 命令 打印字符串 Redis Ping 命令 查看服务是否运行 Redis Quit 命令 关闭当前连接 Redis Select 命令 切换到指定的数据库 11、Redis服务器命令，Redis服务器相关的一些基本命令 命令 描述 Redis Bgrewriteaof 命令 异步执行一个 AOF（AppendOnly File） 文件重写操作 Redis Bgsave 命令 在后台异步保存当前数据库的数据到磁盘 Redis Client Kill 命令 关闭客户端连接 Redis Client List 命令 获取连接到服务器的客户端连接列表 Redis Client Getname 命令 获取连接的名称 Redis Client Pause 命令 在指定时间内终止运行来自客户端的命令 Redis Client Setname 命令 设置当前连接的名称 Redis Cluster Slots 命令 获取集群节点的映射数组 Redis Command 命令 获取 Redis 命令详情数组 Redis Command Count 命令 获取 Redis 命令总数 Redis Command Getkeys 命令 获取给定命令的所有键 Redis Time 命令 返回当前服务器时间 Redis Command Info 命令 获取指定 Redis 命令描述的数组 Redis Config Get 命令 获取指定配置参数的值 Redis Config rewrite 命令 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写 Redis Config Set 命令 修改 redis 配置参数，无需重启 Redis Config Resetstat 命令 重置 INFO 命令中的某些统计数据 Redis Dbsize 命令 返回当前数据库的 key 的数量 Redis Debug Object 命令 获取 key 的调试信息 Redis Debug Segfault 命令 让 Redis 服务崩溃 Redis Flushall 命令 删除所有数据库的所有key Redis Flushdb 命令 删除当前数据库的所有key Redis Info 命令 获取 Redis 服务器的各种信息和统计数值 Redis Lastsave 命令 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示 Redis Monitor 命令 实时打印出 Redis 服务器接收到的命令，调试用 Redis Role 命令 返回主从实例所属的角色 Redis Save 命令 异步保存数据到硬盘 Redis Shutdown 命令 异步保存数据到硬盘，并关闭服务器 Redis Slaveof 命令 将当前服务器转变为指定服务器的从属服务器(slave server) Redis Showlog 命令 管理 redis 的慢日志 Redis Sync 命令 用于复制功能(replication)的内部命令 下表列出了与Redis服务器相关的一些基本命令。 序号 命令 说明 1 BGREWRITEAOF 异步重写仅追加的文件 2 BGSAVE 将数据集异步保存到磁盘 3 CLIENT KILL [ip:port] [ID client-id] 杀死或断开指定的客户端的连接 4 CLIENT LIST 获取到服务器的客户端连接列表 5 CLIENT GETNAME 获取当前连接的名称 6 CLIENT PAUSE timeout 在指定时间内停止处理来自客户端的命令 7 CLIENT SETNAME connection-name 设置当前连接名称 8 CLUSTER SLOTS 获取群集插槽到节点映射的数组 9 COMMAND 获取Redis命令详细信息的数组 10 COMMAND COUNT 获取Redis命令的总数 11 COMMAND GETKEYS 提取键给出一个完整的Redis的命令 12 BGSAVE 将数据集异步保存到磁盘 13 COMMAND INFO command-name [command-name …] 获取特定Redis命令详细信息的数组 14 CONFIG GET parameter 获取配置参数的值 15 CONFIG REWRITE 使用内存中配置来重写配置文件 16 CONFIG SET parameter value 将配置参数设置为给定值 17 CONFIG RESETSTAT 重置由INFO返回的统计信息 18 DBSIZE 返回所选数据库中的键数量 19 DEBUG OBJECT key 获取有关键的调试信息 20 DEBUG SEGFAULT 使服务器崩溃 21 FLUSHALL 从所有数据库中删除所有键 22 FLUSHDB 删除当前数据库中的所有键 23 INFO [section] 获取有关服务器的信息和统计信息 24 LASTSAVE 获取上次成功保存到磁盘的UNIX时间戳 25 MONITOR 监听服务器实时接收的所有请求 26 ROLE 返回实例在复制上下文中的角色 27 SAVE 将数据集同步保存到磁盘 28 SHUTDOWN [NOSAVE] [SAVE] 将数据集同步保存到磁盘，然后关闭服务器 29 SLAVEOF host port 使服务器成为另一个实例的从属，或将其提升作为主服务器 30 SLOWLOG subcommand [argument] 管理Redis慢查询日志 31 SYNC 用于复制的命令 32 TIME 返回当前服务器的时间 12、Redis地理位置(geo)命令 命令 描述 Redis GEOADD 命令 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中 Redis GEODIST 命令 返回两个给定位置之间的距离 Redis GEOHASH 命令 返回一个或多个位置元素的 Geohash 表示 Redis GEOPOS 命令 从key里返回所有给定位置元素的位置（经度和纬度） Redis GEORADIUS 命令 以给定的经纬度为中心， 找出某一半径内的元素 Redis GEORADIUSBYMEMBER 命令 找出位于指定范围内的元素，中心点是由给定的位置元素决定 13、Redis HyperLogLog命令 命令 描述 Redis Pfadd 命令 添加指定元素到 HyperLogLog 中。 Redis Pfcount 命令 返回给定 HyperLogLog 的基数估算值。 Redis Pgmerge 命令 将多个 HyperLogLog 合并为一个 HyperLogLog Redis基准测试中可用选项的列表 以下是Redis基准测试中可用选项的列表。 序号 选项 说明 默认值 1 -h 指定服务器主机名 127.0.0.1 2 -p 指定服务器端口 6379 3 -s 指定服务器套接字 4 -c 指定并行连接的数量 50 5 -n 指定请求的总数 10000 6 -d 指定SET/GET值的数据大小(以字节为单位) 2 7 -k 1=keep alive, 0=reconnect 1 8 -r 使用SET/GET/INCR的随机键，SADD的随机值 9 -p 管道请求 1 10 -h 指定服务器主机名 11 -q 强制让Redis安装。 只显示query/sec值 12 --csv 以CSV格式输出 13 -l 生成循环，永久运行测试 14 -t 只运行逗号分隔的测试列表 15 -I 空闲模式。 只打开N个空闲连接并等待 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis快的秘诀.html":{"url":"docs/tech/Cache/Redis/Redis快的秘诀.html","title":"Redis快的秘诀","keywords":"","body":"Redis快的秘诀 Redis快的秘诀 1、数据存到内存 2、采用单线程模型 3、使用多路I/O复用的I/O模型 4.总结 Redis是一个高性能的key-value数据库，在实际开发中常被用于做分布式缓存、消息队列等。 Redis如此受欢迎这其中一个重要原因是因为其读写数据速度快，能支持10w+qps（每秒查询率）。 那么Redis快的原因是什么？文本从以下三点展开讨论 1、数据存到内存 2、采用单线程模型 3、使用多路I/O复用模型 1、数据存到内存 Redis数据存在内存中且绝大部分请求是对内存操作，因此在进行读写数据操作的时候不会受到硬盘 I/O 速度的限制，速度快。 补充：Redis也提供了两种数据持久化方式：AOF（可回放的命令日志）与 RDB（内存快照）。两种持久化方式各有优缺点，从Redis4.0开始允许使用RDB-AOF混合持久化的方式，这种方式结合了两者的优点。 2、采用单线程模型 2.1 文件事件处理器 Redis 服务器是一个事件驱动程序， 处理的事件分为时间事件和文件事件。Redis基于reactor设计模式开发了文件事件处理器用于高效地处理事件。 它的组成结构为4部分：多个套接字（socket）、IO多路复用程序、文件事件分派器、事件处理器（如下图所示）。因为这个文件处理器是单线程的，所以Redis是单线程模型。 2.2单线程模型的优点 通过采用单线程避免了多线程中的上下文切换损耗及不需要考虑锁问题以及锁问题带来的损耗等。 补充：Redis对数据事件的处理是单线程的，但它在其他模块仍用了多个线程，如异步将数据写入磁盘进行持久化操作。 3、使用多路I/O复用的I/O模型 3.1 概念介绍 I/O模型分为以下五种： 同步阻塞I/O 同步非阻塞I/O IO多路复用（Reactor设计模式也称为异步阻塞IO，例子：Java的Selector、Linux的epoll） 信号驱动I/O模型 异步非阻塞I/O（Proactor设计模式） 在“Redis使用多路I/O复用模型”中“多路”指的是多个Socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求。 3.2 I/O多路复用模型在Redis中的应用 Redis使用epoll同时监听多个Socket连接，并给不同Socket关联不同的处理程序。当被监听的Sokcet准备好连接应答、请求、应答、关闭等操作时，就会产生对应的文件事件。这时文件事件处理器就会调用Socket之前关联好的事件处理器来处理这些事件。 4.总结 Redis之所以快其中主要三个原因为： 数据存到内存、 采用单线程模型避免了些不必要的损耗、 使用多路I/O复用的I/O模型让单个线程高效的处理多个连接请求。 快也还有包括其他的原因如数据模型等。 Redis快的秘诀 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Redis/Redis的过期策略和内存淘汰策略.html":{"url":"docs/tech/Cache/Redis/Redis的过期策略和内存淘汰策略.html","title":"Redis的过期策略和内存淘汰策略","keywords":"","body":"Redis的过期策略和内存淘汰策略 Redis的过期策略 Redis对于过期键有三种清除策略 被动删除 主动删除 当前已用内存超过maxmemory限定时，触发主动清理策略 查看Redis的内存淘汰策略设置 Redis的过期策略 我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 Redis中同时使用了惰性过期和定期过期两种过期策略。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。) Redis对于过期键有三种清除策略 1、被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key 2、主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key 3、当前已用内存超过maxmemory限定时，触发主动清理策略 被动删除 只有key被操作时(如GET)，REDIS才会被动检查该key是否过期，如果过期则删除之并且返回NIL。 1、这种删除策略对CPU是友好的，删除操作只有在不得不的情况下才会进行，不会对其他的expire key上浪费无谓的CPU时间。 2、但是这种策略对内存不友好，一个key已经过期，但是在它被操作之前不会被删除，仍然占据内存空间。如果有大量的过期键存在但是又很少被访问到，那会造成大量的内存空间浪费。expireIfNeeded(redisDb db, robj key)函数位于src/db.c。 但仅是这样是不够的，因为可能存在一些key永远不会被再次访问到，这些设置了过期时间的key也是需要在过期后被删除的，我们甚至可以将这种情况看作是一种内存泄露—-无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。 主动删除 先说一下时间事件，对于持续运行的服务器来说， 服务器需要定期对自身的资源和状态进行必要的检查和整理， 从而让服务器维持在一个健康稳定的状态， 这类操作被统称为常规操作（cron job） 在 Redis 中， 常规操作由 redis.c/serverCron 实现， 它主要执行以下操作 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。 清理数据库中的过期键值对。 对不合理的数据库进行大小调整。 关闭和清理连接失效的客户端。 尝试进行 AOF 或 RDB 持久化操作。 如果服务器是主节点的话，对附属节点进行定期同步。 如果处于集群模式的话，对集群进行定期同步和连接测试。 Redis 将 serverCron 作为时间事件来运行， 从而确保它每隔一段时间就会自动运行一次， 又因为 serverCron 需要在 Redis 服务器运行期间一直定期运行， 所以它是一个循环时间事件： serverCron 会一直定期执行，直到服务器关闭为止。 在 Redis 2.6 版本中， 程序规定 serverCron 每秒运行 10 次， 平均每 100 毫秒运行一次。 从 Redis 2.8 开始， 用户可以通过修改 hz选项来调整 serverCron 的每秒执行次数， 具体信息请参考 redis.conf 文件中关于 hz 选项的说明也叫定时删除，这里的“定期”指的是Redis定期触发的清理策略，由位于src/redis.c的activeExpireCycle(void)函数来完成。 当前已用内存超过maxmemory限定时，触发主动清理策略 noeviction ： 永不过期，返回错误，谁也不删，直接在写操作时返回错误。【默认淘汰策略】当内存不足以容纳新写入数据时，新写入操作会报错。 allkeys-random：随机删除，无差别随机删。当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 allkeys-lru ： 删除lru算法的key，根据LRU算法删除任何key。当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。 allkeys-lfu : 从所有键中驱逐使用频率最少的键 volatile-random：随机删除即将过期key，根据过期设置来随机删除key。当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 volatile-ttl ： 删除即将过期的，根据最近过期时间来删除（辅以TTL），当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 volatile-lru：只对设置了过期时间的key进行LRU（默认值），根据LRU算法生成的过期时间来删除。当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 LFU是在Redis4.0后出现的 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu：从所有键中驱逐使用频率最少的键 当mem_used内存已经超过maxmemory的设定，对于所有的读写请求，都会触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存。注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟。 清理时会根据用户配置的maxmemory-policy来做适当的清理（一般是LRU或TTL），这里的LRU或TTL策略并不是针对redis的所有key，而是以配置文件中的maxmemory-samples个key作为样本池进行抽样清理。 查看Redis的内存淘汰策略设置 config get maxmemory-policy 参考 https://blog.csdn.net/FYWT98/article/details/82585583 Redis的缓存淘汰策略LRU与LFU彻底弄懂Redis的内存淘汰策略Redis的过期策略和内存淘汰策略redis内存淘汰策略及如何配置 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Caffeine.html":{"url":"docs/tech/Cache/Caffeine.html","title":"Caffeine","keywords":"","body":"Caffeine Caffeine缓存框架 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/JetCache.html":{"url":"docs/tech/Cache/JetCache.html","title":"JetCache","keywords":"","body":"JetCache JetCache是一种Java缓存抽象，可为各种缓存解决方案提供一致的使用。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/JCache.html":{"url":"docs/tech/Cache/JCache.html","title":"JCache","keywords":"","body":"JCache Java缓存规范JCache API（JSR107），它对Java对象缓存进行标准化，方便高效开发，让程序员摆脱实现缓存有效期、互斥、假脱机（spooling）和缓存一致性等负担。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/GuavaCache.html":{"url":"docs/tech/Cache/GuavaCache.html","title":"GuavaCache","keywords":"","body":"GuavaCache Guava LocalCache 缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/ConcurrentLinkedHashMap.html":{"url":"docs/tech/Cache/ConcurrentLinkedHashMap.html","title":"ConcurrentLinkedHashMap","keywords":"","body":"ConcurrentLinkedHashMap 基于LRU（Least recently used，最近最少使用）算法来替换Map中的元素 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/EhCache.html":{"url":"docs/tech/Cache/EhCache.html","title":"EhCache","keywords":"","body":"EhCache EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Hazelcast.html":{"url":"docs/tech/Cache/Hazelcast.html","title":"Hazelcast","keywords":"","body":"Hazelcast zelcast是一个高度可扩展的数据分发和集群平台，可用于实现分布式数据存储、数据缓存 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Codis.html":{"url":"docs/tech/Cache/Codis.html","title":"Codis","keywords":"","body":"Codis Redis 的集群解决方案有社区的，也有官方的，社区的解决方案有 Codis 和Twemproxy,官方的集群解决方案就是 Redis Cluster Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Cache/Tair.html":{"url":"docs/tech/Cache/Tair.html","title":"Tair","keywords":"","body":"Tair air是一个Key/Value结构数据的解决方案，它默认支持基于内存和文件的两种存储方式，分别和我们通常所说的缓存和持久化存储对应。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Register/Register注册中心和Config配置中心.html":{"url":"docs/tech/Register/Register注册中心和Config配置中心.html","title":"注册中心和配置中心","keywords":"","body":"Register注册中心和Config配置中心 注册中心和配置中心 注册中心配置中心 1、Zookeeper 2、 3、 4、 5、 [quickstart-register][quickstart-config] Zookeeper Zookeeper了解多少？客户端是原生的还是开源的？watcher是一次性的？为什么是一次性的？效率不能保证 Zookeeper 直接watch：api复杂，只能一级一级关注，一次性的】 Zookeeper:原生：Watcher、curator：Cache分为三类监听类型：节点监听（NodeCache）和节点直接子节点监听（PathChildrenCache）、节点多级子节点监听TreeCache。 Consul相关：consul结构和部署、raft一致性协议/quickstart-register/doc/Consul.md /Users/yangzl/git/quickstart-register/quickstart-zookeeper/docs Apache ZooKeeper Watcher 机制.md Curator.md zoo.cfg zoo-sample.cfg zoo_sample.cfg Zookeeper命令.md Zookeeper学习.md Zookeeper客户端.md Zookeeper服务端和客户端的配置.md 单节点部署启动.md 集群部署启动.md 配置中心：携程Apollo配置中心、disconf、注册中心：Zookeeper、consul、etcd 开源分布式配置中心选型http://vernonzheng.com/2015/02/09/%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/ Zookeeper.md Consul.md Etcd.md Eureka.md Nacos学习.md Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Monitor/Monitor监控.html":{"url":"docs/tech/Monitor/Monitor监控.html","title":"系统监控","keywords":"","body":"系统监控 1、 2、 3、 4、 5、 Monitor监控 监控：zabbit Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Database/DB数据库.html":{"url":"docs/tech/Database/DB数据库.html","title":"数据库","keywords":"","body":"DB数据库 数据库 1、MySQL 2、Oracle 3、数据库操作框架 4、数据库中间件 5、轻量级数据库 6、其他数据库工具 DB-Engines Ranking墨天轮中国数据库流行度排行数据库排行榜 MySQL DML、DDL、DCL的区别 数据库的概念：库，用户，等 SQL列约束、主键约束、外键约束SQL唯一约束、主键、外键三范式：1NF、2NF、3NF 锁表原因及解决思路JDBC接口使用PreparedStatement预编译的好处SQL关键字：DISTINCT、Where(AND/OR、IN、BETWEEN、LIKE)GROUP BY(HAVING)、ORDER BY 数据库优化 SQL优化 索引的种类、数据结构、时间复杂度、实现原理 MySQL自适应索引(Adaptive hash index, AHI)实现解析 游标（cursor） 数据库中事务的四大特性（ACID） 1、DML、DDL、DCL的区别DDL（data definition language）数据库定义语言：CREATE、ALTER、DROP等DCL（Data Control Language）数据库控制语言：包括（grant,deny,revoke等）语句DML（data manipulation language）数据操纵语言:常用到的 SELECT、UPDATE、INSERT、DELETE。 SQL唯一约束、主键、外键三范式：第一范式(1NF)：定义所需要的数据项、确保有数据没有重复的组、确保有一个主键、第二范式(2NF)：满足所有1NF的规则，必须有任意列不依赖主键关系第三范式(3NF)：满足第二范式 、所有非主字段都是依赖于主键 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。第二范式：在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。也就是一类，比如订单信息和客户信息分成两个表第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 2、数据库优化 数据库优化套路 分库分表、优化SQL语句、执行计划和Hint（提示） 数据库优化：1) SQL语句及索引的优化2) 数据库表结构的优化数据库架构扩展：主从复制与读写分离、增加缓存、分库、分表、分区，开启慢查询日志，3) 系统配置的优化4) 硬件优化 3、SQL优化：执行计划和Hint：EXPLAIN 或 EXPLAIN PLAN FOR 、/+ all_rows / 查看执行计划：mysql：EXPLAIN 或者 oracle：EXPLAIN PLAN FOR访问数据扫描方式：全表扫描、通过ROWID的扫描、索引扫描（索引唯一扫描、索引范围扫描、索引全扫描、索引快速扫描）表之间连接：四种SQL优化：执行计划和Hint（提示）、SQL语句优化SQL语句优化：优化语句使用索引、加Hint(提示) SQL优化 一个 SQL 语句的具体执行过程，比如会怎么利用索引，怎么优化之类的 什么样的sql不走索引：where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等 检查SQL是否使用了索引：用explain 来执行检验sql mysql:key列显示MySQL实际决定使用的键（索引） SQL语句优化：避免全表扫描MySQL行级锁、表级锁、页级锁的优化 4、索引的种类、数据结构、时间复杂度、实现原理 索引的作用，结构，为什么可以加快查询，缺点 占用空间，增删改变慢 数据库中主键与索引的区别 加索引能使查询变快，加索引后会使写入、修改、删除变慢，占用存储空间 索引的实现使用的数据结构：B-tree 或者 B+tree（局部性原理、磁盘预读、） 由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 索引的种类：唯一索引、聚集索引、非聚集索引、覆盖索引 索引查询的流程：非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据索引数据结构设相关的计算机原理：磁盘预读原理 和 B+树 B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小 索引类型：a、普通索引：没有限制b、唯一索引：索引列的值必须唯一，但允许有空值。c、主键索引：特殊的唯一索引，不允许有空值。d、组合索引：最左前缀。1):查询条件中出现联合索引第一列,或者全部,则能利用联合索引.2)条件列中只要条件相连在一起,以本文例子来说就是:last_name=’1′ and first_name=’1′与first_name=’1′ and last_name=’1′,无论前后,都会利用上联合索引.3)查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询.复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的e、全文索引 索引的坏处：虽然大大提高了查询速度，但是会降低表的更新速度，例如insert、delete、update时，不仅要更新表，还要更新索引文件。 数据库中事务的定义，什么是数据库事务 数据库中事务的四大特性（ACID） 怎么实现ACID：实现ACID的核心技术是并发控制和日志技术 并发控制：2PL、OCC、MVCC：保证并发操作的正确性 日志：Redo/Undo,WAL协议：保证故障场景下可恢复 数据库事务定义：一致性、隔离性 事务（Transaction）的4大特性ACID ACID 原子性、一致性、隔离性（Isolation）、持久性 事务（Transaction）的隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable： SQL标准定义了4种事务隔离级别：读未提交，读已提交，可重复读，串行化事物隔离级别的实现原理：共享锁、独占锁、行级锁、表级锁事务隔离解决问题：脏读、不可重复读、幻读 read-uncommited 读未提交，别人修改了未提交就能看得到。会产生脏读read-commited 读提交，默认的就是这个。 会产生读取旧数据，repeatable-read 可重复读。会产生幻读，就是突然蹦出来的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。serializable 可串行化，强制事务串行执行。但是性能低下。 Select、where、order by、COUNT、HAVING 、 4、redis怎么防止内存穿透，怎么做到缓存和数据库一致 DB数据库深度分页：覆盖索引、主键索引+join、倒序排列、缓存若干页、业务不允许查太多页 数据库，innobd，隔离级别，行级锁 JDBC规范提供的接口和类Statement、PreparedStatement、CallableStatement区别 12、mybatis中的 $｛param｝与#｛param｝区别 13、mysql主从复制主从好处：数据安全备份、读写分离、业务数据分库存储主从原理：主库的binlog、position输出线程、从库的I/O线程接收binlog、position线程 和 从库的SQL线程 mysql主从复制存在的问题：主库宕机后，数据可能丢失从库只有一个sql Thread，主库写压力大，复制很可能延时 解决方法：半同步复制—解决数据丢失的问题并行复制—-解决从库复制延迟的问题 mysql数据库底层的排序机制？ sort page是怎么工作的？ 1、数据库分页重复和分页实现 使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据 Oracle分页查询的三种方法2、数据库深度分页优化3、分库分表如何做到永不迁移数据和避免热点1、数据库分库分表原因、策略、带来的问题、解决2、数据库分布式事务解决：JTA的XA协议、二阶段提交（2PC、3PC）、柔性事务、最终一致性事务（消息）3、spring事务(Transaction)的七种事务传播行为及五种隔离级别 数据库（database）、表（table）、视图（view）、索引（index）、序列（sequence）、表连接方式：INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN、SELF JOIN、CARTESIAN JOIN（笛卡尔乘积）、UNION ALL、UNION 框架：mybatis、hibernate 数据库问题：索引分类，有什么用，好处、有什么优缺点，为什么可以加快查询，怎么检查一个SQL是否走索引， 索引使用条件、判断是否使用、不使用的情况 聚集索引、非聚集索引、覆盖索引（复合索引或者多字段索引查询），不加索引（全表扫描） B-tree 或者 B+tree 占用空间，增删改变慢 数据库：范式、索引、优化、锁、oracle、mysql、mybatis 数据库的锁：表级锁、页级锁、行级锁，悲观锁、乐观锁查找算法分类： mysql的主从是怎么实现的mysql当表达到一定数量，查询变慢，为什么？感觉是数据库优化的问题，建索引、分库分表、主从读写分离 mysql主从同步基于什么来做的？mysql为什么一张表到了一定量查询会变慢？ MySQL有三种锁的级别：页级、表级、行级。 Oracle OracleJDBC 链接oracle的三种URL写法：SID方式 、ServerName方式、RAC方式 SID是数据库实例的名字Service_name参数，该参数对应一个数据库，而不是一个实例一个数据库对应多个实例（SID）一个数据库可以对应多个Service_name oracle的sid与实例1.SID:对应着实例，一个数据库可以有多个实例（如RAC），SID是用来标识这个数据库内部每个实例的名字。2.SERVICE_NAME：是这个数据库对外宣称的名字，对应着数据库。 Oracle序列的创建 Oracle 物化视图 说明 https://blog.csdn.net/tianlesoftware/article/details/4713553 数据库操作框架 数据库中间件 轻量级数据库 其他数据库工具 数据库：数据源、druid、h2、sqlite、yugong、，mybatis、liquibase、jooq、sharding-sphere、thinkjd Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Database/MySQL/MySQL时区问题.html":{"url":"docs/tech/Database/MySQL/MySQL时区问题.html","title":"MySQL时区问题","keywords":"","body":" MySQL时区问题 MySQL数据库时间和jdbc查询时间相差12小时问题 MySQL自身时区设置 JDBC URL时区设置 JSON时区 排查示例 MySQL时区源码解读 6.X版本 8.X版本 MySQL时区问题 MySQL数据库时间和jdbc查询时间相差12小时问题 可以按照如下检查 检查主机时区（mysql server主机和Java客户端主机）：date MySQL自身时区设置：select now() jdbcURL设置：serverTimezone=Asia/Shanghai json时区：spring.jackson.time-zone=GMT+8 MySQL自身时区设置 使用select now()查询 再去确认一下MySQL时区，一开始的time_zone的值是SYSTEM，忘记截图了，改为GMT+8之后，使用show variables like '%time_zone%'查看一下修改结果，证明时区也没问题了。 JDBC URL时区设置 添加serverTimezone配置， 之前可能是世界时或者其他时区 serverTimezone=UTC 时差应该改为 中国时 serverTimezone=Asia/Shanghai 或者 serverTimezone=GMT%2B8 url: jdbc:mysql://ip:3306/db?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false spring.datasource.url=jdbc:mysql://127.0.0.1:3306/reservoir?characterEncoding=utf8&useSSL=true&zeroDateTimeBehavior=convertToNull&useTimezone=true&serverTimezone=Asia/Shanghai JSON时区 因为页面上提交的是payload数据，走的是json格式，而springboot默认使用的是jackson，遂增加jackson时区配置。 #json timezone spring.jackson.time-zone=GMT+8 MySQL数据库时间和jdbc查询时间相差12小时 Java 与 MySQL 的 13 个小时时差 排查示例 mysql时间和本地时间相差13个小时 修改linux的时间 执行tzselect 命令 date命令查看时区什么都是对的但是mysql的时间就是不对 折腾了一个多小时 set global time_zone = '+08:00'; set time_zone = '+08:00'; 这些命令都测试了还是不行 后台打印本地new Date()没有问题是北京时间，肯定问题出在mysql时区设置上。后台进到mysql命令行模式，查看数据库时区：show variables like '%time_zone%'; 发现果然是时区问题，设置成了美国那里的时区，OK问题发现。 后来直接修改的/etc/my.cnf的 直接添加重启mysql就可以了 default-time-zone='+08:00' MySQL时区源码解读 6.X版本 在mysql:mysql-connector-java:6.0.6.jar中 ConnectionImpl.java中的构造方法 public ConnectionImpl(HostInfo hostInfo) throws SQLException 会调用createNewIO--->connectOneTryOnly--->initializePropsFromServer--->loadServerVariables 在loadServerVariables中会执行SQL从服务端查询属性设置在本地 使用的SQL如下 /* mysql-connector-java-6.0.6 ( Revision: 3dab84f4d9bede3cdd14d57b99e9e98a02a5b97d ) */SELECT @@session.auto_increment_increment AS auto_increment_increment, @@character_set_client AS character_set_client, @@character_set_connection AS character_set_connection, @@character_set_results AS character_set_results, @@character_set_server AS character_set_server, @@init_connect AS init_connect, @@interactive_timeout AS interactive_timeout, @@license AS license, @@lower_case_table_names AS lower_case_table_names, @@max_allowed_packet AS max_allowed_packet, @@net_buffer_length AS net_buffer_length, @@net_write_timeout AS net_write_timeout, @@query_cache_size AS query_cache_size, @@query_cache_type AS query_cache_type, @@sql_mode AS sql_mode, @@system_time_zone AS system_time_zone, @@time_zone AS time_zone, @@tx_isolation AS tx_isolation, @@wait_timeout AS wait_timeout ConnectionImpl类中props和父类中的propertySet保存了连接的所有属性 如果我们没有设置serverTimezone，可以看到propertySet中serverTimezone的值为空 如果我们设置了serverTimezone，可以看到propertySet中就是我们设置的值 在ConnectionImpl.java中的构造方法打断点，可以看到是从druid中的filter构建的（我们项目使用的是druid） ConnectionImpl.java中的构造方法：初始化MysqlaSession，MysqlaSession中再初始化MysqlaProtocol 8.X版本 在mysql-connector-java 8.x版本中 ConnectionImpl的构造方法，初始化的是NativeSession，NativeSession中初始化的是NativeProtocol 在ConnectionImpl的构造方法， 会调用createNewIO--->connectOneTryOnly--->initializePropsFromServer--->initServerSession--->configureTimeZone 在configureTimeZone中使用TimeZone.getDefault()来设置this.serverSession.setSessionTimeZone(selectedTz); 如何使用Java中的mysql时区 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/BigData/Data处理.html":{"url":"docs/tech/BigData/Data处理.html","title":"大数据处理","keywords":"","body":"Data处理 大数据处理 1、Flink框架 2、JStorm和Storm框架 3、Elasticsearch框架 4、Spark框架 5、Spider爬虫 [quickstart-data] 大数据、流式计算 Flink框架 JStorm和Storm框架 Elasticsearch框架 Spark框架 Spider爬虫 数据处理：druid-io、flume、hadoop、hbase、、lucene、solr、、 1、大数据统计重复数和大数据Top 100 问题 大数据统计重复数1、直接使用map保存记录2、先分成若干份，再全部合并 大数据Top 100 问题：1、直接使用快速排序（占用内存大）2、先取出100个数据，然后进行排序，后面的依次跟100个数据的最小值比较，大了就替换3、先分成若干份，分别取出前100，再依次合并（或全部合并） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/SOFA/SOFA.html":{"url":"docs/tech/SOFA/SOFA.html","title":"SOFA","keywords":"","body":"SOFA 1、 2、 3、 4、 5、 SOFARPC介绍 SOFARPC 和其它的开源的 RPC 框架一样，做了很多分层很多的模型抽象，例如图中的 Filter/Router/Cluster/Loadbalance/Serilization/Protocol/Transport 等这些模型。它的特点如下： 透明化、高性能丰富的扩展机制、事件机制支持自定义Filter和自定义Router支持多种负载均衡策略，随机/权重/轮询/一致性hash 等支持多种注册中心，zookeeper/consul/etcd/nacos 等支持多协议， Bolt/Rest/HTTP/H2/gRPC/dubbo 等支持多种调用方式，同步、单向、回调、泛化等支持集群容错、服务预热、自动故障隔离 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/WebApp/ApplicationContainer.html":{"url":"docs/tech/WebApp/ApplicationContainer.html","title":"Web应用容器","keywords":"","body":"ApplicationContainer 应用Web容器 1、 应用Web容器quickstart-jettyquickstart-tomcatquickstart-undertowquickstart-jerseyquickstart-jbossquickstart-weblogicquickstart-webspherequickstart-quickserver 2、集群/分布式环境下Session共享解决 3、 4、 5、 6、 7、 8、 9、 10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、 集群/分布式环境下Session共享解决： 集群/分布式环境下3种session处理策略第一种：粘性session第二种：服务器session复制第三种：session共享机制:使用分布式缓存方案比如memcached、Redis，但是要求Memcached或Redis必须是集群。数据库 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Linux/Linux.html":{"url":"docs/tech/Linux/Linux.html","title":"Linux","keywords":"","body":"Linux 1、Linux学习 2、 3、 4、 5、 Linux环境变量修改 Linux用户空间与内核空间、地址空间 TCP参数 操作系统-内存管理机制 quickstart-linux Linux命令、Shell脚本等 Linux学习 Linux用户空间与内核空间、地址空间.md1、内核空间和用户空间2、Linux进程地址空间逻辑地址空间和物理地址空间进程地址空间和内核地址空间进程内存布局解释3、内存地址的计算方法 linux文件IO、网络IO、5种IO类型 1、查看Linux系统版本2、linux安装软件的方式3、linux下select/poll/epoll机制的比较4、C10K问题5、惊群现象 Linux系统函数read()/write()/pread()/pwrite()的区别 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Linux/查看Linux基本属性信息.html":{"url":"docs/tech/Linux/查看Linux基本属性信息.html","title":"查看Linux基本属性信息","keywords":"","body":" 查看Linux基本属性信息 系统 资源 磁盘和分区 网络 进程 用户 服务 程序 查看机器所有硬件信息 Linux版本信息 查看centos版本号 查看系统信息 查看Linux是64位还是32位 查看CPU信息 查看Mem内存信息 查看磁盘信息 查看网卡信息 查看ip,hostname,cpu,memory,disk 查看Linux基本属性信息 系统 # uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # cat /proc/version # 查看操作系统详情信息 # hostname # 查看计算机名 # lspci -tv # 列出所有PCI设备 # lsusb -tv # 列出所有USB设备 # lsmod # 列出加载的内核模块 # env # 查看环境变量 资源 # free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载 磁盘和分区 # mount | column -t # 查看挂接的分区状态 # fdisk -l # 查看所有分区 # swapon -s # 查看所有交换分区 # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) # dmesg | grep IDE # 查看启动时IDE设备检测状况 网络 # ifconfig # 查看所有网络接口的属性 # iptables -L # 查看防火墙设置 # route -n # 查看路由表 # netstat -lntp # 查看所有监听端口 # netstat -antp # 查看所有已经建立的连接 # netstat -s # 查看网络统计信息 进程 # ps -ef # 查看所有进程 # top # 实时显示进程状态 用户 # w # 查看活动用户 # id # 查看指定用户信息 # last # 查看用户登录日志 # cut -d: -f1 /etc/passwd # 查看系统所有用户 # cut -d: -f1 /etc/group # 查看系统所有组 # crontab -l # 查看当前用户的计划任务 服务 # chkconfig --list # 列出所有系统服务 # chkconfig --list | grep on # 列出所有启动的系统服务 程序 # rpm -qa # 查看所有安装的软件包 查看机器所有硬件信息 这2个命令出来的信息都非常多,所以建议后面使用\"|more\"便于查看 dmidecode |more dmesg |more 5、显示主板序列号 # dmidecode | grep 'Serial Number' # cat /etc/issue | grep Linux Red Hat Enterprise Linux AS release 4 (Nahant Update 5) (查看当前操作系统发行版信息) 查看机器型号 # dmidecode | grep \"Product Name\" Linux版本信息 查看centos版本号 两种方式： cat /etc/redhat-release cat /etc/issue head -n 1 /etc/issue # 查看操作系统版本，是数字1不是字母L 查看系统信息 # uname -a Linux euis1 2.6.9-55.ELsmp #1 SMP Fri Apr 20 17:03:35 EDT 2007 i686 i686 i386 GNU/Linux (查看当前操作系统内核信息) uname -a # 查看内核/操作系统/CPU信息的linux系统信息命令 uname --help -a, --all print all information, in the following order, except omit -p and -i if unknown: -s, --kernel-name print the kernel name -n, --nodename print the network node hostname -r, --kernel-release print the kernel release -v, --kernel-version print the kernel version -m, --machine print the machine hardware name -p, --processor print the processor type or \"unknown\" -i, --hardware-platform print the hardware platform or \"unknown\" -o, --operating-system print the operating system --help display this help and exit --version output version information and exit 查看Linux是64位还是32位 五种方式： getconf LONG_BIT uname -m arch file /sbin/init #结果大于1就是64位，否则32位 cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 查看CPU的位数: getconf LONG_BIT # getconf LONG_BIT 32 (说明当前 CPU 运行在 32bit 模式下，但不代表 CPU 不支持 64bit) # cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 8 (结果大于 0, 说明支持 64bit 计算. lm 指 long mode, 支持 lm 则是 64bit) 查看CPU信息 lscpu cat /proc/cpuinfo 查看cpu cat /proc/meminfo 查看内存 # cpu核心数计算 # 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 # 查看物理CPU个数 cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l # 查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep \"cpu cores\"| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep \"processor\"| wc -l 2. cpu型号查看：model name # 查看CPU信息（型号） cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c #uniq:去除重复行 -c参数：在输出行前面加上每行在输入文件中出现的次数 查看 CPU 信息（型号） # cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 8 Intel(R) Xeon(R) CPU E5410 @ 2.33GHz (看到有 8 个逻辑 CPU, 也知道了 CPU 型号) # cat /proc/cpuinfo | grep physical | uniq -c 4 physical id : 0 4 physical id : 1 (说明实际上是两颗 4 核的 CPU) 再完整看 cpu 详细信息，不过大部分我们都不关心而已. # dmidecode | grep 'Processor Information' 方法一: Linux下CPU相关的参数保存在 /proc/cpuinfo 文件里 cat /proc/cpuinfo |more 方法二: 采用命令 dmesg | grep CPU 可以查看到相关CPU的启动信息 查看CPU的位数: getconf LONG_BIT # getconf LONG_BIT 32 (说明当前 CPU 运行在 32bit 模式下，但不代表 CPU 不支持 64bit) # cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 8 (结果大于 0, 说明支持 64bit 计算. lm 指 long mode, 支持 lm 则是 64bit) 查看Mem内存信息 free -h free -m top cat /proc/cpuinfo 查看cpu cat /proc/meminfo 查看内存 cat /proc/meminfo |more （注意输出信息的最后一行:MachineMem: 41932272 kB） 内存大小 cat /proc/meminfo |grep MemTotal 查看磁盘信息 df -h du -sh # 查看指定目录的大小 测试没权限 fdisk -l 可以看到系统上的磁盘(包括U盘)的分区以及大小相关信息。 直接查看 cat /proc/partitions 3、查看硬盘型号 # more /proc/scsi/scsi |grep -i model # cat /proc/scsi/scsi |grep -i model 硬盘大小 fdisk -l |grep Disk 查看网卡信息 查看网卡信息 # dmesg | grep -i eth 4. 显示有几块物理网卡 # lspci | grep Eth | wc -l 查看ip,hostname,cpu,memory,disk ip a ip=`ifconfig|egrep -o \"\\\"|head -1` echo ip=$ip hostname=`hostname` echo \"主机名=$hostname\" cores=`cat /proc/cpuinfo| grep \"processor\"| wc -l` echo \"逻辑cpu个数=$cores\" memory=`free -h|awk 'NR==2{print $2}'` echo \"内存大小=$memory\" disk=`lsblk -db|awk 'NR>1{sum+=$4} END {print sum/1024/1024/1024}'` echo \"磁盘总大小=${disk}G\" 参考 linux查看硬件配置命令的方法示例 如何查看Linux 硬件配置信息 查看linux系统常用的命令，Linux查看系统配置常用命令 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Linux/查看Linux下CPU占用情况.html":{"url":"docs/tech/Linux/查看Linux下CPU占用情况.html","title":"查看Linux下CPU占用情况","keywords":"","body":"查看Linux下CPU占用情况 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Linux/查看LINUX进程内存占用情况.html":{"url":"docs/tech/Linux/查看LINUX进程内存占用情况.html","title":"查看LINUX进程内存占用情况","keywords":"","body":"查看LINUX进程内存占用情况 查看下大致情况 可以看到总的62G，已经占用了57G $ free -g total used free shared buffers cached Mem: 62 61 1 0 0 4 -/+ buffers/cache: 57 5 Swap: 7 0 7 然后再看下，好像没什么有作用的信息，最大的是一个java进程，但是占用不大，而且不知道是什么进程 可以使用 ps -ef | grep java 查看java进程 $ top top - 14:22:44 up 2224 days, 20:38, 1 user, load average: 4.94, 2.92, 2.53 Tasks: 260 total, 1 running, 259 sleeping, 0 stopped, 0 zombie Cpu0 : 12.5%us, 0.0%sy, 0.0%ni, 87.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu1 : 25.0%us, 0.0%sy, 0.0%ni, 75.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu2 : 12.5%us, 0.0%sy, 0.0%ni, 87.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu3 : 6.2%us, 0.0%sy, 0.0%ni, 93.8%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu4 : 0.0%us, 6.2%sy, 0.0%ni, 93.8%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu5 : 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu6 : 12.5%us, 0.0%sy, 0.0%ni, 87.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu7 : 6.7%us, 6.7%sy, 0.0%ni, 86.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu8 : 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu9 : 6.7%us, 0.0%sy, 0.0%ni, 93.3%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu10 : 11.8%us, 5.9%sy, 0.0%ni, 76.5%id, 0.0%wa, 0.0%hi, 5.9%si, 0.0%st Cpu11 : 12.5%us, 0.0%sy, 0.0%ni, 87.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 65851056k total, 64071568k used, 1779488k free, 18484k buffers Swap: 8388604k total, 0k used, 8388604k free, 4131116k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 8675 appweb 20 0 43.6g 16g 21m S 137.5 25.9 16674,01 java 20293 appweb 20 0 15168 1364 928 R 6.3 0.0 0:00.35 top 1 root 20 0 19232 980 688 S 0.0 0.0 0:09.52 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.01 kthreadd 3 root RT 0 0 0 0 S 0.0 0.0 117:04.43 migration/0 4 root 20 0 0 0 0 S 0.0 0.0 254:01.12 ksoftirqd/0 5 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/0 6 root RT 0 0 0 0 S 0.0 0.0 2:48.04 watchdog/0 7 root RT 0 0 0 0 S 0.0 0.0 136:09.68 migration/1 8 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/1 9 root 20 0 0 0 0 S 0.0 0.0 154:14.58 ksoftirqd/1 10 root RT 0 0 0 0 S 0.0 0.0 2:28.93 watchdog/1 11 root RT 0 0 0 0 S 0.0 0.0 139:15.16 migration/2 12 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/2 13 root 20 0 0 0 0 S 0.0 0.0 128:35.83 ksoftirqd/2 14 root RT 0 0 0 0 S 0.0 0.0 2:44.47 watchdog/2 15 root RT 0 0 0 0 S 0.0 0.0 145:29.92 migration/3 16 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/3 17 root 20 0 0 0 0 S 0.0 0.0 108:00.74 ksoftirqd/3 18 root RT 0 0 0 0 S 0.0 0.0 2:54.11 watchdog/3 19 root RT 0 0 0 0 S 0.0 0.0 155:30.92 migration/4 20 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/4 然后再网上搜到了下面这个命令，rsz就是占用的内存 可以看到占用最大的一个进程是kafka_exporter这个进程占用了大概41G $ ps -e -o 'pid,comm,args,pcpu,rsz,vsz,stime,user,uid' | sort -nrk5 28887 kafka_exporter /data/program/kafka/kafka_e 1.9 41362200 42096296 2021 appweb 500 8675 java /data/program/java/bin/java 219 17027528 45709020 2021 appweb 500 17447 java /data/program/java/bin/java 0.0 505416 8212604 2021 appweb 500 31061 filebeat /usr/share/filebeat/bin/fil 0.9 30420 43872 2019 root 0 23595 wsm-agent /data/program/wsm-agent/bin 0.2 25012 115628 2020 root 0 21653 SecAgent /opt/SecAgent/SecAgent 0.2 16280 988760 2019 root 0 然后查看kafka相关的进程 可以看到就是这个pid为28887的进程kafka_exporter 于是 $ kill 28887 再次查看$ ps -ef| grep kafka 发现进程不存在了 $ ps -ef | grep kafka appweb 21516 19509 0 14:24 pts/0 00:00:00 grep kafka appweb 28887 1 1 2021 ? 6-03:26:55 /data/program/kafka/kafka_exporter-1.3.1.linux-amd64/kafka_exporter --kafka.server=10.1.120.6:9094 再次查看进程占用情况 发现free已经是45G了，比最开始多了40G $ free -g total used free shared buffers cached Mem: 62 21 41 0 0 4 -/+ buffers/cache: 17 45 Swap: 7 0 7 再次查看，发现占用进程也不在了 $ ps -e -o 'pid,comm,args,pcpu,rsz,vsz,stime,user,uid' | sort -nrk5 8675 java /data/program/java/bin/java 219 17029296 45746180 2021 appweb 500 17447 java /data/program/java/bin/java 0.0 505412 8212604 2021 appweb 500 31061 filebeat /usr/share/filebeat/bin/fil 0.9 30460 43872 2019 root 0 23595 wsm-agent /data/program/wsm-agent/bin 0.2 25016 115628 2020 root 0 21653 SecAgent /opt/SecAgent/SecAgent 0.2 16280 988760 2019 root 0 19509 bash -bash 0.0 1908 108472 14:18 appweb 500 2395 crond crond 0.0 1272 116892 2016 root 0 8445 sshd /usr/sbin/sshd 0.0 1124 66224 2016 root 0 1 init /sbin/init 0.0 1040 19232 2016 root 0 31060 filebeat-god /usr/share/filebeat/bin/fil 0.0 72 11388 2019 root 0 15463 sh sh socket.sh 0.1 1636 106492 2018 appweb 500 PID COMMAND COMMAND %CPU RSZ VSZ STIME USER UID 9 ksoftirqd/1 [ksoftirqd/1] 0.0 0 0 2016 root 0 99 cgroup [cgroup] 0.0 0 0 2016 root 0 993 ext4-dio-unwrit [ext4-dio-unwrit] 0.0 0 0 2016 root 0 centos6 free 和 centos 7的free 的差异与对比解决Linux系统buff/cache过大的问题 Linux命令free -h解释 【linux】free命令中cached和buffers的区别 Linux- 技术专题 -buffer/cache 理解Linux 内存 Buffer 和 CacheLinux中Buffer和Cache的区别Linux内存buffer和cache的区别Buffer和Cache的区别(转) Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Linux/查看Linux下端口占用情况.html":{"url":"docs/tech/Linux/查看Linux下端口占用情况.html","title":"查看Linux下端口占用情况","keywords":"","body":" 查看Linux下端口占用情况 使用netstat命令 使用lsof命令 使用示例 查看Linux下端口占用情况 使用netstat命令 在Linux使用过程中，需要了解当前系统开放了哪些端口，并且要查看开放这些端口的具体进程和用户，可以通过netstat命令进行简单查询 netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。 Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等 netstat命令各个参数说明如下： -t : 指明显示TCP端口 -u : 指明显示UDP端口 -n : 不进行DNS轮询，显示IP(可以加速操作) -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。 -t （tcp）仅显示tcp相关选项 -u (udp) 仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen的服务状态 -p 显示建立相关链接的程序名 即可显示当前服务器上所有端口及进程服务，与grep结合可查看某个具体端口及服务情况·· netstat查看端口号占用方式： netstat -tnlp //查看当前所有tcp端口· netstat -tunlp | grep 80 //查看所有80端口使用情况· netstat -tunlp | grep 3306 //查看所有3306端口使用情况· netstat -tunlp|grep 端口号 netstat -anp|grep 端口号 直接使用 netstat -anp | grep portno 即：netstat -anp|grep 8080 查看所有的进程和端口使用情况。发现下面的进程列表，其中最后一栏是PID/Program name 发现8080端口被PID为9658的Java进程占用 进一步使用命令：ps -aux | grep java，或者直接：ps -aux | grep pid 查看 就可以明确知道8080端口是被哪个程序占用了！然后判断是否使用KILL命令干掉！ netstat -anp|grep 8080 --> tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 28500/java ps -aux | grep 28500 --> r/local/tomcat9-jforum/tomcat 使用lsof命令 lsof(list open files)是一个列出当前系统打开文件的工具。 lsof 查看端口占用方式： lsof -i:端口号 lsof -i 需要 root 用户的权限来执行 安装 yum install lsof ➜ ~ lsof -i:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME WeChat 2649 lengfeng 280u IPv4 0x21112d50800cb2b7 0t0 TCP 192.168.2.103:55418->101.91.37.18:http (ESTABLISHED) WeChat 2649 lengfeng 281u IPv4 0x21112d507f7b580f 0t0 TCP 172.16.144.244:56384->101.91.37.47:http (CLOSE_WAIT) WeChat 2649 lengfeng 284u IPv4 0x21112d507f7962b7 0t0 TCP 172.16.144.244:56385->101.91.37.47:http (CLOSED) 具体参数信息如下： COMMAND:进程的名称 PID:进程标识符 USER:进程所有者 FD:文件描述符，应用程序通过文件描述符识别该文件。如cwd等 TYPE:文件类型 DEVICE:指定磁盘的名称 SIZE:文件的大小 NODE:索引节点（文件在磁盘上的标识） NAME:打开文件的确切名称 更多 lsof 的命令如下： lsof -i:8080 查看8080端口占用，显示所有打开8080端口的进程 lsof abc.txt 显示开启文件abc.txt的进程 lsof -c abc 显示abc进程现在打开的文件 lsof -c -p 1234 列出进程号为1234的进程所打开的文件 lsof -g gid 显示归属gid的进程情况 lsof +d /usr/local/ 显示目录下被进程开启的文件 lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长 lsof -d 4 显示使用fd为4的进程 lsof -i 用以显示符合条件的进程情况 lsof -i //显示所有打开的端口 lsof -i -U //显示所有打开的端口和UNIX domain文件 lsof -i[46] [protocol][@hostname|hostaddr][:service|port] 参数解释 46 --> IPv4 or IPv6 protocol --> TCP or UDP hostname --> Internet host name hostaddr --> IPv4地址 service --> /etc/service中的 service name (可以不止一个) port --> 端口号 (可以不止一个) 使用示例 第一步：使用lsof -i:3306 或者 netstat -tunlp | grep 3306 查询端口占用的进程，找到pid 第二步：使用ps -aux | grep 16422 查看进程的详细信息 第三步：kill [root@VM_39_230_centos bin]# lsof -i:3306 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 16422 mysql 19u IPv6 148794 0t0 TCP *:mysql (LISTEN) mysqld 16422 mysql 39u IPv6 643698 0t0 TCP localhost:mysql->localhost:36582 (ESTABLISHED) mysqld 16422 mysql 45u IPv6 643699 0t0 TCP localhost:mysql->localhost:36584 (ESTABLISHED) mysqld 16422 mysql 46u IPv6 643700 0t0 TCP localhost:mysql->localhost:36586 (ESTABLISHED) mysqld 16422 mysql 47u IPv6 643702 0t0 TCP localhost:mysql->localhost:36588 (ESTABLISHED) mysqld 16422 mysql 48u IPv6 643704 0t0 TCP localhost:mysql->localhost:36590 (ESTABLISHED) java 17302 root 122u IPv4 643695 0t0 TCP localhost:36582->localhost:mysql (ESTABLISHED) java 17302 root 123u IPv4 643701 0t0 TCP localhost:36588->localhost:mysql (ESTABLISHED) java 17302 root 124u IPv4 643696 0t0 TCP localhost:36586->localhost:mysql (ESTABLISHED) java 17302 root 125u IPv4 643697 0t0 TCP localhost:36584->localhost:mysql (ESTABLISHED) java 17302 root 126u IPv4 643703 0t0 TCP localhost:36590->localhost:mysql (ESTABLISHED) 或者 [root@VM_39_230_centos bin]# netstat -tunlp | grep 3306 tcp6 0 0 :::3306 :::* LISTEN 16422/mysqld 找到pid 然后 [root@VM_39_230_centos bin]# ps -aux | grep 16422 mysql 16422 0.0 47.7 1340428 485944 ? Sl Jun29 1:46 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/lib/mysql/VM_39_230_centos.err --pid-file=/var/lib/mysql/VM_39_230_centos.pid root 25713 0.0 0.0 112616 700 pts/0 R+ 17:04 0:00 grep --color=auto 16422 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Spring/Spring.html":{"url":"docs/tech/Spring/Spring.html","title":"Spring","keywords":"","body":"Spring 1、 2、 3、 4、 5、 SpringBoot [quickstart-spring-boot][quickstart-spring-boot2] SpringCloud [quickstart-spring-cloud][quickstart-spring-cloud2] SpringMVC [quickstart-spring-framework] SpringData [quickstart-spring-data] SpringBoot学习 /Users/yangzl/git/quickstart-spring-boot/docs /Users/yangzl/git/quickstart-spring-boot2/docs SpringCloud学习 /Users/yangzl/git/quickstart-spring-cloud/docs /Users/yangzl/git/quickstart-spring-cloud2/docs spring和springmvc熟悉吗 spring ioc 的实现原理？怎么把对象初始化的，平时是new的，这个是怎么创建的？aop的实现原理？ Spring：1、spring中的transactional注解，requestMapping注解的实现原理 2、springMvc原理 如何集成web 1、spring依赖注入怎么注入2、Spring注解 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Spring相关：springframework、springMvc、SpringBoot、SpringCloudquickstart-spring-data Spring IOC/DI和AOP原理IOC: Inversion of Control(控制反转)是一种设计思想，就是容器控制应用程序所需要外部资源的创建和管理，然后将其反转给应用程序。DI: Dependency Injection，即“依赖注入”。应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入。其实IOC和DI本就是同一个概念的两种不同的表述 优点　　第一，资源集中管理，实现资源的可配置和易管理，降低对象关系维护的复杂度。　　第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。 AOP利用一种称为“横切”的技术，剖解开封装的对象内部，将那些影响多个类的公共行为封装到一个可重用模块，并将其名为方面(Aspect)。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 实现方式　　　　实现AOP的技术，主要分为两大类：　　一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；JDK动态代理，cglib　　二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。AspectJ、Javassist， 优点　　①.横切关注点的代码都集中于一块，不再是分散在各个业务组件中，不会出现大量重复代码；　　②.核心模块只关注核心功能的代码，与通用模块分离，模块间藕合度降低。 以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Test/Test测试.html":{"url":"docs/tech/Test/Test测试.html","title":"测试","keywords":"","body":"Test测试 测试相关 1、 2、 3、 4、 5、 test：jmeter、loadrunner、seleniumjunit、testng、jmh、mock Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/IoT/物联网IoT.html":{"url":"docs/tech/IoT/物联网IoT.html","title":"物联网IoT","keywords":"","body":"物联网（英语：Internet of Things，简称IoT）是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互 PLC4X官网PLC4X Github PLC4X is a set of libraries for communicating with industrial programmable logic controllers (PLCs) using a variety of protocols but with a shared API.PLC4X 是一组库，用于使用多种协议与工业可编程逻辑控制器 (PLC) 进行通信，但具有共享 API。 PLC4X：新型的工业通信协议通用适配器 物联网数据库IoTDB IoTDB官网IoTDB Github Apache IoTDB（物联网数据库）是一体化收集、存储、管理与分析物联网时序数据的软件系统。 Apache IoTDB 采用轻量式架构，具有高性能和丰富的功能，并与Apache Hadoop、Spark和Flink等进行了深度集成，可以满足工业物联网领域的海量数据存储、高速数据读取和复杂数据分析需求。 物联网数据库 IoTDB 解析 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/操作系统.html":{"url":"docs/tech/OperatingSystem/Linux/操作系统.html","title":"操作系统","keywords":"","body":"操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。 类Unix系统 所谓的类Unix家族指的是一族种类繁多的OS，此族包含了System V、BSD与Linux。由于Unix是The Open Group的注册商标，特指遵守此公司定义的行为的操作系统。而类Unix通常指的是比原先的Unix包含更多特征的OS。 最早的unix是开放的,很多组织对unix都有修改,期中比较有名的就是伯克利大学的修改版本,叫做bsd,是unix的分支,由于bsd的协议允许你直接使用\\修改他的代码,并且可以作为商业用途,所以很多公司的unix都是从bsd衍生过来的,比如hp-unix,ibm的aix等等. linux呢,是一个完全没有参照unix代码的一个仿照unix架构,试图与unix相兼容的开源系统.换句话说,bsd是unix的分支,而linux是类unix系统或者说是仿unix系统. 严格的说，Linux 是只是一个内核。制作 Linux 发行版所要做的工作就是，汇集那些创建一个完整 Linux 操作系统所需的所有软件，将它组合成一个像 Ubuntu、Mint、Debian、RedHat 或者是 Arch 这样的 Linux 发行版。有许多不同的 Linux 发行版。 与此相反的是，BSD 这个名字则代表其内核和操作系统。例如，FreeBSD 提供了 FreeBSD 内核和 FreeBSD 操作系统。它是作为一个单一的项目维护的。换句话说，如果你想要安装 FreeBSD，就只有一个 FreeBSD 可供你安装。如果你想要安装 Linux，你首先需要在许多 Linux 发行版之间选择。 GNU是一个技术组织，Linux仅仅是一个内核，不包含外围的应用程序），所以现在我们使用的Linux系统，应该完整地称之为GNU/Linux才对。 GNU 自己的内核 Hurd 仍在开发中，离实用还有一定的距离。因此，GNU 通常使用 Linux 内核。这样的组合即为GNU/Linux 操作系统，已经有上百万人在使用 GNU/Linux，但他们中的很多人把它误称为“Linux”。 GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU's Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。 作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux（见GNU/Linux命名争议）。 操作系统OSGNU 5万字、97 张图总结操作系统核心知识点 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/CPU工作原理.html":{"url":"docs/tech/OperatingSystem/Linux/CPU工作原理.html","title":"CPU工作原理","keywords":"","body":"CPU工作原理 CPU 的工作原理是什么？ CPU架构/指令集：RISC / CISC | arm | amd | X86/i386 | aarch64 分不清ARM和X86架构，别跟我说你懂CPU！到底什么是Cortex、ARMv8、arm架构、ARM指令集、soc？一文帮你梳理基础概念ARM架构 wiki Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/Linux环境变量修改.html":{"url":"docs/tech/OperatingSystem/Linux/Linux环境变量修改.html","title":"Linux环境变量修改","keywords":"","body":"操作系统级别 vim /etc/profile 添加 source /etc/profile 用户级别：ll -a 查看全部文件和目录 修改其个人用户主目录下的.bashrc文件 source /home/test/.bashrc shell级别： 直接执行export命令 临时性的： 打开Linux终端命令窗口，输入如下命令： export PATH=$PATH:/usr/local/MATLAB/R2013b/bin 为了验证是否修改成功可以再继续输入命令eport进行查看。在下图中可以看到成功添加了matlab的环境变量。 上面修改后如果退出终端并重新打开再次查看环境变量时就会发现上面添加的环境变量又消失了。即这样只做到了临时性修改环境变量。 如果想要环境变量永久生效可以修改下面两个文件中的任何一个： 1 /etc/profile 2 .bash_profile或者.bashrc文件 其中，/etc/profile是全局的环境变量，对所有用户生效，而.bash_profile只对当前用户起作用。 上面操作完成后需要注销Linux才能使刚才的环境变量设置生效。 注意： 2、linux下用冒号”:”来分隔路径 $PATH / $CLASSPATH / $JAVA_HOME 等是用来引用原来的环境变量的值在设置环境变量时特别要注意不能把原来的值给覆盖掉了。 CLASSPATH中当前目录”.”不能丢掉。 export是把这三个变量导出为全局变量。 大小写必须严格区分。 Linux启动时~/.bash_profile等文件的执行过程： 在登录Linux时要执行文件的过程如下： 在刚登录Linux时，首先启动 /etc/profile 文件， 然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个， 执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。 如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。因为在 ~/.bash_profile文件中一般会有下面的代码调用~/.bashrc文件，~/.bashrc会调用 /etc/bashrc文件 在退出shell时，还会执行 ~/.bash_logout文件。 执行顺序为：/etc/profile -> (~/.bash_profile | ~/.bash_login | ~/.profile) -> ~/.bashrc -> /etc/bashrc -> ~/.bash_logout https://blog.csdn.net/tom555cat/article/details/45582851 在登录Linux时要执行文件的过程如下： 在刚登录Linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个，执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。因为在 ~/.bash_profile文件中一般会有下面的代码： if [ -f ~/.bashrc ] ; then . ./bashrc fi ~/.bashrc中，一般还会有以下代码： if [ -f /etc/bashrc ] ; then . /bashrc fi 所以，~/.bashrc会调用 /etc/bashrc文件。最后，在退出shell时，还会执行 ~/.bash_logout文件。 执行顺序为：/etc/profile -> (~/.bash_profile | ~/.bash_login | ~/.profile) -> ~/.bashrc -> /etc/bashrc -> ~/.bash_logout 关于各个文件的作用域，在网上找到了以下说明： （1）/etc/profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。 （2）/etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。 （3）~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。 （4）~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。 （5）~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc /profile中的变量,他们是\"父子\"关系。 （6）~/.bash_profile 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。 总的来说profile是在登录后执行一次 bashrc每次打开新的shell时,该文件被读取 ============ /etc/profile 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. =========== /etc/bashrc 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. =============== ~/.bash_profile 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ========= ~/.bashrc 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取. ========== ~/.profile 在Debian中使用.profile文件代 替.bash_profile文件 .profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。在Debian中使用.profile文件代 替.bash_profile文件。 ============== ~/.bash_logout ==============当每次退出系统(退出bash shell)时,执行该文件. 作者：JeanCheng 来源：CSDN 原文：https://blog.csdn.net/gatieme/article/details/45064705 版权声明：本文为博主原创文章，转载请附上博文链接！ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/Linux用户空间与内核空间、地址空间.html":{"url":"docs/tech/OperatingSystem/Linux/Linux用户空间与内核空间、地址空间.html","title":"Linux用户空间与内核空间、地址空间","keywords":"","body":"1、内核空间和用户空间 2、Linux进程地址空间 逻辑地址空间和物理地址空间 进程地址空间和内核地址空间 进程内存布局解释 3、内存地址的计算方法 我们从内核空间和用户空间的角度看一看整个 Linux 系统的结构。它大体可以分为三个部分，从下往上依次为：硬件 -> 内核空间 -> 用户空间。 在硬件之上，内核空间中的代码控制了硬件资源的使用权，用户空间中的代码只有通过内核暴露的系统调用接口(System Call Interface)才能使用到系统中的硬件资源。其实，不光是 Linux，Windows 操作系统的设计也是大同小异。 实际上我们可以将每个处理器在任何指定时间点上的活动概括为下列三者之一： 1、运行于用户空间，执行用户进程。 2、运行于内核空间，处于进程上下文，代表某个特定的进程执行。 3、运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。 以上三点几乎包括所有的情况，比如当 CPU 空闲时，内核就运行一个空进程，处于进程上下文，但运行在内核空间。 说明：Linux 系统的中断服务程序不在进程的上下文中执行，它们在一个与所有进程都无关的、专门的中断上下文中执行。之所以存在一个专门的执行环境，就是为了保证中断服务程序能够在第一时间响应和处理中断请求，然后快速地退出。 参考 https://www.cnblogs.com/sparkdev/p/8410350.html Linux进程地址空间 https://blog.csdn.net/dongyanxia1000/article/details/51424613 逻辑地址空间和物理地址空间： 逻辑地址：目标模块的相对地址，不同进程可以有相同的逻辑地址，用户程序和程序员只需知道逻辑地址 物理地址：主存， 重定位寄存器含最小的物理地址值，地址转换重定位的作用，将逻辑地址转换成物理地址 界地址寄存器含逻辑地址值。每个逻辑地址值必须小于界地址寄存器，控制程序使用的地址空间的最大值的 1、程序经过编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址）。 2、当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。 3、用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。 4、不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。 5、物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据都要通过物理地址从主存中存取。当装入程序（Loader）将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。 内存保护 1）内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。 2）通过采用重定位寄存器和界地址寄存器来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址值。每个逻辑地址值必须小于界地址寄存器， 3）内存管理机构动态的将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。 4）当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每一个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户进程（程序）及数据不被该进程的运行所影响。 参考：共有三篇，最下面的前一篇 http://www.choudan.net/2013/10/24/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0(%E4%B8%80).html Linux进程地址空间 进程地址空间和内核地址空间 进程地址空间：用户态地址空间使用，当进程切换时，用户态地址空间的映射就会发生改变 内核地址空间：内核态地址空间使用，Linux的内核空间在所有进程中都映射到相同的物理内存上。内核代码和数据总是可寻址的（总是可以找到的），任意时刻都可处理中断和系统调用 在32位下就是一块容量为4GB的内存地址 Linux默认：0-0xC0000000 3G低地址空间为用户地址空间，0xC0000000-0xFFFFFFFF 1G高地址空间为内核地址空间 Windows默认：2G、2G 《系统虚拟化：原理与实现》，中间简单的介绍了进程的地址空间和从逻辑地址映射到线性地址，线性地址映射到物理地址的过程。突然发现大学期间学的内存分段分页的那些知识可以和进程地址空间完整的贯通起来，构成对虚拟内存的一个理解 进程地址空间 每个程序都能看到一片完整连续的地址空间，这些空间并没有直接关联到物理内存，而是操作系统提供了内存的一种抽象概念，使得每个进程都有一个连续完整的地址空间，在程序的运行过程，再完成虚拟地址到物理地址的转换。我们同样知道，进程的地址空间是分段的，存在所谓的数据段，代码段，bbs段，堆，栈等等。每个段都有特定的作用 对于32位的机器来说，虚拟的地址空间大小就是4G，可能实际的物理内存大小才1G到2G，意味着程序可以使用比物理内存更大的空间。 从0xc000000000到0xFFFFFFFF共1G的大小是内核地址空间（后面再探讨内核地址空间，先重点关注用户地址空间），余下的低地址3G空间则是用户地址空间。 用户地址空间： 1、Code VMA: 即程序的代码段，CPU执行的机器指令部分。通常，这一段是可以共享的，即多线程共享进程的代码段。并且，此段是只读的，不能修改。 2、Data VMA: 即程序的数据段，包含ELF文件在中的data段和bss段。 3、堆和栈: 这两个大家都十分熟悉了，new或者malloc分配的空间在堆上，需要程序猿维护，若没有主动释放堆上的空间，进程运行结束后会被释放。栈上的是函数栈临时的变量，还有程序的局部变量，自动释放。 4、共享库和mmap内容映射区：位于栈和堆之间，例如程序使用的printf，函数共享库printf.o固定在某个物理内存位置上，让许多进程映射共享。mmap是一个系统函数，可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址。此处参考后面的第三条。 5、命令行参数: 程序的命令行参数 6、环境变量：类似于Linux下的PATH，HOME等环境变量，子进程会继承父进程的环境变量。 https://www.cnblogs.com/fuzhe1989/p/3936894.html 进程内存布局解释：命令行、环境变量、栈、共享库和mmap段、堆、BSS、data、代码段 内核地址空间： 在一个多任务OS中，每个进程都运行在它自己的内存沙箱中。这个沙箱就是虚拟地址空间，在32位下就是一块容量为4GB的内存地址。内核将这些虚拟地址按页表（page table）映射为物理内存，并交由CPU访问。每个进程有自己的页表集，但有一点要注意。虚拟地址一旦被启用，就会应用到机器上所有运行的程序上，也包括内核自己。因此虚拟地址空间必须为内核预留一部分（否则就没办法和内核交互了） 给内核预留那么多空间，并不是说内核真的使用了那么多物理内存，只是内核可以这部分虚拟地址自由的映射到某片物理内存上（而不用和其它虚拟地址遵循相同的规则）。 内核空间在页表中被标记为专属的特权代码（ring 2或更低），用户态的程序访问它时就会产生页错误（page fault）。 Linux的内核空间在所有进程中都映射到相同的物理内存上。内核代码和数据总是可寻址的（总是可以找到的），任意时刻都可处理中断和系统调用。作为对比，当进程切换时，用户态地址空间的映射就会发生改变 进程地址空间的最上面是栈，栈里保存了局部变量，以及大多数编程语言中的函数参数。 一次方法或函数调用就会向栈增加一个栈帧（stack frame）。当函数返回时栈帧就会被销毁。 因为数据遵循严格的“后入先出”顺序，这种简单的设计意味着不需要复杂的数据结构就能追踪到栈的上下文——栈顶的一个指针就搞定。栈的Push和pop操作因此变得快速且确定。同时，栈区域的稳定重用也有助于栈内存在CPU缓存中保持活跃，加快了访问速度。进程中的每个线程都有自己的栈。 如果推入栈的数据过多，可能会耗尽栈映射的地址区域。这会导致一次页错误，Linux将其处理为一次expand_stack()调用，实际上是调用acct_stack_growth()检查当前是否可以增加栈大小。如果栈大小小于RLIMIT_STACK（通常8MB）就可以继续增长，程序会正常继续，不会察觉到什么。这是栈大小调整的默认处理。 但是，如果栈大小达到了上限，就会发生栈溢出，程序会接到一次段错误（Segmentation Fault）。相对的，当栈变小时，不会缩减栈大小。这就像联邦预算，只增不减（笑）。 在访问到未映射内存区（上图中的白色部分）时，只有动态栈增长可能是合法的。其它方式访问到未映射区域时都会引发一次页错误，进而导致段错误。一些映射区是只读的，对它们的写操作也会导致段错误。 https://blog.csdn.net/u014449366/article/details/65630338 内存地址的计算方法 内存是按字节编址的，所以单位是字节哈，1字节可是等于8位的。因为计算的范围一般比较小，所以就记住两个就够了。记住几个常用的 2的10次方为1024即1KB 2的20次方=（2的10次方）的平方，即1MB就行了 2的30次方=（2的10次方）的3次方=1GB， 我们常说的内存大小为4GB=41024M=410241024K=4102410241024B 这里的B是Byte的简写，而不是bit：1Byte=8bit 32位地址：2^32 = 2^2*G = 4G Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/TCP参数.html":{"url":"docs/tech/OperatingSystem/Linux/TCP参数.html","title":"TCP参数","keywords":"","body":"参考 https://blog.csdn.net/erlib/article/details/50236919 https://kiswo.com/article/1017 https://www.cnblogs.com/pangguoping/p/5830328.html https://www.jianshu.com/p/83ff61d074bf Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/多进程和多线程的区别.html":{"url":"docs/tech/OperatingSystem/Linux/多进程和多线程的区别.html","title":"多进程和多线程的区别","keywords":"","body":" 多进程和多线程的区别 什么时候用多进程什么时候用多线程 Java线程和操作系统线程的关系 多进程和多线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位 多进程之间不共享数据，程序上下文区分开。 多线程之间共享数据，在数据处理上要谨慎 多进程和多线程的主要区别是： 线程是进程的子集（部分），一个进程可能由多个线程组成。 多线程共享进程数据，共享简单；但同步复杂。 多进程的数据是分开的、共享复杂，需要用IPC；但同步简单。 程序： 只是一组指令的有序集合，是计算机硬盘上的一些文件，是“死的” 进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位，是“活的” 线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 进程和线程都是一个时间段的描述，是CPU工作时间段的描述。 什么是多进程？ 进程是程序在计算机上的一次执行活动，即正在运行中的应用程序，通常称为进程。 当你运行一个程序，你就启动了一个进程。每个进程都有自己独立的地址空间(内存空间)，每当用户启动一个进程时，操作系统就会为该进程分配一个独立的内存空间，让应用程序在这个独立的内存空间中运行。 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程，也称多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。 多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。 什么是多线程？ 线程是一个轻量级的子进程，是最小的处理单元；是一个单独的执行路径。可以说：线程是进程的子集（部分），一个进程可能由多个线程组成。 线程是独立的。如果在一个线程中发生异常，则不会影响其他线程。它使用共享内存区域。 多线程是一种执行模型，它允许多个线程存在于进程的上下文中，以便它们独立执行但共享其进程资源。 参考 https://www.php.cn/faq/416853.html https://www.jianshu.com/p/fd3927cd6ee7 https://blog.csdn.net/linraise/article/details/12979473 什么时候用多进程什么时候用多线程 多线程：io密集型 多进程：计算 cpu耗用的多 多进程优点：进程增减容易，进程互不干扰可以专心干自己的事情，效率高些，调试起来也方便些 多进程缺点：进程数大于cpu核数，又比较繁忙，导致频繁进行上下文切换会严重降低整体效率 多线程优点：上下文切换问题没那么严重，线程间可以方便地共享数据 多线程缺点：共享数据的时候需要小心，坑多，会增加一定代码复杂度个人倾向于一般尽量采用多进程，轻松舒服。 当涉及较多同步阻塞操作时，或者不得不需要较多实例时考虑多进程。 那么在 Python 中什么时候用多线程什么时候用多进程呢？ 当在CPU-bound(计算密集型：绝大多数时间在计算) 时最好用 - 多进程， 而在 I/O bound(I/O密集型 ： IO 处理 并且 大多时间是在等待) 的时候最好用 - 多线程。 python因为其全局解释器锁GIL而无法通过线程实现真正的平行计算。这个论断我们不展开，但是有个概念我们要说明，IO密集型 vs. 计算密集型。 IO密集型：读取文件，读取网络套接字频繁。 计算密集型：大量消耗CPU的数学与逻辑运算，也就是我们这里说的平行计算。 而concurrent.futures模块，可以利用multiprocessing实现真正的平行计算。 核心原理是： concurrent.futures会以子进程的形式，平行的运行多个python解释器，从而令python程序可以利用多核CPU来提升执行速度。 由于子进程与主解释器相分离，所以他们的全局解释器锁也是相互独立的。每个子进程都能够完整的使用一个CPU内核。 Java线程和操作系统线程的关系 1.操作系统线程模型 1.1 线程实现在用户空间下 1.2 线程实现在操作系统内核中 1.3使用用户线程加轻量级进程混合实现 OS中线程的实现有三种，一种是用户级线程ULT（UserLevelThreads），一种是内核支持线程KST（KernelSupportedThreads），还有一种是前两种的组合方式。 OS内核常驻在内存中，所以将内存空间分为内核空间和用户空间。 线程在内核中实现有以下几个好处: 1、内核可以在多处理器系统中调度同一进程中的多个线程并行执行。 2、如果某一个进程中的线程阻塞了，可以跨进程调度其他线程进行执行 3、线程的切换速度快，开销小。并且内核本身支持多线程技术可以提高系统的执行速度和效率。 Java线程在操作系统上本质: 现在的Java中线程的本质，其实就是操作系统中的线程，Linux下是基于pthread库实现的轻量级进程，Windows下是原生的系统Win32 API提供系统调用从而实现多线程。 参考 https://blog.csdn.net/CringKong/article/details/79994511 https://blog.csdn.net/yangmx_5/article/details/68065299?utm_source=blogkpcl7 https://www.jianshu.com/p/7c980955627e Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Linux/操作系统-内存管理机制.html":{"url":"docs/tech/OperatingSystem/Linux/操作系统-内存管理机制.html","title":"操作系统-内存管理机制","keywords":"","body":" 操作系统-内存管理机制 页面置换算法 页面替换算法 Linux内存管理 操作系统内存管理机制 虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page).每个页都是一段连续的地址。 对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上。 虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会通过MMU（内存管理单元）去匹配对应的物理地址，而如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。 而虚拟内存和物理内存的匹配是通过页表实现，页表存在MMU中，页表中每个项通常为32位，既4byte，除了存储虚拟地址和页框地址之外，还会存储一些标志位，比如是否缺页，是否修改过，写保护等。可以把MMU想象成一个接收虚拟地址项返回物理地址的方法。 页面置换算法 地址映射过程中，若在页面中发现所要访问的页面不再内存中，则产生缺页中断。 当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘的副本；如果该页面没有被修改过，那么它在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖掉被淘汰的页面就可以了。 而用来选择淘汰哪一页的规则叫做页面置换算法。 因为在计算机系统中，读取少量数据硬盘通常需要几毫秒，而内存中仅仅需要几纳秒。一条CPU指令也通常是几纳秒，如果在执行CPU指令时，产生几次缺页中断，那性能可想而知，因此尽量减少从硬盘的读取无疑是大大的提升了性能。 而前面知道，物理内存是极其有限的，当虚拟内存所求的页不在物理内存中时，将需要将物理内存中的页替换出去，选择哪些页替换出去就显得尤为重要，如果算法不好将未来需要使用的页替换出去，则以后使用时还需要替换进来，这无疑是降低效率的，让我们来看几种页面替换算法。 页面替换算法 1、最优页面置换算法(Optimal Page Replacement Algorithm) 2、最近最少使用页面置换算法(Least Recently Used) 3、最近未使用页面置换算法(Not Recently Used Replacement Algorithm) 4、先进先出的页面置换算法(First-In First-Out Page Replacement Algorithm) 5、第二次机会页面置换算法(Second Chance Page Replacement Algorithm) 6、时钟替换算法(Clock Page Replacement Algorithm) 参考 https://blog.csdn.net/Kang_TJU/article/details/76991229 https://www.jianshu.com/p/2b11639905ec Linux内存管理 内核空间 页(page)是内核的内存管理的基本单位 内核把页划分在不同的区(zone) 用户空间 用户空间中进程的内存，往往称为进程地址空间。 Linux采用虚拟内存技术。进程的内存空间只是虚拟内存（或者叫作逻辑内存），而程序的运行需要的是实实在在的内存，即物理内存（RAM）。 在必要时，操作系统会将程序运行中申请的内存（虚拟内存）映射到RAM，让进程能够使用物理内存。 进程与内存 所有进程都必须占用一定数量的内存，这些内存用来存放从磁盘载入的程序代码，或存放来自用户输入的数据等。内存可以提前静态分配和统一回收，也可以按需动态分配和回收。 参考 https://www.jianshu.com/p/2b11639905ec Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/MacOS使用.html":{"url":"docs/tech/OperatingSystem/MAC/MacOS使用.html","title":"MacOS使用","keywords":"","body":"MacOS 软件下载网站： Xclient麦氪搜(iMacso.com)MacWkMacBL（马可波罗） MAC OS 如何安装命令行工具:Command Line Tools 打开终端输入：xcode-select --install 回车 安装好了测试结果：gcc -v 切换root：sudo -i mac install telnet : brew tap theeternalsw0rd/telnet brew install telnet 安装 Homebrew： 命令粘贴至终端 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Run brew help to get started brew -v brew更新到最新版本，执行：brew update install：brew install git update：brew upgrade git 查看：which git 安装git不生效，使用brew link git 安装git-lfs：brew install git-lfs 安装Erlang，执行：brew install erlang 安装RabbitMQ Server，执行：brew install rabbitmq 安装golang：brew install go brew install gradle MacOS快捷键 https://support.apple.com/zh-cn/HT201236 https://support.apple.com/zh-cn/guide/mac-help/mchlp2469/mac MacOS触摸板使用 https://support.apple.com/zh-cn/HT204895 一个手指：鼠标左键，二个手指：鼠标右键 两根手指：用双指轻点两下可放大或缩小网页或 PDF，放大页面，上下滚动，在网页上回退或前进页面 三根手指：全屏左右滑动，展示全部打开应用 四根手指：到桌面，到启动台 mac软件参考awesome-macAwesome Mac mac 系统怎么访问局域网内的共享文件夹 解决方法 1、点击 Finder 前往菜单中的「前往服务器」（或快捷键 command+k） 2、在连接服务器对话框中输入「smb://Windows主机的IP地址」，其中 smb 是访问 Windows 共享文件夹所使用的协议名称，SMB：服务器信息块协议（Server Message Block protocol）。 3、连接Windows主机后会显示该主机的所有共享文件夹，选择想要访问的一个即可 macOS环境 查看端口、进程号、进程名 记录一些mac下的常用命令： 1、查看进程号 ps -ef | grep 进程名 ps -ef | grep java | grep zookeeper 2、查看端口被哪个进程监听 sudo lsof -i :端口 lsof -i tcp:8080 该命令会显示占用8080端口的进程，有其 pid 3、查看进程监听的端口 sudo lsof -nP -p 进程号 | grep LISTEN sudo lsof -nP | grep LISTEN | grep 进程号 lsof -nP -p 5450 | grep LISTEN lsof -nP | grep LISTEN | grep 39269 知道进程号，查看进程详细信息 ps | grep 39269 4、查看监听端口的进程 sudo lsof -nP | grep LISTEN | grep 端口号 lsof -nP | grep LISTEN | grep 8080 5、看到一个新的方法（MacOS统计TCP/UDP端口号与对应服务） echo \"### TCP LISTEN ###\" lsof -nP -iTCP -sTCP:LISTEN https://blog.csdn.net/glw0223/article/details/86737591 Mac滚动截屏 最常规的或许就是登陆QQ，使用Ctrl + Command（Alt）+ A，简单粗暴。没错，使用QQ快捷键截图可能是那些年我们最常用的方式。当然，这种方式并没有过时，大家依然常用，方便，快捷，实用。 另外，Mac有自带截图功能。 （1）Shift + Command + 3，会将生成图片自动保存到桌面上。 （2）Shift + Command + 4，会出现十字光标，按需选中要截图的内容后，会将生成图片自动保存到桌面上。 （3）Shift + Command + 4，会出现十字光标，按空格键，出现相机图标，然后点击界面，就会把当前界面生成图片自动保存到桌面上。 以上截图方式就已经很方便，那么，如果要截长图，有什么好的办法呢？ Chorme浏览器有自带截长图功能，方便好用。 打开需要截长图的网页，右键--检查--Shift + Command + P，输入“screen”，选择 “Capture full size screenshot”： 参考Mac滚动截屏了解一下？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/Mac软件安装.html":{"url":"docs/tech/OperatingSystem/MAC/Mac软件安装.html","title":"Mac软件安装","keywords":"","body":"/// QQ、微信、企业微信 QQ音乐、迅雷、网易邮箱大师、有道云笔记、有道词典、搜狗输入法 TeamViewer V2RayX XMind Office（WPS） IDEA（GoLand、PyCharm、WebStorm、CLion） OmniGraffle） The Unarchiver EasyConnect docker Chrome VSCODE(Visual Studio Code) Termius（CRT、iTerm2） 在终端使用: //显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles -bool true //不显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles -bool false IDEA Maven JDK 安装Xcode xcode-select --install 如果报错：不能安装该软件,因为当前无法从软件更新服务器获得。 只需要去这个地址 https://developer.apple.com/download/more/ 在左边的搜索框中搜索Command Line Tools 然后回车 将其中适合你电脑版本的那个下载下来安装好即可。 安装之后再次执行xcode-select --install xcode-select: error: command line tools are already installed, use \"Software Update\" to install updates 更新软件 Update them from Software Update in System Preferences or run: softwareupdate --all --install --force If that doesn't show you an update run: sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install 安装brew 官方命令安装报错： curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/universal-darwin19/rbconfig.rb:229: warning: Insecure world writable dir /usr/local/bin in PATH, mode 040777 就直接设置代理，或者使用其他的源安装 安装之后 brew -v 安装 brew cask brew tap homebrew/cask brew install brew-cask-completion 安装switchhosts brew install switchhosts --cask 或者 brew cask install switchhosts 安装Git brew install git Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/Homebrew.html":{"url":"docs/tech/OperatingSystem/MAC/Homebrew.html","title":"Homebrew","keywords":"","body":"Homebrew介绍 Homebrew介绍和安装 Homebrew安装 Homebrew常用的brew命令 安装过程中遇到的问题 连接不上网站的问题 Homebrew的brew install 和 brew cask install 的区别 Homebrew介绍和安装 Homebrew官网Homebrew DocumentationHomebrew GithubMac App Store Search & Install any app on Mac 🍺 The missing package manager for macOS (or Linux)mac缺少macOS（或Linux）的软件包管理器 Homebrew 是一款 Mac OS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。 Homebrew 通过简单的一条指令，就可以实现包管理，不需要关心各种依赖和文件路径的情况。 Homebrew 的两个术语： Formulae：软件包，包括了这个软件的依赖、源码位置及编译方法等； Casks：已经编译好的应用包，如图形界面程序等。 Homebrw相关的几个文件夹用途： bin：用于存放所安装程序的启动链接（相当于快捷方式） etc：brew安装程序的配置文件默认存放路径 Library：Homebrew 系统自身文件夹 Cellar：通过brew安装的程序将以 [程序名/版本号] 存放于本目录下 通过brew install安装应用最先是放在/usr/local/Cellar/目录下。 有些应用会自动创建软链接放在/usr/bin或者/usr/sbin，同时也会将整个文件夹放在/usr/local 可以使用brew list 软件名确定安装位置。可以在mac终端直接输入 brew list mysql Homebrew安装 Install Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Run brew help to get started brew -v brew更新到最新版本，执行：brew update Homebrew常用的brew命令 查看brew版本：brew -v 更新brew版本：brew update 本地软件库列表：brew list 列出已安装的软件 查看软件库版本：brew list --versions 查找/搜索软件包：brew search xxx （xxx为要查找软件的关键词），如brew search wget 安装软件包：brew install xxx （xxx为软件包名称），如brew install wget 卸载软件包：brew uninstall xxx 卸载软件：brew remove 软件名，如brew remove wget 安装软件：brew cask install xxx（xxx为软件名称） 卸载软件：brew cask uninstall xxx 查找软件安装位置：which xxx （xxx为软件名称） 列出过时的软件包（已安装但不是最新版本）：brew outdated 更新过时的软件包（全部或指定）：brew upgrade 或 brew upgrade wget 用浏览器打开brew的官方网站：brew home 显示软件信息：brew info 显示包依赖：brew deps 要获取最新的包的列表，首先得更新 Homebrew 自己。这可以用 brew update 办到。 brew update 更新包 (formula)更新之前，我会用 brew outdated 查看哪些包可以更新。 brew outdated 然后就可以用 brew upgrade 去更新了。Homebrew 会安装新版本的包，但旧版本仍然会保留。 brew upgrade # 更新所有的包 brew upgrade $FORMULA # 更新指定的包 清理旧版本一般情况下，新版本安装了，旧版本就不需要了。我会用 brew cleanup 清理旧版本和缓存文件。Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。 brew cleanup # 清理所有包的旧版本 brew cleanup $FORMULA # 清理指定包的旧版本 brew cleanup -n # 查看可清理的旧版本包，不执行实际操作这样一套下来，该更新的都更新了，旧版本也被清理了。 锁定不想更新的包如果经常更新的话，brew update 一次更新所有的包是非常方便的。但我们有时候会担心自动升级把一些不希望更新的包更新了。数据库就属于这一类，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。我们更希望找个时间单独处理它。这时可用 brew pin 去锁定这个包，然后 brew update 就会略过它了。 brew pin $FORMULA # 锁定某个包 brew unpin $FORMULA # 取消锁定 其他几个常用命令 brew info 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。 brew info $FORMULA # 显示某个包的信息 brew info # 显示安装了包数量，文件数量，和总占用空间 brew deps 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。 brew deps --installed --tree # 查看已安装的包的依赖，树形显示 还有很多有用的命令和参数，没事 man brew 一下可以涨不少知识。 参考定期更新 Homebrewhttps://github.com/Homebrew/brew/blob/master/docs/FAQ.mdhttps://segmentfault.com/a/1190000004353419Homebrew常用安装卸载命令 安装过程中遇到的问题 连接不上网站的问题 如何解决类似 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 的问题 笔者最近发现 github 的用户头像和自己文章中的图片显示不出来了。然后今天发现安装 homeBrew 和 nvm 出现了标题的报错信息。 以上是安装 pnpm 的报错信息，可以发现，脚本需要到 raw.githubusercontent.com 上拉取代码。 网上搜索了一下，发现是 github 的一些域名的 DNS 解析被污染，导致DNS 解析过程无法通过域名取得正确的IP地址。 解决方案 打开 https://www.ipaddress.com/ 输入访问不了的域名 查询之后可以获得正确的 IP 地址 在本机的 host 文件中添加，建议使用 switchhosts 方便 host 管理 199.232.68.133 raw.githubusercontent.com 199.232.68.133 user-images.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 添加以上几条 host 配置，页面的图片展示就正常了，homebrew 也能装了，nvm 也行动灵活了。 参考如何解决类似 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 的问题 #10 Homebrew的brew install 和 brew cask install 的区别 Homebrew 提供了两种安装软件的方式，brew install 和 brew cask install，下面对两种方式进行一些解释说明。 1. brew install brew 是下载源码解压，然后 ./configure && make install ，同时会包含相关依存库，并自动配置好各种环境变量。 Homebrew is the easiest and most flexible way to install the UNIX tools Apple didn’t include with macOS. 对于对程序员只需通过简单的指令，就能快速安装和升级本地的各种开发环境，非常快捷方便。 2. brew cask install brew cask 是针对已经编译好了的应用包（.dmg/.pkg）下载解压，然后放在统一的目录中（Caskroom），省掉了自己下载、解压、安装等步骤。 Homebrew-Cask extends Homebrew and brings its elegance, simplicity, and speed to macOS applications and large binaries alike. 这个对一般用户来说会比较方便，包含很多在 AppStore 里没有的常用软件。 简单来说， brew install 用来安装一些不带界面的命令行工具和第三方库。 brew cask install 用来安装一些带界面的应用软件。 参考brew install 和 brew cask install 的区别brew和brew cask有什么区别？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/Darwin操作系统.html":{"url":"docs/tech/OperatingSystem/MAC/Darwin操作系统.html","title":"Darwin操作系统","keywords":"","body":"Darwin是由苹果公司于2000年所发布的一个开放源代码操作系统。Darwin是macOS和iOS操作环境的操作系统部分。苹果公司于2000年把Darwin发布给开放源代码社区。 Darwin 是一个由苹果公司（Apple Inc.）开发的 UNIX 操作系统。自2000年后，Darwin 是苹果所有操作系统的基础，包括 macOS（原名 Mac OS X ，后缩写为 OS X，至 WWDC 2016 改名为 macOS）、iOS、watchOS 和 tvOS。 Darwin (操作系统)) 达尔文操作系统 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/Kap录屏软件.html":{"url":"docs/tech/OperatingSystem/MAC/Kap录屏软件.html","title":"Kap录屏软件","keywords":"","body":"https://getkap.co/ https://github.com/wulkano/kap Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/MAC/Mac让终端走代理的几种方法.html":{"url":"docs/tech/OperatingSystem/MAC/Mac让终端走代理的几种方法.html","title":"Mac让终端走代理的几种方法","keywords":"","body":"方法1: 在终端中直接运行命令 export http_proxy=http://proxyAddress:port 这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。 如果你用的是ss代理，在当前终端运行以下命令，那么wget curl 这类网络命令都会经过ss代理 export ALL_PROXY=socks5://127.0.0.1:1080 方法2: 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容 export http_proxy=\"http://localhost:port\" export https_proxy=\"http://localhost:port\" 以使用shadowsocks代理为例，ss的代理端口为1080,那么应该设置为 export http_proxy=\"socks5://127.0.0.1:1080\" export https_proxy=\"socks5://127.0.0.1:1080\" 或者直接设置ALL_PROXY export ALL_PROXY=socks5://127.0.0.1:1080 localhost就是一个域名，域名默认指向 127.0.0.1，两者是一样的。 然后ESC后:wq保存文件，接着在终端中执行 source ~/.bashrc 或者退出当前终端再起一个终端。 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了。 或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。 alias setproxy=\"export ALL_PROXY=socks5://127.0.0.1:1080\" alias unsetproxy=\"unset ALL_PROXY\" alias ip=\"curl -i http://ip.cn\" 方法3: 改相应工具的配置，比如apt的配置 sudo vim /etc/apt/apt.conf 在文件末尾加入下面这行 Acquire::http::Proxy \"http://proxyAddress:port\" 保存apt.conf文件即可。 关于apt的代理设置可以参考这里 关于git的代理设置看这里:用shadowsocks加速git clone 方法4(推荐): 利用proxychains在终端使用socks5代理 补充： 如果代理服务器需要登陆，这时可以直接把用户名和密码写进去 http_proxy=http://userName:password@proxyAddress:port https://blog.fazero.me/2015/09/15/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Windows/Windows.html":{"url":"docs/tech/OperatingSystem/Windows/Windows.html","title":"Windows介绍","keywords":"","body":" WinPE Windows ADK Windows To Go：功能概述 USB启动盘制作工具/U盘启动盘 微软开发者网络MSDN Windows 10 Business Editions和Consumer Editions版本区别 USB启动盘制作工具/U盘启动盘 Rufus 老毛桃 WinPE Windows PE (WinPE) WinPE官网介绍 Windows预先安装环境（英语：Microsoft Windows Preinstallation Environment），简称Windows PE或WinPE，是Microsoft Windows的轻量版本，主要提供个人电脑开发商（主要为OEM厂商）、工作站、服务器打造定制的操作系统环境，或系统离线时进行故障排除来使用，以取代格式较旧的MS-DOS引导磁片/引导光盘。 其可理解为Windows的Live CD或子系统，系统核心采用32位/64位。由于硬件需求不大，因此便于存储在光盘、U盘等各种便携式存储设备。 Windows PE最初是设计给个人电脑开发商使用，以便于电脑生产时将Windows预装入内，但目前也以捆包的方式提供给一般的软件开发者使用，目前从Windows XP以及之后的Windows公开版本都有支持。 Windows PE含有Windows XP、Windows Server 2003、Windows Vista、Windows 7、Windows 8、Windows 8.1、Windows 10的PE内核。 Windows® 预安装环境 (Windows PE) 是一个最小的操作系统，旨在为安装 Windows 准备计算机。它可用于启动没有操作系统的计算机、分区和格式化硬盘驱动器、复制磁盘映像以及从网络共享启动 Windows 安装程序。 Windows PE 作为独立产品提供给拥有适当许可协议的客户，并且是许多 Windows 技术的集成组件，包括 Windows 安装程序和 Windows 部署服务。 Windows PE 3.0 是基于 Windows® 7 操作系统的最新版本。 Windows PE 技术参考) Windows预先安装环境 wiki WinPE制作介绍 Windows ADK The Windows Assessment and Deployment Kit (Windows ADK) Windows 评估和部署工具包 (Windows ADK) 包含在新计算机中自定义、评估和部署 Windows 操作系统所需的所有工具。 Windows ADK（Windows Assessment and Deployment Kit），曾用名Windows AIK或WAIK（Windows Automated Installation Kit）是Microsoft开发的旨在帮助将Microsoft Windows操作系统映像部署到目标计算机或VHD虚拟硬盘上的工具集合，最早出现在Windows Vista上。WAIK 是Microsoft Deployment Toolkit的必要组件。 Windows ADK是微软最新发布的用于Windows 部署是的一个工具包，这个工具主要用于在企业和OEM厂商中执行大规模的Windows部署。 在以前用于大规模部署时用到的工具主要是OPK和WAIK，而Windows ADK不仅包含了这些工具，还包含了Windows 预安装环境、部署映像、服务和管理以及Windows 系统映像管理器。 使用 Windows ADK 进行 Windows 部署) Download and install the Windows ADK Windows ADK wiki Windows To Go：功能概述 Windows To Go （以下简称为 WTG） Windows To Go：功能概述 说走就走的「Windows」—— Windows To Go 制作详解 Mac 安装使用 Windows To Go 教程 Mac使用 Windows To Go 把Win 10 系统安装到移动硬盘或U盘上 微软开发者网络MSDN MSDN官方网站MSDN wikiMSDN，我告诉你 微软开发者网络（英语：MSDN, Microsoft Developer Network） 微软开发者网络（英语：MSDN, Microsoft Developer Network）是早期微软公司在推广Win32 程序设计以及开发工具时，专门为开发人员所提供的一个服务，是使用微软技术开发软件或应用程序时必定会参访的地方，同时它也有提供订阅的服务，由微软不定时供应最新的软件及技术文件，MSDN的技术文件库是免费开放让所有人在在线阅读，但光盘的版本必须要利用MSDN Library Subscription才可以拿到，不过自从Visual Studio 2005开始，MSDN Library即提供免费的网络下载。 Windows 10 Business Editions和Consumer Editions版本区别 Windows 10 Upgrades – Business Editions Vs. Consumer Editions 一、两者的产品名称区别：win10 business edition为批量版（也称VOL版），指市面上的win10商业版集合，而consumer edition则为零售版，指的是市面上的win10普通版本集合。 二、两者的内置win10版本区别： consumer editions版本包含Home(家庭版)、Education(教育版)、Professional(专业版)； business editions版本包含Education(教育版)、Enterprise (企业版)、Professional(专业版)。 business edition和consumer edition均是win10的版本集合产品，而win10分有七个版本，具体如下： 家庭版(Home)：供家庭用户使用，无法加入Active Directory和Azure AD，不允许远程链接。 专业版(Professional)：供小型企业使用 在家庭版基础上增加了域账号加入、bitlocker、企业商店等功能。 企业版(Enterprise)：供中大型企业使用 在专业版基础上增加了DirectAccess，AppLocker等高级企业功能。 教育版(Education)：供学校使用 (学校职员, 管理人员, 老师和学生) 其功能基本和企业版的一样。 移动版(Mobile)：面向尺寸较小、配置触控屏的移动设备，例如智能手机和平板电脑，集成有与Windows 10家庭版相同的通用Windows应用和针对触控操作优化的Office。 移动企业版(Mobile Enterprise)：以移动版为基础的企业版本。该版本可以批量允许客户使用，添置企业管理更新功能，以及安全补丁软件的检查与更新功能。 专业工作站版(Windows 10Pro for Workstations)：该版本重点优化了多核处理以及大文件处理的功能，提供6TB大内存、ReFS文件系统、高速文件共享和工作站模式。 物联网核心版(Windows 10 IoT Core)：面向小型低价设备，主要针对物联网设备。 Windows 10 baike Windows 10版本business_editions和consumer_editions的区别？ Windows 10 镜像的 Consumer Editions 和 Business Editions 的区别 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/OperatingSystem/Windows/batch/Batch批处理-CMD-MS-DOS.html":{"url":"docs/tech/OperatingSystem/Windows/batch/Batch批处理-CMD-MS-DOS.html","title":"Batch批处理-CMD-MS-DOS","keywords":"","body":"1、Batch批处理命令、解释器（通常是COMMAND.COM或者CMD.EXE）解释运行、应用于DOS和Windows系统（MS-DOS） 2、x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构 x86的32位架构（i386、x86）、x86的64位架构（AMD64、Intel 64、x86-64、x64） 3、微架构使得指令集架构（ISA，如x86）可以在处理器（CPU）上被运行。指令集架构（如x86）可以在不同的微架构上运行。 测试脚本 md 创建文件夹 rd 删除文件夹 cd 进入文件夹 dir 列出文件夹文件 tree 显示目录结构 echo \"hell\" >> test.txt TYPE 显示文件内容命令 ren sourceName targetName 重命名文件和目录 DEL file 删除文件命令 DEL . DR 删除当前目录下的全部文件 COPY 将文件从一个位置复制到另一个位置。 XCOPY 目录复制命令 date 查看和设置日期 time 设置或显示时间。 算术运算符：+-/% 关系运算符:EQU、NEQ、LSS、LEQ、GTR、GEQ 逻辑运算符:AND、OR、NOT 赋值运算符:+=、-=、=、/=、%= 按位运算符:&|^ 命令 备注 MD 创建子目录 CD 改变当前目录 RD 删除子目录命令 DIR 示磁盘目录命令 PATH 路径设置命令 TREE 显示磁盘目录结构命令 DELTREE 删除整个目录命令 FORMAT 磁盘格式化命令 SCANDISK 检查磁盘当前状态命令 UNFORMAT 恢复格式化命令 DISKCOPY 整盘复制命令 VOL 显示磁盘卷标命令 SCANDISK 检测、修复磁盘命令 DEFRAG 重整磁盘命令 SYS 系统复制命令 COPY 文件复制命令 XCOPY 目录复制命令 TYPE 显示文件内容命令 REN 文件改名命令 FC 文件比较命令 ATTRIB 修改文件属性命令 DEL 删除文件命令 UNDELETE 恢复删除命令 VER 查看系统版本号命令 DATE 查看日期命令 编号 命令 描述 1 VER 显示正在使用的MS-DOS的版本。 2 ASSOC 这是将扩展名与文件类型(FTYPE)相关联的批处理命令，显示现有关联或删除关联。 3 CD 更改进入不同的目录，或显示当前目录。 4 CLS 清除屏幕。 5 COPY 将文件从一个位置复制到另一个位置。 6 DEL 删除文件而不是目录。 7 DIR 列出目录的内容。 8 DATE 查找系统日期。 9 ECHO 显示消息，或打开或关闭命令回显。 10 EXIT 退出DOS控制台。 11 MD 在当前位置创建一个新的目录。 12 MOVE 在目录之间移动文件或目录。 13 PATH 此批处理命令显示或设置路径变量。 14 PAUSE 该批处理命令会提示用户并等待输入一行。 15 PROMPT 此批处理命令可用于更改或重置cmd.exe提示符。 16 RD 这个批处理命令删除目录，但目录需要是空的才能被删除。 17 REN 重命名文件和目录 18 REM 此批处理命令用于批处理文件中的备注，防止执行备注的内容。 19 START 该批处理命令在新窗口中启动程序，或打开文档。 20 TIME 该批处理命令设置或显示时间。 21 TYPE 该批处理命令将文件或文件的内容打印到输出中。 22 VOL 此批处理命令显示卷标。 23 ATTRIB 显示或设置当前目录中的文件的属性 24 CHKDSK 这个批处理命令检查磁盘是否有问题。 25 CHOICE 这个批处理命令为用户提供了一个选项列表。 26 CMD 此批处理命令将调用另一个命令提示符实例。 27 COMP 该批处理命令根据文件大小比较2个文件。 28 CONVERT 此批处理命令将卷从FAT16或FAT32文件系统转换为NTFS文件系统。 29 DRIVERQUERY 此批处理命令显示所有已安装的设备驱动程序及其属性 30 EXPAND 此批处理命令从压缩的.cab压缩文件中提取文件。 31 FIND 该批处理命令在文件或输入中搜索字符串，输出匹配的行。 32 FORMAT 此批处理命令将磁盘格式化为使用Windows支持的文件系统(如FAT，FAT32或NTFS)，从而覆盖磁盘的先前内容。 33 HELP 该批处理命令显示Windows提供的命令的列表。 34 IPCONFIG 此批处理命令显示Windows IP配置。显示连接的配置和连接的名称。 35 LABEL 此批处理命令添加，设置或删除磁盘标签。 36 MORE 此批处理命令一次显示一个或多个文件的内容。 37 NET 根据使用的命令提供各种网络服务。 38 PING 这个批处理命令通过网络将ICMP/IP “回显”发送到指定的地址的包。 39 SHUTDOWN 该批处理命令关闭计算机，或者注销当前用户。 40 SORT 该批处理命令从源文件获取输入，并按字母顺序排序其内容，从A到Z或从Z到A。它将在控制台上打印输出。 41 SUBST 此批处理命令将驱动器号分配给本地文件夹，显示当前分配或删除分配。 42 SYSTEMINFO 该批处理命令显示计算机及其操作系统的配置。 43 TASKKILL 该批处理命令结束一个或多个任务。 44 TASKLIST 此批处理命令列出任务，包括任务名称和进程标识(PID)。 45 XCOPY 这个批处理命令以更高级的方式复制文件和目录。 46 TREE 该批处理命令将当前目录的所有子目录的树显示为递归或深度的任何级别。 47 FC 这个批处理命令列出了两个文件之间的实际差异。 48 DISKPART 此批处理命令显示和配置磁盘分区的属性。 49 TITLE 该批处理命令设置控制台窗口中显示的标题。 50 SET 显示当前系统上的环境变量列表。 CMD命令是一种命令提示符，CMD是command的缩写，即命令提示符（CMD），是在OS / 2 ， Win为基础的操作系统（包括Windows 2000和XP中， Vista中，和Server 2003 ）下的“MS-DOS方式”。中文版Windows XP 中的命令提示符进一步提高了与DOS 下操作命令的兼容性，用户可以在命令提示符直接输入中文调用文件。 DOS，是磁盘操作系统 MS-DOS，微软磁盘操作系统 x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构。最早的8086处理器于1978年由Intel推出，为16位微处理器。 关于x86的32位架构（常被称为i386、x86），请见“IA-32”。 关于x86的64位架构（常被称为AMD64、Intel 64、x86-64、x64），请见“x86-64”。 指令集架构（英语：Instruction Set Architecture，缩写为ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部I/O。指令集架构包含一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。 微架构（英语：microarchitecture），也被叫做计算机组织，微架构使得指令集架构（ISA）可以在处理器上被运行。指令集架构可以在不同的微架构上运行。 计算机结构是一门探讨微架构与指令集两者交互的一门学问。 批处理（Batch）通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的解释器（通常是COMMAND.COM或者CMD.EXE）解释运行。类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。也可以在批处理文件后面加上更多种类的参数。 CMD可以指：命令提示符，一个用于运行Windows命令行界面程序或某些DOS程序的壳层程序。 DOS，是磁盘操作系统（英文：Disk Operating System）的缩写，是个人计算机上的一类操作系统。 DOS是单一用户、单工的操作系统，拥有不可重入的基本核心函数（意即同时间只能有一个程序调用这些函数）。有一个例外的状况，就是常驻程序（Terminate and Stay Resident，缩写为TSR）。某些常驻程序允许用户多任务操作；然而此时仍有“核心不可重入”的问题：当一个进程（process）调用了操作系统核心中的服务函数（也就是系统调用）时，在这个调用结束之前，其他的进程绝对不能进行系统调用、打断第一个进程。[2] DOS的核心为用户程序提供了各式各样的函数，例如：在显示屏上显示文字、从键盘读入字符、访问磁盘上的文件等等。 DOS透过批处理文件（扩展名为.BAT）提供界面脚本的功能。这些文件是纯文本格式的，可以用任何的文本编辑器（像是edit.com）编辑。他们运行起来和编译而成的程序没有两样。文件中的每一行都被视为命令来运行。批处理文件也可以使用数个内部命令，例如goto和条件表达式。[3] DOS家族包括MS-DOS、PC-DOS、DR-DOS、FreeDOS、PTS-DOS、ROM-DOS、JM-OS等，其中以MS-DOS最为著名。虽然这些系统常被简称为\"DOS\"，但没有任何一个系统单纯以\"DOS\"命名（只有一个毫无关连的1960年代IBM大型主机操作系统以此命名）。此外，有几个和DOS无关、在非x86的微计算机系统上运行的磁盘操作系统在名称中也有\"DOS\"字眼，而且在专门讨论该机器的场合中也会简称为\"DOS\"（例如：AmigaDOS、AMSDOS、ANDOS、Apple DOS、Atari DOS、Commodore DOS、CSI-DOS、ProDOS、TRS-DOS等），但这些系统和DOS可执行文件以及MS-DOS API并不兼容。 MS-DOS 微软磁盘操作系统，MS-DOS，英语：MicroSoft Disk Operating System的缩写，一个由美国微软公司发展的操作系统，运行在Intel x86个人计算机上。它是DOS操作系统家族中最著名的一个，在Windows 95以前，DOS是IBM PC及兼容机中的最基本配备，而MS-DOS则是个人计算机中最普遍使用的DOS操作系统。 https://zh.wikipedia.org/wiki/DOS https://zh.wikipedia.org/wiki/MS-DOS Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/编程语言.html":{"url":"docs/tech/Language/编程语言.html","title":"编程语言","keywords":"","body":"编程语言 C语言：C、C++ JVM语言：Java、Groovy、Scala、Kotlin、Clojure Python： Lua： 前端：JavaScript Go： C - 1972 C语言是1972年在贝尔实验室发明的，当时丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson）正在开发UNIX。Ken Thompson之前开发了B语言。Dennis Ritchie决定从B语言中获得灵感，通过添加类型来创建C语言。 C++ - 1980 最初在1980年由Bjarne Stroustrup以C和类的名义创建，后来在1983年以c++语言命名。c++编程语言现在已被ISO标准化，并广泛应用于工业和其他领域。 Python - 1991 Python是一种解释性编程语言，具有多范式、多平台的特点。Python支持结构化、函数式和面向对象的命令式编程。这些年来，Python变得非常流行，甚至在2019年成为最受欢迎的语言之一。 Lua - 1993 Lua创建于1993年，是一种自反的命令式脚本语言，用于嵌入其他应用程序以扩展功能。 Ruby - 1995 Matsumoto Yukihiro由于对自己的Smalltalk和Lisp开发经历感到失望，于1993年开始在Emacs下设计Ruby语言。他在1995年发布了第一版。Ruby是解释型的、面向对象的、多范式的编程语言。 Java - 1995 Java是James Gosling在1995年创建的一种面向对象的编程语言，至今仍是业界最流行和使用最多的语言。Java允许完成客户机到web应用程序的所有工作，而谷歌将其作为Android移动操作系统上开发应用程序的语言，进一步扩展了它的功能。 JavaScript - 1995 JavaScript是一种脚本编程语言，主要用于Web，但现在可以在服务器端使用Node.js等。JavaScript是一种面向原型的编程语言。 PHP - 1995 就编程语言而言，1995年无疑是极其重要的一年，因为在Java和JavaScript之后，PHP也在这一年诞生。PHP主要用于Web，是一种面向对象的命令式语言，可以像其他解释语言一样在本地工作。 C# - 2000 c#是微软在2000年与Sun就Java语言发生争执后创建的。c#是一种面向对象的编程语言，用于在Microsoft上开发。该语言派生于c++和Java，使用它们的一般语法和一些概念。c#也可以用于开发ASP上的web应用程序。 Groovy - 2003 Groovy是一种运行在Java平台上的面向对象编程语言。Groovy是Java语言的替代品，它的灵感来自Python、Ruby或Smalltalk。 Scala - 2003 Scala是一种多范式编程语言，旨在以简洁优雅的形式表达常见的编程模型。Scala通过静态类型集成了面向对象和函数式编程的范例。 Clojure - 2007 Clojure是一种经过编译的跨平台函数式编程语言，旨在创建安全且易于分发的程序。Clojure是基于Lisp的三大语言之一。Clojure可以转换为Java代码、JavaScript代码和. net代码。因此，Clojure可以在JVM、CLR、浏览器和Node.js上使用。 Go - 2009 Go是一种经过编译的并发式编程语言，灵感来自C和Pascal。这种语言是由谷歌从Robert Griesemer、Rob Pike和Ken Thompson（他在1969年创造了B语言）最初提出的概念发展而来的。 Rust - 2010 Rust是由Mozilla设计和开发的多范型编译的编程语言。Rust是“一种安全、并发、实用的语言”，同时支持纯函数式编程风格、actor模型、过程式编程以及面向对象编程。Rust常被称为c++的潜在继承者之一。 Kotlin — 2011 Kotlin是一种面向对象的函数式编程语言，具有静态类型，允许在Java虚拟机、JavaScript和本地的多种平台进行编译。2017年，谷歌使Kotlin成为继Java之后Android官方支持的第二种编程语言。 Swift - 2014 Swift是一种经过编译的、多范式的对象编程语言，其设计目标是简单、高性能和安全。它是由苹果公司开发的开源软件，从而与Objective-C一起成为开发移动iOS应用程序的解决方案。 参考 https://developer.aliyun.com/article/736663 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/Golang.html":{"url":"docs/tech/Language/Golang.html","title":"Golang","keywords":"","body":"Golang 参考quickstart-golang go语言 https://golang.org/project/ 源码https://golang.org/dl/ mac 下安装go环境 执行brew install go 未安装brew则先安装brew 见文章末 配置环境变量 1. 设置goroot 2. 设置gopath goroot和go path都设置到启动linux其中项中 执行 sudo vi /etc/profile 加入 go config export PATH=$PATH:/usr/local/opt/go/libexec/bin export GOPATH=/Users/xxx/go 执行wq! 强制保存 ps: 安装 brew 在终端输入命令 ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装后更新下 brew update 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/Python.html":{"url":"docs/tech/Language/Python.html","title":"Python","keywords":"","body":"Python 参考 quickstart-python 1、Python+自动化运维 Python+自动化测试 Python+AI Python+爬虫 Python+大数据 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/Lua.html":{"url":"docs/tech/Language/Lua.html","title":"Lua","keywords":"","body":"Lua 参考quickstart-lua 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/Erlang.html":{"url":"docs/tech/Language/Erlang.html","title":"Erlang","keywords":"","body":"Erlang Erlang： 官网：http://www.erlang.org/ 文档：http://erlang.org/doc/design_principles/users_guide.html 下载：http://www.erlang.org/downloads https://github.com/erlang/otp brew install go RabbitMQ 3.7.0 发布，正式支持 Erlang/OTP 20 （OTP 20.1.4 已发布，OTP (Open Telecom Platform) 是一个开源的 Erlang 分发和一个用 Erlang 编写的应用服务器。） 开放电信平台 OTP OTP (Open Telecom Platform) 是一个开源的 Erlang 分发和一个用 Erlang 编写的应用服务器，由爱立信开发。 OTP 包含： 一个 Erlang 解释器 一个 Erlang 编译器 服务器之间的通讯协议 一个 Corba 对象请求代理 名为 Dialyzer 的静态分析工具 一个分布式的数据库服务 Mnesia 大量的开发库 https://www.oschina.net/p/otp Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/Ruby.html":{"url":"docs/tech/Language/Ruby.html","title":"Ruby","keywords":"","body":"Ruby 1、Ruby on Rails Ruby on Rails是一个可以使你开发、部署、维护 web 应用程序变得简单的框架。这个 Web 开发框架在开发人员当中极其流行，它声称“为确保编程员满意和持续高效地工作进行了优化”。用户包括 Basecamp、推特、Shopify 和 GitHub 等公司。 支持的操作系统：Windows、Linux 和 OS X 相关网站：https://rubyonrails.org 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/C++.html":{"url":"docs/tech/Language/C++.html","title":"C++/C","keywords":"","body":"C++ 参考quickstart-cpp 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 16、 17、 18、 19、 20、 21、 22、 23、 24、 25、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Language/.NET开发语言.html":{"url":"docs/tech/Language/.NET开发语言.html","title":"C#语言","keywords":"","body":"C#语言 ASP.NET、.NET和C#的区别和关系 ASP.NET网站技术 .Net框架 C#开发语言 ASPX文件 C#语言 ASP.NET、.NET和C#的区别和关系 ASP.NET网站技术 ASP.NET是一种用来快速创建动态Web网站的技术，不是语言，它使用C#(或者http://vb.net)为开发语言。C#是一种面向对象的编程语言；net只是一个框架，.net中所有的编程语言，比如c# http://vb.net等编写的程序必须在.net framework框架下运行。 .NET 分成两个方面：WinForm和WebForm，http://ASP.NET就是属于WebForm，也就是平时说的B/S模式的开发。而WinForm就是属于C/S模式。 Asp.NET可以用C#或http://VB.NET来开发。编译后形成CLR，通过服务器的IIS+.NET FrameWork再次编译来运行。 .Net框架 .Net全称.NET Framework是一个开发和运行环境，该战略是微软的一项全新创意，它将使得“互联网行业进入一个更先进的阶段”，.NET不是一种编程语言。简单说就是一组类库框架。 .NET有很多种语言组成，比如C#、 http://VB.NET、J#、Jsript、Managed C++，但是都是运行在.NET FrameWork Run Time底下的。其中，C#是主流。 C#开发语言 C#是.NET Framework框架支持的一种主力开发语言，可用于开发http://ASP.NET网站,Windows程序，控制台程序，甚至于手机软件(Windows Phone)。 .net和C#的区别 ASPX文件 .aspx（或.asp）文件与.html（.htm）文件的区别与联系 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Blockchain/Blockchain区块链.html":{"url":"docs/tech/Blockchain/Blockchain区块链.html","title":"区块链","keywords":"","body":"Blockchain区块链 区块链Blockchain 指纹（fingerprint） 比特币Bitcoin 以太坊 区块链资料 区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。 中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。 区块链共享价值体系首先被众多的加密货币效仿，并在工作量证明上和算法上进行了改进，如采用权益证明和SCrypt算法。随后，区块链生态系统在全球不断进化，出现了首次代币发售ICO；智能合约区块链以太坊；“轻所有权、重使用权”的资产代币化共享经济； 和区块链国家。目前，人们正在利用这一共享价值体系，在各行各业开发去中心化电脑程序(Decentralized applications, Dapp)，在全球各地构建去中心化自主组织和去中心化自主社区(Decentralized autonomous society, DAS)。 2008年11月，一位自称中本聪(Satoshi Nakamoto)的人提出了比特币，而区块链技术正是实现比特币的关键。 区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。 区块链在数据结构上就是有序链表，每一个区块就是链表中的存储单元可以记录交易相关的数据，而记录前后区块的记录就是链表的指针域。 那么问题来了，我们都知道改变链表的内容是很简单的，我们可以插入一个新的存储单元，然后更新指针域就可以了，如何做到“不可篡改”呢？ 区块链的链表指针域经过了特殊的设计，使用了两次哈希计算： 首先他的指针就是上一段区块的哈希值， 第二，他对本区块也做了一次哈希（注意：这一次哈希是用到了指向上一个区块的哈希值，使二者耦合），并存储在区块中，用来校验内容，内容哪怕改变一个字节也无法校验通过。 有了这样的设计，黑客如果修改某一个区块，这个区块的哈希值校验就无法通过，为此，黑客需要修改当前区块之后的所有区块哈希值来起到伪造的目的。 由于区块链的规模巨大（百亿级别），黑客需要拥有比肩全网算力的水平才能达到目的。 黑客这么做显然是赔钱的啊（正常也没这个能力），这样就间接完成了不可篡改。 什么是区块链？从科技层面来看，区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。从应用视角来看，简单来说，区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。这些特点保证了区块链的“诚实”与“透明”，为区块链创造信任奠定基础。而区块链丰富的应用场景，基本上都基于区块链能够解决信息不对称问题，实现多个主体之间的协作信任与一致行动。 　　区块链如何创造信任与合作机制，深入到具体的应用场景，就能够看得更加清楚。区块链“不可篡改”的特点，为经济社会发展中的“存证”难题提供了解决方案，为实现社会征信提供全新思路；区块链“分布式”的特点，可以打通部门间的“数据壁垒”，实现信息和数据共享；区块链形成“共识机制”，能够解决信息不对称问题，真正实现从“信息互联网”到“信任互联网”的转变；区块链通过“智能合约”，能够实现多个主体之间的协作信任，从而大大拓展了人类相互合作的范围。总体而言，区块链通过创造信任来创造价值，它能保证所有信息数字化并实时共享，从而提高协同效率、降低沟通成本，使得离散程度高、管理链条长、涉及环节多的多方主体仍能有效合作。 参考： [3] 廖雪峰.区块链原理 https://www.liaoxuefeng.com/wiki/1207298049439968/1311929706479649 [4] Investopedia.Blockchain: Everything You Need to Know - Investopedia https://www.investopedia.com/terms/b/blockchain.asp [5] 贵阳市人民政府.贵阳区块链发展和应用 http://www.cbdio.com/image/site2/20161231/3417eb9bbd5919d2122102.pdf Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Blockchain/Ethereum以太坊.html":{"url":"docs/tech/Blockchain/Ethereum以太坊.html","title":"Ethereum以太坊","keywords":"","body":"Ethereum以太坊 以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Blockchain/Bitcoin比特币.html":{"url":"docs/tech/Blockchain/Bitcoin比特币.html","title":"Bitcoin","keywords":"","body":"Bitcoin比特币 在区块链之前是机器学习和人工智能（ML/AI）与加密相关的东西，如哈希、签名、混淆等比特币以及类似的 POW 区块链区块链项目EOS以太坊ETHBTC 区块链Blockchain 指纹（fingerprint） 比特币Bitcoin 比特币（英语：Bitcoin）是一种去中心化，非普遍全球可支付的电子加密货币（也是虚拟货币）。原理是Blockchain https://bitcoin.org/en/ 比特币网站 https://blockchain.info/zh-cn/ 火币网：https://www.huobipro.com/zh-cn/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Blockchain/NFT.html":{"url":"docs/tech/Blockchain/NFT.html","title":"NFT","keywords":"","body":"NFT NFT介绍 Non-fungible Token（非同质通证） NFT（非同质化代币，non-fungible token）是一种被称为区块链（数位账本）上的数据单位，每个代币可以代表一个独特的数码资料。由于其不能互换，非同质化代币可以代表数位文件，如画作、声音、影片、游戏中的项目或其他形式的创意作品。 什么是NFT What You Need To Know About Non-Fungible Tokens (NFTs) Non-fungible token wiki NFT应用 一家中国的基于NFT技术的交易平台 数字星球艺术品平台数字星球NFT平台是全球领先的区块链NFT平台，数字星球NFT平台致力构建一个集知名IP、艺术作品交易、链游孵化、艺术家培育于一体的元宇宙生态。 NFT游戏Axie Infinity单日收入已超800万美元，超过了王者荣耀的单日收入。 24种NFT游戏 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/AI/MachineLearning机器学习.html":{"url":"docs/tech/AI/MachineLearning机器学习.html","title":"机器学习","keywords":"","body":"MachineLearning机器学习 Machine Learning, ML,机器学习 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/AI/tensorflow.html":{"url":"docs/tech/AI/tensorflow.html","title":"tensorflow","keywords":"","body":"tensorflow 英文官方网站： http://tensorflow.org/ 官方GitHub仓库： https://github.com/tensorflow/tensorflow 中文版 GitHub 仓库： https://github.com/jikexueyuanwiki/tensorflow-zh TensorFlow中文社区 http://www.tensorfly.cn/ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/AI/人工智能技术.html":{"url":"docs/tech/AI/人工智能技术.html","title":"人工智能技术","keywords":"","body":"人工智能技术 人工智能技术，如机器学习、深度学习、神经网络等等， 这些技术大多来自于学术机构或科研单位的研究成果，学者们首先会通过一些论文和报告给出某个概念的清晰定义，然后再有相关科技公司进行研发和生产。 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器， 该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。 人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/AI/蚂蚁金服共享智能技术实践：如何降低数据共享的难度.html":{"url":"docs/tech/AI/蚂蚁金服共享智能技术实践：如何降低数据共享的难度.html","title":"蚂蚁金服共享智能技术实践：如何降低数据共享的难度","keywords":"","body":"蚂蚁金服共享智能技术实践：如何降低数据共享的难度 解决数据孤岛，在满足隐私保护和数据安全的前提下，在不同的组织、公司与用户之间进行数据共享。 为了解决这一问题，国内外不少科技公司先后推出了解决方案，比如谷歌推出的联邦学习、蚂蚁金服提出的共享智能等 当前，业界解决隐私泄露和数据滥用的数据共享技术路线主要有两条。 一条是基于硬件可信执行环境（TEE：Trusted Execution Environment）技术的可信计算， 另一条是基于密码学的多方安全计算（MPC：Multi-party Computation）。 TEE 字面意思是可信执行环境，核心概念为以第三方硬件为载体，数据在由硬件创建的可信执行环境中进行共享。 目前在生产环境可用的 TEE 技术，比较成熟的基本只有 Intel 的 SGX 技术，基于 SGX 技术的各种应用也是目前业界的热门方向，微软、谷歌等公司在这个方向上都有所投入。 MPC（Multi-party Computation，多方安全计算）一直是学术界比较火的话题，但在工业界的存在感较弱，之前都是一些创业小公司在这个方向上有一些探索，例如 Sharemind，Privitar，直到谷歌提出了基于 MPC 的在个人终端设备的“联邦学习”(Federated Learning）的概念，使得 MPC 技术一夜之间在工业界火了起来。 人工智能目前存在的难题是鱼与熊掌不可兼得，也就是隐私性跟可用性难以兼顾。 如果想要 AI 系统发挥作用，就可能需要牺牲隐私。但是，在大量真实场景中，如果做不到同时兼顾隐私和可用性，会导致很多 AI 落地的困境。 随着对数据安全和重视和隐私保护法案的出台，曾经粗放式的数据共享受到挑战，各个数据拥有者重新回到数据孤岛的状态。 同时，互联网公司也更加难以收集和利用用户的隐私数据，数据孤岛反而成为了常态。如果希望更好的利用数据，就必须在满足隐私保护和数据安全的前提下，在不同的组织、公司与用户之间进行数据共享。 为了解决这一问题，国内外不少科技公司先后推出了解决方案，比如谷歌推出的联邦学习、蚂蚁金服提出的共享智能等。本文，InfoQ 对蚂蚁金服机器学习算法中台负责人周俊进行了采访，了解共享智能如何解决金融领域的数据共享问题。 参考 https://www.infoq.cn/article/UjafrLAg5V4v7Mj2TMTC Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/AI/ArtificialIntelligence人工智能.html":{"url":"docs/tech/AI/ArtificialIntelligence人工智能.html","title":"人工智能","keywords":"","body":"ArtificialIntelligence人工智能 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能的定义可以分为两部分，即“人工”和“智能”。 “人工”比较好理解，争议性也不大。有时我们会要考虑什么是人力所能及制造的，或者人自身的智能程度有没有高到可以创造人工智能的地步，等等。但总的来说，“人工系统”就是通常意义下的人工系统。 关于什么是“智能”，就问题多多了。这涉及到其它诸如意识（CONSCIOUSNESS）、自我（SELF）、思维（MIND）（包括无意识的思维（UNCONSCIOUS_MIND））等等问题。人唯一了解的智能是人本身的智能，这是普遍认同的观点。但是我们对我们自身智能的理解都非常有限，对构成人的智能的必要元素也了解有限，所以就很难定义什么是“人工”制造的“智能”了。因此人工智能的研究往往涉及对人的智能本身的研究。其它关于动物或其它人造系统的智能也普遍被认为是人工智能相关的研究课题。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/CloudComputing云计算.html":{"url":"docs/tech/others/CloudComputing云计算.html","title":"CloudComputing云计算","keywords":"","body":"CloudComputing云计算 云计算（英语：cloud computing），是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的电脑基建作计算和资源。 服务模式：美国国家标准和技术研究院的云计算定义中明确了三种服务模式： 1、软件即服务（SaaS）：消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Adobe Creative Cloud，Microsoft CRM与Salesforce.com。 2、平台即服务（PaaS）：消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine。 3、基础设施即服务（IaaS）：消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace。 部署模型：美国国家标准和技术研究院的云计算定义中也涉及了关于云计算的部署模型： 1、公有云（Public Cloud） 2、私有云（Private Cloud） 3、社群云（Community Cloud） 4、混合云（Hybrid Cloud） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/EdgeComputing边缘计算.html":{"url":"docs/tech/others/EdgeComputing边缘计算.html","title":"EdgeComputing边缘计算","keywords":"","body":"EdgeComputing边缘计算 边缘运算（英语：Edge computing），又译为边缘计算，是一种分散式运算的架构，将应用程序、数据资料与服务的运算，由网络中心节点，移往网络逻辑上的边缘节点来处理。边缘运算将原本完全由中心节点处理大型服务加以分解，切割成更小与更容易管理的部分，分散到边缘节点去处理。边缘节点更接近于用户终端装置，可以加快资料的处理与传送速度，减少延迟。在这种架构下，资料的分析与知识的产生，更接近于数据资料的来源，因此更适合处理大数据。 参考 https://www.jiqizhixin.com/graph/technologies/466f587d-614f-42ce-847a-4f731c93be4e Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/Front/Front前端.html":{"url":"docs/tech/Front/Front前端.html","title":"前端开发","keywords":"","body":"Front前端开发 前端框架 1、 2、 3、 4、 5、 前端js统计pv uv 百度统计、Google分析 1、 2、 3、 https://github.com/twbs/bootstrap Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/00.Tools开发工具.html":{"url":"docs/Tools/00.Tools开发工具.html","title":"开发工具","keywords":"","body":"Tools开发工具 开发工具 1、Maven学习 2、 3、 4、 5、 Maven学习 1、Maven工程标准架构、打包编译命令2、Maven详解Maven基本概念：仓库、jarMaven依赖管理和依赖冲突解决Maven生命周期关于scope依赖范围 工具：maven、gradle、ant+ivynexus、jenkinssonar、findbugs、 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/VCS.html":{"url":"docs/Tools/VCS/VCS.html","title":"版本控制系统VCS","keywords":"","body":" VCS介绍 Version Control Systems 版本控制是指对某些（通常是基于文本的）文档的修订编目。虽然术语“版本控制”通常与程序员相关，但它同样适用于作家、记者甚至大学生。自动跟踪文档修订和版本的常见服务示例包括 Google Docs 和 Dropbox。 试试看！在 Google Docs 中，只需点击“文件”->“查看修订历史”。在 Dropbox 中，只需右键单击已修改的文件，然后单击“查看以前的版本”。 Below is a list of these VCS, categorized by generation: First Generation SCCS (Source Code Control System) RCS (Revision Control System) Second Generation CVS (Concurrent Versions System) SVN (Apache Subversion) Perforce Helix Core Third Generation Git Mercurial BitKeeper Darcs (Darcs Advanced Revision Control System) Monotone Bazaar Fossil Pijul 参考he Evolution Of Version Control System (VCS) Internals Subversion (SVN)、Git、Mercurial 和 Bazaar 都是积极开发的版本控制软件解决方案目前IDEA支持Subversion (SVN)、Git、Mercurial Git, GitHub, SVN, Mercurial, Perforce Git vs Mercurial vs SVN(Subversion) SVN 与 Git 和 Mercurial 不同，因为它是一个所有用户都必须拉取和提交的单一存储库。 Git 和 Mercurial 有一个分布式模型。这意味着每台计算机上都有一个存储库，并且通常有一个“官方”存储库，人们会选择向其提交更改并从中提取。 Git 和 Mercurial 非常相似。我更喜欢 Mercurial，因为我发现它更易于使用。对于 2 人团队，我会推荐 Mercurial，但这只是我的意见。如果您不熟悉版本控制，那么您仍然需要花时间学习使用任何选项，但 Mercurial 对我来说似乎是最简单的。 要启动 Mercurial 存储库，您所要做的就是打开一个 shell 并 cd 到您想要进行版本控制的目录，然后输入hg init. 这将创建存储库。要将文件夹中的所有内容添加到存储库，请键入hg add .。以下是一些其他的各种命令： 要提交本地更改： hg commit -m \"Descriptions of changes\" 从服务器拉取到最新版本： hg pull 要推送本地更改： hg push 首先，它们是用什么语言编写的。我使用 Git 和 Mercurial 的经历非常相似，但我知道如果我想调整 Mercurial，我可以做到，因为它是用 Python 编写的。Git 至少有点用 C 语言，我不太熟悉。 Git 和 Mercurial 就是所谓的分布式。每个副本都是平等的，它们可以在临时基础上相互推送和拉取（使用该术语）更改。另一方面，Subversion 由一个单一的中央存储库组成，每个工作副本都是该中央服务器的从属，推拉（在这种情况下是提交和更新）来自它和它本身的更改。 为几个人安装 Git 或 Mercurial 包括获得对同一服务器的 SSH 访问权限并安装几个软件包。而对于 SVN，据我所知，您需要在 Apache 下配置和运行一个实际的服务器应用程序，然后使用 SSL 证书和 .htaccess 等来保护它。 对于我所有的个人项目，我使用 Mercurial 或 Git。如果我与一个大型团队一起工作，我可能会选择 Subversion，因为您可以获得集中式身份验证和托管。但是对于两个人，我会选择分布式的一个，因为这样您就不必搞乱集中式身份验证和托管。:-) Git 和 Mercurial 非常相似（但足够不同以保证谨慎）。另一方面，SVN 则完全不同：前两个是分布式 VCS，因此它们不需要中央服务器，而 SVN 则需要。一般来说，许多项目都在向分布式系统发展。 对于您的小项目，使用 Git 或 Mercurial 可能会更好。你选择哪一个本质上是一个品味问题，尽管我自己更喜欢 Git（并且更熟悉它）。您根本不需要设置服务器：您可以通过 SSH 推送/拉取更改，甚至可以通过电子邮件向彼此发送补丁（这可以直接从 VCS 完成，但有点麻烦）。您可以随时设置中央服务器，所有更改都将在那里。您可以使用例如 GitHub 或 Gitorious 来托管您的项目（如果您使用 Git，我不了解 Mercurial）。 参考Git vs Mercurial vs SVN2020 Version Control Software Comparison: SVN, Git, MercurialGit vs Mercurial vs SVN (Subversion)Git vs. SVN: Which version control system is right for you?Mercurial vs. Git: How Are They Different?version-control-systems-keep-your-code-in-order Github Github于2008年上线，目前，除了Git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。 Bitbucket Bitbucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。 Coding Coding.net 为软件开发者提供基于云计算技术的软件开发平台，包括项目管理，代码托管，运行空间和质量控制等等。 GitLab GitLab 提供丰富的 Git 代码管理功能，是目前主流的企业内部 Git 代码仓库解决方案。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/SVN学习.html":{"url":"docs/Tools/VCS/SVN学习.html","title":"SVN学习","keywords":"","body":"SVN常用命令之checkout、export Eclipse SVN插件安装 SVN常用命令之checkout、export svn checkout (co) — 从版本库取出一个工作副本。 关于export命令 导出一个干净的不带.svn文件夹的目录树 一般默认下载最新的代码！ 如果你想要下载指定版本的工程的话用： svn export -r 2232 http://10.11.22.11/svn/project001 svn co svn://20.26.20.144/products/runtime-config-center/runtime-config-prodaz/config-gateway-zjosb-cache/resources-sandun-static --username=yangzl --password=mypassword --no-auth-cache svn export --force --username yangzl --password mypassword http://10.11.20.81/svn/test/gateway/gateway-backend-parent/ gateway-backend-parent 参考https://blog.csdn.net/gengxiaoming7/article/details/50512195http://svnbook.red-bean.com/zh/1.6/svn.ref.svn.c.checkout.html SVN官方命令参考地址：http://www.subversion.org.cn/svnbook/nightly/svn.ref.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Git.html":{"url":"docs/Tools/VCS/Git/Git.html","title":"Git","keywords":"","body":" Git介绍 Git分支管理和提交注释规范 MacOS 给 Git(Github)设置代理（HTTP/SSH）设置代理（HTTP/SSH）) Git介绍 Git客户端： https://git-scm.com/ https://github.com/git/git https://github.com/git/git-scm.com https://git-scm.com/book/zh/v2 Git大文件存储，Git Large File Storage： https://git-lfs.github.com https://github.com/git-lfs/git-lfs .ignore插件： https://github.com/hsz/idea-gitignore https://github.com/github/gitignore https://www.gitbook.com/ https://github.com/GitbookIO/gitbook https://github.com/git-tips/tips https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git Git的gitattributes文件详解 https://blog.csdn.net/taiyangdao/article/details/78484623 Git分支管理和提交注释规范 Git分支管理规范：Git-flow方式 Git-flow工具：Sourcetree、IDEA插件（Git Flow Integration、GitToolBox、Git Commit Template） Git提交注释规范：(): // 提交消息头Message header Git提交注释日志规范 细节见：https://www.jianshu.com/p/d0ba3c2b678d 最广泛的 angular 规范 ，大家可以瞻仰下： https://github.com/angular/angular/commits/master 如何规范你的Git commit？ https://developer.aliyun.com/article/770277 IDEA插件 GitToolBox Git Flow Integration Git Commit Template Git上传文件报错 LFS upload missing objects, tried manually uploading git lfs fetch --all git lfs push --all origin master git config -f .lfsconfig lfs.url https://github.com/youngzil/notes.git/info/lfs MacOS给Git(Github)设置代理（HTTP/SSH） 分辨需要设置的代理 HTTP 形式： git clone https://github.com/owner/git.git SSH 形式： git clone git@github.com:owner/git.git 一、HTTP 形式 走 HTTP 代理 git config --global http.proxy \"http://127.0.0.1:8080\" git config --global https.proxy \"http://127.0.0.1:8080\" 走 socks5 代理（如 Shadowsocks） git config --global http.proxy \"socks5://127.0.0.1:1080\" git config --global https.proxy \"socks5://127.0.0.1:1080\" 取消设置 git config --global --unset http.proxy git config --global --unset https.proxy 二、SSH 形式 修改 ~/.ssh/config 文件（不存在则新建）： # 必须是 github.com Host github.com HostName github.com User git # 走 HTTP 代理 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080 # 走 socks5 代理（如 Shadowsocks） # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p 参考https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1 查看版本 git --version Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： $ git config --global user.name \"李老师\" $ git config --global user.email li@csdn.net 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Git常用命令.html":{"url":"docs/Tools/VCS/Git/Git常用命令.html","title":"Git常用命令","keywords":"","body":"Git常用命令速查表 Git常用命令速查表 Git 常用命令速查表(图文+表格) Git常用命令速查表（收藏大全） ------------------------------commit------------------------------ $ git status # 检查文件当前的状态 $ git add [文件名] # 追踪新的文件 $ git diff --cached # 若要看已经暂存起来的文件和上次提交时的快照之间的差异 $ git commit -m \"Story 182: Fix benchmark\" # 用一行命令提交更新 $ git commit -a -m 'added new benchmarks' # 跳过add命令直接提交 $ git rm --cached log.log # 从git仓库中删除不小心追踪的文件（用于gitignore之前追踪的文件） $ git mv file_from file_to # 移动文件/重命名文件 ------------------------------branch------------------------------ $ git branch # 查看分支 $ git branch -v # 查看各分支最后一个提交对象 $ git branch --merged # 查看已经merge过的分支 $ git branch --no-merged # 尚未merge的分支 $ git branch -d testing # 删除掉分支(如果还没有merge,会出现错误,-D可以强制删除) $ git branch -a # 查看所有分支（包括远程服务器） $ git push [远程仓库名] [本地分支名]:[远程分支名] # 推送本地分支到远程分支 # 如果本地分支名为空，则会直接删除远程分支名 $ git checkout -b iss53 # 新建分支并切换到新分支 =$ git branch iss53; git checkout iss53 $ git cherry-pick [id] # 合并某一个单独的commit ------------------------------log--------------------------------- $ git log --pretty=format:\"%h - %an, %ar : %s\" # 用特性的format查看log $ git log --graph # 用图表的形式显示git的合并历史 ------------------------------config--------------------------------- $ git config --global user.name \"John Doe\" # 配置用户名 ！仅第一次必须 $ git config --global user.email je@example.com # 配置电邮 ！仅第一次必须 $ git config --list # 查看配置信息 $ git config --global alias.stash-unapply '!git stash show -p | git apply -R' # 设置别名 ------------------------------stash------------------------------ $ git stash # 储藏当前工作内容 $ git stash save \"暂存区名字\" $ git stash list # 查看所有已经储藏的内容 $ git stash pop # 弹出一个储藏，恢复之前缓存的工作目录 这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。 $ git stash apply # 将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝。 $ git stash apply [stash@{0}] # 在当前工作区应用储藏的内容，默认最新 $ git stash apply --index # 在当前工作区应用储藏的内容，并保持之前暂存区的状态 $ git stash drop # 删除一个储藏 $ git stash drop stash@{0} $ git stash clear # 删除所有缓存的stash。 $ git stash show # 查看指定stash的diff,后面可以跟着stash名字 $ git stash show -p # 在该命令后面添加-p或--patch可以查看特定stash的全部diff git-stash用法小结 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Git命令学习.html":{"url":"docs/Tools/VCS/Git/Git命令学习.html","title":"Git命令学习","keywords":"","body":" Git下载代码、提交代码、查看记录、查看状态、提交、回滚 Git修改和配置用户名和邮箱 本地代码库回滚和远程代码库回滚 一、git clone 二、git remote 三、git fetch 四、git pull 五、git push Git恢复之前版本的两种方法reset、revert Git撤销中间某次提交 Git仓库分支(Branch)和标签(Tag)和标签(Tag)) Git推送tag到服务端 Git还原最近一次提交记录 Git撤销已经提交到远程服务器的commit Git查看提交记录 Git分支操作 廖雪峰的Git教程 Git下载代码、提交代码、查看记录、查看状态、提交、回滚 Git官网 https://git-scm.com/book/zh/v2 git使用用户名密码clone的方式： git clone http://username:password@remote eg: username: abc@qq.com, pwd: test, git地址为git@xxx.com/test.git git clone http://abc%40qq.com:test@git@xxx.com/test.git 注意：用户名密码中一定要转义 @符号转码后变成了%40 git clone http://abc%40qq.com:test@git@xxx.com/test.git $HOME/test 使用Git下载指定分支命令为：git clone -b 分支名仓库地址 使用Git下载v.2.8.1分支代码，使用命令：git clone -b v2.8.1 https://git.oschina.net/oschina/android-app.git 更新 git pull : 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 提交 git add . git commit -m \"add 3 files.\" // 一次性提交3个文件 git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 查看历史、状态 git log显示历史的提交列表 git show 便可以显示某次提交的修改内容 git show filename 可以显示某次提交的某个内容的修改信息。 git log --author=\"yangzl\" git status // 查看当前仓库状态（仓库下的工作区文件是否被修改过） 回滚 git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id git push origin :the_branch //删除远程 the_branch 比较版本不同 git diff readme.txt // 查看工作区的readme.txt与缓存区的readme.txt的区别 branch分支查看新建删除 查看本地都有哪些分支 git branch 查看所有的分支，包括远程的 git branch -a 删除本地的某个分支 git branch -D hongchangfirst 删除远程的分支 git branch -r -d origin/hongchangfirst 【git 删除远程分支】冒号前面的空格不能少，相当于把一个空分支push到server上，等于删除该分支。 git push origin :br (origin 后面有空格) 查看命令帮助 git switch -h git clone -h 参考 https://www.cnblogs.com/chris0710/p/8925977.html https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008 本地代码库回滚和远程代码库回滚 【本地代码库回滚】： git reset --hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除 git reset --hard HEAD~3：将最近3次的提交回滚 【远程代码库回滚】： 这个是重点要说的内容，过程比本地回滚要复杂 应用场景：自动部署系统发布后发现问题，需要回滚到某一个commit，再重新发布 原理：先将本地分支退回到某个commit，删除远程分支，再重新push本地分支 操作步骤： 1、git checkout the_branch 2、git pull 3、git branch the_branch_backup //备份一下这个分支当前的情况 4、git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id 5、git push origin :the_branch //删除远程 the_branch 6、git push origin the_branch //用回滚后的本地分支重新建立远程分支 7、git push origin :the_branch_backup //如果前面都成功了，删除这个备份分支 Git修改和配置用户名和邮箱 git修改提交作者和邮箱 用户名和邮箱地址的作用 用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。 每次commit都会用用户名和邮箱纪录。 github的contributions统计就是按邮箱来统计的。 查看用户名和邮箱地址： $ git config user.name $ git config user.email $ git config user.name \"yangzl\" git config user.email \"yangzl@XXX.com\" // 或者设置本地项目库配置，进入到仓库的根目录下面执行就可以了 git config user.name \"yangzl\" git config user.email \"youngzil@163.com\" 修改用户名和邮箱地址：设置全局 git config --global user.name \"yangzl\" git config --global user.email \"youngzil@163.com\" 参考 cnblogs.com/sunshinekevin/p/11617547.html https://blog.csdn.net/cxq2111504104/article/details/102931136 https://blog.csdn.net/diu_brother/article/details/51982993 § git clone § git remote § git fetch § git pull § git push 一、git clone 远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 $ git clone 比如，克隆jQuery的版本库。 $ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 $ git clone git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ SSH协议还有另一种写法。 $ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 二、git remote $ git remote origin 使用-v选项，可以参看远程主机的网址。 $ git remote -v origin git@github.com:jquery/jquery.git (fetch) origin git@github.com:jquery/jquery.git (push) 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 $ git clone -o jQuery https://github.com/jquery/jquery.git $ git remote jQuery 上面命令表示，克隆的时候，指定远程主机叫做jQuery。 git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show git remote add命令用于添加远程主机。 $ git remote add git remote rm命令用于删除远程主机。 $ git remote rm git remote rename命令用于远程主机的改名。 $ git remote rename 三、git fetch 一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 $ git fetch 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 $ git fetch 比如，取回origin主机的master分支。 $ git fetch origin master 所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 $ git branch -r origin/master $ git branch -a master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 $ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 git checkout 版本号 git reset HEAD $ git merge origin/master 或者 $ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 四、git pull git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull : 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin $ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。 Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 $ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用--rebase选项。 $ git pull --rebase : 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p 等同于下面的命令 $ git fetch --prune origin $ git fetch -p 五、git push git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git push : 注意，分支推送顺序的写法是:，所以git pull是:，而git push是:。 如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 $ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 $ git push origin :master 等同于 $ git push origin --delete master 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 $ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config --global push.default matching 或者 $ git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。 $ git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。 $ git push --force origin 上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。 最后，git push不会推送标签（tag），除非使用--tags选项。 $ git push origin --tags Git恢复之前版本的两种方法reset、revert git reset 原理： git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本 查看版本号： git log 使用“git reset --hard 目标版本号”命令将版本回退： git reset --hard 目标版本号 git log 使用“git push -f”提交更改： git push -f【此时如果用“git push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧】 git revert 原理： git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。 查看版本号： git log 2.使用“git revert -n 版本号”反做，并使用“git commit -m 版本名”提交： git revert -n 8b89621019c9adc6fc4d242cd41daeb13aeb9861 注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。 git commit -m \"revert add text.txt\" git log 3.使用“git push”推上远程库： git push 参考 https://blog.csdn.net/yxlshk/article/details/79944535 Git撤销中间某次提交 1、普通的简单提交，直接git revert然后push提交就好了 git revert 100047dcc 2、如果是撤销一个merge的提交， 先查看父commit_id：git log commit_id：比如Merge: 80d8b76f 7b8c0e95 git revert 100047dcc -m 1，参数 -m 就是指定要撤销的那个提价，从左往右，从1开始数；也就是我撤销的是80d8b76f，如果要撤销7b8c0e95，就是-m 2 接着其把代码冲突，然后我就解决冲突，保留主分支的代码，去掉那个人的代码。 然后push提交就好了 参考 https://blog.csdn.net/u013066244/article/details/79920012 Git仓库分支(Branch)和标签(Tag) 标签(Tag)也是属于仓库Repository的 一、tag 标签使用方法 列出标签git tag # //在控制台打印出当前仓库的所有标签 git tag -l ‘v0.1.*’ # //搜索符合模式的标签 2 打标签 客户端上操作： git clone http://admin@ald8.cn:8080/r/ald8.git //先连接下载分支 git checkout master //切到master git tag v1.00440376 -m \"20190424第一版\" //tag 自定义版本标识 版本id号 -m \"备注“ 切换标签（这个适用于代码回滚或切换到指定标签版本） git checkout [tagname] //与切换分支命令相同git checkout V1.02 //当前目录全部代码切换到V1.02时的代码 删除标签 客户端上操作：git tag -d v1.00 //删除本地标签 git push origin :v1.00 //删除git服务器上的标签 标签发布git push origin V1.00 //将V1.00标签提交到git服务器 git push origin --tags # //将本地所有标签一次性提交到git服务器 二、发布和回滚 代码第一次上线发布做版本标签 git tag v1.00 440376 -m \"20190424第一版\" //打标签 git push origin V1.00 //标签发布 git checkout v1.00 //开始切换版本到v1.00，文件结构会自动更新 第二次上线发布做版本标签git tag V1.01 [root@ald8 www]# cd /data/www/ald8[root@ald8 ald8]# git tag v1.010a7e9f -m \" 20190430\" //打标签 [root@ald8 ald8]# git push origin v1.01 //标签发布 [root@ald8 ald8]# cp -rp ald8 ald8.v1.00 //切换版本时先备份，可以应急手动快速回滚第一个版本 [root@ald8 ald8]# git checkout v1.01 //开始切换版本到v1.01，文件结构会自动更新 Previous HEAD position was 440376f... Initial commit HEAD is now at 0a7e9fc... 111 假如第二次发布的版本发现有bug，需要快速回滚到第一版本，这里有两种方式 A . 删除备当前版本目录文件ald8，再将第一版的备份文件ald8.v1.00改名成ald8即可. [root@ald8 /]# rm /data/www/ald8 -rf [root@ald8 /]# mv /data/www/ald8.v1.00 /data/www/ald8 B. 使用git切换版本的功能，直接执行切换命令即可 [root@ald8 /]# cd /data/www/ald8 [root@ald8 ald8]# git checkout v1.00 Previous HEAD position was 0a7e9fc... 111 HEAD is now at 440376f... Initial commit 这样就完成了版本的回滚。 参考 https://blog.csdn.net/iprettydeveloper/article/details/53944125 https://blog.csdn.net/cbuy888/article/details/89497440 https://www.cnblogs.com/senlinyang/p/8527764.html https://blog.csdn.net/jdsjlzx/article/details/98654951 Git推送tag到服务端 将tag同步到远程服务器 git push origin v20201215-RELEASE 推送所有： git push origin --tags 1.push单个tag推送 git push origin [tagname] 2.push所有tag git push --tags 或 git push origin --tags 很早之前，我们就提到过用git tag来给工程打上标签，但是这个命令只是在本地仓库打标签而已， 为了能把标签同步到远程服务器，我们可以这样做： 默认情况下，git push并不会把tag标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。 1.push单个tag，命令格式为：git push origin [tagname] 例如： git push origin v1.0 #将本地v1.0的tag推送到远端服务器 2.push所有tag，命令格式为：git push [origin] --tags 例如： git push --tags 或 git push origin --tags 以上命令经检验通过，如果不起作用，请在Git控制台上确认你的账号是否有权限推送Tag。这一点很重要，因为这个原因，我有过一段时间很抓狂。 创建Tag git tag -a tagName -m \"my tag\" 给指定的某个commit号加tag git tag -a v1.2 9fceb02 -m \"my tag\" 列出已有的tag git tag 查询远程tags的命令如下： git ls-remote --tags origin git删除tag git tag -d tagName 删除tag git push origin :refs/tags/tagName 删除远程 git push origin :refs/tags/2020-09-07-RELEASE 删除远程 git tag -d v20201215-RELEASE git push origin :refs/tags/v20201215-RELEASE tag重命名：先根据已有的tag创建一个新的tag推送到服务器，再删除 把【2020-09-07-RELEASE4】重命名为【v20200907-RELEASE】 git tag v20200907-RELEASE 2020-09-07-RELEASE4 git push origin v20200907-RELEASE git tag -d 2020-09-07-RELEASE4 git push origin :refs/tags/2020-09-07-RELEASE4 问题场景： 同事A在本地创建tagA并push同步到了远程->同事B在本地拉取了远程tagA(git fetch)->同事A工作需要将远程标签tagA删除->同事B用git fetch同步远端信息，git tag后发现本地仍然记录有tagA 分析：对于远程repository中已经删除了的tag，即使使用git fetch --prune，甚至\"git fetch --tags\"确保下载所有tags，也不会让其在本地也将其删除的。而且，似乎git目前也没有提供一个直接的命令和参数选项可以删除本地的在远程已经不存在的tag（我目前是没找到有关这类tag问题的git命令~~，有知道的同学可以告知我下，互相进步）。 解决方法： git tag -l | xargs git tag -d #删除所有本地分支 git fetch origin --prune #从远程拉取所有信息 git branch --contains Tag_V1.0.0 # 看看本地哪个分支包含这个tag/commit 查询远程tags的命令如下： git ls-remote --tags origin tag常用git命令： git tag #列出所有tag git tag -l v1.* #列出符合条件的tag（筛选作用） git tag [tag名] #创建轻量tag（无-m标注信息） git tag -a [tag名] #创建含注解的tag git push origin --tags #推送所有本地tag到远程 git push origin [本地tag名] #推送指定本地tag到远程 git tag -d [本地tag名] #删除本地指定tag git push origin :refs/tags/[远程tag名] #删除远程指定tag git fetch origin [远程tag名] #拉取远程指定tag git show [tag名] #显示指定tag详细信息 Git还原最近一次提交记录 首先先把本地的代码备份 git stash save 'message...可以添加一些注释' 显示保存进度的列表。也就意味着，git stash命令可以多次执行。 git stash list 版本号可用如下指令查看 git log remotes/origin/master 先在本地回退到需要的版本 git reset --hard 6f2c8c38 强制把本地提交到远端覆盖远端的【必须是自己提交后没有其他人提交】 git push origin master --force 更新代码 git pull 通过git stash pop命令恢复进度后，会删除当前进度。 git stash pop [–index] [stash_id] git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。 git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区） git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 git stash apply [–index] [stash_id] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。 git stash clear 删除所有存储的进度。 Git撤销已经提交到远程服务器的commit 0零【可选】、如果需要可以把本地的先暂存起来 git stash save \"暂存区名字\" 一、使用git log查看需要撤回的commitId git log 二、撤销： 方式一：//撤销commit，但不修改代码git reset commitId 方式二：//撤销commit，同时将代码恢复到对应ID的版本git reset --hard commitId 三、可以把本地的先暂存起来 git stash save \"暂存区名字\" 四、需要将撤销提交到远程服务器的执行 git push origin HEAD --force 五【可选】、如果执行了第 0零 步，需要还原在IDEA中最好可以直接使用可视化界面操作 git stash pop命令恢复之前缓存的工作目录 这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。 git stash apply命令，将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝。 参考https://www.cnblogs.com/pbblogs/p/11922638.html Git查看提交记录 git log --pretty=format:\"%h %s\" --graph --all | grep b2caf7f Git分支操作 查看电脑B本地仓库的分支 git branch 查看本地和远程仓库的所有分支 git branch -a 查看远程仓库的分支(其实用起来还没有直接 git branch -a 查看所有来得清晰) git branch -r 同步远程分支 git fetch 将本地分支与远程保持同步 git checkout -b 本地分支名x origin/远程分支名x 拉取远程分支并同时创建对应的本地分支 首先同步所有远程分支，如下： git branch -r | grep -v '->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done 将本地所有分支与远程保持同步 git fetch --all 最后拉取所有分支代码 git pull --all Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Github学习.html":{"url":"docs/Tools/VCS/Git/Github学习.html","title":"Github学习","keywords":"","body":"guide指导 https://guides.github.com/ video视频 youtube.com/githubguides 中文翻译 http://blog.csdn.net/fishycx/article/details/44992515 图标 https://shields.io/ https://github.com/aimuch/iGit GitHub项目中文排行榜GitHub趋势项目排行 GitHub Actions Extend GitHub:可以搜索Github的Apps和Actions插件 GitHub Actions 入门教程 Gitbook Action配置 Github App Extend GitHub:可以搜索Github的Apps和Actions插件 详解 Github App 的玩法 什么是 Github App 简单翻译一下，就是 Github App 可以通过 Github 提供的认证信息去调用 Github API。 Github 还提供了一个叫做“OAuth App”的东西，它的使用方式和 Github App 非常类似，最大的不同点是 OAuth App 所获取的权限都是固定且只读的，用户只能读取固定的数据而不能修改数据； 而 Github App 几乎可以获取Github提供的所有功能权限，且所获取的权限可以被设定为“只读”，“可读可写”和“禁止访问”，对于权限的授权粒度会更细。 GitHub Logos图标 章鱼猫Octocat图标 虽然有各种美妙的版本来诠释 GitHub 吉祥物章鱼猫的涵义，但根据创始人 PJ Hyett 的说法，章鱼猫出自另一个创始人 Tom Preston-Werner 从一个图片网站花 50 美元买来的图片（当然，他们现在完全拥有这个形象），目的只是为 404 页面找一张有趣的图片。 Octocat（章鱼猫）＝ Octopus（章鱼）+ Cat（猫） PJ Hyett 在 Quora 给出的解释 GitHub 员工 Zach Holman 也在一次演讲中提到了 Octocat 的来历： GitHub Logos and Usage Octodex图片 Python爬取章鱼猫Octocat全部图片 GitHub 吉祥物章鱼猫（Octocat）的来历是什么？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Git-flow.html":{"url":"docs/Tools/VCS/Git/Git-flow.html","title":"Git-flow","keywords":"","body":"brew install git-flow git flow version brew uninstall git-flow IDEA中要是报错：Git Flow Integration报告不支持的GITFLOW_VERSION 参考 https://github.com/OpherV/gitflow4idea/blob/develop/GITFLOW_VERSION.md 卸载git-flow brew uninstall git-flow 安装git-flow (AVH Edition) Stable release： brew install git-flow-avh Development release： brew install git-flow-avh --HEAD 进入项目根目录 git flow init -d git flow init [-d] 该-d标志将接受所有默认值。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/Git实际使用.html":{"url":"docs/Tools/VCS/Git/Git实际使用.html","title":"Mac通过git统计代码行数","keywords":"","body":"Git实际使用 通过git统计代码行数 统计一段时间内某个用户（提交记录）的增删行数 git log --author=\"lengfeng\" --since='2021-03-01' --until='2021-03-02' --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加的行数:%s 删除的行数:%s 总行数: %s\\n\",add,subs,loc }' 或者 git log --after=\"2021-03-02\" --before=\"2021-03-04\" --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 + $2 } END { printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc }' git扫描 Log 单独统计每个人的增删行数 git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 + $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -; done git统计某一开发者提交代码的增删改动行数和具体详细的改动内容 echo \"统计结果\" && git log --author=\"lengfeng\" --after=\"2018-04-16\" --before=\"2021-04-16\" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加行数:%s 删除行数:%s 变化总行数:%s\\n\",add,subs,loc }' && echo \"详情如下:\" && git log --word-diff --author=\"lengfeng\" --since=\"2018-04-16 00:00:01\" --until=\"2021-04-16 12:00:00\" -p --stat 其实合并了两条git命令一次性输出： git log --author=\"lengfeng\" --after=\"2018-04-16\" --before=\"2021-04-16\" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加行数:%s 删除行数:%s 变化总行数:%s\\n\",add,subs,loc }' 和 git log --word-diff --author=\"lengfeng\" --since=\"2018-04-16 00:00:01\" --until=\"2021-04-16 12:00:00\" -p --stat 参考Mac通过git统计代码行数统计本地Git仓库中不同贡献者的代码行数的一些方法统计代码git提交的行数 循环目录下所有项目设置Git用户和邮箱 setGitUserAndMail.sh #!/bin/bash # shellcheck disable=SC2045 echo \"全局用户：`git config --global user.name`\" echo \"全局邮箱：`git config --global user.email`\" for dir in $(ls .) do if [ -d $dir ] then cd $dir echo '----------------------------------------------------------------' echo \"当前文件夹是$dir\" echo \"用户：`git config user.name`\" echo \"邮箱：`git config user.email`\" git config user.name \"yangzl\" git config user.email \"youngzil@163.com\" echo \"设置用户和邮箱后\" echo \"用户：`git config user.name`\" echo \"邮箱：`git config user.email`\" cd ../ fi done Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/巧用GithubAction同步代码到Gitee.html":{"url":"docs/Tools/VCS/Git/巧用GithubAction同步代码到Gitee.html","title":"巧用GithubAction同步代码到Gitee","keywords":"","body":"一款实用的 GitHub Actions 小工具：Gitee Pages Actions https://my.oschina.net/doocs/blog/4408590 巧用GithubAction同步代码到Gitee http://yikun.github.io/2020/01/17/%E5%B7%A7%E7%94%A8Github-Action%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0Gitee/ 生成/添加SSH公钥： 本机执行： ssh-keygen -t rsa -C \"ypungzil@163.com\" cat ~/.ssh/id_rsa.pub 生成/添加SSH公钥参考 https://gitee.com/help/articles/4181#article-header0 添加SSH公钥 https://gitee.com/profile/sshkeys steps: name: Mirror the Github organization repos to Gitee. uses: youngzil/notes@master with: src: github/notes dst: gitee/notes dst_key: $ dst_token: $ account_type: user Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Git/通过Git分支来规范代码上线流程.html":{"url":"docs/Tools/VCS/Git/通过Git分支来规范代码上线流程.html","title":"通过Git分支来规范代码上线流程 ","keywords":"","body":"通过Git分支来规范代码上线流程 Git分支管理规范：Git-flow方式 Git-flow工具：Sourcetree、IDEA插件（Git Flow Integration、GitToolBox、Git Commit Template） Git提交注释规范：(): // 提交消息头Message header Git提交注释日志规范 细节见：https://www.jianshu.com/p/d0ba3c2b678d 最广泛的 angular 规范 ，大家可以瞻仰下： https://github.com/angular/angular/commits/master 或者 Git工作流: 主干开发tag上线 使用git的朋友应该都熟悉一些常见的工作流，比如主干开发分支上线和分支开发主干上线。 前者是指在master分支永远是开发版的最新代码，而分支上则是当前线上部署的代码，后者反之。 这里给大家介绍一个我个人非常习惯的流程：主干开发，Tag上线。 只用master分支，上线打tag 所谓Tag上线是指我们全程都只有一个master分支，所有代码都向master提交，当上线的时候我们会在当前版本上打一个tag, tag名就是版本号，比如v1.0.xxxx。 版本号可以根据一个简单的规则来定，v.主版本号.副版本号.HHmm。其中后面的HHmm表示上线时的小时和分钟， 例如今天下午17点的第一次上线可以叫v1.0.1700, 如果发现有问题18点又进行了一次上线，可以打一个名为v1.0.1800, 如果明天晚上又上线了一次，可以将版本号改为v1.1.2015。 使用这种打tag的方式上线有一个好处，那就是可以保留你所有的上线代码版本，你可以随时退回到任意一次上线的代码库，这样就比分支上线方便一些。 修复线上bug下面来看一个常见的场景，如果线上遇到bug需要修复而master分支已经提交了新开发的代码了该怎么办呢？ 非常简单，使用checkout命令，直接退回到最近一次上线的tag位置，然后以此为基准创建一个新的fix分支: git checkout fix-bug v1.1.2015 执行完以后就已经在新创建的fix-bug分支了，而且代码已经回到了最近一次上线的状态。 完成修复以后直接commit并打上新的tag, 比如v1.2.xxxx, 最后切回master分支，将fix-bug合并到master即可： git commit '修复xxx问题' git tag v1.2.xxxx git checkout master git merge v1.2.xxxx 非常简单，而且免除了一个代码库有众多分支难以管理的困扰。 参考https://blog.csdn.net/phpwww/article/details/44339647http://www.ruanyifeng.com/blog/2012/07/git.html Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/VCS/Mercurial.html":{"url":"docs/Tools/VCS/Mercurial.html","title":"Mercurial","keywords":"","body":"Git vs Mercurial vs SVN [duplicate] Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/Gitbook.html":{"url":"docs/Tools/Gitbook.html","title":"Gitbook","keywords":"","body":"Gitbook Gitbook介绍 Gitbook官网 Gitbook文档 Gitbook Github地址 Gitbook CLI Gitbook插件 GitBook文档（中文版） Setup and Installation of GitBook Gitbook使用 安装 GitBook：npm i gitbook-cli -g 初始化 GitBook 项目：gitbook init 安装 GitBook 依赖：gitbook install 打包 GitBook 项目：gitbook build 开启 GitBook 服务：gitbook serve GitBook 命令行查看：gitbook -help GitBook 版本查看：gitbook -V 我们在 终端 输入 gitbook serve 即可开启一个 localhost:4000 的服务，请在浏览器中输入 http://localhost:4000 即可访问服务。 生成电子书 GitBook 可以生成一个网站，但也可以输出内容作为电子书（ePub，Mobi，PDF）。 # Generate a PDF file $ gitbook pdf ./ ./mybook.pdf # Generate an ePub file $ gitbook epub ./ ./mybook.epub # Generate a Mobi file $ gitbook mobi ./ ./mybook.mobi Gitbook配置 book.json配置 基本信息、links、plugins、pluginsConfig等 book.json示例1 book.json示例2 GitBook相关配置及优化 使用 Gitbook 打造你的电子书 gitbook使用教程使用Git进行控制，并把项目托管到 GitBook.com（二）GitBook 简明教程 gitbook简单使用 GitBook插件整理 gitbook使用及book.json详细配置 电子书制作利器：GitBook GitBook - 快速打造可留言的博客 GitBook应用 Gitbook教程（小白入坑gitbook全过程） book.json部分配置参考 { \"title\": \"Kubernetes\", \"description\": \"Kubernetes \", \"language\": \"zh-hans\", \"author\": \"Jimmy\", \"plugins\": [ \"page-toc-button\", \"back-to-top-button\", \"image-captions\", \"-lunr\", \"-search\", \"search-plus\", \"-highlight\", \"prism\", \"prism-themes\", \"sitemap-general\" ], \"pluginsConfig\": { \"image-captions\": { \"caption\": \"图 _PAGE_LEVEL_._PAGE_IMAGE_NUMBER_：_CAPTION_\" }, \"prism\": { \"css\": [ \"prism-themes/themes/prism-ghcolors.css\" ] }, \"sitemap-general\": { \"prefix\": \"https://jimmysong.io/kubernetes-handbook/\" } } } Gitbook插件 可以在 plugins.gitbook.com 查找或者在 NPM 或者 Github 上找插件。 Gitbook 的插件在 NPM 上都是以 gitbook-plugin 开头的，很容易查找的。 Gitbook插件官方Github Gitbook插件官方文档 gitbook 入门教程之小白都能看懂的 Gitbook 插件开发全流程 GitBook v3.2.3 使用教程 gitbook 入门教程之实用插件(新增3个插件) GitBook 插件 gitbook常用的插件 GitBook插件整理 - book.json配置 Gitbook详解（五）-插件的配置和使用详解 GitBook 和它有趣的插件 gitbook 插件项目 Gitbook插件篇 推荐12个实用的gitbook插件 Gitbook插件推荐 Gitbook 插件和主题 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDE.html":{"url":"docs/Tools/IDE/IDE.html","title":"集成开发环境IDE","keywords":"","body":"IDE: 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。 IDE 由哪些部分组成？ IDE 通常由以下几个部分组成： 源代码编辑器：一个旨在帮助开发人员轻松编写软件代码的文本编辑器，特色功能包括：视觉提示突出显示语法、特定编程语言的自动补全功能、检查正在编写的代码是否存在错误。 本地构建版本自动化：这些实用工具可以在创建软件的本地构建版本时自动执行简单的可重复任务，如将计算机源代码编译成二进制代码、封装二进制代码、运行自动测试。 调试器：一个用于测试其他程序的程序，它能以图形方式显示原始代码中的错误位置。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDEA/IDEA学习.html":{"url":"docs/Tools/IDE/IDEA/IDEA学习.html","title":"IDEA学习","keywords":"","body":"IDEA官网 IDEA插件中心 IDEA主题样式 idea配置所在路径 IDEA问题解决参考 代码格式化模板 IDEA快捷键参考 IDEA插件.md IDEA注释配置.md Mac下IntelliJ IDEA快捷键大全.md 快捷键：快捷键提示插件Key Promoter X 快捷键补全代码https://www.zhihu.com/question/300830746/answer/1273966329 IDEA官网 IntelliJ IDEA https://www.jetbrains.com/ 官网https://www.jetbrains.com/idea/ 官方文档https://www.jetbrains.com/idea/documentation/ 下载地址：https://www.jetbrains.com/idea/download/ IDEA插件中心：http://plugins.jetbrains.com/ https://www.oschina.net/p/intellij+idea IntelliJ IDEA 被认为是当前 Java 开发效率最快的 IDE 工具。它整合了开发过程中实用的众多功能，几乎可以不用鼠标可以方便的完成你要做的任何事情，最大程度的加快开发的速度。简单而又功能强大。与其他的一些繁冗而复杂的 IDE 工具有鲜明的对比。 IDEA主题样式：http://www.riaway.com/ idea配置所在路径 Config:~/Library/Preferences/IdeaIC13 System:~/Library/Caches/IdeaIC13 Plugins:~/Library/Application Support/IdeaIC13 Logs:~/Library/Logs/IdeaIC13 IDEA问题解决参考 https://blog.csdn.net/heatdeath/article/category/7325258 代码格式化模板 https://github.com/krasa/EclipseCodeFormatter https://github.com/alibaba/p3c https://github.com/google/google-java-format https://github.com/google/styleguide IDEA快捷键参考 https://mp.weixin.qq.com/s/4UDT7J-_vpgSciYr_TZPWA Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDEA/IDEA插件.html":{"url":"docs/Tools/IDE/IDEA/IDEA插件.html","title":"IDEA插件","keywords":"","body":"IDEA插件 IDEA插件开发 Idea插件开发-开发自己的第一款idea插件IDEA插件开发（一）一个简单的表单demoIDEA 插件开发入门教程 IDEA常用插件 Key Promoter X 是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。对于想完全使用快捷键在IDEA的，这个插件就很有用。 代码检查相关 Alibaba Java Coding Guidelines - 阿里巴巴Java开发规约 Findbugs MetricsReloaded 代码复杂度检查 数据库相关 Free Mybatis plugin 快速在 Mybatis Mapper 类方法和 Mybatis mapper.xml sql 语句间相互定位。 MyBatis Log Plugin 这款插件是直接将 Mybatis 执行的 sql 脚本显示出来，无需处理，可以直接复制出来执行的 MybatisX 易用性相关 Rainbow Brackets 有多级括号的时候，不同级的括号颜色不一样，有助于弄清楚括号的对应关系。让你的左括号和对应的右括号(大小括号都可以)显示相同的颜色，以此快速看出括号的范围。 .ignore 生成各种ignore文件，一键创建git ignore文件的模板，免得自己去写 Maven Helper 查看 maven 包引用关系，快速定位有冲突的吧。比起 IDEA 自带的 Diagrams 更清晰好用。 String Manipulation 提供针对文本处理的操作，和 CamelCase 的功能类似，不过除了 camel 风格字符串转换，还包括很多强大的功能： Lombok 支持lombok的各种注解，从此不用写getter setter这些 可以把注解还原为原本的java代码 非常方便 GsonFormat 一键根据json文本生成java类 非常方便，地址：https://plugins.jetbrains.com/plugin/7654-gsonformat Translation 最好用的翻译插件，功能很强大，界面很漂亮，整合主流翻译插件,idea快捷键一键翻译.ctrl+shit+y，地址：https://plugins.jetbrains.com/plugin/8579-translation 插件名称 插件介绍 官网地址 Key promoter 快捷键提示 https://plugins.jetbrains.com/plugin/4455?pr=idea CamelCase 驼峰式命名和下划线命名交替变化 https://plugins.jetbrains.com/plugin/7160?pr=idea CheckStyle-IDEA 代码规范检查 https://plugins.jetbrains.com/plugin/1065?pr=idea FindBugs-IDEA 潜在 Bug 检查 https://plugins.jetbrains.com/plugin/3847?pr=idea MetricsReloaded 代码复杂度检查 https://plugins.jetbrains.com/plugin/93?pr=idea Statistic 代码统计 https://plugins.jetbrains.com/plugin/4509?pr=idea JRebel Plugin 热部署 https://plugins.jetbrains.com/plugin/?id=4441 CodeGlance 在编辑代码最右侧，显示一块代码小地图 https://plugins.jetbrains.com/plugin/7275?pr=idea GsonFormat 把 JSON 字符串直接实例化成类 https://plugins.jetbrains.com/plugin/7654?pr=idea Eclipse Code Formatter 使用 Eclipse 的代码格式化风格，在一个团队中如果公司有规定格式化风格，这个可以使用。 https://plugins.jetbrains.com/plugin/6546?pr=idea Codota 该插件的强大之处在于： 支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。 支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。 SequenceDiagram SequenceDiagram 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！ 在某个类的某个函数中，右键 --> Sequence Diagaram 即可调出。 UML Support 如果需要研究源码，内置 UML Support 插件可以很好地查看类继承关系。详细使用文档，参考：https://www.jetbrains.com/help/idea/class-diagram.html 2、lombok 地址：https://plugins.jetbrains.com/plugin/6317-lombok-plugin 支持lombok的各种注解，从此不用写getter setter这些 可以把注解还原为原本的java代码 非常方便。 3、p3c 地址：https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines 阿里巴巴出品的java代码规范插件 可以扫描整个项目找到不规范的地方 并且大部分可以自动修复 更多可看： https://github.com/alibaba/p3c/tree/master/idea-plugin 4、FindBugs-IDEA 地址：https://plugins.jetbrains.com/plugin/3847-findbugs-idea 检测代码中可能的bug及不规范的位置，检测的模式相比p3c更多， 写完代码后检测下 避免低级bug，强烈建议用一下，一不小心就发现很多老代码的bug。 6、Maven Helper 地址：https://plugins.jetbrains.com/plugin/7179-maven-helper 一键查看maven依赖，查看冲突的依赖，一键进行exclude依赖 对于大型项目 非常方便。 7、VisualVM Launcher 地址：https://plugins.jetbrains.com/plugin/7115-visualvm-launcher 运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配，某个对象占用了多大的内存，jvm调优必备工具。 8、GenerateAllSetter 地址：https://plugins.jetbrains.com/plugin/9360-generateallsetter 一键调用一个对象的所有set方法并且赋予默认值 在对象字段多的时候非常方便。 9、MyBatisCodeHelperPro 地址：https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro mybatis代码自动生成插件，大部分单表操作的代码可自动生成 减少重复劳动 大幅提升效率。 参考 https://juejin.im/entry/5c4f9f9d6fb9a049a5714c8c https://www.cnblogs.com/jajian/p/8081658.html 最全IDEA插件 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDEA/IDEA注释配置.html":{"url":"docs/Tools/IDE/IDEA/IDEA注释配置.html","title":"IDEA注释配置","keywords":"","body":"通过创建代码模板的方式 Preferences | Editor | Live Templates中 1、创建Template Group，MyTemplateGroup 2、创建Live Template，2个 1、类注释 cc 、class comment template /** $CLASS_NAME$ @Description: * @author：youngzil@163.com @Date $DATE$ $TIME$ @since 1.0.0 */ className()、date()、date() 2、方法注释 mc 、 method comment template /** $METHOD_NAME$ @Description: @param：$METHOD_PARAM$ @author：youngzil@163.com @Date $DATE$ $TIME$ @since 1.0.0 */ methodName()、methodParameters()、methodParameters() 在Preferences | Editor | File and Code Templates 中点击右侧的Includes中找到File Header，在里面输入如下 /** @ProjectName ${PROJECT_NAME} @ClassName ${NAME}.java @version 1.0.0 @Description TODO @author youngzil@163.com @createTime ${DATE} ${TIME} @Copyright yangzl Corporation */ *注： ${PACKAGE_NAME} : 包路径 ${NAME} : 文件名 ${USER} ： 主机用户名 ${DATE} ： 系统当前日期，格式为：yyyy/mm/dd ${TIME} ： 系统当前时间 格式为：HH:mm ${YEAR}：当前年 ${MONTH}：当前月 ${MONTH_NAME_SHORT} ： 月份名称简写；如：Jan, Feb, etc. ${MONTH_NAME_FULL} ： 月份名称全拼；如：January, February. ${DAY} ：当前天 ${DAY_NAME_SHORT} ：星期简写；如：Mon, Tue, etc. ${DAY_NAME_FULL}：星期全写；如：Mon, Tue, etc. ${HOUR} ： 当前小时 ${MINUTE} ：当前分钟 ${PROJECT_NAME} ： 项目名称 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDEA/IDEA热加载工具JRebel.html":{"url":"docs/Tools/IDE/IDEA/IDEA热加载工具JRebel.html","title":"IDEA热加载工具JRebel","keywords":"","body":"IDEA + Spring Boot 的三种热加载方案IDEA+JRebel实现全自动热部署 JRebel 激活码 2020 亲测可用 基于JRebel开发的MybatisPlus热加载插件 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/IDEA/Mac下IntelliJ IDEA快捷键大全.html":{"url":"docs/Tools/IDE/IDEA/Mac下IntelliJ IDEA快捷键大全.html","title":"Mac下IntelliJ IDEA快捷键大全","keywords":"","body":"Mac键盘符号和修饰键说明 ● ⌘ Command ● ⇧ Shift ● ⌥ Option ● ⌃ Control ● ↩︎ Return/Enter ● ⌫ Delete ● ⌦ 向前删除键（Fn+Delete） ● ↑ 上箭头 ● ↓ 下箭头 ● ← 左箭头 ● → 右箭头 ● ⇞ Page Up（Fn+↑） ● ⇟ Page Down（Fn+↓） ● Home Fn + ← ● End Fn + → ● ⇥ 右制表符（Tab键） ● ⇤ 左制表符（Shift+Tab） ● ⎋ Escape (Esc) 1、Command + D 复制当前行或选定的块 2、Option + Enter 显示意向动作和快速修复代码 导入包，import 3、Control + Option + O 优化import 4、Control + O 覆盖方法（重写父类方法），override 5、Control + I 实现方法（实现接口中的方法），implements 6、Control + J 快速查看文档 查看方法注释文档7、Command + N 生成代码，生成getter、setter等8、移动代码：Option + Shift + ↓ 9 alt + enter 修正错误 8、 Command + / 注释/取消注释与行注释 Command + Option + / 注释/取消注释与块注释9、Command + Option + L 格式化代码 10、 Tab / Shift + Tab 缩进代码 / 反缩进代码 11、 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Command + Shift + U 大小写切换 12、 Option + Delete 删除到单词的开头 Option + Fn + Delete 删除到单词的末尾 13、 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift + 加号 展开所以代码块 Command + Shift + 减号 折叠所有代码块14、 Command + W 关闭活动的编辑器选项卡 15、Command + ; Project StructureCommand + , Preferences设置16、17、18、19、20、 1、Compiler 设置编译2、Live Templates：设置快捷键psvm 也就是public static void main的首字母。如何像写一个System.out.println();就是sout依次还有在方法体内键入for会有一个fori的提示，选中然后tab键，就会自动创建一个for循环。知道了这个规律，应该还有很多类似的用法。更多的提示可以CTRL + j 可以查看，mac系统下是command＋j。3、Code Style --> java 设置格式化模板4、alt+enter 导入包5、Code Completion 开启自动提示：自动提示忽略大小写设置：找到“Code Completion”->点击Case sensitive completion后面的选择框，选中None，然后一路确 IntelliJ IDEA For Mac 快捷键 根据官方pdf翻译：https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf 在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，一个叫做：Mac OS X，一个叫做：Mac OS X 10.5+ 目前都是用：Mac OS X 10.5+ 有两套的原因：https://intellij-support.jetbrains.com/hc/en-us/community/posts/206159109-Updated-Mac-OS-X-keymap-Feedback-needed 建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。 Mac键盘符号和修饰键说明 ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩︎ Return/Enter ⌫ Delete ⌦ 向前删除键（Fn+Delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → ⇥ 右制表符（Tab键） ⇤ 左制表符（Shift+Tab） ⎋ Escape (Esc) 一、Editing（编辑） Control + Space 基本的代码补全（补全任何类、方法、变量） Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型） Command + Shift + Enter 自动结束代码，行末自动添加分号 Command + P 显示方法的参数信息 Control + J 快速查看文档 Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） Command + 鼠标放在代码上 显示代码简要信息 Command + F1 在错误或警告处显示具体描述信息 Command + N, Control + Enter, Control + N 生成代码（getter、setter、构造函数、hashCode/equals,toString） Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + Option + T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） Command + / 注释/取消注释与行注释 Command + Option + / 注释/取消注释与块注释 Option + 方向键上 连续选中代码块 Option + 方向键下 减少当前选中的代码块 Control + Shift + Q 显示上下文信息 Option + Enter 显示意向动作和快速修复代码 Command + Option + L 格式化代码 Control + Option + O 优化import Control + Option + I 自动缩进线 Tab / Shift + Tab 缩进代码 / 反缩进代码 Command + X 剪切当前行或选定的块到剪贴板 Command + C 复制当前行或选定的块到剪贴板 Command + V 从剪贴板粘贴 Command + Shift + V 从最近的缓冲区粘贴 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 Command + Shift + U 大小写切换 Command + Shift + ] / Command + Shift + [ 选择直到代码块结束/开始 Option + Fn + Delete 删除到单词的末尾 Option + Delete 删除到单词的开头 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift + 加号 展开所以代码块 Command + Shift + 减号 折叠所有代码块 Command + W 关闭活动的编辑器选项卡 二、Search/Replace（查询/替换） Double Shift 查询任何东西 Command + F 文件内查找 Command + G 查找模式下，向下查找 Command + Shift + G 查找模式下，向上查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径） Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） 三、Usage Search（使用查询） Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法 Command + Shift + F7 在文件中突出显示的用法 Command + Option + F7 显示用法 四、Compile and Run（编译和运行） Command + F9 编译Project Command + Shift + F9 编译选择的文件、包或模块 Control + Option + R 弹出 Run 的可选择菜单 Control + Option + D 弹出 Debug 的可选择菜单 Control + R 运行 Control + D 调试 Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 五、Debugging（调试） F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 跳出 Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点 Option + F8 计算表达式（可以更改变量值使其生效） Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） Command + Shift + F8 查看断点信息 六、Navigation（导航） Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ Command + Option + O 前往指定的变量 / 方法 Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 Esc 从工具窗口进入代码文件窗口 Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 Command + Shift + F4 关闭活动run/messages/find/... tab Command + L 在当前文件跳转到某一行的指定处 Command + E 显示最近打开的文件记录列表 Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置 Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方 Command + Shift + Delete 跳转到最后一个编辑的地方 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Option + Space, Command + Y 快速打开光标所在方法、类的定义 Control + Shift + B 跳转到类型声明处 Command + U 前往当前光标所在方法的父类的方法 / 接口定义 Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置 Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） Control + H 显示当前类的层次结构 Command + Shift + H 显示方法层次结构 Control + Option + H 显示调用层次结构 F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置 F4 / Command + 方向键下 编辑/查看代码源 Option + Home 显示到当前文件的导航条 F3选中文件/文件夹/代码行，添加/取消书签 Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 Control + 0...Control + 9 定位到对应数值的书签位置 Command + F3 显示所有书签 七、Refactoring（重构） F5 复制文件到指定目录 F6 移动文件到指定目录 Command + Delete 在文件上为安全删除文件，弹出确认框 Shift + F6 重命名文件 Command + F6 更改签名 Command + Option + N 一致性 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option + P 提取参数 八、VCS/Local History（版本控制/本地历史记录） Command + K 提交代码到版本控制器 Command + T 从版本控制器更新代码 Option + Shift + C 查看最近的变更记录 Control + C 快速弹出版本控制器操作面板 九、Live Templates（动态代码模板） Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住 Command + J 插入自定义动态代码模板 十、General（通用） Command + 1...Command + 9 打开相应编号的工具窗口 Command + S 保存所有 Command + Option + Y 同步、刷新 Control + Command + F 切换全屏模式 Command + Shift + F12 切换最大化编辑器 Option + Shift + F 添加到收藏夹 Option + Shift + I 检查当前文件与当前的配置文件 Control + ` 快速切换当前的scheme（切换主题、代码样式等） Command + , 打开IDEA系统设置 Command + ; 打开项目结构对话框 Shift + Command + A 查找动作（可设置相关选项） Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） 十一、Other（一些官方文档上没有体现的快捷键） Command + Shift +8 竖编辑模式/列编辑 一、Editing（编辑） ● ⌃Space 基本的代码补全（补全任何类、方法、变量） ● ⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型） ● ⌘⇧↩ 自动结束代码，行末自动添加分号 ● ⌘P 显示方法的参数信息 ● ⌃J, Mid. button click 快速查看文档 ● ⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） ● ⌘+鼠标放在代码上 显示代码简要信息 ● ⌘F1 在错误或警告处显示具体描述信息 ● ⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString） ● ⌃O 覆盖方法（重写父类方法） ● ⌃I 实现方法（实现接口中的方法） ● ⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） ● ⌘/ 注释/取消注释与行注释 ● ⌘⌥/ 注释/取消注释与块注释 ● ⌥↑ 连续选中代码块 ● ⌥↓ 减少当前选中的代码块 ● ⌃⇧Q 显示上下文信息 ● ⌥↩ 显示意向动作和快速修复代码 ● ⌘⌥L 格式化代码 ● ⌃⌥O 优化import ● ⌃⌥I 自动缩进线 ● ⇥ / ⇧⇥ 缩进代码 / 反缩进代码 ● ⌘X 剪切当前行或选定的块到剪贴板 ● ⌘C 复制当前行或选定的块到剪贴板 ● ⌘V 从剪贴板粘贴 ● ⌘⇧V 从最近的缓冲区粘贴 ● ⌘D 复制当前行或选定的块 ● ⌘⌫ 删除当前行或选定的块的行 ● ⌃⇧J 智能的将代码拼接成一行 ● ⌘↩ 智能的拆分拼接的行 ● ⇧↩ 开始新的一行 ● ⌘⇧U 大小写切换 ● ⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始 ● ⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete） ● ⌥⌫ 删除到单词的开头 ● ⌘+ / ⌘- 展开 / 折叠代码块 ● ⌘⇧+ 展开所以代码块 ● ⌘⇧- 折叠所有代码块 ● ⌘W 关闭活动的编辑器选项卡二、Search/Replace（查询/替换） ● Double ⇧ 查询任何东西 ● ⌘F 文件内查找 ● ⌘G 查找模式下，向下查找 ● ⌘⇧G 查找模式下，向上查找 ● ⌘R 文件内替换 ● ⌘⇧F 全局查找（根据路径） ● ⌘⇧R 全局替换（根据路径） ● ⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） ● ⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）三、Usage Search（使用查询） ● ⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法 ● ⌘⇧F7 在文件中突出显示的用法 ● ⌘⌥F7 显示用法四、Compile and Run（编译和运行） ● ⌘F9 编译Project ● ⌘⇧F9 编译选择的文件、包或模块 ● ⌃⌥R 弹出 Run 的可选择菜单 ● ⌃⌥D 弹出 Debug 的可选择菜单 ● ⌃R 运行 ● ⌃D 调试 ● ⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置五、Debugging（调试） ● F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 ● F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 ● ⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 ● ⇧F8 跳出 ● ⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点 ● ⌥F8 计算表达式（可以更改变量值使其生效） ● ⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 ● ⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） ● ⌘⇧F8 查看断点信息六、Navigation（导航） ● ⌘O 查找类文件 ● ⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ ● ⌘⌥O 前往指定的变量 / 方法 ● ⌃← / ⌃→ 左右切换打开的编辑tab页 ● F12 返回到前一个工具窗口 ● ⎋ 从工具窗口进入代码文件窗口 ● ⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 ● ⌘⇧F4 关闭活动run/messages/find/... tab ● ⌘L 在当前文件跳转到某一行的指定处 ● ⌘E 显示最近打开的文件记录列表 ● ⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 ● ⌘⇧⌫ 跳转到最后一个编辑的地方 ● ⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) ● ⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处 ● ⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 ● ⌥ Space, ⌘Y 快速打开光标所在方法、类的定义 ● ⌃⇧B 跳转到类型声明处 ● ⌘U 前往当前光标所在方法的父类的方法 / 接口定义 ● ⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置 ● ⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置 ● ⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） ● ⌃H 显示当前类的层次结构 ● ⌘⇧H 显示方法层次结构 ● ⌃⌥H 显示调用层次结构 ● F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置 ● F4 / ⌘↓ 编辑/查看代码源 ● ⌥ Home 显示到当前文件的导航条 ● F3选中文件/文件夹/代码行，添加/取消书签 ● ⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 ● ⌃0...⌃9 定位到对应数值的书签位置 ● ⌘F3 显示所有书签七、Refactoring（重构） ● F5 复制文件到指定目录 ● F6 移动文件到指定目录 ● ⌘⌫ 在文件上为安全删除文件，弹出确认框 ● ⇧F6 重命名文件 ● ⌘F6 更改签名 ● ⌘⌥N 一致性 ● ⌘⌥M 将选中的代码提取为方法 ● ⌘⌥V 提取变量 ● ⌘⌥F 提取字段 ● ⌘⌥C 提取常量 ● ⌘⌥P 提取参数八、VCS/Local History（版本控制/本地历史记录） ● ⌘K 提交代码到版本控制器 ● ⌘T 从版本控制器更新代码 ● ⌥⇧C 查看最近的变更记录 ● ⌃C 快速弹出版本控制器操作面板九、Live Templates（动态代码模板） ● ⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住 ● ⌘J 插入自定义动态代码模板十、General（通用） ● ⌘1...⌘9 打开相应编号的工具窗口 ● ⌘S 保存所有 ● ⌘⌥Y 同步、刷新 ● ⌃⌘F 切换全屏模式 ● ⌘⇧F12 切换最大化编辑器 ● ⌥⇧F 添加到收藏夹 ● ⌥⇧I 检查当前文件与当前的配置文件 ● §⌃, ⌃` 快速切换当前的scheme（切换主题、代码样式等） ● ⌘, 打开IDEA系统设置 ● ⌘; 打开项目结构对话框 ● ⇧⌘A 查找动作（可设置相关选项） ● ⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）十一、Other（一些官方文档上没有体现的快捷键） ● ⌘⇧8 竖编辑模式 Mac键盘符号和修饰键说明 ● ⌘ Command ● ⇧ Shift ● ⌥ Option ● ⌃ Control ● ↩︎ Return/Enter ● ⌫ Delete ● ⌦ 向前删除键（Fn+Delete） ● ↑ 上箭头 ● ↓ 下箭头 ● ← 左箭头 ● → 右箭头 ● ⇞ Page Up（Fn+↑） ● ⇟ Page Down（Fn+↓） ● Home Fn + ← ● End Fn + → ● ⇥ 右制表符（Tab键） ● ⇤ 左制表符（Shift+Tab） ● ⎋ Escape (Esc)一、Editing（编辑） ● ⌃Space 基本的代码补全（补全任何类、方法、变量） ● ⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型） ● ⌘⇧↩ 自动结束代码，行末自动添加分号 ● ⌘P 显示方法的参数信息 ● ⌃J, Mid. button click 快速查看文档 ● ⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） ● ⌘+鼠标放在代码上 显示代码简要信息 ● ⌘F1 在错误或警告处显示具体描述信息 ● ⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString） ● ⌃O 覆盖方法（重写父类方法） ● ⌃I 实现方法（实现接口中的方法） ● ⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） ● ⌘/ 注释/取消注释与行注释 ● ⌘⌥/ 注释/取消注释与块注释 ● ⌥↑ 连续选中代码块 ● ⌥↓ 减少当前选中的代码块 ● ⌃⇧Q 显示上下文信息 ● ⌥↩ 显示意向动作和快速修复代码 ● ⌘⌥L 格式化代码 ● ⌃⌥O 优化import ● ⌃⌥I 自动缩进线 ● ⇥ / ⇧⇥ 缩进代码 / 反缩进代码 ● ⌘X 剪切当前行或选定的块到剪贴板 ● ⌘C 复制当前行或选定的块到剪贴板 ● ⌘V 从剪贴板粘贴 ● ⌘⇧V 从最近的缓冲区粘贴 ● ⌘D 复制当前行或选定的块 ● ⌘⌫ 删除当前行或选定的块的行 ● ⌃⇧J 智能的将代码拼接成一行 ● ⌘↩ 智能的拆分拼接的行 ● ⇧↩ 开始新的一行 ● ⌘⇧U 大小写切换 ● ⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始 ● ⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete） ● ⌥⌫ 删除到单词的开头 ● ⌘+ / ⌘- 展开 / 折叠代码块 ● ⌘⇧+ 展开所以代码块 ● ⌘⇧- 折叠所有代码块 ● ⌘W 关闭活动的编辑器选项卡二、Search/Replace（查询/替换） ● Double ⇧ 查询任何东西 ● ⌘F 文件内查找 ● ⌘G 查找模式下，向下查找 ● ⌘⇧G 查找模式下，向上查找 ● ⌘R 文件内替换 ● ⌘⇧F 全局查找（根据路径） ● ⌘⇧R 全局替换（根据路径） ● ⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） ● ⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）三、Usage Search（使用查询） ● ⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法 ● ⌘⇧F7 在文件中突出显示的用法 ● ⌘⌥F7 显示用法四、Compile and Run（编译和运行） ● ⌘F9 编译Project ● ⌘⇧F9 编译选择的文件、包或模块 ● ⌃⌥R 弹出 Run 的可选择菜单 ● ⌃⌥D 弹出 Debug 的可选择菜单 ● ⌃R 运行 ● ⌃D 调试 ● ⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置五、Debugging（调试） ● F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 ● F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 ● ⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 ● ⇧F8 跳出 ● ⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点 ● ⌥F8 计算表达式（可以更改变量值使其生效） ● ⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 ● ⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） ● ⌘⇧F8 查看断点信息六、Navigation（导航） ● ⌘O 查找类文件 ● ⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ ● ⌘⌥O 前往指定的变量 / 方法 ● ⌃← / ⌃→ 左右切换打开的编辑tab页 ● F12 返回到前一个工具窗口 ● ⎋ 从工具窗口进入代码文件窗口 ● ⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 ● ⌘⇧F4 关闭活动run/messages/find/... tab ● ⌘L 在当前文件跳转到某一行的指定处 ● ⌘E 显示最近打开的文件记录列表 ● ⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 ● ⌘⇧⌫ 跳转到最后一个编辑的地方 ● ⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) ● ⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处 ● ⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 ● ⌥ Space, ⌘Y 快速打开光标所在方法、类的定义 ● ⌃⇧B 跳转到类型声明处 ● ⌘U 前往当前光标所在方法的父类的方法 / 接口定义 ● ⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置 ● ⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置 ● ⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） ● ⌃H 显示当前类的层次结构 ● ⌘⇧H 显示方法层次结构 ● ⌃⌥H 显示调用层次结构 ● F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置 ● F4 / ⌘↓ 编辑/查看代码源 ● ⌥ Home 显示到当前文件的导航条 ● F3选中文件/文件夹/代码行，添加/取消书签 ● ⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 ● ⌃0...⌃9 定位到对应数值的书签位置 ● ⌘F3 显示所有书签七、Refactoring（重构） ● F5 复制文件到指定目录 ● F6 移动文件到指定目录 ● ⌘⌫ 在文件上为安全删除文件，弹出确认框 ● ⇧F6 重命名文件 ● ⌘F6 更改签名 ● ⌘⌥N 一致性 ● ⌘⌥M 将选中的代码提取为方法 ● ⌘⌥V 提取变量 ● ⌘⌥F 提取字段 ● ⌘⌥C 提取常量 ● ⌘⌥P 提取参数八、VCS/Local History（版本控制/本地历史记录） ● ⌘K 提交代码到版本控制器 ● ⌘T 从版本控制器更新代码 ● ⌥⇧C 查看最近的变更记录 ● ⌃C 快速弹出版本控制器操作面板九、Live Templates（动态代码模板） ● ⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住 ● ⌘J 插入自定义动态代码模板十、General（通用） ● ⌘1...⌘9 打开相应编号的工具窗口 ● ⌘S 保存所有 ● ⌘⌥Y 同步、刷新 ● ⌃⌘F 切换全屏模式 ● ⌘⇧F12 切换最大化编辑器 ● ⌥⇧F 添加到收藏夹 ● ⌥⇧I 检查当前文件与当前的配置文件 ● §⌃, ⌃` 快速切换当前的scheme（切换主题、代码样式等） ● ⌘, 打开IDEA系统设置 ● ⌘; 打开项目结构对话框 ● ⇧⌘A 查找动作（可设置相关选项） ● ⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）十一、Other（一些官方文档上没有体现的快捷键） ● ⌘⇧8 竖编辑模式 导航⌘O 查找类文件 Ctrl + N⌘⌥O 前往指定的变量 / 方法 Ctrl + Shift + Alt + N⌃← / ⌃→ 左右切换打开的编辑tab页 Alt← / Alt→⎋ 从工具窗口进入代码文件窗口 ESC⌘L 在当前文件跳转到某一行的指定处 Ctrl + G⌘E 显示最近打开的文件记录列表 Ctrl + E⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 Ctrl + Alt + ← Ctrl + Alt + →⌘⇧⌫ 跳转到最后一个编辑的地方⌃H 显示当前类的层次结构 Ctrl + H⌘⇧H 显示方法层次结构⌃⌥H 显示调用层次结构F4 / ⌘↓ 编辑/查看代码源⌘⌥U 显示类UML图⌃J 查看注释编辑⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）⌥⌫ 删除到单词的开头⌘+ / ⌘- 展开 / 折叠代码块⌘F1 在错误或警告处显示具体描述信息⌘⌥L 格式化代码⌃⌥O 优化import⇧↩ 开始新的一行⌘⇧↩ 自动结束代码，行末自动添加分号⌃I 实现方法（实现接口中的方法）⇧F6 重命名文件或者变量⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）⌘P 显示方法的参数信息查找Double⇧ 查找任何东西⌘⇧F 全局查找（根据路径）⌘F 文件内查找⌘G 查找模式下，向下查找⌘⇧G 查找模式下，向上查找导航⌘⌥B 跳转到接口的实现⌘U 查看接口定义⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处⌃⇧B 跳转到类型声明处⌥ Space, ⌘Y 快速打开光标所在方法、类的定义⌘O 查找类文件⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/F12 返回到前一个工具窗口⎋ 从工具窗口进入代码文件窗口⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口F3选中文件/文件夹/代码行，添加/取消书签⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签⌃0…⌃9 定位到对应数值的书签位置⌘F3 显示所有书签⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）通用⌃⌘F 切换全屏模式 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/Eclipse/Eclipse快捷键.html":{"url":"docs/Tools/IDE/Eclipse/Eclipse快捷键.html","title":"Eclipse快捷键","keywords":"","body":" eclipse查看一个方法被谁引用的快捷键四种方法 1.（首推）双击选中该方法名，Ctrl+Alt+H，显示在Call Hierarchy显示 2.（次推）选中该方法名，Ctrl+Shift+G 就显示这个方法被谁引用了，在Search搜索 3.选中该方法名，Ctrl + H（全局搜索） 4.选中该方法名右键 reference Command+Shift+T 搜索文件，包含jar Command+Shift+R 搜索文件，不包含jar Ctrl + H 搜索文件内字符串 Command + T 查看一个类的子类或者实现 Ctrl+Alt+H 显示在Call Hierarchy显示 Command+Shift+G 在Search搜索显示 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/Eclipse/Eclipse插件安装.html":{"url":"docs/Tools/IDE/Eclipse/Eclipse插件安装.html","title":"Eclipse插件安装","keywords":"","body":"Eclipse插件安装 Eclipse插件 eclipse在线升级 http://download.eclipse.org/eclipse/updates/4.7 把网址“http://download.eclipse.org/eclipse/updates”复制到网址浏览器的上可以得到最新4.7等等版 Oxygen http://download.eclipse.org/releases/oxygen Enabled 1、安装eclipse 2、配置JDK 3、配置Maven 4、安装SVN（http://subclipse.tigris.org/update_1.12.x） 5、反编译工具enhanced-class-decompiler：Eclipse Marketplace 6、安装Egit（Eclipse Marketplace） 7、安装Servers： 1、如果不行再安装下一步，http://download.eclipse.org/webtools/repository/oxygen/---》Web Tools Platform (WTP) 3.9.1a，如果不行再安装下一步 2、（Help->InstallNew Software->\"Kepler\" repository(Web,XML\">http://download.eclipse.org/releases/kepler)->Web,XML, Java EE and OSGi Enterprise Development ->JST Server AdaptersExtensions(打勾选上该项)） 8、配置Tomcat 9、JUint（Eclipse自带） 10、TestNG：Eclipse Marketplace 或者 http://beust.com/eclipse 11、安装FindBugs 安装指引：http://findbugs.cs.umd.edu/eclipse/ 官方发布的http://findbugs.cs.umd.edu/eclipse 候选版本和正式版本的http://findbugs.cs.umd.edu/eclipse-candidate 所有版本的http://findbugs.cs.umd.edu/eclipse-daily，包括开发版本 参考 http://blog.csdn.net/xlxxcc/article/details/52056732 12、阿里Java代码规约检查插件P3C：https://p3c.alibaba.com/plugin/eclipse/update 13、EasyShell：Eclipse Marketplace 14、ShellEd：使用zip包安装的方式，先安装下面2个依赖插件 在http://sourceforge.net/projects/shelled/files/latest/download下载ShellEd的zip包 ShellEd依赖的： name: man-page viewer http://download.eclipse.org/technology/linuxtools/updates-nightly/ Name: Dynamic Languages Toolkit http://download.eclipse.org/technology/dltk/updates-dev/4.0-nightly/ 15、Lombok -Xbootclasspath/a:/Users/yangzl/mysoft/lombok/lombok-1.18.0.jar -javaagent:/Users/yangzl/mysoft/lombok/lombok-1.18.0.jar 16、idea 插件：JRebel和JProfiler，idea自带的jvm Profiler 是async-profiler，有些人在IDEA中配置了JRebel热部署，要想JRebel和JProfiler同时运行，就要改手动管理JProfiler session了。 17、Gradle 18、安装C++ 参考 http://blog.csdn.net/yuanguangyu1221/article/details/50564017 19、Sonar 20、 21、 22、 23、 24、 25、 26、 27、 28、 29、 30、 常用的插件 git： http://marketplace.eclipse.org/content/egit-git-integration-eclipse Spring： http://marketplace.eclipse.org/content/spring-tools-aka-spring-ide-and-spring-tool-suite sonar和findbugs： https://marketplace.eclipse.org/content/sonarlint https://marketplace.eclipse.org/content/findbugs-eclipse-plugin 反编译： http://marketplace.eclipse.org/content/enhanced-class-decompiler gradle： http://marketplace.eclipse.org/content/buildship-gradle-integration testNG和junit： http://marketplace.eclipse.org/content/testng-eclipse http://marketplace.eclipse.org/content/junit-5-support-oxygen jboss： http://marketplace.eclipse.org/content/jboss-tools python： http://marketplace.eclipse.org/content/pydev-python-ide-eclipse eclipse皮肤： http://marketplace.eclipse.org/content/eclipse-color-theme http://marketplace.eclipse.org/content/darkest-dark-theme shell： http://marketplace.eclipse.org/content/easyshell ShellEd：使用zip包安装的方式 在http://sourceforge.net/projects/shelled/files/latest/download下载ShellEd的zip包 ShellEd依赖的： name: man-page viewer http://download.eclipse.org/technology/linuxtools/updates-nightly/ Name: Dynamic Languages Toolkit http://download.eclipse.org/technology/dltk/updates-dev/4.0-nightly/ 。 Python插件 www.python.org上进行下载 这里也主要分为底层语言支持的安装及eclipse插件的安装。 1、双击下载好的python-2.7.11.amd64.msi进行python的相关安装，有的时候可能双击后一闪而过，这可能是你下载的文件有问题重新下载应该就可以解决。 2、狂点下一步，直至安装完成。 3、将python的安装目录(这里为：D:\\python)添加到环境变量，然后在命令行中输入\"python -V\"，即可看到相应的python版本号为2.7.11。 余下的部分就是安装eclipse的python相关插件，并对eclipse进行相关的配置。 打开eclipse，点击\"Help\" --> \"Eclipse Marketplace\"，输入\"pydev\"，点击\"Find\" 点击\"Install\"，安装完后会重启eclipse。 接下来就是配置PyDev的过程了。 点击eclipse的\"Window\" --> \"Preferences\" --> \"PyDev\" --> \"Interpreters\" --> \"Python Interpreter\" --> \"New\" 在弹出的菜单中点击\"Browse\"，选择前面安装python后所生成的python.exe文件。 至此，PyDev的配置已经完成 在Eclipse中安装pydev插件 启动Eclipse, 点击Help->Install New Software... 在弹出的对话框中，点Add 按钮。 Name中填:Pydev, Location中填http://pydev.org/updates 然后一步一步装下去。 如果装的过程中，报错了。 就重新装。 配置pydev解释器 安装好pydev后， 需要配置Python解释器。 在Eclipse菜单栏中，点击Windows ->Preferences.在对话框中，点击pyDev->Interpreter - Python. 点击New按钮， 选择python.exe的路径, 打开后显示出一个包含很多复选框的窗口. 点OK 如果是Mac系统， 点击“Auto Config” 按钮 开始写代码 启动Eclipse, 创建一个新的项目, File->New->Projects... 选择PyDev->PyDevProject 输入项目名称. 新建 pyDev Package. 就可以写代码了。 输入包名，这里输入Test1 https://www.cnblogs.com/Bonker/p/3584707.html 参考 http://blog.csdn.net/yuanguangyu1221/article/details/50571339 Scala插件 http://www.scala-lang.org/ https://github.com/scala/scala http://scala-ide.org/ 首先，你需要去Scala的官网上载你需要的安装包 双击进行安装 输入scala -version，可以看到说明Scala已经安装完成，你可以直接输入scala以进入解释器模式。下面则用来配置eclipse的开发环境 eclipse scala插件安装 打开eclipse，并点击\"Help\"选择其中的\"Eclipse Marketplace\"，并输入scala，而后点击搜索 点击\"Scala IDE 4.7.x\"相对应的\"Install\"按钮，进行安装。 安装Maven-Scala插件 有两种方法： 一是从http://alchim31.free.fr/m2e-scala/update-site/下载， 二是通过Eclipse配置安装。 安装m2e-scala http://alchim31.free.fr/m2e-scala/update-site/ 通过Eclipse配置安装。 第一步：添加远程的原型或模板目录：http://repo1.maven.org/maven2/archetype-catalog.xml 第二步：新建Archetype，因为maven默认没有Group Id: net.alchim31.maven Artifact Id: scala-archetype-simple Version:1.6 创建maven项目适合选择Select an Archetype时候选择scala-archetype-simple类型 参考 http://blog.csdn.net/yuanguangyu1221/article/details/50889522 SVN插件 https://github.com/subclipse SVN:http://subversion.apache.org/ eclipse marketplace： http://marketplace.eclipse.org/content/subversive-svn-team-provider http://marketplace.eclipse.org/content/subclipse https://www.eclipse.org/subversive/ TortoiseSVN网址：https://tortoisesvn.net/ subclipse插件网址：http://subclipse.tigris.org/ subclipse插件包下载: http://subclipse.tigris.org/servlets/ProjectDocumentList?folderID=2240 打开Eclipse 4.4，点击菜单Help—>Install New Software 进入安装窗体后，点击安装窗体的Add按钮，然后在弹出的窗体中输入插件安装地址 http://subclipse.trigris.org/update_1.8.x 对应TortoiseSVN 1.7.x 版本 http://subclipse.trigris.org/update_1.10.x 对应TortoiseSVN 1.8.x 版本 http://subclipse.tigris.org/update_1.12.x 对应TortoiseSVN 1.9.x 版本，为目前最高版本的SVN插件(截止到2017年1月20日)， Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/IDE/Eclipse/使用Eclipse进行远程调试.html":{"url":"docs/Tools/IDE/Eclipse/使用Eclipse进行远程调试.html","title":"使用Eclipse进行远程调试","keywords":"","body":"https://blog.csdn.net/catoop/article/details/50630095 下面说一下方法吧： 环境：Tomcat、Eclipse，做远程调试我们并不需要其他特殊插件 1、配置Tomcat/bin/startup.bat 在前面增加代码：SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 其中8000即为我们远程调试的端口，后面会用到。另外，该命令不可手工换行（博客显示的时候可能会被换行，实际配置的时候请注意）。 2、启动Tomcat 查看Tomcat控制台输出，能看到我们刚刚的配置已经生效，输出如下： 3、配置Eclipse 点击Eclipse上面的debug图标，选择Debug Configurations，打开窗口找到Remote Java Application， 双击 Remote Java Application 即可创建一个远程调试 选择源码、填写Host和Port，点击Debug即可进入Debug模式。 点击上面圈起来的图标（Disconnect）即可断开Debug模式。 断开Debug模式后，可以随时再开启Debug模式， =========================================================================================== JVM Configuration =========================================================================================== JAVAOPT=\"${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g\" JAVA_OPT=\"${JAVA_OPT} -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:SurvivorRatio=8\" JAVA_OPT=\"${JAVA_OPT} -verbose:gc -Xloggc:/dev/shm/mq_gc%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy\" JAVA_OPT=\"${JAVA_OPT} -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m\" JAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow\" JAVA_OPT=\"${JAVA_OPT} -XX:+AlwaysPreTouch\" JAVA_OPT=\"${JAVA_OPT} -XX:MaxDirectMemorySize=15g\" JAVA_OPT=\"${JAVA_OPT} -XX:-UseLargePages -XX:-UseBiasedLocking\" JAVA_OPT=\"${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${BASE_DIR}/lib\" JAVA_OPT=\"${JAVA_OPT} -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n\" JAVA_OPT=\"${JAVA_OPT} ${JAVA_OPT_EXT}\" JAVA_OPT=\"${JAVA_OPT} -cp ${CLASSPATH}\" Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/maven/Maven中optional和scope元素的使用.html":{"url":"docs/Tools/maven/Maven中optional和scope元素的使用.html","title":"Maven中optional和scope元素的使用","keywords":"","body":"Maven中optional和scope元素的使用 optional元素 这里的optional元素设置为true表示何意？optional是Maven依赖jar时的一个选项，表示该依赖是可选的，项目之间依赖不传递。不设置optional（默认）或者optional是false，表示传递依赖。 scope元素 scope元素主要用来控制依赖的使用范围，指定当前包的依赖范围和依赖的传递性，也就是哪些依赖在哪些classpath中可用。常见的可选值有：compile, provided, runtime, test, system等。 compile（编译） 默认值。compile表示对应依赖会参与当前项目的编译、测试、运行等，是一个比较强的依赖。打包时通常会包含该依赖，部署时会打包到lib目录下。比如：spring-core这些核心的jar包。 provided（已提供） provided适合在编译和测试的环境，和compile功能相似，但provide仅在编译和测试阶段生效，provide不会被打包，也不具有传递性。 runntime（运行时） runntime仅仅适用于运行和测试环节，在编译环境下不会被使用。比如编译时只需要JDBC API的jar，而只有运行时才需要JDBC驱动实现。 system system范围依赖与provided类似，不过依赖项不会从maven仓库获取，而需要从本地文件系统提供。使用时，一定要配合systemPath属性。不推荐使用，尽量从Maven库中引用依赖。 test（测试） scope为test表示依赖项目仅参与测试环节，在编译、运行、打包时不会使用。最常见的使用就是单元测试类了： scope依赖的传递性 其中B依赖A，C依赖B，传递性的关键是B依赖A时所设置的scope值，当B采用不同的值时对应的依赖关系如下：当B通过test或provided依赖A时，C不依赖A；当B通过runtime或compile依赖A时，C依赖A； 上面讲解scope的不同参数值，针对这些参数值，在多个项目中的依赖传递性如下： Maven中optional和scope元素的使用，你弄明白了？ Maven optional关键字透彻图解 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/Blog/Blog文章笔记写作系统.html":{"url":"docs/Tools/Blog/Blog文章笔记写作系统.html","title":"Blog文章笔记写作系统","keywords":"","body":"Blog文章笔记写作系统 可选方案 GitBook + GitBook/GitHub + GitBook/Travis/Github Actions + GitBook/Github Pages 在 master 上写 md，然后 push 到 master， Travis 自动执行 gitbook build，并且把生成好的文档 push 到 gh-pages，好让 pages 服务生效。 其他的开源Blog框架：Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll 打造完美写作系统：Gitbook+Github Pages+Github Actions 使用 travis + gitbook + github pages 优雅地发布自己的书 七大开源blog框架介绍 文件格式 可选文件格式 AsciiDoc Markdown HTML Word GitBook默认使用Markdown语法，从 2.0.0 版本起，GitBook也能支持AsciiDoc作为输入的格式了。 文档站点生成器 Gitbook VuePress docsify docsify 入坑指南与我放弃 Gitbook 的那些理由 使用Gitbook创建的云原生的书籍可供参考 CI工具 GitBook Travis Github Actions mdBook使用 可以使用Travis构建然后推送到gh-pages，也可以使用GitHub Action gitbook-action.yml示例 一文多发平台 ArtiPub (Article Publisher 的简称，意为 \"文章发布者\") 是一款开源的一文多发平台 ArtiPub一文多发平台 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/Blog/写文章的模板.html":{"url":"docs/Tools/Blog/写文章的模板.html","title":"写文章的模板","keywords":"","body":"写文章的模板 比如一个文章讲解CR（Code Review） what—什么是CR Why—为什么要引入CR Who—参与CR的主体 Where—不同的研发节点进行CR when--什么时候引入CR How--如何进行CR 多写，是有讲究的。特别是对于技术类的文章来说，为什么？因为技术文章是有套路或者说模板可循的。例如：介绍一个新技术 介绍技术名称和大概作用 抛出一个常见的问题 以往的技术是如何解决的 新技术是如何解决的 新技术在解决方案上对比旧技术的优势 新技术存在的问题与不足 展望新技术的发展和提出更多的应用场景 有条件的还可以提供性能测试结果等等，加强说服力 盘点国内免费好用的图床 CSDN博客园简书思否segmentfault开源中国OSCHINA腾讯云开发者社区知乎掘金阿里云开发者社区51CTO CSDN地址水印设置 x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_100,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdW5nemls,size_50,color_000FFF,t_70#pic_center Github地址水印设置 x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_100,text_aHR0cHM6Ly9naXRodWIuY29tL3lvdW5nemls,size_50,color_000FFF,t_70#pic_center Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/Blog/GitHubPages写博客方法.html":{"url":"docs/Tools/Blog/GitHubPages写博客方法.html","title":"GitHubPages写博客方法","keywords":"","body":"GitHubPages写博客方法 GitHubPages写博客方法： 一种是：GitHub Pages + Hexo 的方式 另外一种是：GitHub Pages + jekyll 的方式 一种是：GitHub Pages + Hexo 的方式： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 另外一种是：GitHub Pages + jekyll 的方式： http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html https://www.jianshu.com/p/9f71e260925d https://github.com/qiubaiying/qiubaiying.github.io/wiki/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/Pandoc.html":{"url":"docs/Tools/fileformat/Pandoc.html","title":"Pandoc标记语言转换工具","keywords":"","body":"Pandoc Pandoc介绍 Pandoc是使用Haskell语言编写的一款跨平台、自由开源及命令行界面的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”[3]。 Pandoc官网Pandoc Github Pandoc文档Pandoc’s Markdown 語法中文翻譯 Pandoc的使用 Pandoc的基本指令格式是： pandoc [options] [input-file] ... 简单的格式转换指令： pandoc -o output.html input.md 其中-o ouput.html表示输出文件为output.html，input.md是输入文件。 Pandoc会根据文件的后缀名自动判断格式，用户也可以显式地指定输入文件和输出文件格式： pandoc -f markdown -t html -o output.html input.md 其中-f markdown表示输入文件格式为Markdown，-t html表示输出文件格式为HTML。 --from and --to Pandoc wikiPandoc vs Multimarkdown Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/AsciiDoc.html":{"url":"docs/Tools/fileformat/AsciiDoc.html","title":"AsciiDoc文件","keywords":"","body":"AsciiDoc Lightweight markup language 轻量级标记语言（LML），也称为简单或人性化的标记语言，是一种标记语言与简单的，不引人注目的语法。 AsciiDoc规范 AsciiDoc两种实现： asciidoc-py： Python)实现 Asciidoctor： Ruby)实现 Asciidoctor文档 AsciiDoc Syntax Quick Reference 具有ADOC 文件扩展名的文件很可能是一个AsciiDoc文件。 简而言之，这些类型的ADOC文件用于将纯文本文件转换为易于阅读的格式，如HTML或PDF 。 什么是ADOC文件？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/markdown/Markdown.html":{"url":"docs/Tools/fileformat/markdown/Markdown.html","title":"Markdown文件","keywords":"","body":"Markdown Markdown介绍 Markdown编辑器推荐 Markdown介绍 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。[4]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。 markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 相比WYSIWYG编辑器 优点： 1、因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持markdown编辑模式。 所见即所得（英语：What You See Is What You Get，缩写：WYSIWYG）是由菲利普·威尔逊（Flip Wilson）所提出的一种计算机文本编辑器方面的技术，使得编辑文字时在屏幕上直接呈现最终显示效果，如打印到纸张上的效果，故也称可视化操作。今日此项技术通常是文书处理系统所必需的（TeX例外），但对于其他文档来说却不一定，例如HTML。 语法参考： https://daringfireball.net/projects/markdown/ https://github.com/younghz/Markdown https://www.appinn.com/markdown/ https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet https://yuhongjun.github.io/tech/2017/05/02/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88.html#1-%E6%96%9C%E4%BD%93%E5%92%8C%E7%B2%97%E4%BD%93 https://www.jianshu.com/p/191d1e21f7ed Markdown编辑器推荐 Markdown编辑器推荐 Typora 在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。 Typora 是一款支持实时预览的 Markdown 文本编辑器。看到Typora的第一眼，我就爱上了它。它没有专业软件那么复杂而难以上手的功能，却也没有为了简洁而妥协到难以使用，它的每一寸肌肤都恰到好处，与它相处的每一刻都十分愉悦。 由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 GFM 标准，它是由著名代码托管网站 GitHub 所制定的。Typora 主要使用的也是 GFM 标准。 Typora官网 Typora 完全使用详解Typora入门：全网最全教程2020Typora小白完全使用教程 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/markdown/Markdown语法.html":{"url":"docs/Tools/fileformat/markdown/Markdown语法.html","title":"Markdown语法","keywords":"","body":"Markdown语法 markdown编辑器语法——文字颜色、大小、字体与背景色的设置 https://blog.csdn.net/manjianchao/article/details/53668280 参考 http://xianbai.me/learn-md/article/extension/table.html 标题： h1级标题 h2级标题 h3级标题 h4级标题 h5级标题 h6级标题 锚点1级 锚点2级 锚点3级 锚点4级 锚点5级 锚点6级 锚点7级 锚点8级，可见7、8级都被忽略了 测试测试 测试2 分割线：三个以上的短线 即可作出分割线，有空行 分割线 三个或者三个以上的 - 或者 * 都可以。 示例： --- 图片语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 超链接：连接名称 我是链接名 点我刷新 超链接语法：超链接名title可加可不加 示例： 简书 百度 超链接名 示例 简书 另一种超链接写法：[链接名][链接代号] here 然后在别的地方定义 3 这个详细链接信息， 直接展示链接的写法：http://www.izhangbo.cn 键盘键 Ctrl+[ and Ctrl+] code格式：反引号 Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调： 斜体强调 粗体强调 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 这是引用的内容 这是引用的内容 这是引用的内容 图片 使用 icon 图标文字 段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 表格： Item Value value Computer $1600 sss Phone $12 ssss Pipe $1 sss 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有三个才行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 无序列表：使用 - 加一个空格（） 无需列表1 无序列表2 无序列表3 无序列表 语法： 无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表：使用 数字 加一个英文句点，点后面有空格是换行 有序列表 有序列表 有序列表 有序列表 有序列表 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 注意：序号跟内容之间要有空格 换行缩进形成代码区块 这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用 给引用的文本开始位置都加一个 '>'， 便可组成一个块引用。在块引用中，可以结合 其他markdown元素一块使用，比如列表。 强调 也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码... 代码... 代码... 单行代码 create database hero; 代码块 function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/markdown/模板.html":{"url":"docs/Tools/fileformat/markdown/模板.html","title":"md模板","keywords":"","body":"模板 整个文档内容，可以是文件名字 1、第一点内容 1、细点1 1、你好 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2、顶顶顶顶 2、细点2 3、细点3 2、第二点内容 1、哈哈哈哈 2、嘻嘻嘻 3、你好啊 3、第三点内容 你好啊 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/markdown/Markdown语法模板.html":{"url":"docs/Tools/fileformat/markdown/Markdown语法模板.html","title":"Markdown语法模板","keywords":"","body":"﻿# Markdown语法模板 @TOC 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F 替换：Ctrl/Command + G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 这个是加深文本颜色的 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片 链接: link. 图片: 带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 [ ] 计划任务 [x] 完成任务 创建一个表格 一个简单的表格是这么创建的： 项目 | Value -------- | ----- 电脑 | $1600 手机 | $12 导管 | $1 设定内容居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右 | 第一列 | 第二列 | 第三列 | |:-----------:| -------------:|:-------------| | 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： | TYPE |ASCII |HTML |----------------|-------------------------------|-----------------------------| |Single backticks|'Isn't this fun?' |'Isn't this fun?' | |Quotes |\"Isn't this fun?\" |\"Isn't this fun?\" | |Dashes |-- is en-dash, --- is em-dash|-- is en-dash, --- is em-dash| 创建一个自定义列表 Markdown : Text-to-HTML conversion tool Authors : John : Luke 如何创建一个注脚 一个具有注脚的文本。2 2. 注脚的解释 ↩ 注释也是必不可少的 Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过欧拉积分 $$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图： sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入 导出 如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Tools/fileformat/markdown/Typora模板.html":{"url":"docs/Tools/fileformat/markdown/Typora模板.html","title":"Typora模板","keywords":"","body":"Typora模板 删除 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/技术圈的反对种族歧视.html":{"url":"docs/tech/others/技术圈的反对种族歧视.html","title":"技术圈的反对种族歧视","keywords":"","body":"技术圈的反对种族歧视 为反对种族歧视，GitHub正在把master/slave等术语替换掉 GitHub同众多科技公司都表示支持移除那些可能冒犯黑人开发者的词汇，但GitHub是第一个在开源项目社区中真正作出行动的。 这包括删除诸如“master”和“slave”之类的术语，用“main/default/primary”和“secondary”之类的词替代。 而且还有“blacklist”和“whitelist”之类的术语用“allow list”和“deny/exclude list”替代。 首先，Android移动操作系统，Go编程语言，PHPUnit库和Curl文件下载实用程序已表示打算用中立的词来替换blacklist/whitelist这类有颜色歧义的名称。 类似地，OpenZFS文件存储管理器也适当的替换了用于描述存储环境之间关系的“master”和“slave”术语。 现在，几个开源项目正在将其默认Git存储库的名称从“master”更改为main，default，primary，root或其他名称等替代名称。 相关术语由来已久 master/slave的术语由来已久。2014年，当时Drupal项目首次尝试，使用“master/slave”代替“primary/replica”。 为反对种族歧视，GitHub正在把master/slave等术语替换掉 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/tech/others/系统名词.html":{"url":"docs/tech/others/系统名词.html","title":"系统名词","keywords":"","body":"系统名词 惊群效应 惊群效应（thundering herd） 惊群简单来说就是多个进程或者线程在等待同一个事件，当事件发生时，所有线程和进程都会被内核唤醒。唤醒后通常只有一个进程获得了该事件并进行处理，其他进程发现获取事件失败后又继续进入了等待状态，在一定程度上降低了系统性能。 解决：只唤醒一个等待进程 集群脑裂 HA高可用集群中\"脑裂\"问题 脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。 这就相当于原本一个集群，被分成了两个集群，出现了两个“大脑”，这就是脑裂。 对于这种情况，我们也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。 刚刚在说明脑裂场景时，有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会出现脑裂问题的，而不会出现的原因就跟过半机制有关。 https://www.cnblogs.com/kevingrace/p/7205846.htmlhttps://juejin.cn/post/6844903895387340813 羊群效应 羊群效应理论（The Effect of Sheep Flock），也称羊群行为（Herd Behavior）、从众心理。 zookeeper分布式锁避免羊群效应（Herd Effect） CPU的总线风暴 CLI和GUI 命令行接口（Command Line Interface，CLI） 图形用户界面（Graphical User Interface，简称GUI，又称图形用户接口） WebDAV 基于Web的分布式编写和版本控制Web Distributed Authoring and Versioning (WebDAV) 基于Web的分布式编写和版本控制（WebDAV）是超文本传输协议（HTTP）的扩展，有利于用户间协同编辑和管理存储在万维网服务器文档。WebDAV由互联网工程任务组的工作组在RFC4918中定义。 Web 分布式创作和版本控制 (WebDAV) 由一组辅助 HTTP/1.1 的方法、标头和内容类型，用于管理资源属性，创建和管理资源集合、URL 命名空间操作和资源锁定（避免碰撞）。 基于Web的分布式编写和版本控制RFC4918定义 Google透明度报告 Google透明度报告 包括： Google 安全浏览 网络上的 HTTPS 加密 。。。 阈值与阀值的区别 阈值是“正版”！ 阈值又叫临界值，是指一个效应能够产生的的最低值或最高。 这个词运用到各个邻域，包括建筑学、生物学、飞行、化学、电信、电学、心理学等，如生态阈值。在表达“界限”、“范围”的意思时应该用“阈”而不是“阀”。 阀值本来是没有的，国家的咬文嚼字工作组，通过统计全国人民使用词语的习惯，发现了阀值这个词。后来才被社科语言研究所收录的。 阈的意思是界限，故阈值又叫临界值，是指一个效应能够产生的最低值或最高值。此一名词广泛用于各方面，包括建筑学、生物学、飞行、化学、电信、电学、心理学等，如生态阈值。 一个领域或一个系统的界限称为阈，其数值称为阈值。在各门科学领域中均有阈值。 在PS中的阈值，实际上是基于图片亮度的一个黑白分界值，默认值是50%中性灰，即128，亮度高于128(50%的灰)的会变黑（可以跟滤镜中的其它――高反差保留，再用阈值效果会更好） 阀值和阈值有很多区别。不论是发音还是词义。 1、阀（fá）：形声。从门,伐声。本义:阀阅。即仕官人家自序功状而树立在门外左边的柱子。 2、阈（yù）：门槛、门限，泛指界限或范围。 在自动控制系统中能产生一个校正动作的最小输入值；刺激引起应激组织反应的最低值。 可见，其实阀值就是阈值的错写而已，并不存在阀值这个词，只是很多人不认识这个阈值的阈字，结果就让“阀值”大行其道了。 阙值，阈值，阀值，傻傻分不清 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/面试学习技术网站.html":{"url":"docs/Interview/面试学习技术网站.html","title":"面试学习技术网站","keywords":"","body":"面试学习技术网站 知识点相关 1.JavaGuide Github地址： https://github.com/Snailclimb/JavaGuide JavaGuide-Interview star: 64.0k 介绍: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 2.CS-Notes Github 地址：https://github.com/CyC2018/CS-Notes Star: 68.3k 介绍: 技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。 3. advanced-java Github地址：https://github.com/doocs/advanced-java star: 23.4k 介绍: 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习。 4.JCSprout Github地址：https://github.com/crossoverJie/JCSprout star: 21.2k 介绍: Java Core Sprout：处于萌芽阶段的 Java 核心知识库。 各种框架Demo学习示例代码tutorials Github地址：https://github.com/eugenp/tutorials 介绍: 涵盖了大多数框架的使用示例代码，java学习使用示例 各种框架Demo学习示例教程 地址：https://www.baeldung.com/ 介绍: 大多数框架的使用示例代码 5.toBeTopJavaer Github地址：https://github.com/hollischuang/toBeTopJavaer star: 4.0 k 介绍: Java工程师成神之路。 6.architect-awesome Github地址：https://github.com/xingshaocheng/architect-awesome star: 34.4 k 介绍:后端架构师技术图谱。 7.technology-talk Github地址： https://github.com/aalansehaiyang/technology-talk star: 6.1k 介绍: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识。 8.fullstack-tutorial Github地址： https://github.com/frank-lam/fullstack-tutorial star: 4.0k 介绍: fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试。 9.3y Github地址：https://github.com/ZhongFuCheng3y/3y star: 1.9 k 介绍: Java 知识整合。 10.java-bible Github地址：https://github.com/biezhi/java-bible star: 2.3k 介绍: 这里记录了一些技术摘要，部分文章来自网络，本项目的目的力求分享精品技术干货，以Java为主。 11.interviews Github地址: https://github.com/kdn251/interviews/blob/master/README-zh-cn.md star: 35.3k 介绍: 软件工程技术面试个人指南（国外的一个项目，虽然有翻译版，但是不太推荐，因为很多内容并不适用于国内）。 11.Java面试+Java学习指南 Github地址: https://github.com/AobingJava/JavaFamily star: 介绍: 【Java面试+Java学习指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 算法相关网站 1.LeetCodeAnimation Github 地址： https://github.com/MisterBooo/LeetCodeAnimation Star: 33.4k 介绍: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路）。 2.awesome-java-leetcode Github地址：https://github.com/Blankj/awesome-java-leetcode star: 6.1k 介绍: LeetCode 上 Facebook 的面试题目。 3.leetcode Github地址：https://github.com/azl397985856/leetcode star: 12.0k 介绍: LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。) HackerRank 地址：HackerRank 介绍: 该网站非常出名，大多数程序相关岗位的人都知道这个网站,而且都不需要配置任何编译开发环境 就可以直接开始写算法，函数一类的挑战题目。网站上也有很多算法题，难度从低到高，非常的全面，可以深入学习算法。 TopCoder 地址：TopCoder 介绍: TopCoder这个网站可以说是一个程序设计比赛的网站，成立于2001年，最早的在线编程竞技平台之一，网站提供了一系列的算法挑战，采用比赛、评分、支酬等方式吸引众多平面设计师和程序员业余工作。参赛者可使用代码编辑器直接进行在线作答，比拼获胜者可获得竞赛赞助方提供的奖励，大家可以上去那里跟来自全世界的程序员(事实上大多数也是大学生)进行更直接的交流。 Geekforgeeks 地址：Geekforgeeks 介绍: Geeksforgeeks是印度的一家致力于计算机科学的百科全书,根据不同的用户计算机水平而发布不同的难度等级,从基础到专家级,内容涵盖了编程、算法、面试问题等。 它有许多常见算法练习的解决方案。每个解决方案包括许多不同的方法，以及每种方法的复杂性，一种非常有帮助的网站。 Lintcode 地址：Lintcode 介绍: 支持中英双语，汇集了算法、数据结构，人工智能，系统设计等众多领域的题目，网站还会举办编程比赛，很多算法爱好者在这里切磋技艺。汇集了各大公司的算法面试题。有阶梯式训练题库,帮你选好应该刷的题目,在线刷题。 Codeforces 地址：Codeforces 介绍: Codeforces 又被戏称为 CF，是一家俄罗斯的网站，这里有很好的比赛，很好的题目，很好的选手，简称\"三好\"。是一个举办比赛、做题和交流的平台，网站自带blog功能，可以求助/发布题解。 地址：https://coderbyte.com/ 介绍: 地址：https://www.kaggle.com/ 介绍: 地址：https://www.codechef.com/ 介绍: 地址：https://codesignal.com/ 介绍: 九章算法 地址：九章算法 介绍: Codegym 地址：Codegym 介绍: Codegym是一个以Java为中心的平台，它比其他平台上都要更加深入的介绍Java，这个网站将理论和实践知识相结合，你可以在上面找到1200多个练习项目。主要具备以下特点：互动课程，这部分有500多小时的编程课程 内置IDE，帮助你解决实践问题 活跃的Java社区 这个平台通过游戏化和故事化让学习变得有趣 Treehouse 地址：Treehouse 介绍: Treehouse是另一个将编程知识简单化讲解的平台，它会教你处理特定项目所需的技能，比如创建一个APP，创建一个WordPress博客等。Treehouse支持所有流行的编程语言——Java、Python、c++、Ruby和其他语言，具有以下好处：现实环境中练习问题 与导师面对面的交流 离线访问 Khan Academy 地址：Khan Academy 介绍: 尽管Khan Academy没有Java或Python教程，但该平台是理解计算机科学基本概念的一个很好的起点，完成这些课程后，你将会了解数据结构相关的知识，掌握oOP概念，并获得“程序员思维”，具有以下特点： 免费的课程 涉及前端开发和数据库管理 易于使用的界面 有助于巩固知识的小测试 Udemy 地址：Udemy 介绍: Udemy是一个领先的在线教育平台，提供大多数编程语言课程，用户群体也相当大，课程分为收费和免费，这是由讲师决定，价格从10美元到几百美元不等，主要具有以下特点： 广泛的编程语言选择 可以按照自己的节奏获取学习材料 Code4Startup 地址：Code4Startup 介绍: 如果您想在创业领域获得更多实际经验，Code4Startup是一个很好的平台，可以很好地利用你的开发技能。这个项目允许初级程序员为实际的初创公司编写代码，同时，企业主可以节省招聘人才的费用。 除了作为一个实践场所，Code4Startup还为编程专业的学生提供了大量的免费课程。就我个人而言，Learn Ruby on Rails、Heroku和Wistia API等多个课程我都很喜欢。 One Month 地址：One Month 介绍: 如果你为“我如何在一个月内学会一门编程语言?”，请务必查看这个平台。这个编程网站可以帮助初级程序员快速掌握JS、Python和Ruby的基本概念，遗憾的是，该平台上的大多数课程都是付费，尽管少数免费课程，还有一个讨论编程热点新闻的博客。 PluralSight 地址：PluralSight 介绍: Pluralsight的课程从入门到高级，涵盖了所有流行的编程语言，以及数据科学的基础知识，主要具有以下特性： 课程范围广泛 有专门针对高级开发人员的课程 广泛的订阅计划 Coursera 地址：Coursera 介绍: 与Udemy一样，Coursera是另一个值得CS和编程学生学习的资源。与Udemy不同的是，该平台关注的是大学层面的深入研究，而不是实践理念。 这个平台是计算机科学专业的一个强大的资源，你可以通过它学习斯坦福大学、密歇根大学等学校的课程。 Freecodecamp 地址：Freecodecamp 介绍: 这是最大的技术社区之一，拥有相当广泛的教程和课程，这在我看来是其他网站都没法比的，你会在这里找到实用的、基于项目的作业——这就是为什么一旦你掌握了扎实的编程理论，最好还是去Freecodecamp看看的原因，与此同时，Freecodecamp上拥有大量的免费资源。 Codewars 地址：Codewars 介绍: Codewars是一个代码练习网站，能够培养程序员，特别是编程新手的逻辑思维能力，如果你经常对编程提不起动力学习，那么，Codewars你值得拥有，砌墙式进阶的方式会让你对编程更加感兴趣。除了刷题进阶之外，它的社区也值得关注，在这里你可以看到许多困扰着程序员的问题，还有别人解答的解决方案 地址： 介绍: 地址： 介绍: 技术博客 朱小厮的博客 地址：https://blog.csdn.net/u013256816 介绍: DockOne 地址：http://dockone.io/ 介绍: Kubernetes相关 开源社 地址：https://kaiyuanshe.cn/ 介绍: 开源相关的资讯 中生代技术 地址：https://github.com/freshmantechnology 介绍: 各种技术交流 programcreek 地址：https://www.programcreek.com/ 介绍: Java、Python等代码示例网站 Java基础 地址：http://www.cnblogs.com/xrq730/category/731394.html 介绍: Java基础知识 Java学习博客 地址：https://my.oschina.net/ywbrj042 介绍: Netty、Dubbo等框架 Spring、Java等学习 地址：https://github.com/yqbjtu/springboot 地址：https://github.com/windwant/windwant-service 地址：https://blog.csdn.net/derrantcm/article/details/73456550 地址：https://blog.csdn.net/heatdeath/ 介绍: 2016年阿里中间件性能挑战赛亚军代码 地址：https://github.com/dongeforever/middlewarerace 介绍: MySQL教程 地址：https://github.com/jaywcjlove/mysql-tutorial 介绍: Redis、Netty、RabbitMQ、SpringBoot、SpringCloud学习博客 地址：https://blog.csdn.net/derrantcm/article/details/73456550 介绍: Java各种综合 地址：https://github.com/windwant/windwant-service 介绍: SpringBoot学习 地址：https://github.com/yqbjtu/springboot 介绍: dubbo源码解析 地址：https://mp.weixin.qq.com/s/pSnHnIyldAunJQEXO-kcww 地址：https://github.com/tianheframe/dubbo-2.6.5 介绍: java学习网址 地址：https://www.mkyong.com/java/java-properties-file-examples/ 地址：https://www.jianshu.com/u/f57de6e249f6 介绍: Bash 地址：https://github.com/denysdovhan/bash-handbook 介绍: GoLang 地址：https://github.com/qyuhen/book 地址：https://github.com/chai2010/advanced-go-programming-book 介绍: Python 地址：https://github.com/realpython/python-guide 地址：https://github.com/eastlakeside/interpy-zh 介绍: Docker 地址：https://github.com/yeasy/docker_practice 介绍: DeepLearning深度学习 地址：https://github.com/exacity/deeplearningbook-chinese 地址：https://github.com/exacity/deeplearningbook-chinese 地址：https://github.com/rasbt/python-machine-learning-book 地址：https://github.com/fchollet/deep-learning-with-python-notebooks 地址： 介绍: 大型网站技术架构：摘要与读书笔记 地址：https://www.cnblogs.com/xybaby/p/8907880.html 介绍: https://github.com/justjavac/free-programming-books-zh_CN https://github.com/dypsilon/frontend-dev-bookmarks https://github.com/jobbole/awesome-programming-books https://github.com/hackerkid/Mind-Expanding-Books https://github.com/many-books/study-book https://github.com/EbookFoundation/free-programming-books https://github.com/programthink/books https://github.com/addyosmani/essential-js-design-patterns https://github.com/DuGuQiuBai/Java https://github.com/Pines-Cheng/share https://github.com/chunminglu/bookshttps://github.com/mynane/PDFhttps://github.com/javagrowing/JGrowing 码农周刊整理 地址：https://github.com/nemoTyrant/manong 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/简历和面试.html":{"url":"docs/Interview/简历和面试.html","title":"简历和面试","keywords":"","body":"简历和面试 设计模式、 加解密 面试题目 https://github.com/c-rainstorm/blog/blob/master/interview/%E9%98%BF%E9%87%8C%E4%BA%8C%E9%9D%A2%E5%87%86%E5%A4%87.md https://zhuanlan.zhihu.com/p/70020121 https://zhuanlan.zhihu.com/p/66160652 https://blog.csdn.net/afreon/article/details/79519131 面试过程： 4：问：项目中有哪些难点，是怎么克服的？答：。。。。回答的稀里糊涂的，自己都不知道说了啥(记得好像是说每一个都是难点)5：问：项目采用分布式开发，一共使用到了几个系统？分别是哪些？答：7个...后面的没回答上来(客户web层，客户service层，mq消息队列...)6：问：项目中有用到MQ，主要是实现哪些功能？答：发短信，发邮件7：问：怎样判断mq中的方法成功执行了或者执行失败答：通过状态，比如，A调用B，在A这边捕捉异常，通过返回状态进行判断。8：问：项目中的订单和商品是一个系统还是分的两个系统？答：2个9：怎样保证这两个系统中的数据同步？比如：用户下单后，需要在商品系统那边减库存，如何保证同步？( HR面： 业余爱好 为什么不参加竞赛？ 你觉得你在项目运行过程中作为组长是否最大限度发挥了组员的优势？具体事例？ 如何看待阿里在大数据方面的投入？对阿里的发展有什么建议？对蚂蚁金服的发展有什么看法？ 职业规划，今后想发展的工作方向 家乡在哪里，是否愿意长期在杭州发展？ 薪酬问题及入职情况 蚂蚁金服的总部还是在杭州，一共3轮面试，第一轮电话面试，也是最重要的技术面试，面试时间大约1个多小时，聊了Java的基础知识，容器类，线程安全和非安全的，多线程相关基础知识，实现方式，死锁的检查与排查，JVM内存模型，Java底层代码阅读，原子性，可见性实现原理，数据库相关，ACDI相关原则，乐观锁实现方案，分库分表理论，如何设计分库分表规则，分布式系统的相关理论，3原则，一致性hash原理，了解或使用过哪些开源的RPC框架，基本设计原理是什么，另外最基础的Spring，SpringMVC，ibatis等框架的使用当然是不可缺少的拉。 技术面试感觉下来要求的是一个广度，深度尚可，要对Java各方面都有所涉猎。 第二轮面试就是技术总监当面聊了，去上海office面见了技术总监，出乎意料的是没聊技术相关的，聊了一下过往经历，以及对公司业务发展方向的看法，人很nice，感觉不错。第三轮就是HR当面聊了，hr面嘛，3观要正，价值观要ok，然后就是薪资待遇福利交待，balabala 4.进程间通讯方式（IPC） 扩展：半双工（即数据只能在一个方向上流动）、全双工a、管道（无名管道）b、FIFO（命名管道）c、共享内存d、消息队列e、信号量 6.启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 首先java.exe 会帮助我们找到 JRE ，接着找到位于 JRE 内部的 jvm.dll ，这才是真正的 Java 虚拟机器 , 最后加载动态库，激活 Java 虚拟机器。虚拟机器激活以后，会先做一些初始化的动作，比如说读取系统参数等。一旦初始化动作完成之后，就会产生第一个类加载器―― Bootstrap Loader 1.加载字节码（启动类加载器，扩展类，应用程序类，自定义加载器） 2.验证格式 3.准备（分配内存） 4.解析（解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程） 5.初始化整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。 7.双亲委派a、类加载器分为启动类加载器，bootstrap classloader 加载JAVA_HOME/lib目录下面的classb、扩展类加载器extensnion classloader 加载JAVA_HOME/lib/ext目录下面的classc、程序类加载器application classloader 加载用户类路径（classpath）上所指定的类库d、自定义类加载器 继承ClassLoader抽象类 双亲委派机制：指的是类加载器收到类加载的请求有，将这个请求为派给父类加载器完成。若父类无法完成这个加载请求，子类加载器进行加载。*也就是说，所有的请求多会传送到顶层的启动类加载器，从顶层开始试图加载类，无法加载再向下传递。 打破双亲委派机制：JNDI 线程上下文类加载器。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。 OSGI 热部署 使用的是自定义的类加载器机制，每一个程序模块（bundle）都有一个自己的类加载器。 扩展问题a、能不能自己写一个java.lang.Object的类？如果能怎么写,如果不能为什么?不能自己写以\"java.\"开头的类，其要么不能加载进内存，要么即便你用自定义的类加载器去强行加载，也会收到1个SecurityException。 b、请设计一个能够在服务端执行的分析JVM中状态的程序。 8.classloader的功能和工作模式 JVM内存区域：堆（新生代、老年代）、栈（java虚拟机栈、native方法栈）、方法区（永久代）、程序计数器、 1、面试官可以先问你什么时候一个对象会被GC？　　 算法，根搜索算法，当一个对象不可达时，通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 2、接着继续问你为什么要在这种时候对象才会被GC？　　gc经常发生的是在堆区，堆区分为新生代、老年代，新生代分为一个eden空间和两个survivor空间。a、 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；b、 Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；c、发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。 方法区：存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代 3、接着继续问你GC策略都有哪些分类？标记-清除算法----------标记和清除效率低，而且产生一堆不连续的内存碎片复制算法------------将内存按照容量划分成几块，当某一块的用完之后，直接把存活的对象复制到另一块上面，然后把已使用的一次性清除掉。新生代用的比较多，划分比例为8：1:1，一个eden，两个survivor空间。每次可用的空间能够达到90%。 缺点是较多的复制操作，效率会变低，还会浪费空间。标记-整理算法----------标记之后，整理一下，然后清除掉。 老年代常用算法分代收集算法---------根据对象存活周期，将内存分为几块，根据不同的特点采用最适合的收集算法 4、你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？　　5、你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？　　6、你如果选出来了，继续问你，为什么要选择这个策略？ GCROOT哪里来的(哪些可以是GCROOT)？GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。主要有以下几种：a.虚拟机栈(栈桢中的本地变量表)中的引用的对象b.本地方法栈中JNI的引用的对象c.方法区中的类静态属性引用的对象d.方法区中的常量引用的对象 回收器：1、新生代，均使用标记-复制算法。serial收集器 单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。使用标记-复制垃圾收集算法ParNew收集器 serial的多线程版本，新生代收集器，使用标记-复制垃圾收集算法。可以和CMS一起使用，很重要。Parallel Scavenge收集器，也是多线程的垃圾收集器，但是和parNew的关注点不同，关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是CPU用于运行应用程序的时间和CPU总时间的占比，吞吐量 = 代码运行时间 / (代码运行时间 + 垃圾收集时间) 2、老年代：Serial Old收集器、Parallel Old收集器以及CMS收集器。Serial Old收集器 标记整理算法，单线程。 主要是在JDK1.5版本之前和Parallel Scavenge年轻代收集器配合使用，或者作为CMS收集器的后备收集器。Parallel Old收集器 标记整理算法，多线程。和Parallel Scavenge一样，是关注吞吐量的，经常和Parallel Scavenge一起使用。CMS收集器 目前老年代收集器中比较优秀的垃圾收集器。使用\"标记-清除\"算法的并发收集器，以获取最短停顿时间为目标的收集器。分为个阶段：1、初始标记 stop the world 2、并发标记 3、重新标记 stop the world 4、并发清除。 由于并发清理阶段，如果用户产生了垃圾对象，但是过了标记阶段，所以会产生浮动垃圾，因为不能像其他收集器那样等到完全填满了老年代以后才进行垃圾收集，需要预留一部分空间来保证当出现浮动垃圾的时候可以有空间存放这些垃圾对象。这个空间比例可以设置。 3、G1收集器：不区分所谓的新生代、老年代，将整个内存区域混合在一起，划分成不同的子区域。 在小范围内还是会划分成年轻代、老年代。采用不同的GC方式来处理。 是用什么GC可以设置的，例如java -Xmx10m -Xms10m -XX:+UseG1GC -XX:+PrintGCDetails TestDemo 类加载机制的简单连环炮。1、首先肯定是先问你Java的类加载器都有哪些2、回答了这些以后，可能会问你每个类加载器都加载哪些类？　　3、说完以后，可能会问你这些类加载之间的父子关系是怎样的？　　4、你在回答的时候可能会提到双亲委派模型，5、那么可以继续问你什么是双亲委派模型？　　6、你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？　　例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。 6、你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？看自己的类加载器的逻辑了，如果只重写了findClass方法并没有重写loadClass方法，就没有改变父类委托机制。如果改写了loadClass，就以自己改写的loadClass逻辑为准。a、重写findClass方法的自定义类，首先会通过父类加载器进行加载，如果所有父类加载器都无法加载，再通过用户自定义的findClass方法进行加载。b、重写loadClass来实现，可以在JVM的不同类加载器中保留具有相同全限定名的类，这种情况下，就有可能有大量相同的类，被不同的自定义类加载器加载到JVM中，并且这种实现方式是不符合双亲委派模型。 注意：defineClass 将二进制字节转换成Class类 class文件加载过程：加载（资源，将二进制字节文件存到方法区中）--》验证（文件格式）--》准备（分配类变量的内存空间、设置类变量初始值）--》解析（将常量池的符号引用转换为直接引用）--》初始化（执行java代码，初始化类变量和其他资源） Java的内存模型是怎么设计的？（线程之间的通信机制有两种共享内存和消息传递，java采用的是共享内存模型）a、java内存模型（JAVA Memory Model）描述的是一组规则或规范，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。所有的变量都存储在主存中，每条线程有自己的工作内存，工作内存保存了被该线程所使用到的变量的主内存的副本拷贝。线程对变量的所有操作，都要在工作内存中进行。线程之间的互相访问，也要通过主内存。b、Happens-Beforec、定义了8种操作：lock unlock read->load(不能单独出现) use assign store->write(不能单独出现)、 你回答了以后，还会继续问你为什么要这么设计？问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？只能保证可见性，不能保证写入操作的原子性。当且仅当满足以下条件时，才应该使用a、对变量的写入操作不依赖当前的值，或者只有单个线程更新变量的值。b、该变量不会与其他变量一起，纳入不变性条件。 你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。 ========================================================================================== 9.synchronized和lock的用法区别 各自底层原理synchronized：对象级别的同步块，底层包含monitorenter和monitorexit指令方法级别同步，底层是 ACC_SYNCHRONIZED 标识来判断Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。lock： 10.分布式锁11.如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源12.spring中的transactional注解，requestMapping注解的实现原理13.springMvc原理 如何集成web14.什么是缓存击穿 如何避免缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 15.自己做的项目对自己帮助很大的方面 成长的方面16.如何排查ooma、查看服务器运行日志、项目日志，捕捉到异常JAVA heap space （dump堆转储快照，用工具进行分析，确认到底是内存泄漏还是内存溢出，如果是内存泄漏，查看泄露对象为什么无法回收；如果不存在内存泄漏，说明对象都是必须存活的，则需要修改堆参数-Xms -Xmx）StackOverflowError 线程请求的栈深度大于虚拟机所允许的栈深度（-Xss设置栈内存大小）OutOfMemoryError 虚拟机在扩展栈时，无法申请到足够的空间PermGen space 运行时常量池溢出 or 方法区溢出unsafe.allocateMemory() 直接内存溢出b、查看linux日志 /var/log/message 看看有没有kill掉进程的记录c、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryError，当应用抛出OutOfMemoryError时生成dump文件。 dump文件的几种方式：1、使用jmap -dump命令2、使用jconsole工具3、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryErro4、使用hprof。启动虚拟机加入-Xrunhprof:heap=site，会生成java.hprof.txt文件。该配置会导致jvm运行非常的慢，不适合生产环境。（HPROF可以用来展示和跟踪cpu的使用情况，内存分配的统计数据等。不仅如此，它还支持对 java进程完整的内存dump，所有线程的monitor stats数据） jdk的命令行工具；1、jps 等同于ps，列出正在运行的虚拟机进程2、jstat 用于监视虚拟机各种运行状态信息（例如：jstat gc 2764 250 20）3、jinfo 实时地查看和调整jvm的各项参数4、jmap 用于生成堆转储快照5、jhat 堆转储快照的分析工具6、jstack java堆栈信息跟踪工具（一般多jstack几次才能看出来） jdk的可视化工具：1、JConsole2、VisualVM =====================================问题：Redis Bitmap是什么？ HikariCP连接池（号称性能最好的JDBC连接池:HikariCP）？常用的JDBC连接池包括：DBCP：单线程，性能较差，适用于小型系统C3P0：单线程，并发量低，性能不好BoneCP：一个高效、免费、开源的Java数据库连接池实现库，它的性能几乎是C3P0、DBCP的25倍。性能高于duridDruid：Druid是Java语言中最好的数据库连接池。能够提供强大的监控和扩展功能。特色：为分析监控设计；快速的交互式查询；高可用；可扩展。 springboot自动启动类?---------》答案：SpringApplication.run(); spring常用的接口和类，实现原理（在什么时候初始化，什么时候注入，什么时候调用）？BeanFactory.java，基本的接口类ApplicationContext.java，BeanFactory的扩展类1、DefaultListableBeanFactory是整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory集成自DefaultListableBeanFactory。XmlBeanFactory与DefaultListableBeanFactory不同的地方是XmlBeanFactory使用了自定义的XML读取器XmlBeanDefinitonReader,实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory接口。2、XmlBeanDefinitonReader集成自AbstractBeanDefinitionReader，完成了XML配置文件的读取过程。1）使用ResourceLoader将资源文件路径转换成对应的Resource文件2）通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件3）通过实现接口BeanDefinitonDocumentReader的DefaultBeanDefinitonDocumentReader类对Document进行解析，并使用BeanDefinitonParserDelegate对Element进行解析。3、XmlBeanFactory IOC容器的初始化过程：BeanDefiniton的Resource的资源定位、载入和注册的过程 GC，问怎么标记回收对象的，从GCROOT不可达的对象（根据四种引用关系，强软弱虚），GCROOT哪里来的(哪些可以是GCROOT)？java提供finalize()方法？GC和finalize()方法都是不可靠的 什么时候一个对象会被GC？答：GC发生在堆区，分为新生代和老年代。新生代还分为Eden和两个Survivor区域。a、对象优先在eden分配，当eden空间不够用的时候，发生minor gcb、当老年代空间不够用的时候，发生full gc，一般会伴随着一次minor gc，大对象直接进入老年代。c、发生minor gc时，会检测之前每次晋升到老年代的内存大小，是否大于当前的老年代的剩余大小。如果大于，则进行一次full gc。如果小于，则看是否允许担保失败，如果允许担保失败，则进行一次minor gc，如果不允许，进行full gc。 为什么要在这个时候对象才会被GC？GC策略都有哪些分类？答：标记-清除算法，产生不连续的内存空间，标记和清除效率不高 适用于老年代复制算法，浪费一部分空间，较多的复制操作，效率变低 适用于新生代标记-整理算法，整理需要时间，但是必要的 适用于老年代 这些策略分别都有什么优劣势？都适用于什么场景？给你举个实际的场景，让你选择一个GC的策略？为什么要选择这个策略？什么是gc，什么是cms算法？并发标记清除算法，分为4个步骤，初始标记-》并发标记-》重新标记-》并发清除。会产生浮动垃圾，就是重新标记过程中生产的垃圾，所以要保留一部分空间。 cms算法实现原理？整个过程是怎么样的？怎么避免full gc？1、system.gc() 调用大多数情况下会出发full gc，应该禁止使用。2、老年代空间不足 调优时尽量做到让对象在minor gc阶段呗回收，避免创建过大的对象和数组。3、永久代空间不足也会触发full gc。增大永久代空间、或者改成cms gc。4、cms gc出现promotion failed和concurrent mode failure两种状况会出现full gc。都是因为老年代空间不足造成的措施：增大survivor space、老年代空间或者调低触发并发gc的比例。5、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间6、堆中分配很大的对象，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。设置-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程 java g1垃圾收集器？ 类加载机制的相关问题：java的类加载器都有哪些？每个类加载器都加载哪些类？这些类加载器之间的父子关系是怎么样的？回答的时候可能会提到双亲委派模型，双亲委派模型是什么？java的类加载器为什么要使用双亲委派模型？如何自定义自己的类加载器？自己的类加载器和java自带的类加载器关系如何处理？bootstrapExtendsystem/appself defined 内存的相关问题：内存分为哪几部分？这些部分分别都存储哪些数据？一个对象从创建到销毁都是怎么在这些部分里存活和转移的？内存的哪些部分会参与GC的回收？java的内存模型是怎么设计的？为什么这么设计？回答：Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。在并发编程领域，有两个关键问题：线程之间的通信和同步。线程之间的通信机制有两种：共享内存和消息传递。Java的并发采用的是共享内存模型Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。 java线程、java线程池、java集合、java队列、java正则表达式、java native方法、JAVA泛型jdk和jre的区别 java、Spring中的ServletContext相关Spring的DispacherServlet和ContextLoaderListener中的WebApplicationContext的关系获取spring的ApplicationContext几种方式：直接创建（2种），工具类WebApplicationContextUtils，extends或者implements（ApplicationObjectSupport就是实现ApplicationContextAware） java nio的selector 和linux的epoll select，类似与epoll或者java里面的selector ZeroCopy和mmap思想 集合重写写equals，就必须重写hashCode？使用hash表的时候需要重写 Java基础概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO与文件、多线程、反射 ============================面试题：1、nio、Bio，aio的区别，大概机制，接口nio 同步非阻塞io（不等待，但是主动查询io是否完成），高并发的程序一般用这.Channel、Buffer、Selector Reactor就是Java的NIO。bio 同步阻塞io（等待操作完成）aio 异步非阻塞io（不等待，也不主动查询，io完成会主动通知） AsynchronousChannel、AsynchronousSocketChannel 2、数据库，innobd，隔离级别，行级锁3、分布式4、类加载器和双亲委派机制，何时破坏双亲委派机制5、几种垃圾回收器6、java8新特性，lamda，函数接口7、多线程：创建线程池，两个线程一个初始化，一个循环，改变一个值，并发包下接口类8、java虚拟机的内存模型，内存工作方式9、spring 、aop、ioc10、二叉树算法11、MySQL的事务级别，mybatis一个mapper实现两个sql12、多线程，100个子线程，执行完成，将结果返回主线程13、如何在大量数据中查找某一段的数据，不用limit14、dubbo的原理，结构15、整体介绍负载均衡架构16、多线程的好处？一定能加快运行速度么？因为线程切换也是需要时间的17、Integer和int类型，哪个放在堆内存？哪个在栈内存？ 18、堆里面和栈内存，分别是什么时候回收？19、outofmemory的问题，怎么定位？20、常用有哪些设计模式？21、一致性hash的实现原理 简历：SMART原则 1、同盾科技面试2、公司面试总结3、招聘要求4、公司面试注意事项5、别人的面试经历16、 面试问题：netty小对象、大对象的管理jvm在操作系统层面的内存AQS的Zookeeper怎么保障全部通知到【定时更新】查找数组中重复出现次数最多的数字rocketmq扩容怎么保证顺序消息Redis的五种数据类型的实现是什么数据结构 公司面试注意事项： 项目中遇到的技术难点：并发，稳定性，容错，性能等方面入手。内存泄漏 面试经验：https://mp.weixin.qq.com/s/oQdmQpO4XXFaJbfjt8GvXQ?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com刷题：LeetCode+《剑指offer》基础知识简历：SMART原则英语锻炼面试 消息的功能，为什么这么做，那几个接口怎么适配的：kafka的实现原理：怎么存储，怎么通信零拷贝，java怎么使用hashmap的实现原理：数据+链表，比如put操作：先定位数据位置，再比较链表中是否存在synchronized 和 volatile 区别 先做个简单的自我介绍：主要是三个周期：第一个周期是14年7月到15年8月 南京亚信软件，第二段是15年8月到16年9月：南京快钱 平台的维护对接和需求开发第三段是16年9月到目前是南京亚信软件， 为什么换工作到杭州快钱项目介绍目前的项目介绍 同盾科技面试： 为什么选择封装Acticemq和Rocketmq在什么情况下，选择Acticemq，什么情况下Rocketmq对比一下Acticemq和Rocketmq推荐给客户的时候，怎么推荐哪一个中间件，就是什么场景下使用哪个mq中间吗：并发、部署、运维、高可用 kafka和rocketmq对比有什么区别语言、缓存批量发送-吞吐量和安全、存储时候文件的区别使用的注册中心和协调框架--zookeeper、nameSrv 统一配置平台有几个服务：zookeeper通知、Redis缓存、HDFS和数据库存储，amber服务控制台 如果Zookeeper主节点宕机，重新选主30S不可用，文件更新了，怎么实现实时通知客户端异常重试，重新多少次就打印日志 使用消息通知，消息挂了怎么办，消息怎么判断客户端确实接收到了，通知的时候记录，然后消费端接收的时候，消费成功做反馈客户端如果宕机了，服务端怎么知道呢？ 实时感知，客户端和服务端之间做长连接，如果客户端有几千Client，配置中心只有几个服务，这个你怎么保证这么多连接可用 常见的RPC框架指的是哪些，知道的开源的Rpc框架有哪些，dubbo有使用过吗？dubbo底层通讯序列化使用的是什么？负载均衡是在客户端还是服务端？ netty：tcp拆包和粘包的原因是什么，netty有哪些方式？netty零拷贝指的是什么？那linux的用户态和内核态有什么区别？netty使用的是什么内存？（直接内存和堆外内存），内核态操作的是什么内存？堆内存和堆外内存怎么释放？通过操作系统的什么方法去写内存的？在java里面什么时候才会触发堆外内存回收，回答GC，手动释放，还有吗？如果我要实现内存池，采用什么方式？直接内存，怎么设计呢？unsafe方法有了解吗？CAS这个有了解吗？ABA问题怎么处理 hashmap介绍，1.6和1.8有什么改进？hashmap扩容过程？concurrenthashmap在1.8有什么优化？lamdba表达式有什么优点，为什么使用这个？.stream是干嘛的？ synch声明在静态块和普通方法有什么区别？java有几种锁？lock接口有几种锁？什么时候用读写锁？跟valitile有什么区别，用在什么场景？（其实是读多写少这种），什么时候valitile，什么时候用atom原子类型？一个变量为什么不用atom而是valitile？ barracyle栅栏机制？ java堆内存溢出怎么排查？什么情况下堆内存溢出？什么栈内存溢出？tlab就是内存逃逸分析？ G1和cms对比，有什么优缺点？G1可以设置单个块最大的回收时间，真实有效吗？达到了这个时间会发生什么？ springcloud是不是用过，springboot使用过吗？ 了解过微服务开发吗？答sprngcloud、servermesh， servermesh主流的技术是什么？istio的数据层面和控制面都是哪些组件？各是干什么的？sidecar和dubbo各有什么优势？sidecar和应用之间怎么通信？是怎么代理应用的？应用的请求sidecar怎么获取的？ 大数据有什么了解吗？没有， apigateway有接触吗？开源的接触过什么？跟后端是怎么通信的？（其实还是想问跟后端是rpc框架是什么）rpc通信是什么方式？都不用dubbo吗？那rpc都是用的什么？csf底层用的什么序列化（谷歌那个，td，protobuff），用什么通信？Zookeeper注册？，springcloud的api网关是哪个服务？还有其他的api网关？ 大数据不是做流计算 别人的面试经历1 zookeeper的watcher乐观锁怎么实现 c. 说出一个空间换时间的场景 G1和CMS的区别，G1有啥劣势；Kafka的整体架构；Netty的一次请求过程；自旋锁/偏向锁/轻量级锁（这个问题在头条的面试里也出现了一次）、hbase线上问题排查（刚好遇到过NUMA架构下的一个问题，借此把hbase的内核介绍了下）。 求一棵树两个节点的最近的公共父节点。思路基本是对的，但是有些细节有问题，面试官人很好，边看边跟我讨论，我边改进，前前后后估计用来快半小时。然后又继续问问题，HTTP 301 302有啥区别？设计一个短链接算法；md5长度是多少？ ThreadLocal如果引用一个static变量是不是线程安全的 问了一些基础问题和netty的写流程，还问了一个redis数据结构的实现，结构他问了里面字符串是怎么实现的，有什么优势。一直感觉这个太简单，没好好看，只记得有标记长度，可以直接取。然后就来两道编程题。第一题是求一棵树所有左叶子节点的和，比较简单，一个深度优先就可以搞定。第二题是给定一个值K，一个数列，求数列中两个值a和b，使得a+b=k。我想到了一个使用数组下标的方法（感觉是在哪里有见过，不然估计是想不出来），这种可是达到O(n)的复杂度；他又加了个限制条件，不能使用更多内存，我想到了快排+遍历，他问有没有更优的，实在想不出来，他提了一个可以两端逼近，感觉很巧妙。 先让我讲下kafka的结构，然后怎么防止订单重复提交，然后开始围绕缓存同步问题展开了长达半小时的讨论：先写数据库，再写缓存有什么问题？先写缓存再写数据库有什么问题？写库成功缓存更新失败怎么办？缓存更新成功写库失败怎么办？ 我提到了istio，介绍了设计理念，感觉他有点意外。然后他问java8的新特性，问我知不知道lambda表达式怎么来的，我从lambda演算说到lisp说到scala，感觉他更意外。几个netty的问题，gc的问题， 第一部分就是日志上传和接收，然后就如何保证日志上传的幂等性开始不断深入，先让我设计一个方案，然后问有没有什么改进的，然后如何在保证幂等的前提下提高性能，中间穿插分布式锁、redis、mq、数据库锁等各种问题。 结合秒杀的场景深入，如何实现分布式锁、如何保证幂等性、分布式事务的解决方案。问我分布式锁的缺点，我说性能会出现瓶颈，他问怎么解决，我想了比较久，他提示说发散下思维，我最后想了个简单的方案，直接不使用分布式锁，他好像挺满意。感觉他们更看重思考的过程，而不是具体方案。还问了一致性hash如何保证负载均衡，kafka和rocketmq各自的优缺点，dubbo的一个请求过程、序列化方式，序列化框架、PB的缺点、如何从数据库大批量导入数据到hbase。 也是让我先介绍项目，问我有没有用过mq，如何保证消息幂等性。我就把kafka0.11版本的幂等性方案说了下，就没再问技术问题了 公司面试总结： 19年面试：1、19年5月14号 周二 面试 fit2cloud ，在南京刚刚起步，一个开发，两个销售，在南京建邺万达租的一个一室的房间，暂时不考虑2、京东数科，周三（5/15）14：00，后面确定电话面试，因为面试的回答不好，没有结果额3、途牛 中间件部门，微信视频面试两轮，最后还是说不合适4、杭州同盾，电话面试一轮，收获还是挺多的，后来又到面两轮，还是被刷了5、杭州呆萝卜，文滔推荐了两次，都简历不通过，要有电商业务经验的6、杭州滴滴，猴哥内退小橘业务部门，简历都没过7、在boss上投递了涂鸦，一直显示面试，都2个多星期了，都没有反应，pass 海康二维火百世汇通jd 招聘要求： java基础扎实：熟悉IO、多线程、集合操作等基础技能熟悉分布式、缓存、消息队列等中间件技术熟悉mysql数据库的基本操作 熟悉常用设计模式熟悉并对javaEE、SOA、spring、osgi等技术潮流保持关注，有数据库、分布式、性能优化、高并发、高可用性系统设计开发经验有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解;熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术；熟悉常用算法和数据结构，熟悉分布式系统原理负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 1、重点本科或以上学历（985/211），计算机软件或相关专业，英语CET4以上;2、精通java编程，熟悉java sdk提供的主要能力;3、理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发;4、熟悉多线程编程，熟练使用java并发包下的各项常用基础设施;5、熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务;6、熟悉常用网络协议，如TCP/IP, HTTP;7、能够熟练使用linux，能够利用常用的工具对程序进行跟踪诊断;8、有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解;9、具备良好学习、沟通能力及团队协作精神，对工作积极严谨，勇于承担压力。 这里有世界一流的中间件产品和场景，包括应用托管容器、分布式调用服务、分布式消息服务、分布式数据服务和大数据计算平台等，掌控着超千亿规模的消息推送和分布式数据库调用，是全球流量最大的中间件集群之一这里有世界最大的电商交易业务场景，团队提供的高可用架构基础设施直面双11洪峰流量，包括容量规划、准入控制、限流降级、流量调度、弹性伸缩和全链路压测等，体系化支撑阿里巴巴电商链路的稳定运行这里有世界领先的企业互联网架构平台，以中间件技术部多款核心产品作为基础设施构建的云计算解决方案，面对互联网+的浪潮，帮助企业级客户轻松构建并托管分布式应用，解决集中化和互联网化的业务需求我们的使命：做分布式架构基础设施，建设支撑百万笔交易的分布式架构能力，建设支撑百万台服务器和超万个系统的服务能力我们的愿景：打造世界一流的中间件产品，打造世界一流的高可用架构基础设施，打造世界一流的企业级互联网架构平台全面参与阿里巴巴集团中间件（容器，服务框架、消息中间件、数据中间件等）的设计，核心代码开发，系统稳定性开发，性能优化等工作帮忙业务方解决技术难题，用技术推动业务发展岗位要求: 熟悉java concurrent包 ，熟悉高并发，分布式通信，存储等相关技术 3年以上相关工作经验 熟悉Linux操作系统、熟悉开源的中间件软件 熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先 具有高并发相关工作经验优先 有很强的与客户沟通和理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情； 职位描述： 负责阿里巴巴菜鸟基础技术组件和产品的研发和设计工作，有监控系统经验者优先。 从架构角度横向关注菜鸟业务系统，为菜鸟系统微服务化，云化，流程引擎自动化等共享技术方面做技术支撑。职位要求 计算机相关专业本科或以上学历，三年以上J2EE项目开发经验； 扎实的编程基础，精通java开发语言，熟悉jvm，web开发、缓存，分布式架构、消息中间件等核心技术； 精通Java EE相关的主流开源框架，能了解到它的原理和机制，如Spring、iBatis、struts等； 熟悉Oracle、MySql等数据库技术，对sql优化有一定的经验； 思路清晰，良好的沟通能力与技术学习能力； 有基础技术组件，分布式存储/计算相关经验者优先考虑。 岗位描述:蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。岗位要求:1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力；5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； 满足以下三个以上条件：1、从事一线研发工作5年以上，有优秀的设计与代码编写能力2、熟练掌握C/C++/Go/Python/Java/Nodejs等1至2种以上语言（GO加分，同时会Java+GO/Java+Python加分）3、熟悉多种消息中间设计实现如：Kafka, RabbitMQ,activemq等（向社区提交过patch者优先）4、熟悉etcd，consul,zookeeper等分布式组件（阅读过源码并向社区提交过patch者优先）5、熟悉常用算法和数据结构，熟悉分布式系统原理6、熟悉RPC框架、系统架构优化设计等（阅读过dubbo等源码并向社区提交过PR者优先）7、具备网络知识，熟悉TCP/IP通信原理者优先8、有大型高并发项目架构设计经验者优先9、有开源社区贡献者经验优先10、熟悉微服务架构及服务治理优先11、熟悉Kubernetes者优先11、参与过PaaS平台规划，设计研发过PaaS/FaaS关键部件优先 负责小桔车服架构及稳定性建设，主要包括两块工作：一、架构产品规划及架构治理，二、提升车服软件总体稳定性任职要求一、精通java语言，对java语言特性及jvm有全面深度理解；二、熟悉消息中间件的特性，知道高性能消息中间件的设计思路；三、存储系统选型能力强，熟悉搜索产品、kv存储、数据库，能根据业务的当前发展阶段做出最优的存储选型；四、对服务治理有体系化思考，熟悉业界知名服务治理方案如dubbo、spring boot，能比较不同方案的优劣；五、在存储、中间件或服务治理领域有开源贡献者优先；六、对稳定性建设有体系化的思考，知道如何在指定时间内按部就班地将稳定性提升至指定水平。 熟悉Java并发和网络编程，有良好的数据结构和算法功底； 熟悉消息中间件的原理和关键技术，熟悉Kafka/Pulsar/RocketMQ等消息产品的原理和实现，有开源社区贡献者优先； 对CAP理论、Paxos/Raft算法、高可用架构、分布式事务等有一定理解，并由一定实践经验者优先； 有分布式存储的使用和研发经验者优先； 了解或熟悉一种分布式流计算框架的应用场景和关键技术，例如Spark/Flink/Kafka Streams/Apache Samza等，有相关研发经验者优先； 有技术热情和较强的学习能力，有良好的分析解决问题和技术攻关能力，具备良好的沟通能力、抗压能力和团队协作能力； 岗位职责：参与曹操专车中间件（服务框架、消息中间件、数据中间件等）的设计，代码开发，系统稳定性开发，性能优化等工作主要方向：监控告警、网关、日志处理、消息中间件、公用组件服务等岗位要求： 3年以上相关工作经验，Java基础扎实，熟悉多线程，分布式系统，数据存储等相关技术 熟悉常用的中间件技术（如消息系统、RPC框架、缓存系统、存储层中间件等） 掌握多线程及高性能的设计与编码及性能调优，有高并发应用开发经验优先 熟悉Linux操作系统、能够熟练编写shell脚本 有监控、网关、日志处理等系统经验者优先 有大数据处理框架使用经验者优先，如storm、hadoop等 对用过的开源框架能了解到它的原理和机制，有开源项目贡献者优先 有较强的沟通理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情； 工作职责: 负责基础架构技术、产品的设计与研发 负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 优化基础服务性能，提升服务可用性，增加系统稳定性，保障业务高效运行 解决线上服务运行期间出现的各种问题任职要求： 计算机或相关专业本科以上学历（5年及以上工作经验） 精通Java程序开发，熟悉Linux/Unix开发环境 熟悉常用开源分布式系统，精通但不限于kafka/rocketmq/mongodb/redis/opentsdb等任意一种开源产品源代码 良好的分布式理论与实践能力 良好的沟通协作能力，较强的分享精神 有Github等开源社区贡献经验的优先 岗位描述: 负责中间件消息系统核心模块的设计和方案落地。 负责公共云和专有云的稳定性。 负责新产品线的调研和论证。更高层需求： 负责产品路线的选型。 负责公共云和专有云的具体打法，为结果负责。岗位要求: 4年以上分布式系统相关经验。 至少精通一种编程语言，Java或C++。 深入理解分布式存储理论，微服务优化实践。 计算机理论基础扎实，例如对操作系统原理、TCP/IP等有比较深入的理解。 具有独立设计一款生产环境高可用高可靠的中间件能力，例如RocketMQ。 熟悉高并发、分布式通信、存储、开源中间件软件等相关技术者更佳。 有很强的与客户沟通和理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情。 岗位职责：1、参与曹操专车中间件（服务框架、消息中间件、数据中间件等）的设计，代码开发，系统稳定性开发，性能优化等工作；2、主要方向：监控告警、网关、日志处理、消息中间件、公用组件服务等。任职要求：1、4年以上相关工作经验，Java基础扎实，熟悉多线程，分布式系统，数据存储等相关技术；2、熟悉常用的中间件技术（如消息系统、RPC框架、缓存系统、存储层中间件等）；3、掌握多线程及高性能的设计与编码及性能调优，有高并发应用开发经验优先；4、熟悉Linux操作系统、能够熟练编写shell脚本；5、有监控、网关、日志处理等系统经验者优先；6、有大数据处理框架使用经验者优先，如storm、hadoop等；7、对用过的开源框架能了解到它的原理和机制，有开源项目贡献者优先；8、有较强的沟通理解能力，有良好的团队协作精神、环境适应能力和执行力，在较大压力下保持工作激情。 岗位职责： 参与有赞PaaS中间件（容器，服务框架、消息中间件、数据中间件等）的设计，核心代码开发，维护系统稳定性，性能优化等工作 深入理解所负责的中间件的技术原理、架构和使用场景, 帮助业务方更好的利用中间件产品解决技术难题 规划中间件产品的发展方向，用中间件技术、通用产品、通用平台解决业务架构难题,支撑业务系统的快速发展岗位要求： 精通Golang／Java／C++语言 ，5年以上相关工作经验 精通高并发，分布式，存储等相关技术3.熟悉消息中间件，RPC框架，数据层，性能优化等相关技术4.有优秀的问题排查能力5.善于独立思考，有快速学习能力，不断突破技术瓶颈，乐于探索未知领域，在较大压力下保持工作激情 工作职责: 负责基础架构技术、产品的设计与研发 负责分布式缓存、消息、rpc、链路跟踪等某个或某些中间件产品的设计与研发 优化基础服务性能，提升服务可用性，增加系统稳定性，保障业务高效运行 解决线上服务运行期间出现的各种问题任职要求： 计算机或相关专业本科以上学历（5年及以上工作经验） 精通Java程序开发，熟悉Linux/Unix开发环境 熟悉常用开源分布式系统，精通但不限于kafka/rocketmq/mongodb/redis/opentsdb等任意一种开源产品源代码 良好的分布式理论与实践能力 良好的沟通协作能力，较强的分享精神 有Github等开源社区贡献经验的优先 岗位描述:蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。岗位要求:1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节；2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制；3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力；5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； 岗位职责：1、框架和中间件产品迭代2、框架和中间件产品性能优化3、框架和中间件产品上云，支持多租户等云产品特性岗位要求：1、Java基础扎实，掌握Java NIO和Netty基本原理2、熟悉常用RPC框架比如Dubbo、Thrift、gRPC者优先3、熟悉Spring Cloud、Service Mesh微服务解决方案者优先4、熟悉相关调用链开源产品者优先5、具备良好的沟通能力以及技术产品规划改进能力 职位描述：参与蚂蚁在海量数据访问、变更、灾备等场景下，业务数据一致性所依托的分布式事务中间件产品的技术设计、研发和推广； 分布式事务产品功能的设计、研发和运维，及商业版的推广； 蚂蚁分布式事务开源版 fescar 的研发和运营； 配合蚂蚁全站业务发展、技术演进的数据中间件技术；职位要求：1.2年及以上使用JAVA开发的经验，JAVA基础扎实，理解IO、多线程、集合、网络等基础框架、对JVM原理有一定的了解；2.熟悉数据库编程，对mysql、oracle等数据库有一定使用经验；熟悉分布式系统的设计和应用；3.熟悉并具有XA、TCC等分布式事务框架或者解决方案经验者优先；4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，有良好的团队合作和沟通能力。 团队介绍：主要负责蚂蚁金服中间件产品的研发、运维和推广；团队目前运营的开源品牌SOFAStack（https://github.com/alipay），在金融级分布式架构领域非常活跃；分布式事务开源版本fescar，在社区也非常活跃；团队技术氛围非常好，有定期分享和参与各种开源论坛的机会，人员的成长和技术视野的提升都非常快。团队Leader很重视团队人员的技术成长，新人有专门的师兄，并且会制定相应成长计划，并定期Review做调整。注：工作地选择杭州或者北京均可；职位描述工作职责：1.作为底层系统开发人员，通过中间件技术、通用产品、通用平台解决业务架构难题，保障和支撑有赞业务的快速增长和迭代；2.参与有赞PaaS中间件(微服务框架、消息中间件、数据中间件、分布式KV存储系统等)的设计、核心代码开发，维护系统稳定性，提升产品和系统的性能；3.深入理解所负责的中间件的技术原理、架构和使用场景，帮忙业务开发更好的利用中间件产品解决技术难题，提升业务的开发和迭代速度；4.参与产品推广、技术宣讲和培训，提升业务开发对底层中间件和系统的了解，减少和消除因对底层系统不了解造成的故障；5.结合业界实践和有赞的实际情况，规划中间件和底层系统平台的发展方向，保障底层系统的持续稳定运行。工作内容：1.了解业务开发的需求和痛点，对业务实际中遇到的问题进行总结，抽象成为对中间件产品的需求设计、开发核心中间件产品，不断满足业务在功能、性能、稳定性等方面的需求；2.在结合有赞的业务场景和实际情况的前提下，吸纳开源产品优秀的设计和架构，并进行针对性的改良和适配；为需求方做技术培训，组织技术分享并能输出技术沉淀；3.协助业务方进行底层系统的技术选型和方案评估，为业务方提供专业的建议和支持；4.推动整体业务开放对底层中间件系统进行规范、合理的使用，保障底层系统的健康、稳定运行。任职要求：1.熟悉C++、Golang或Java语言 ，2年以上相关工作经验；2.熟悉高并发、分布式，存储、微服务架构等相关技术，熟悉网络编程；3.熟悉Linux操作系统、熟悉业界主流和常用的中间件软件；4.善于独立思考，有快速学习能力，不断突破技术瓶颈，乐于探索未知领域，在较大压力下保持工作激情；5.熟悉消息中间件，RPC框架，数据层，性能优化等相关技术经验者优先；6.熟练使用关系型数据库，对索引调优有一定经验或者了解其原理者优先；7.有良好的问题排查经验，有 docker 容器管控、PaaS 平台等领域的实践经验者优先。成长建议：1.关注和重视技术基础，对数据结构、算法、操作系统、网络编程等计算机基础课程进行深入的学习，并在实践中不断加深理解；2.不断提升对所维护和开发的产品的了解程度，结合业务实际场景进行深入的思考，提升对技术产品整体的认识能力和架构能力；3.学习和了解业务主流开源中间 任职条件对于Java基础技术体系（包括JVM、类装载机制、多线程并发、IO、网络）有一定的掌握和应用经验；良好的面向对象设计理解，熟悉面向对象设计原则，掌握设计模式及应用场景；熟悉底层中间件、分布式技术（包括缓存、消息系统、热部署、JMX等）；对于高并发、高稳定可用性、高性能、大数据处理有过实际项目产品经验者优先。 高可用架构团队是阿里巴巴保障稳定性的护航舰队，提供的高可用架构基础设施直面双11洪峰流量，包括全链路压测、容量规划、准入控制、限流降级、流量调度、弹性伸缩等；通过同城双活、异地多活、单元化体系建设，支撑阿里巴巴电商链路的分钟级故障切换，保证业务稳定运行。目前，我们承载着产品 PaaS 云化的承前启后的使命，通过阿里云赋能外部用户，急需高可用相关的研发人才，一方面完善高可用中间件自身的核心功能演进，满足业务系统大规模、高并发、高可用的需求；另一方面，需要快速迭代开发，将原来对内部为主的高可用中间件做成真正完善的可以对外部企业开放的云产品，帮助客户构建易使用、易运维的分布式系统。根据对云计算平台的业务需求，从稳定性、功能、性能等方面，负责设计、实现、改进云产品，把原来仅能满足内部使用的中间件组件，打造成功能完善且满足外部企业需求的云产品。开发云产品自身的管控、自动运维、监控、服务计费、产品运营、故障定位等工具。和架构师紧密合作，了解客户当前在技术上遇到的困难，帮忙业务方解决技术问题，用技术推动业务发展。2、熟悉 Java 常见开发框架，有扎实的 Java 基础和丰富的 WEB 开发经验3、精通linux平台上的Java语言编程，熟悉数据库开发技术，熟悉shell编程4、对数据结构、算法设计、系统架构设计等有较为深刻的理解5、熟悉系统高可用和稳定性方法策略，比如同城容灾、异地双活、异地多活等，有实战经验优先6、精于架构设计、性能优化，有故障处理、监控、限流、降级、预案、容量规划实战经验优先7、有前端开发经验，熟悉 ReactJS 者优先 职位名称：蚂蚁金服-消息和分布式计算系统研发工程师/专家职位描述：参与蚂蚁分布式消息中间件和分布式流计算框架的设计和研发工作。通信产品广泛应用在蚂蚁金服的各项业务中，承担了海量的消息投递任务和复杂的单元化路由任务，并且保证系统的高可用和消息的高可靠。职位要求：1.精通 Java 并发和网络编程，有良好的数据结构、算法功底；2.熟悉消息中间件的应用场景和核心技术，熟悉 Kafka/ActiveMQ/RocketMQ等 MQ 产品的原理和实现，有开源社区贡献者优先； 3.对CAP理论、Paxos/Raft 算法、高可用架构、事务等理论有深入理解，并有一定的实践经验；4.了解或熟悉一种分布式流计算框架的应用场景和核心技术，例如 Storm/Kafka Streams/Apache Samza 等，有相关研发经验者优先；5.了解或熟悉IoT架构、MQTT协议等，有相关研发经验者优先；6.有分布式存储的使用和研发经验者优先；7.熟悉 JVM 基本运行原理和性能调优经验者优先； 8.熟悉 Linux 内核者优先。 岗位描述: 蚂蚁中间件团队是服务于整个蚂蚁金服集团（包括钱包、网商、小贷、芝麻、聚宝、国际、口碑等）的核心技术团队，致力于打造支撑每秒亿级金融交易规模的基础中间件平台，为高速发展的业务提供业界一流的，金融级高可用高性能的分布式基础服务，也将十年磨一剑的技术做产品化输出，为蚂蚁业务生态的合作伙伴提供技术赋能。期待您的加入，一起在蚂蚁这个极具挑战和丰富多彩的业务舞台上玩技术，支撑 DT 驱动的互联网金融生态！ 您将参与蚂蚁 Java 中间件（包括RPC通讯、消息队列、应用容器、开发框架、协调管控系统、数据中间件、搜索平台等）的高可用设计、核心编码、性能优化和产品化开发等工作。 岗位要求: 1.3年以上 JAVA 开发经验，有并发编程经验，熟悉文件I/O，网络 I/O 及类加载等机制细节； 2.有大规模分布式系统或者类库的研发经验，熟悉开源中间件，深入了解实现机制； 3.熟悉JVM基础知识，具有一定的调优经验和内存、线程相关问题排查经验； 4.有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，具有良好的团队合作和沟通能力和抗压能力； 5.熟悉 Linux 内核者优先，有消息中间件、RPC、数据层中间件等中间件研发经验值者优先，有性能优化经验者优先； Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/开源组织和公司开源项目地址和网站.html":{"url":"docs/Interview/开源组织和公司开源项目地址和网站.html","title":"开源组织和公司开源项目地址和网站","keywords":"","body":"开源组织和公司开源项目地址和网站 阿里巴巴 Github首页 地址： https://github.com/alibaba 介绍: 支付宝Github首页 地址： https://github.com/alipay 介绍: 阿里中间件团队博客 地址： http://jm.taobao.org/ 介绍: 新美大 Github首页 地址： https://github.com/Meituan-Dianping 介绍: 美团技术团队 地址： https://tech.meituan.com/ 介绍: 美团Github首页 地址： https://github.com/meituan 介绍: 大众点评Github首页 地址： https://github.com/dianping 介绍: 有赞 Github首页 地址： https://github.com/youzan 介绍: 有赞技术团队 地址： https://tech.youzan.com/ 介绍: CNCF（Cloud Native Computing Foundation） Github首页 地址： https://github.com/cncf 介绍: CNCF基金会，云原生社区 谷歌Google Github首页 地址： https://github.com/google 介绍: 脸书facebook Github首页 地址： https://github.com/facebook 介绍: 推特twitter Github首页 地址： https://github.com/twitter 介绍: 亚马逊Amazon Github首页 地址： https://github.com/amzn 介绍: 亚马逊云服务 Github地址： https://github.com/aws 介绍: 腾讯Tencent Github首页 地址： https://github.com/Tencent 介绍: 百度 Github首页 地址： https://github.com/baidu 介绍: 京东 Github首页 地址： https://github.com/CHINA-JD 介绍: 小米 Github首页 地址： https://github.com/orgs/XiaoMi 介绍: 雅虎 Github首页 地址： https://github.com/yahoo 介绍: 领英 Github首页 地址： https://github.com/linkedin 介绍: 网易 Github首页 地址： https://github.com/NetEase 介绍: Netflix Github首页 地址： https://github.com/Netflix 介绍: 亿贝 Github首页 地址： https://github.com/eBay 介绍: 微软 Github首页 地址： https://github.com/Microsoft 介绍: 豆瓣 Github首页 地址： https://github.com/douban 介绍: 唯品会 Github首页 地址： https://github.com/vipshop 介绍: 苹果 Github首页 地址： https://github.com/apple 介绍: 猫途鹰 Github首页 地址： https://github.com/tripadvisor 介绍: 三星 Github首页 地址： https://github.com/SAMSUNG 介绍: 地址： 介绍: 地址： 介绍: 其他技术组织 中生代技术 地址：https://zhongshengdai.com/ 地址：https://yq.aliyun.com/teams/136/type_blog-cid_0-page_6 地址：https://www.itdks.com/member/organizer/16 地址：https://zhuanlan.zhihu.com/freshmantechnology 地址：https://github.com/freshmantechnology 介绍: 中生代技术社区成立于2015年，是一家立足于成都，服务全国的技术社区运营，技术管理咨询和技术人才猎头公司。也有技术分享 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/框架网站.html":{"url":"docs/Interview/框架网站.html","title":"框架网站","keywords":"","body":"框架网站 不错的框架网站 各种相关 GitHub Pages 地址：https://github.com/jekyll/jekyll 介绍: 博客模板框架 万维网联盟，又称W3C理事会，World Wide Web Consortium (W3C) 地址：https://www.w3.org/ 地址：https://github.com/w3c 地址：https://www.w3schools.com/ 地址：http://www.w3school.com.cn/ 地址：https://www.w3cschool.cn/ 介绍: 在 W3School，你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 oreilly系利图书网站 地址：https://www.oreilly.com/index.html 地址：https://learning.oreilly.com/ 介绍: 码库CTOLib 地址：https://www.ctolib.com/ 介绍: 码库CTOLib.COM每日更新收录实用的开源项目和资源，目前共有55447个收录，并归类到659个分类中 github代码扫描工具，github账号登录 地址：https://codecov.io/ 地址：https://travis-ci.org/ 地址：https://goreportcard.com 地址：https://app.codacy.com/manual/looly/hutool/dashboard 介绍: 代码扫描、测试覆盖率等 Java设计模式 地址：https://github.com/iluwatar/java-design-patterns 介绍: 面试 地址：https://github.com/kdn251/interviews/blob/master/README-zh-cn.md 介绍: Java算法 地址：https://github.com/TheAlgorithms/Java 介绍: Java开发框架 地址：https://github.com/gothinkster/realworld 地址：https://github.com/jhipster/generator-jhipster 介绍: Java相关的教程、各种教程和示例。 地址：https://github.com/akullpp/awesome-java 地址：https://github.com/eugenp/tutorials 介绍: Reactive编程 地址：https://github.com/kaushikgopal/RxJava-Android-Samples 介绍: Reactive编程通过提供很好的抽象来处理异步和基于事件的编程而获得了广泛的普及。RxJava是ReactiveX的Java实现，它通过Observables提供反应式编程。 Java Functional Programming函数式编程概念 地址：https://github.com/winterbe/java8-tutorial 介绍: Java8是已发布的最具破坏性和创新性的Java之一，因为它已经在Java中引入了“ Functional Programming ”。借助Lambda和Streaming之类的概念，Java最终达到了函数式编程领域，同时保持了其传奇而全面的向后兼容性。 Java Functional Programming函数式编程概念（Lambda，Streams，Functional Interface，Parallel Streaming等）的小而有用的示例。 编码挑战类书籍 地址：https://github.com/careercup/CtCI-6th-Edition/tree/master/Java 介绍: 本书涵盖了所有类型和种类的编码挑战，包括算法复杂性，数学和逻辑难题，动态编程，排序和搜索，多线程等等。 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/其他的学习网站.html":{"url":"docs/Interview/其他的学习网站.html","title":"其他学习网站","keywords":"","body":"其他的学习网站 各方面的学习网站，比如买房等 各种相关 2017杭州买房经验 地址：https://github.com/houshanren/hangzhou_house_knowledge 介绍: openstack 地址：https://www.openstack.org/ 介绍: OpenStack是一个开源的云计算管理平台项目，是一系列软件开源项目的组合。由NASA(美国国家航空航天局)和Rackspace合作研发并发起，以Apache许可证（Apache软件基金会发布的一个自由软件许可证）授权的开源代码项目。 [1] OpenStack为私有云和公有云提供可扩展的弹性的云计算服务。项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台 地址：ChromeAppHeroes 介绍: 谷粒-Chrome插件英雄榜, 为优秀的Chrome插件写一本中文说明书, 让Chrome插件英雄们造福人类~ 地址：学习文章 介绍: java技术文章 《自学是门手艺》 地址：weekly-reading 地址：GitHub Trending 地址：李笑来Github 介绍: 一个介绍技术的博客 地址：技术学习博客 介绍: 地址：Java教程 介绍: 地址：慕课网 介绍:比较不错的编程视频教学网站，可以找到比较体系的东西，当然，有些内容要花钱就是了。 地址：中国大学MOOC 介绍: 有很多名校的课程，当然不止CS。 地址：LeetCode 介绍: 经典的刷题网站，主要是算法题。 地址：LintCode 介绍: 和LeetCode类似,经典的刷题网站，主要是算法题。 地址：牛客网 介绍: 一个联网求职学习交流社区。 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: 地址： 介绍: Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Interview/学习.html":{"url":"docs/Interview/学习.html","title":"待学习","keywords":"","body":"学习 训练营第一天 1、synchronized关键字的字节码原语 2、volatile关键字的字节码原语 3、synchronized与volatile的硬件级实现 4、无锁、偏向锁、轻量级锁、重量级锁的升级过程 5、内存屏障的基本概念 6、JVM规范如何要求内存屏障 7、硬件层级内存屏障如何帮助java实现高并发 8、面试第4题（线程间通讯）的8种解法 9、作业 训练营第二天 1、线程池的学与思 2、使用线程池的好与不好 3、为什么阿里开发手册建议自定义线程池 4、自定义线程池的最佳实践 5、常见线程池类型与应用场景 1）CachedPool 2）FixedThreadPool 3）ScheduledPool 4）WorkStealingPool 5）ForkJoinPool 6、比线程更牛X的线程，压测结果展现纤程的威力 7、总结 一个小伙伴最近参加某个一线互联网公司的面试，被问了以下问题，看看大家能否答出来： （1）synchronized的CPU原语级别是如何实现的？ （2）一千万个数，如何高效求和。 （3）不用数学库，求2开平方的值，精确到小数点儿后10位。 （4）线程A不断打印1-10的数字，打印到第5个数字时通知线程B，请完成编码。 （5）下列三种业务，应该如何使用线程池： 高并发、任务执行时间短的业务 并发不高、任务执行时间长的业务 并发高、业务执行时间长的业务 （6）你如何来设计12306网站，能够撑住最高百万级别TPS（淘宝最高54万TPS）？ 微软 Microsoft Azure谷歌云平台 Google Cloud Platform （GCP）亚马逊Amazon Web Services (AWS)阿里云Google Kubernetes Engine（GKE） 加解密、填充对齐等，证书等，参考网上在线加解密参数算法设计模式操作系统linux、shell、go、c++、python Ruby on Rails（官方简称为 Rails，亦简称为 RoR），是一个使用 Ruby 语言写的开源 Web 应用框架，严格按照 MVC 结构开发。https://rubyonrails.org/ 狼人杀麻将、健身常识医学常识看手机上的待办事项德州扑克 IPU网址http://www.aiipu.com/doc Jupyter Notebook 有个 斯蒂芬周都博客，里面全是mac主流软件都破解版京东的网关 Java面试视频链接：https://pan.baidu.com/s/1OTzaoG456DtwqB-dGPZmMg提取码：8nm1这是我们的免费直播每天晚上八点到十点都有直播课程https://ke.qq.com/course/384333?tuin=2f51f3e9点击一下即可报名，报名成功截图给我下哦 工作流https://www.flowable.org/https://github.com/flowable/flowable-engine 好文章https://github.com/doocshttps://github.com/apachecn/awesome-algorithm Spring Cloud第一代和第二代的组件组合汇总，如下表所示。Spring Cloud第一代 Spring Cloud第二代网关 Spring Cloud Zuul Spring Cloud Gateway注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper客户端软负载均衡 Ribbon spring-cloud-loadbalancer熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel 【【【每天学习的知识点】】】 Tomcat生产部署：配置详解、启动参数调优及JVM参数优化缓存热点Key、大Value数据库分页重复和分页实现数据库深度分页优化Java泛型的类型擦除和Java语法糖（12个）多线程，到底该设置多少个线程？参考Redis、Nginx；为什么他们会那么快呢jetty的使用 各种编码ASCII、GB2312、GBK、unicode、utf-8ASCII流程图 Linux命令：du、df、tar、awk等SSH、SCP、sftp等动态代理和静态代理热部署和热加载SSO实现OpenID和OAuth 1、SSO实现OPenID和OAuth2、各种编码详解-ASCII、GB2312、UTF-83、ASCII流程图四种授权类型（authorization grant），即四种颁发令牌的方式：1、授权码（authorization code）方式、2、隐藏式（implicit）、3、密码式（password）、4、客户端凭证（client credentials） G1和CMS区别对比逃逸分析与TLAB、内存泄漏AQS(AbstractQueuedSynchronizer)：一个int状态位和一个有序队列来配合完成直接内存详解：分配和回收 Linux探秘之用户态与内核态 数据库：范式、索引、优化、锁、oracle、mysql、mybatis设计模式quickstart-design-pattern数据结构和算法：树的类型、复杂度、排序算法、查找算法分布式：分布式事务与一致性算法.md、分布式锁，分布式缓存、分布式主键、分布式事务、对CAP理论、Paxos/Raft算法、高可用架构HTTP：OSI七层、TCP、http连接、Https 限流：高并发流量限制（计数器、漏桶、令牌桶）：限流（过载保护）BloomFilter布隆过滤器（是BitMap位图的变形）（变形CountingBloomFilter ）CuckooFilter布谷鸟哈希缓存算法（页面置换算法）-FIFO、LFU、LRU 3672234979杨子付 5、常用框架消息：消息：Activemq、Rocketmq、kafka、MQTT缓存：Redis、memcached、什么是缓存击穿 如何避免，注册中心的：zookeeper、consul、etcd容器相关：docker、kubernetes、istio通讯：nettyrpc微服务框架：Dubbo、SpringCloudSpring：Springframe、Springboot、SpringCloud数据库：mybatis、hibernate分布式：分布式事务与一致性算法.md、分布式锁，分布式缓存、分布式主键惊群问题：定义，解决：计算机常见专业名词.mdlinux熟悉：进程、线程和轻量级进程：计算机常见专业名词.md线程切换、内核线程和用户线程、零拷贝等解释：https://blog.csdn.net/tianyue168/article/details/7403693 6、开发项目：自己做过的项目：网关gateway、消息组件、配置中心amber、缓存aicahe，查看示例代码 7、加解密单向加密和双向加密（对称加密和非对称加密）单向加密(信息摘要)：MD5、SHA对称加密：DES、3DES、AES非对称加密：RSA、DSA、ECDSA查看项目quickstart-crypto 10、WebSocket和WebService 17、SSO实现OpenID和OAuth.md 其他框架：字节码框架asm、设计模式、disruptor、fastdfs、guava、jvm序列化框架、yaml框架、xml框架、webString字符串压缩、reflect反射、reactivex、quartz、proxy代理、logging框架、linux相关、json、jfinal、javase、uuid、文档、 消息特性jmx锁负载均衡 1.TCP/IP 三次握手 四次挥手2.Http的格式说明3.状态码说明4.进程间通讯方式（IPC）5.数据库隔离级别，索引类别，oracle的SID 实例6.启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程 首先java.exe 会帮助我们找到 JRE ，接着找到位于 JRE 内部的 jvm.dll ，这才是真正的 Java 虚拟机器 , 最后加载动态库，激活 Java 虚拟机器。虚拟机器激活以后，会先做一些初始化的动作，比如说读取系统参数等。一旦初始化动作完成之后，就会产生第一个类加载器―― Bootstrap Loader 1.加载字节码（启动类加载器，扩展类，应用程序类，自定义加载器） 2.验证格式 3.准备（分配内存） 4.解析（解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程） 5.初始化整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。 7.双亲委派 8.classloader的功能和工作模式 9.synchronized和lock的用法区别 各自底层原理synchronized：对象级别的同步块，底层包含monitorenter和monitorexit指令方法级别同步，底层是 ACC_SYNCHRONIZED 标识来判断Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。lock： 10.分布式锁11.如何设计线程池 需要什么特性 怎么扩容 缩容 如何去取资源 分配资源12.spring中的transactional注解，requestMapping注解的实现原理13.springMvc原理 如何集成web14.什么是缓存击穿 如何避免15.自己做的项目对自己帮助很大的方面 成长的方面16.如何排查oom 问题：Redis Bitmap是什么？HikariCP连接池（号称性能最好的JDBC连接池:HikariCP）？springboot自动启动类?spring常用的接口和类，实现原理（在什么时候初始化，什么时候注入，什么时候调用）？GC，问怎么标记回收对象的，从GCROOT不可达的对象（根据四种引用关系，强软弱虚），GCROOT哪里来的(哪些可以是GCROOT)？java提供finalize()方法？GC和finalize()方法都是不可靠的 什么时候一个对象会被GC？为什么要在这个时候对象才会被GC？GC策略都有哪些分类？这些策略分别都有什么优劣势？都适用于什么场景？给你举个实际的场景，让你选择一个GC的策略？为什么要选择这个策略？什么是gc，什么是cms算法？cms算法实现原理？整个过程是怎么样的？怎么避免full gc？java g1垃圾收集器？ 类加载机制的相关问题：java的类加载器都有哪些？每个类加载器都加载哪些类？这些类加载器之间的父子关系是怎么样的？回答的时候可能会提到双亲委派模型，双亲委派模型是什么？java的类加载器为什么要使用双亲委派模型？如何自定义自己的类加载器？自己的类加载器和java自带的类加载器关系如何处理？bootstrapExtendappself defined 内存的相关问题：内存分为哪几部分？这些部分分别都存储哪些数据？一个对象从创建到销毁都是怎么在这些部分里存活和转移的？内存的哪些部分会参与GC的回收？java的内存模型是怎么设计的？为什么这么设计？ java线程、java线程池、java集合、java队列、java正则表达式、java native方法、JAVA泛型jdk和jre的区别java、Spring中的ServletContext相关Spring的DispacherServlet和ContextLoaderListener中的WebApplicationContext的关系获取spring的ApplicationContext几种方式：直接创建（2种），工具类WebApplicationContextUtils，extends或者implements（ApplicationObjectSupport就是实现ApplicationContextAware）java nio的selector 和linux的epoll select，类似与epoll或者java里面的selectorZeroCopy和mmap思想集合重写写equals，就必须重写hashCode？使用hash表的时候需要重写 Java基础：概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO与文件、多线程、反射 1.项目介绍，从业务出发，自顶向下，模块职责清晰，确保面试官能听懂，反映出对业务的抽象总结2.项目亮点，体现业务价值，解决方法包括但不限于抽象建模、方法论、工具等，如果涉及技术要展示出你对这项技术的理解，反应你的学习热情与计算机基础，如多线程、缓存、索引、事务等3.基础知识，通用的东西要掌握好，如java集合、多线程、jvm几乎是必考，如果简历重点提了某项组件最好了解下原理，比如mysql，把索引、事务、锁的原理了解好4.工程实践，缓存、可用性、微服务、高并发、扩展性、性能优化、幂等、质量保证等问题，如果没有思路可以从自己系统出发5.系统设计，让你设计一种常见的系统，其实也是反映了你在1、2的能力，leetcode上有一道系统设计题可以搜下它的结题思路，总结好思路自己尝试设计微信抢红包、电商秒杀、餐厅点餐、直播等系统，这种问题大概率会问道6.算法，刷题练手，注意代码风格、边界条件的判断7.二三面大概率会问到，你对什么感兴趣、最近在学习什么，然后让你介绍 面试题：1、nio、Bio，aio的区别，大概机制，接口2、数据库，innobd，隔离级别，行级锁3、分布式4、类加载器和双亲委派机制，何时破坏双亲委派机制5、几种垃圾回收器6、java8新特性，lamda，函数接口7、多线程：创建线程池，两个线程一个初始化，一个循环，改变一个值，并发包下接口类8、java虚拟机的内存模型，内存工作方式9、spring 、aop、ioc10、二叉树算法11、MySQL的事务级别，mybatis一个mapper实现两个sql12、多线程，100个子线程，执行完成，将结果返回主线程13、如何在大量数据中查找某一段的数据，不用limit14、dubbo的原理，结构15、整体介绍负载均衡架构16、多线程的好处？一定能加快运行速度么？因为线程切换也是需要时间的，就跟自旋锁和互斥锁的效率一样，线程睡眠和唤醒也是需要时间和消耗资源的。17、Integer和int类型，哪个放在堆内存？哪个在栈内存？18、堆里面和栈内存，分别是什么时候回收？19、outofmemory的问题，怎么定位？20、常用有哪些设计模式？21、一致性hash的实现原理22、数据库索引和主键的区别： 对MySQL的了解，和oracle的区别对设计模式的看法和认知有哪些设计模式如何实现分布式缓存多线程如何避免死锁关于树的算法题-二叉树的锯齿形层次遍历：二叉树的锯齿形层次遍历http://www.lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/Java的垃圾回收机制对Runtime的了解 如何进行自学阅读过那些书籍 第一个项目：项目最终实现效果项目具体部分使用的设计模式并简述选择理由项目有何需改进之处并初拟改进方案第二个项目：项目运行过程中成员是否曾就某一点发生争执？作为Leader你是如何解决的？具体事例？ 数据库的范式JVM内存模型及调优浏览器的缓存机制如何解决高并发问题？是否进行过相应程序的编写？LintCode 算法题 - 最小子串覆盖。原题链接：最小子串覆盖http://www.lintcode.com/zh-cn/problem/minimum-window-substring/想问的问题 应用容器：Spring-Boot、Docker方向，自诊断、开发效率、模块化· RPC链路：链路跟踪、服务治理、动态流量管理、分布式调度 · 高可用方向：异地容灾、环境隔离/切换 hql学习Zuul代码netty使用：常用的编解码RXjava学习，RxJava是基于响应式编程思想，实现并扩展了观察者模式，可以进行异步操作的库completablefuture原理解析，异步编程类Lambda表达式和函数式接口，Lambda表达式3种，函数式接口JDK8内置4类StreamsAPI，创建、转换、聚合ReduceRP、FP、FRP区别，反应式编程、函数式编程、函数反应式编程Fork/Join框架restful接口是什么边缘计算guice，DI注入管理lettuce，Redis客户端异步反应式编程caffeine，本地JVM缓存guava，本地JVM缓存android的webview 免费的程序书籍https://github.com/EbookFoundation/free-programming-books Head First」编程系列丛书 有赞 https://tech.youzan.com/youzan-service-regression-test-platform/ https://www.guru99.com/java-tutorial.html https://howtodoinjava.com/security/aes-256-encryption-decryption/ Github装逼指南——Travis CI 和 Codecov https://segmentfault.com/a/1190000004415437 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/Effective Java中文版.html":{"url":"docs/Book/Java/Effective Java中文版.html","title":"Effective Java中文版","keywords":"","body":"《Effective Java中文版》 《Effective Java》 本书的源代码 https://github.com/jbloch/effective-java-3e-source-code Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/Java多线程编程核心技术.html":{"url":"docs/Book/Java/Java多线程编程核心技术.html","title":"Java多线程编程核心技术","keywords":"","body":"《Java多线程编程核心技术》 代码参考 https://github.com/loveincode/java-multi-thread-programming Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/Java编程思想.html":{"url":"docs/Book/Java/Java编程思想.html","title":"Java编程思想","keywords":"","body":"《Java编程思想》 https://github.com/xbtlin/thinking-In-Java Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/深入理解Java虚拟机JVM高级特性与最佳实践.html":{"url":"docs/Book/Java/深入理解Java虚拟机JVM高级特性与最佳实践.html","title":"深入理解Java虚拟机JVM高级特性与最佳实践","keywords":"","body":"《深入理解Java虚拟机JVM高级特性与最佳实践》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/码出高效-Java开发手册.html":{"url":"docs/Book/Java/码出高效-Java开发手册.html","title":"码出高效：Java开发手册","keywords":"","body":"《码出高效：Java开发手册》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Java/Java程序性能优化.html":{"url":"docs/Book/Java/Java程序性能优化.html","title":"Java程序性能优化","keywords":"","body":"《Java程序性能优化》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/DB/深入浅出MyBatis技术原理与实战.html":{"url":"docs/Book/DB/深入浅出MyBatis技术原理与实战.html","title":"深入浅出MyBatis技术原理与实战","keywords":"","body":"《深入浅出MyBatis技术原理与实战》 代码 https://github.com/johnnywong233/mybatis_all Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/DB/高性能MySQL.html":{"url":"docs/Book/DB/高性能MySQL.html","title":"高性能MySQL","keywords":"","body":"《高性能MySQL》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/HTTP/图解HTTP.html":{"url":"docs/Book/HTTP/图解HTTP.html","title":"图解HTTP","keywords":"","body":"《图解HTTP》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/HTTP/TCPIP详解：卷一.html":{"url":"docs/Book/HTTP/TCPIP详解：卷一.html","title":"TCPIP详解：卷一","keywords":"","body":"《TCPIP详解：卷一》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Linux/鸟哥的Linux私房菜.html":{"url":"docs/Book/Linux/鸟哥的Linux私房菜.html","title":"鸟哥的Linux私房菜","keywords":"","body":"《鸟哥的Linux私房菜》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Netty/Netty权威指南.html":{"url":"docs/Book/Netty/Netty权威指南.html","title":"Netty权威指南","keywords":"","body":"《Netty权威指南》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Python/Python之禅.html":{"url":"docs/Book/Python/Python之禅.html","title":"Python之禅","keywords":"","body":"《Python之禅》（The Zen of Python） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/JavaScript/JavaScript语言精粹.html":{"url":"docs/Book/JavaScript/JavaScript语言精粹.html","title":"JavaScript语言精粹","keywords":"","body":"《JavaScript语言精粹》（JavaScript: The Good Parts） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/数据结构算法/大话数据结构.html":{"url":"docs/Book/数据结构算法/大话数据结构.html","title":"大话数据结构","keywords":"","body":"大话数据结构 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/分布式/从PAXOS到ZOOKEEPER分布式一致性原理与实践.html":{"url":"docs/Book/分布式/从PAXOS到ZOOKEEPER分布式一致性原理与实践.html","title":"从PAXOS到ZOOKEEPER分布式一致性原理与实践","keywords":"","body":"《从PAXOS到ZOOKEEPER分布式一致性原理与实践》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/并发/Java并发编程的艺术.html":{"url":"docs/Book/并发/Java并发编程的艺术.html","title":"Java并发编程的艺术","keywords":"","body":"Java并发编程的艺术 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/并发/Java并发编程之美.html":{"url":"docs/Book/并发/Java并发编程之美.html","title":"Java并发编程之美","keywords":"","body":"Java并发编程之美 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/并发/Java并发编程实战.html":{"url":"docs/Book/并发/Java并发编程实战.html","title":"Java并发编程实战","keywords":"","body":"Java并发编程实战 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/并发/七周七并发模型.html":{"url":"docs/Book/并发/七周七并发模型.html","title":"七周七并发模型","keywords":"","body":"七周七并发模型 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/并发/多处理器编程的艺术.html":{"url":"docs/Book/并发/多处理器编程的艺术.html","title":"多处理器编程的艺术","keywords":"","body":"多处理器编程的艺术.md Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/代码整洁之道.html":{"url":"docs/Book/架构设计/代码整洁之道.html","title":"代码整洁之道","keywords":"","body":"《代码整洁之道》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/重构.html":{"url":"docs/Book/架构设计/重构.html","title":"重构","keywords":"","body":"《重构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/亿级网站架构核心技术.html":{"url":"docs/Book/架构设计/亿级网站架构核心技术.html","title":"亿级网站架构核心技术","keywords":"","body":"《亿级网站架构核心技术》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/可伸缩服务架构.html":{"url":"docs/Book/架构设计/可伸缩服务架构.html","title":"可伸缩服务架构","keywords":"","body":"《可伸缩服务架构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/大型网站技术架构-核心原理与案例分析.html":{"url":"docs/Book/架构设计/大型网站技术架构-核心原理与案例分析.html","title":"大型网站技术架构-核心原理与案例分析","keywords":"","body":"《大型网站技术架构-核心原理与案例分析》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/大型网站系统与Java中间件实践.html":{"url":"docs/Book/架构设计/大型网站系统与Java中间件实践.html","title":"大型网站系统与Java中间件实践","keywords":"","body":"《大型网站系统与Java中间件实践》 高可用：分布式、主备 volatile和synchronize效果类似，但是volatile不保证原子性，synchronize是原子性的 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/Design of Design.html":{"url":"docs/Book/架构设计/Design of Design.html","title":"Design of Design","keywords":"","body":"《Design of Design, The: Essays from a Computer Scientist 1st Edition》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/人月神话-软件项目管理之道.html":{"url":"docs/Book/架构设计/人月神话-软件项目管理之道.html","title":"人月神话-软件项目管理之道","keywords":"","body":"《人月神话：软件项目管理之道》（英语：The Mythical Man-Month: Essays on Software Engineering） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/微服务架构设计模式.html":{"url":"docs/Book/架构设计/微服务架构设计模式.html","title":"微服务架构设计模式","keywords":"","body":"微服务架构设计模式 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/深入浅出设计模式.html":{"url":"docs/Book/架构设计/深入浅出设计模式.html","title":"深入浅出设计模式","keywords":"","body":"《深入浅出设计模式》（ Head First Design Patterns） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/面向模式的软件架构.html":{"url":"docs/Book/架构设计/面向模式的软件架构.html","title":"面向模式的软件架构","keywords":"","body":"《面向模式的软件架构》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/没有银弹-软件工程的本质性与附属性工作.html":{"url":"docs/Book/架构设计/没有银弹-软件工程的本质性与附属性工作.html","title":"没有银弹-软件工程的本质性与附属性工作","keywords":"","body":"《没有银弹：软件工程的本质性与附属性工作》（英语：No Silver Bullet—Essence and Accidents of Software Engineering） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/架构设计/设计模式-可复用面向对象软件的基础.html":{"url":"docs/Book/架构设计/设计模式-可复用面向对象软件的基础.html","title":"设计模式-可复用面向对象软件的基础","keywords":"","body":"《设计模式：可复用面向对象软件的基础》（ Design Patterns: Elements of Reusable Object-Oriented Software） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Interview/剑指Offer.html":{"url":"docs/Book/Interview/剑指Offer.html","title":"剑指Offer","keywords":"","body":"《剑指Offer》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Interview/程序员面试宝典.html":{"url":"docs/Book/Interview/程序员面试宝典.html","title":"程序员面试宝典","keywords":"","body":"《程序员面试宝典》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Interview/程序员面试金典.html":{"url":"docs/Book/Interview/程序员面试金典.html","title":"程序员面试金典","keywords":"","body":"《程序员面试金典》 Java代码实现 https://github.com/Wang-Jun-Chao/Cracking-the-Coding-Interview 第五版Python代码 https://github.com/panxl6/cc150 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/其他的/具体数学.html":{"url":"docs/Book/其他的/具体数学.html","title":"具体数学","keywords":"","body":"《具体数学》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/其他的/人类网络·社会位置决定命运.html":{"url":"docs/Book/其他的/人类网络·社会位置决定命运.html","title":"人类网络·社会位置决定命运","keywords":"","body":"《人类网络·社会位置决定命运》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/其他的/性能之巅.html":{"url":"docs/Book/其他的/性能之巅.html","title":"性能之巅","keywords":"","body":"《性能之巅》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/其他的/浪潮之巅.html":{"url":"docs/Book/其他的/浪潮之巅.html","title":"浪潮之巅","keywords":"","body":"《浪潮之巅》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/其他的/编写可读代码的艺术.html":{"url":"docs/Book/其他的/编写可读代码的艺术.html","title":"编写可读代码的艺术","keywords":"","body":"《编写可读代码的艺术》（《The Art of Readable Code》） https://github.com/trekhleb/state-of-the-art-shitcode/blob/master/README.zh-CN.md 《代码整洁之道》 1、命名规范：变量、方法（方法名+形参）、类 2、代码逻辑上的优化 3、函数级别的代码组织优化。 4、 5、 6、 7、 命名规范：变量、方法（方法名+形参）、类 如： 一般用词 更加丰富多义的词语 send deliver, dispatch, announce, distribute, route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add, new 命名可以加入什么信息： 单位 命名的长度 1、丢弃无用词汇 2、短范围配短名字 3、使用经典的缩写 缩写 完整 str string doc document eq equal 一般常量都是以大写 + 下划线来命名的 命名的歧义 filter()、select()、 exclude() clip、clipTail、clipTo 如果要有个表示上下限变量，max/min 前缀是个好选择。 如果是表示 [n, m] 这个区间，用 first/last 比较好。 如果是表示 [n, m) 这个区间，用 begin/ending,end 比较好。 命名一个布尔值变量，善用 can, is, has 等修饰。同时，否定意味的词，例如 disable_ssl，noSync 尽量不用。 由于一些约定俗成的规则，阅读者还是容易对一个词产生惯性思维。例如 get(), List::size()，会传递一个 轻量操作 的错误信息。 我们可以使用 computeXXX()、 allocateXXX() 、fetchxxx() 修改命名，告诉阅读者函数的意图。同时也可以修改函数实现来贴合这些约定俗成的规则。 代码逻辑上的优化 条件语句组织顺序大致三种： 简单先行 错误先抛 正先否后 尽量使用 提前 return 的思想。 拆分过长的表达式：利用 变量 来简化表达式，以提升代码可读性。 逻辑关系之变化 1、德摩根律 2、短路逻辑不要滥用 3、取反：正想逻辑过于复杂，可以用：反向逻辑 再取反（其实就是德摩根律）：当发现一个判断条件参数过多，就要考虑它的反逻辑，也许更加简洁。 变量多，那就减少：无价值的临时变量 作用域太大，那就缩小：变量对尽量少的代码可见 压缩变量作用域，我们可以在使用变量的逻辑前，再声明变量，将变量的作用域就固定在变量被使用的几行代码内 变量在越少 不同 的地方被使用、赋值，定位它的变化就越容易。 奥古斯都·德·摩根首先发现了在命题逻辑中存在着下面这些关系： 非(P 且 Q) = (非 P) 或 (非 Q) 非(P 或 Q) = (非 P) 且 (非 Q) 函数级别的代码组织优化。 专注于函数的目的：我们需要将对于目的而言 相关性较小的子问题 抽取出来，变成一个独立的函数，甚至是库。这个取决于这个子问题使用的范围是一个文件，还是一整个项目。 一次只做一件事：让代码 保持单纯，抽取不相干子问题，让代码段尽量一次只做一件事 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/medicine/人体使用手册.html":{"url":"docs/Book/medicine/人体使用手册.html","title":"人体使用手册","keywords":"","body":"《人体使用手册》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/medicine/普通生物学.html":{"url":"docs/Book/medicine/普通生物学.html","title":"普通生物学","keywords":"","body":"《普通生物学》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/国史大纲.html":{"url":"docs/Book/history/国史大纲.html","title":"国史大纲","keywords":"","body":"《国史大纲》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/明朝那些事儿.html":{"url":"docs/Book/history/明朝那些事儿.html","title":"明朝那些事儿","keywords":"","body":"《明朝那些事儿》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/万历十五年.html":{"url":"docs/Book/history/万历十五年.html","title":"万历十五年","keywords":"","body":"《万历十五年》 《万历十五年》（英语：1587, a Year of No Significance: The Ming Dynasty in Decline）是美籍华裔历史学家黄仁宇最出名、也是体现其“大历史观”的一部明史研究专著。 内容概要： 明朝第十三代皇帝是明神宗朱翊钧，年号万历（1572－1620年），万历十年（1582年）六月二十日，内阁首辅张居正去世，明神宗开始亲政，他贪财征税，沉湎于酒色之中（一说是染上鸦片烟瘾），又因立太子之事与内阁争执长达十余年，国本之争使他以不上朝及怠政作为与大臣的对抗。 万历十四年（1586年）后，神宗开始连续不上朝，期间长达三十年，史称万历怠政。万历中期后虽然不上朝，但是也没有宦官、外戚干政，也没有严嵩这样的奸臣，朝内党争也有所控制，万历朝鲜之役、女真入侵辽东和梃击案，神宗都有反应及参与，表示他还有看奏章，并透过一定的方式控制朝局。 一般史家认为的明朝灭亡之起点，如万历十年（1582年）张居正去世，万历二十年（1592年）长达六年的援朝鲜之战，万历三十一年间的“妖书案”，接下来万历四十三年（1615年）起的“三大案”（梃击案、红丸案、移宫案），万历四十七年（1619年）的萨尔浒之战等。与这些年份相比，万历十五年（1587年）虽然有海瑞、戚继光的去世，但终究只是无足轻重的一年，也即如其英文版的书名：无关紧要的1587年（1587, a Year of No Significance）。 但黄仁宇提出与其他史学者不同的看法，指出此一年似是天下盛平，无重大动荡，实际上可能却是明朝发展至尽头而步向灭亡的一年。黄仁宇引用典籍，特别是《神宗实录》，就此年中发生的立储之争和一连串使万历帝感到大为不快的问题作分析，研究发生在万历帝身上的变化。黄仁宇指出，虽然最后万历帝在种种问题上妥协，但他由此怠政三十三年，可能是他对抗无效之后，对文官集团的一种报复方式。由此可以理解，明朝的皇帝表面上是有至高无上的绝对权力，但终归也要受到传统文化和文官集团的掣肘。 另外书中还提到海瑞、戚继光、李贽等人，也是受到传统文化的掣肘，而得不到有意义的发展。对海瑞，黄仁宇形容“他虽然被人仰慕，但没有人按照他的榜样办事，他的一生体现了一个有教养的读书人服务于公众而牺牲自我的精神，但这种精神的实际作用却至为微薄。”；对戚继光，黄仁宇评“戚继光的求实精神，表现于使革新不与传统距离过远。”；而对李贽，黄仁宇也评说李贽不过是反映明朝在儒家伦理文化趋于僵化下，思想界的苦闷和困局。 万历怠政 万历怠政，是指明朝明神宗当政期间的怠政现象[1][2][3]。明神宗的长期怠政主要是执政中后期，因其对政事心灰意懒，加上久病不愈无法处理政事，造成了其长达30年的怠政。数十年的怠政造成当时明政府政务废弛的现象，在女真族兴起并侵占明朝东北领土、扩张势力的同时，明神宗依然称疾不上朝，是导致明朝逐步步向灭亡的原因之一[4]。 楚宗之乱，是明神宗万历年间的四次政治案件，是一场由于国本之争引起的一连串东林党争事件，即两次妖书案，两次楚藩案，又称二书二楚。 楚藩案，是明朝万历年间楚国（楚藩）发生的两次事件，即“楚太子案”、“楚宗劫杠案”，学者常认为这是妖书案斗争的一部分，细节可分为“二书二楚”四大案，即“第一次妖书案”、“第二次妖书案”、“楚太子案”、“楚宗劫杠案”等四案。 明末三案 明末三案，是中国明朝末期宫廷中发生的梃击案、红丸案、移宫案的总称。这三起事件引发了满朝士大夫互相侵轧，故有“三大案”之称。事实上早在三大案之前，明神宗万历年间还有二书二楚四案，即两次妖书案，两次楚藩案，这些案件表面上的问题都是所谓的“国本之争”，但实际上是激烈的东林党争，直到南明灭亡为止。 东林党争 东林党争是指明末东林党与阉党以及其他政坛派别之间的争斗，“言事者益裁量执政，执政日与枝柱，水火薄射，讫于明亡。”[1]东林党是明末以江南士大夫为主的政治集团。在东林党之外，还有浙党、齐党、楚党、昆党、宣党等，统称为齐楚浙党（后多加入阉党），东林党争几乎是东林党与全国朋党集团之争。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/中国通史.html":{"url":"docs/Book/history/中国通史.html","title":"中国通史","keywords":"","body":"《中国通史》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/第二次世界大战战史.html":{"url":"docs/Book/history/第二次世界大战战史.html","title":"第二次世界大战战史","keywords":"","body":"《第二次世界大战战史》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/世界史：从史前到21世纪全球文明的互动.html":{"url":"docs/Book/history/世界史：从史前到21世纪全球文明的互动.html","title":"世界史：从史前到21世纪全球文明的互动","keywords":"","body":"《世界史：从史前到21世纪全球文明的互动》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/history/全球通史：从史前史到21世纪.html":{"url":"docs/Book/history/全球通史：从史前史到21世纪.html","title":"全球通史：从史前史到21世纪","keywords":"","body":"《全球通史：从史前史到21世纪》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/Stock/炒股的智慧.html":{"url":"docs/Book/Stock/炒股的智慧.html","title":"炒股的智慧","keywords":"","body":"炒股的智慧 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/others/上帝掷骰子吗.html":{"url":"docs/Book/others/上帝掷骰子吗.html","title":"上帝掷骰子吗","keywords":"","body":"《上帝掷骰子吗》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/others/我不是教你诈.html":{"url":"docs/Book/others/我不是教你诈.html","title":"我不是教你诈","keywords":"","body":"《我不是教你诈》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/others/拆掉思维力的墙.html":{"url":"docs/Book/others/拆掉思维力的墙.html","title":"拆掉思维力的墙","keywords":"","body":"《拆掉思维力的墙》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/others/最优输运理论专题.html":{"url":"docs/Book/others/最优输运理论专题.html","title":"最优输运理论专题","keywords":"","body":"《最优输运理论专题》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Book/others/说话之道.html":{"url":"docs/Book/others/说话之道.html","title":"说话之道","keywords":"","body":"《说话之道》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/English/英语学习.html":{"url":"docs/English/英语学习.html","title":"英语学习","keywords":"","body":"英语学习 1、i.e. vs e.g. 2、 3、 4、 5、 6、 7、 8、 9、 10、 i.e. vs e.g. i.e.是拉丁文id est的缩写，它的意思就是that is.被用来近一步描述一个已经被提及过的东西。 而e.g.是拉丁文 exempli gratia的缩写, 意思是“for the sake of example”，更通俗的说就是 “for example.” 它被用来引出之前陈述过的内容的例子。 我们可以把 i.e. 当中的 i 记成是“in other words.”这就意味着接下来我们要准备补充说明或者重新解释我们刚刚提到的部分。 e.g. 就把它当作是“example”的简单形式。 两倍：Double 三倍：Triple VS Treble 四倍：Quadruple 四分之一：Quarter Triple VS Treble triple是多个不同的东西形成的三倍、三个部分的：比如triple-sized； treble是多个同样的东西形成的三倍、乘以三的：比如treble nine（999）； Triple means in threesTriple chocolate cookies have three types of chocolateTreble means it has three parts, or happens three times, like 000 would be treble zero Some people use them in place of each other, which is non-standard, but still understandable. Quarter vs Quadruple The quarter, short for quarter dollar, is a United States coin worth 25 cents, one-quarter of a dollar. quarter：25美分，1美元的四分之一，相等的四个部分之一*一季度“””小时; 一个“四分之一”世纪；“四分之一”注；四分之一磅。 quadruple 长度是东西的四倍，大或多。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/English/英语单词.html":{"url":"docs/English/英语单词.html","title":"英语单词","keywords":"","body":"英语单词 motto 座右铭 maxim 格言 model 模型，偶像 example 例子 motto(maxim) Dream as if you would live forever, live as if you would die today! model(example) Albert Einstein The time is passing! rat n. 老鼠，耗子；公贼、叛徒、告密者、讨厌鬼、可耻的人 the Year of the OX principal n.校长 fragile adj.易碎的；脆弱的 affection n.恋爱，喜爱 affectionate adj. 充满深情的，有爱心的 precede vt.vi 在...之前，先于 patent 专利证书，专利发明 abrupt adj.突然的，意外的 valid adj.有效的，确凿的 accumulate vt.积累，累积，聚积 procedure n.程序，步骤，手续 abundant adj.丰富的，充裕的 tutor n.家庭教师，导师，助教 acknowledge vt.承认，确认，答谢 loan n.贷款，借出物 catalogue n.目录 absurb adj.荒谬的，可笑的 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/English/计算机专业英语.html":{"url":"docs/English/计算机专业英语.html","title":"计算机专业英语","keywords":"","body":"计算机专业英语 https://github.com/guanpengchn/awesome-pronunciation http://www.heycode.com/book/art/13642.html https://www.shanbay.com/wordlist/3004/28126/ https://github.com/HurleyJames/Computer-English-Words https://github.com/qomumu/JEnglish/blob/master/unit-1/1.md https://github.com/EarsEyesMouth/computerese-cross-referencesgi Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/medicine/医学常识.html":{"url":"docs/medicine/医学常识.html","title":"医学常识","keywords":"","body":"医学常识 头孢类药物 发烧和感冒区别 消炎药和抗生素 常用药物功效 自己的病： 2020年2月1号开始胸口疼，血压高 2019年12月份耳鸣 2019年2月份肛周脓肿 医学书籍 通风是很么？吃海鲜排不出来就通风？ 消炎药和抗生素 消炎药包括抗生素，抗生素更霸道 消炎药： 左氧氟沙星片.可乐必妥：用于治疗成年人大于18岁，由下列细菌的敏感菌株所引起的下列轻、中、重度感染（详见说明书） 阿莫西林胶囊和阿奇霉素分散片都是抗生素的，都是可以起到消炎效果的 消炎药:青霉素类，阿莫西林（西林），头孢（四代），（罗等*）红霉素，（）沙星， 可以吃头孢类药物，参考【头孢类药物】 发烧和感冒区别： 发烧（一般感冒），细菌，容易治疗 感冒（病毒感冒），病毒，不容易杀死，比如SARS，2019冠状病毒 病毒感染，细菌感染以及支原体感染。生病一定要抽血化验查找原因，只有找到反复感染的原因，才能对症治疗，从根本上解决问题。 没有细菌感染就不要用抗生素。 病毒感冒药，快克， 发烧感冒药：扑热息疼 感冒:连花清瘟教堂，快克，阿莫西林， 头孢类药物 头孢：各种球菌，杆菌引起的炎症，好多部位的各种炎症，扁桃体，咽炎，肺炎，中耳炎，脓疱病，创伤感染等，属于烈性消炎药，要注意是不是过敏才能吃，不能跟其他消炎药一起吃，更不能喝酒吸烟， 头孢类药物有好几代 头孢类抗生素。头孢目前主要有四代： 头孢氨苄是第一代， 第二代主要是头孢克洛，头孢呋辛，头孢孟多等。 第三代是目前最常用的，有头孢噻肟钠，头孢哌酮，头孢他啶，头孢曲松，头孢匹胺，头孢泊肟酯，头孢地嗪等。 第四代为最新，有头孢吡肟，头孢匹罗，头孢唑南等，应用不是太多。 头孢类药物有很多，通常按照产出的先后顺序分为：一代、二代、三代、四代、五代。 那么一代头孢，对革兰氏阳性菌效果比较好，代表药物有头孢氨苄，头孢唑啉。 第二代头孢，代表的药物有头孢克洛，头孢丙烯。 第三代头孢，代表的药物有头孢哌酮，头孢他啶。 第四代，代表药物有头孢吡肟。 不同的类型的头孢类的药物，那么其针对的一些细菌谱是不一样的。再比如，第四代第五代的头孢，对革兰氏阴性菌的效果很好，第五代的头孢，对革兰氏阳性菌阴性菌的效果都是很好的。 申洛.头孢克洛缓释胶囊：消炎药 天立威.头孢克肟片（肟[wò]） 常用药物功效： 小伤口：碘伏处理，纱布， 大伤口：双氧水， 医用酒精（75%酒精），主要是打针消毒 神经痛药物： 甲钴胺片，适用神经病变， 怡神保.甲钴胺片：肌肉痛 麦拓.甲钴胺片 高血压药： 硝苯地平控释片，适用高血压，冠心病，慢性稳定型心绞痛， 年轻人高血压：吃沙坦类降压药，比如安内喜.氯沙坦钾氢氯噻嗪片 欣然.硝苯地平缓释片：高血压药 止痛药： 布洛芬 及通安.氨酚曲马多片：本品用于中度至重度急性疼痛的治疗 可普芬.洛芬待因片：中等强度疼痛止痛，适用于术后痛和中度癌痛止痛 止疼药:阿司匹林，布洛芬，扑热息痛，罗非昔布， 耳鸣药： 金纳多.银杏叶提取物滴剂：耳鸣眩晕， 左拂.盐酸左氧氟沙星滴耳液：治疗敏感菌引起的外耳道炎、中耳炎 2020年2月1号开始胸口疼，血压高： 肩下面，乳房下侧，乳房周围，还有十字中心疼，喝热水也微痛，坐着有轻微呼吸困难， 从2月1号开始，吃了八天药了， 趴下床上，甚至侧着身子，有挤压就疼， 1月29或者30号开始的。 2月2号中午吃药 在诊所买了药，包括复方三七胶囊，阿莫西林胶囊，扑热息疼等 敏使朗.甲磺酸倍他司汀片 久联.萘普生胶囊 吃了没有什么效果 2月10号左右去宋集镇医院： 拍了CT和心电图，都没有什么异常，就让买活血止痛胶囊吃 没有什么作用 2月14号去县医院看病： 本来挂了心血管科，到了又直接去看的急诊科，结果是高中同班同学帮我看的 血压150多，心电图无异常，拍了胸部CT无异常，血检结果显示细菌感染，类似感冒 申洛.头孢克洛缓释胶囊：消炎药 怡神保.甲钴胺片：肌肉痛 欣然.硝苯地平缓释片：高血压药 吃了有点效果，后来就自己买药，没买到同牌子的，就买了下面两种替代 天立威.头孢克肟片 麦拓.甲钴胺片 康恩贝.甲钴胺片 3月5号到江苏省人民医院： 看了胸心外科（王伟专家号）：说是正常的，问有没有什么肌肉痛的检查，说没有，就拍了胸部CT，后来说出没有问题 看了心血管内科（钱卫冲专家号）：测量了两次血压，一次151-80多，一次148-88，医生让先暂停吃降压药，让回家早上测量一次，晚上睡觉前测量一次，每次测量三次，每次间隔一分钟，连续测试一周，然后再决定做什么检查或者使用什么药，说年轻人应该使用吃沙坦类降压药，不应该使用硝苯地平这类的降压药 复方三七胶囊，阿莫西林胶囊，扑热息疼，活血止痛胶囊， 阿莫西林胶囊和阿奇霉素分散片都是抗生素的，都是可以起到消炎效果的，所以这两个药物是可以使用的 消炎药包括抗生素，抗生素更霸道 2019年12月份耳鸣： 做了耳朵听力测试，没有问题，就给开了下面这两个药 金纳多.银杏叶提取物滴剂：耳鸣眩晕， 左拂.盐酸左氧氟沙星滴耳液：治疗敏感菌引起的外耳道炎、中耳炎 2019年2月份肛周脓肿： Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/medicine/腰椎间盘突出治疗.html":{"url":"docs/medicine/腰椎间盘突出治疗.html","title":"腰椎间盘突出治疗","keywords":"","body":"腰椎间盘突出 腰间盘突出 游泳、倒走、做小燕飞 把附近肌肉肌群锻炼到 一组哑铃一张卧推登够了[奸笑] 小的5公斤开始练😂 有条件直接健身房。开始固定器械也比较安全[奸笑] 腰间盘突出是什么 怎么减肥、怎么减肚子 德州扑克，下围棋 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Stock/股票Stock和基金学习.html":{"url":"docs/Stock/股票Stock和基金学习.html","title":"股票","keywords":"","body":"股票Stock和基金学习 躺赢计划 场内与场外的区别 场内基金与场外基金的区别 基金的开放封闭 ETF基金 联接基金 LOF基金 套利 股票、基金、证券、债券、信托、期货、国债、外汇 股票 基金 证券 债券 信托 期货 外汇 市盈率（静态市盈率，动态市盈率，TTM市盈率） 躺赢计划 【躺赢计划】是一个以指数基金为主要投资对象，以定投为投资方式，以低估买入、中估持有、高估卖出为投资策略，长期投资收益目标为年化15%的财富计划。 计划具体细节如下： 1.每周二午间进行定投，若遇节假日，顺延到下一个周二。 2.定投金额以300元一周为基准，市场越低估定投金额越大，越高估则金额越小。基准根据普通上班族一月工资6000的20%即1200设定，这是一个基本不影响生活的比例。 3.买入对象主要是场外的指数基金，若无低估品种可买则会买入货币基金，等有低估品种出现，再卖出货币基金买入。 4.股市有波动，短期买入有下跌风险，若无长期持有打算，或者3年~5年内需要用到的钱，请不要投入股市。 作者：躺赢君 链接：https://xueqiu.com/6943090400/127326199 来源：雪球 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。 市值=股价×总股本 在不同的地方上市，根据不同的地方股价计算，市值不同 总市值=A股市值+H股市值 总股本:225.78亿 港股本:158.82亿 股价13.260 总市值:2993.79亿 港市值:2106.01亿 一手：一手是证券市场的一个交易的最低限额，每个市场的规定不一样。 A股买卖交易规则以100股的整数倍为单位，也说以手为单位，即一手是100股。每次买进都只能是100股的整数，或是说一手的整数倍。 集合竞价、连续竞价、交易时间 股票振幅：股票振幅就是股票开盘后的当日最高价和最低价之间的差的绝对值与前日收盘价的百分比，它在一定程度上表现股票的活跃程度。 市盈率＝每股市价／每股盈利，反映市盈率偏低，股票价值被低估，一般来说，市盈率极高（如大于100倍）的股票，其股息收益率为零。因为当市盈率大于100倍，表示投资者要超过100年的时间才能回本，股票价值被高估，没有股息派发。 股票的市净率＝每股市价／每股净资产，市净率指的是每股股价与每股净资产的比率。 市净率可用于股票投资分析，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低 周转率(换手率)＝(某一段时期内的成交量)/(发行总股数)x100%，“换手率”也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。 量比=（现成交总手数 / 现累计开市时间(分) ）/ 过去5日平均每分钟成交量，量比的数值越大，表明了该股当日流入的资金越多，市场活跃度越高；反之，量比值越小，说明了资金的流入越少，市场活跃度越低。我们可以从量比曲线与数值与曲线上，可以看出主流资金的市场行为，如主力的突发性建仓，建完仓后的洗盘，洗盘结束后的拉升，这些行为可以让我们一目了然！ 内盘（空方急于卖出的能量大小）、外盘（主动性买盘）这两个数据大体可以用来判断买卖力量的强弱。 若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。 10. 各种指数 各种交易所 各种板块、行业 新经济公司将“回A股” 发行的CDR到底是什么？ 场外暗盘交易：暗盘交易只局限于有限的范围。交易时间，比较短暂，一般为新股正式上市日前一个营业日下午4时15分至6时30分的两个多小时的时间。 新股破发：最新的股票跌破发行价，新股破发中的发，是指股票的发行价格。新股破发是指股票发行上市当日就跌破发行价，在一级市场申购中签的股民也是要赔钱的。在股市中，当股价跌破发行价时即为破发。而普遍情况，特别在牛市行情中比较少见，在市场徘徊期常见到。 交易时间 周一至周五 (法定休假日除外) 上午9：30 --11：30 下午13：00 -- 15：00 竞价成交 (1) 竞价原则：价格优先、时间优先。价格较高的买进委托优先于价格较低买进委托，价格较低卖出委托优先于较高的卖出委托；同价位委托，则按时间顺序优先。 (2) 竞价方式：上午9：15--9：25进行集合竞价；上午9：30--11：30、下午13：00--15：00进行连续竞价 (对有效委托逐笔处理)。 什么是市值？ 一般来说，市值是指一家上市公司的发行股份按市场价格计算出来的股票总价值，公式表达就是“市值=股价×总股本”，这个概念几乎没有分歧。 1、站在上市公司的角度：市值=股价×总股本=净利润×市盈率 2、站在财务（外部）投资人的角度：市值=未来合宜的净利润水平÷预期回报率 严格的说，一家公司的股票其实不是“同时”在内地和香港上市，而是“一部分在香港一部分在内地”上市。比方说一亿股股票，不是在内地上市一亿、在香港也上市一亿。而是内地上市8000万，香港上市2000万。在内地上市的部分不可以在香港市场交易，在香港上市的部分也不可以在内地股市交易（除非经过复杂手续退出香港市场重新在内地股市上市）。所以两地上市也没什么冲突的，一边一部分而已。【引自《A＋H股公司总市值怎么算》】 中国上海证券交易所和深圳证券交易所的规定中，一手等于100股；香港一手可能是100股、200股、400股或20000股，每家公司都不一样。一手是证券市场的一个交易的最低限额，每个市场的规定不一样。 分为以下两种情况： 1、A股一手是100股。A股主要指的沪A（上海交易所上市的股票）与深A（深圳交易所上市的股票）。A股买卖交易规则以100股的整数倍为单位，也说以手为单位，即一手是100股。每次买进都只能是100股的整数，或是说一手的整数倍。 2、港股交易跟国内的股票交易不一样，它交易的每手股数是不固定的，不同的股票规定数是不同的，具体在股票的详情页能看到。有400股为一手、1000股为一手、2000股为一手、4000股为一手等。 股票振幅： （当日最高点的价格－当日最低点的价格）/昨天收盘价×100%=振幅 或者：最高点的幅度 - 最低点的幅度 = 振幅 数据分析编辑 股票振幅的数据分析，对考察股票有较大的帮助，一般可以预示几种可能： 1、可能是庄家高度控盘，散户手中流动的筹码很少，数量不多的成交量就会对股价形成很大波动。 2、可能是庄家通过大幅拉高或杀跌进行吸筹或出货的操作。 3、处于多空明显分歧的阶段，如某股票在连续上涨或者涨停后，打开涨停或跌停时，就会出现较大的价格波动。 股票的市盈率（Price-to-Earning Ratio，P/E或PER），又称为市盈率，指每股市价除以每股盈利（Earnings Per Share，EPS），通常作为股票是便宜抑或昂贵的指标（通货膨胀会使每股收益虚增，从而扭曲市盈率的比较价值）。市盈率把企业的股价与其制造财富的能力联系起来。 每股盈利的计算方法，一般是以该企业在过去一年的净利润除以总发行已售出股数。市盈率越低，代表投资者能够以相对较低价格购入股票。假设某股票的市价为24元，而过去一年的每股盈利为3元，则市盈率为24/3=8。该股票被视为有8倍的市盈率，即在假设该企业以后每年净利润和去年相同的基础上，如果不考虑通货膨胀因素，回本期为8年，折合平均年回报率为12.5%，投资者每付出8元可分享1元的企业盈利。但上市公司通常只会把部分盈利用来派发股息，其余用来作进一步发展，所以市盈率的倒数不等于股息率。 股息收益率 上市公司通常会把部分盈利派发给股东作为股息。上一年度的每股股息除以股票现价，是为现行股息收益率。如果股价为50元，去年股息为每股5元，则股息收益率为10%，此数字一般来说属于偏高，反映市盈率偏低，股票价值被低估。 一般来说，市盈率极高（如大于100倍）的股票，其股息收益率为零。因为当市盈率大于100倍，表示投资者要超过100年的时间才能回本，股票价值被高估，没有股息派发。 市盈率所代表的意义： 如果某股票有较高市盈率，则有可能因以下原因： 市场预测未来的盈利增长速度快。 该企业一向录得可观盈利，但在前一个年度出现一次过的特殊支出，降低了盈利。 出现泡沫，该股被以超过其内在价值的价格在交易。 该企业有特殊的优势，保证能在低风险情况下持久录得盈利。 市场上可选择的股票有限，在供求定律下，股价将上升。这令跨时间的市盈率比较变得意义不大。 如果某股票有较低市盈率，则有可能因以下原因： 市场预测该企业和去年相比较，盈利将减少，企业价值将下降。 该企业在去年出现过一次性的特殊收入，暂时提高了去年的盈利。 该股的价格被市场低估。 股票的供给超过了市场上资金的投资需求。 ※值得一提，如果某股票的市盈率为零，即代表股票去年是在于亏损状态。 股票的市净率（Price-to-Book Ratio, PBR, P/B），又名市账率、股價淨值比，指每股市价除以每股净资产，通常作为股票孰贱孰贵的指标之一。 市净率指的是每股股价与每股净资产的比率。 市净率可用于股票投资分析，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低；但在判断投资价值时还要考虑当时的市场环境以及公司经营情况、盈利能力等因素。 每股净资产 每股净资产是指股东权益与总股数的比率。其计算公式为：每股净资产= 股东权益 / 总股数。这一指标反映每股股票所拥有的资产现值。每股净资产越高，股东拥有的每股资产价值越多；每股净资产越少，股东拥有的每股资产价值越少。通常每股净资产越高越好。 在基本分析（Fundamental Analysis ）的各种指标中，每股净资产是判断企业内在价值最重要的参考指标之一。 什么是换手率 “换手率”也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。 换手率(Turnover Rate) 是以百分比衡量的一年内股票的成交量占股票总数的比例。以样本总体的性质不同有不同的指标类型，如交易所所有上市股票的总换手率、基于某单个股票发行数量的换手率、基于某机构持有组合的换手率。 换手率的计算公式 换手率的计算公式为： 周转率(换手率)＝(某一段时期内的成交量)/(发行总股数)x100% 换手率的实质意义 换手率的高低往往意味着这样几种情况： (l)股票的换手率越高，意味着该只股票的交投越活跃，人们购买该只股票的意愿越高，属于热门股；反之，股票的换手率越低，则表明该只股票少人关注，属于冷门股。 (2)换手率高一般意味着股票流通性好，进出市场比较容易，不会出现想买买不到、想卖卖不出的现象，具有较强的变现能力。然而值得注意的是，换手率较高的股票，往往也是短线资金追逐的对象，投机性较强，股价起伏较大，风险也相对较大。 (3) 将换手率与股价走势相结合，可以对未来的股价做出一定的预测和判断。某只股票的换手率突然上升，成交量放大，可能意味着有投资者在大量买进，股价可能会随之上扬。如果某只股票持续上涨了一个时期后，换手率又迅速上升，则可能意昧着一些获利者要套现，股价可能会下跌。 量比是衡量相对成交量的指标。它是指股市开市后平均每分钟的成交量与过去5个交易日平均每分钟成交量之比。其计算公式为：量比=（现成交总手数 / 现累计开市时间(分) ）/ 过去5日平均每分钟成交量 [1] 。 量比这个指标所反映出来的是当前盘口的成交力度与最近五天的成交力度的差别，这个差别的值越大表明盘口成交越趋活跃，从某种意义上讲，越能体现主力即时做盘，准备随时展开攻击前蠢蠢欲动的盘口特征。因此量比资料可以说是盘口语言的翻译器，它是超级短线临盘实战洞察主力短时间动向的秘密武器之一。它更适用于短线操作。 量比反映出的主力行为从计算公式中可以看出，量比的数值越大，表明了该股当日流入的资金越多，市场活跃度越高；反之，量比值越小，说明了资金的流入越少，市场活跃度越低。我们可以从量比曲线与数值与曲线上，可以看出主流资金的市场行为，如主力的突发性建仓，建完仓后的洗盘，洗盘结束后的拉升，这些行为可以让我们一目了然！ 内盘外盘，股市术语。内盘常用S（取英文 sell [sel] 卖出 的首字母S）表示，外盘用B（取英文buy [baɪ] 买入 的首字母B）表示。 内盘：以买入价格成交的数量，即卖方主动以低于或等于当前买一、买二、买三等价格下单卖出股票时成交的数量，用绿色显示。内盘的多少显示了空方急于卖出的能量大小。 外盘：以卖出价格成交的数量，即买方主动以高于或等于当前卖一、卖二、卖三等价格下单买入股票时成交的数量，用红色显示。外盘的多少显示了多方急于买入的能量大小。 内盘：以买一、买二、买三等价格成交的交易，买入成交数量统计加入内盘。 外盘：以卖一、卖二、卖三等价格成交的交易。卖出成交数量统计加入外盘。 内盘、外盘这两个数据大体可以用来判断买卖力量的强弱。若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。 参考 https://www.jianshu.com/p/d333c2873153 https://baike.baidu.com/item/%E8%82%A1%E7%A5%A8/22647 场内与场外的区别 场内场外的“场”指的是证券交易所。 通常在股票账户内买卖就是场内交易，在支付宝天天基金等平台申购赎回就是场外。 场内买卖交易，就可以看成是像咸鱼这样的二手市场，和其他投资人进行二手买卖。 场外申购赎回，就是我们直接向厂家（基金公司）进货或退货 我们把基金份额看做是一种商品，基金公司就是生产这种商品的厂家。 场内的价格实时变动，交易相对灵活，但是场内交易需要花更多的时间精力去操作。 场外3点前按当天的净值，3点后按下一个交易日的净值，比较省心省事。 场内基金与场外基金的区别 场内交易是指通过证券交易所进行的买卖活动。 用场内交易方式进行买卖的基金，就是场内基金，最典型的场内基金就是ETF。 只要不是场内交易的基金，全都是场外基金。比如我们用支付宝，蛋卷申购赎回的就是场外基金。 场内与场外基金的区别有几点： 交易价格不一样。场外基金所有的申购赎回都是按照当天统一的净值进行确认，一天只有一个价格。 而场内基金价格收市场涨跌影响，买卖价格是随时变化的。 场外基金未知价原则。 场外基金申购赎回是未知价原则，申购赎回时不知道净值多少，收盘后按照当天最终净值来确认。 场内交易，买卖时价格多少，就按什么价格清算。 交易时间不同 场内基金只有交易时间才能买卖，早上9点15到11点半，下午1点到3点。 场外基金随时可以委托，但是3点前委托按照当天的净值确认，3点后委托按照第二天的净值确认。 买卖的确认时间不同。 场内基金今天买入，明天就可以卖出。今天卖出的钱，当天就可以继续买入。 场外基金，一般周一买入，周三才能赎回。赎回的到账时间也比较长，一般都要几天时间才到账。 参考：场内基金与场外基金的区别 场内场外，傻傻分不清楚 基金的开放封闭 开放基金就是开放给投资者，可以在场外申购赎回的基金，故而基金的规模也是随时在变化的； 封闭基金就是发行完毕后，就不能申购赎回的基金。申购赎回期过后，投资者只能通过场内买卖，故而基金的规模是固定的。 ETF基金 ETF的全称为Exchange Traded Funds，是一种在交易所上市交易的、基金份额可变的一种指数基金。中文名叫“交易型开放基金”。是一种场内场外都可以交易的基金。 而且场内场外的份额可以互通。场外申购的可以在场内卖出；场内购买的，也可以在场外赎回。 不过ETF的申购门槛比较高，一般100万起步。所以我们普通投资者想买ETF，就只能到场内进行买卖，操作和买卖股票一样 联接基金 因为ETF的申购门槛较高，而场内买卖需要股票账户，而且需要手动操作，不能设置自动扣款定投等原因，于是有基金公司成立了联接基金。 联接基金就是买ETF的基金。买了联接基金，就等于买了对应的ETF。只不过联接基金是场外交易，方便没有股票账户的投资者和想要设置自动定投的投资者。 它的管理费和托管费一般和对应的ETF一致，不再额外多收费。只不过申购赎回费会比场内买卖的买卖佣金贵。 LOF基金 LOF基金是Listed Open-Ended Fund的缩写，称为上市开放式基金。 LOF和ETF类似，也是场内场外均可交易、场内场外份额互通的基金。 和ETF不同的是它的申购门槛较低，一般1000元起申购。所以我们普通投资者也可以在场外申购 ETF：场内买卖的指数基金 ETF链接：主要投资于ETF的开放式指数基金。 LOF：同时可以场内买卖和场外申购赎回的基金，可以是指数基金，也可以是普通的开放式基金。 套利 由于ETF和LOF都是场内场外均可交易，且份额互通，所以就会存在套利。 套利是什么呢？简单来说就是倒买倒卖。 比如香港的苹果手机比内地便宜，就会有很多代购从香港买了拿到内地卖，赚差价，这就叫套利。 基金也是一样。当同一只基金场内场外的价格出现价差，比如场内价格比场外便宜，就会有投资者买入场内的基金份额，拿去场外卖。 而一般ETF的交易量较大，报价比较实时，几分钟一次，所以场内外价差都比较小；而LOF的交易量较小，几小时甚至一天才报一次价，场内外价差一般较大。 买卖ETF和LOF时，一定要注意场内外的价差，在价格便宜的地方买，价格贵的地方卖。 参考：小白指数基金课：三分钟搞懂场内场外、开放封闭、ETF、联接、LOF什么是ETF，ETF链接，LOF？ 股票、基金、证券、债券、信托、期货、国债、外汇 股票 股票（stock）或是资本存货（capital stock）是一种有价证券，股份公司将其所有权借由这种有价证卷进行分配。因为股份公司需要筹集资金，因此将股票发给投资者作为公司资本部分所有权的凭证，成为股东以此获得股息（股利），并分享公司成长或交易市场波动带来的利润；但也要共同承担公司运作错误所带来的风险。 基金 通过发行基金份额，将众多资金集合成独立资产，由基金托管人（例如银行）托管，由专业的基金管理公司管理和运作，以投资组合的方式进行证券投资的一种利益共享、风险共担的投资方式。间接参与投资。 证券 证券（Securities）是有价证券的简称，是一种表示财产权的有价凭证，持有者可以依据此凭证，证明其所有权或债权等私权的证明文件。例如：股票、债券、权证和股票价款缴纳凭证等。 债券 债券，是发行者为筹集资金发行的、在约定时间支付一定比例的利息，并在到期时偿还本金的一种有价证券。 信托 信托是委托人基于对受托人的信任，将其财产权委托给受托人，由受托人按委托人的意愿以自己的名义，为受益人的利益或特定目的，进行管理和处分的行为。 期货 期货合约（Futures contract），简称期货（Futures），是一种跨越时间的交易方式。买卖双方透过签订合约，同意按指定的时间、价格与其他交易条件，交收指定数量的现货。通常期货集中在期货交易所，以标准化合约进行买卖，但亦有部分期货合约可透过柜台交易进行买卖，称为场外交易合约。交易的资产通常是商品或金融工具。双方同意购买和出售资产的预定价格被称为远期价格。未来的指定时间 - 即交付和付款发生时 - 称为交货日期。因为它是标的资产的函数，期货合约是衍生产品。 外汇 外汇是货币行政当局（中央银行、货币机构、外汇平准基金组织及财政部）以银行存款、财政部库券、长短期政府证券等形式所保有的在国际收支逆差时可以使用的债权。 股票，股票就是作为公司股东的一个凭证，证明股东的身份。需要关注的点是股东可以定期享受公司的盈利分红，可以去参与公司的一些管理。如果公司效益不好，也有可能会负担公司的亏损，你相当于是公司的所有者，公司的盈亏都和你有关。（市面小散户一般不参与公司管理） 债券，债券相当于是一个借款证明，公司为了筹集资金向社会公众发行债券，会写明到期日以及利息的支付，将来到期不管公司财务状况如何，都要支付本金和利息，所以如果你买债券，相当于是把自己的钱借给公司用，你到时候收固定的本金和利息，在这期间不会参与公司的管理、享受分红。公司的亏损也不需要你负责 基金，基金就是大家买了基金的钱会统一由基金公司来运作，由他们的基金经理去投资买股票、债券等，然后根据这些股票的收益来计算基金的收益 参考：【通俗理解】股票、基金、证券、债券、信托、期货、国债、外汇 股票分类 按票面形式，可分为记名股票、无记名股票和有面额股票。 按股东权利，分为优先股和普通股。 按流通状况，分为流通股和非流通股。 按上市交易所和买卖主体，可分为 A股：人民币普通股票。境内、港、澳、台居民均可开立A股账户。 B股：人民币特种股票。以人民币标明面值，以外币认购和买卖，在境内（上海及深圳）证券交易所上市交易的股票。准许持有合法外汇的境内居民自由开户买卖B股。 H股：境外上市外资股，是境内上市公司在境外发行上市的股份。 N股 S股 L股 我国上市公司的股票有A股、B股、H股、N股和S股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。 1、A股的正式名称是人民币普通股票。它是由我国境内的公司发行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票。 2、B股的正式名称是人民币特种股票，它是以人民币标明面值，以外币认购和买卖，在境内（上海、深圳）证券交易所上市交易的。 它的投资人限于：外国的自然人、法人和其他组织，香港、澳门、台湾地区的自然人、法人和其他组织，定居在国外的中国公民。中国证监会规定的其他投资人。现阶段B股的投资人，主要是上述几类中的机构投资者。B股公司的注册地和上市地都在境内。只不过投资者在境外或在中国香港，澳门及台湾。 3、H股，即注册地在内地、上 市地在香港的外资股。香港的英文是HOngKOng，取其字首，在港上市外资股就叫做H股。依此类推，纽约的第一个英文字母是N，新加坡的第一个英文字母 是S纽约和新加坡上市的股票就分别叫做N股和S股。 4、N股，是指那些在中国大陆注册、在纽约（New York）上市的外资股。在我国股市中，当股票名称前出现了N字，表示这只股是当日新上市的股票，字母N是英语New(新)的缩写。看到带有N字头的股票 时，投资者除了知道它是新股，还应认识到这只股票的股价当日在市场上是不受涨跌幅限制的，涨幅可以高于10％，跌幅也可深于10％。这样就较容易控制风险和把握投资机会。 如N北化、N建行、N石油等。 A股的正式名称是人民币普通股票。它是由我国境内的公司发行,供境内机构、组织或个人(不含台、港、澳投资者)以人民币认购和交易的普通股股票。 B股的正式名称是人民币特种股票。它是以人民币标明面值,以外币认购和买卖,在境内(上海、深圳) 证券交易所上市交易的股票。在2001年2月前,B股的投资人仅限于: 外国的自然人、法人和其他组织,香港、澳门、台湾地区的自然人、法人和其他组织,定居在国外的中国公民,以及中国证监会规定的其他投资人。2001年2月19日之后,中国证监会宣布对内开放B股市场,准许持有合法外汇的境内居民自由开户买卖B股。 H股又称境外上市外资股,是境内上市公司在境外发行上市的股份。 红筹股： 红筹股：在中华人民共和国境外注册，在香港上市的股票称为红筹股。红筹股已经成为除B股及H股外，内地企业进入国际资本市场筹资的一条重要渠道。 按公司业绩，可分为绩优股和垃圾股。 红筹股是指在中国境外注册、在香港上市的带有中国大陆概念的股票。“带有中国大陆概念”主要指中资控股和主要业务在中国大陆。 早期的红筹股，主要是一些中资公司收购香港中小型上市公司后改造而形成的，如“中信泰富”等。近年来出现的红筹股，主要是内地一些省市将其在香港的窗口公司改组并在香港上市后形成，如“上海实业”、“北京控股”等。 蓝筹股： 蓝筹股是指稳定的现金股利政策对公司现金流管理有较高的要求，通常将那些经营业绩较好，具有稳定且较高的现金股利支付的公司股票称为“蓝筹股”。蓝筹股多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱。 “蓝筹”一词源于西方赌场。在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱，红色筹码次之，白色筹码最差，投资者把这些行话套用到股票。 龙头股： 指的是某一时期在股票市场的炒作中对同行业板块的其他股票具有影响和号召力的股票，它的涨跌往往对其他同行业板块股票的涨跌起引导和示范作用。 黑马股： 黑马原本指在赛马场上本来不被看好的马匹，却能在比赛中成为出乎意料的获胜者。反映到股市上，黑马股是指投资者本来不看好，却能够异军突起，价格可能脱离过去的价位而在短期内大幅上涨的个股。 白马股： 是指长期绩优、回报率高并具有较高投资价值的股票，具有成长性，但是还没成为蓝筹权重的股票称为白马股。 白菜股： 指股票单价偏低的个股，没有确切的衡量标准的股票。白菜股不代表是烂股，有一部分银行股、钢铁股也是白菜股。 妖股： 股市上通常把那些股价走势奇特、怪异的股票称为“妖股”。 什么是ST股和PT股 ST股 根据证监会规定:当一个公司连续两年亏损或者净资产低于股票面值的时候，在股票名称前就会加上“ST”，表示“特殊处理”的意思。 沪深证券交易所在1998年4月22日宣布,根据1998年实施的股票上市规则,将对财务状况或其它状况出现异常的上市公司的股票交易进行特别处理,由于“特别处理”的英文是Special treatment（缩写是“ST”）,因此这些股票就简称为ST股。 ST股票每天的涨跌都不得超过5%。用于警示投资者注意投资风险和防止庄家恶意炒作。 如果在第三年，公司的经营未有改善，依旧处于亏损状态，股票名称前除“ST”外还会加上“”，即“ST”，意为有退市风险。 上述财务状况或其它状况出现异常主要是指两种情况, 一是上市公司经审计连续两个会计年度的净利润均为负值, 二是上市公司最近一个会计年度经审计的每股净资产低于股票面值。 在上市公司的股票交易被实行特别处理期间,其股票交易应遵循下列规则： （1）股票报价日涨跌幅限制为5％； （2）股票名称改为原股票名前加“ST”,例如“ST辽物资”； （3）上市公司的中期报告必须审计。 PT股 “PT”的英语 Particular Transfer（意为特别转让）的缩写。这是旨在为暂停上市股票提供流通渠道的“特别转让服务”。对于进行这种特别转让的股票,沪深交易所在其简称前冠以“PT”,称之为“PT股” 。 根据《公司法》和证券法的规定,上市公司出现连续三年亏损等情况,其股票将暂停上市。沪深交易所从1999年7月9日起,对这类暂停上市的股票实施“特别转让服务”。第一批这类股票有“PT双鹿”,“PT农商社”,“PT苏三山”和“PT渝太白”。 PT即特别转让。依据《公司法》和《证券法》规定，上市公司出现连续三年亏损等情况，其股票将暂停上市。沪深交易所对这类暂停上市的股票实施特别转让服务，并在其简称前冠以PT，称之为PT股票。 PT股票在历史上曾经出现过几只，它与正常的股票也存在着很大的区别。 PT股票和正常股票的区别： 1、交易时间不同。PT股票仅限于每周五的开市时间内进行，而非交易日持续交易。 2、跌幅限制不同。PT股票申报价不得超过上一次转让价格的上下5％，这个和ST股票的日涨跌幅相同。 3、撮合方式不同。PT股票是交易所于收市后一次性对该股票当天所有有效申报按集合竞价方式进行撮合，产生唯一的成交价格，所有符合成交条件的委托盘均按此价格成交。 4、交易性质不同。PT股票不是上市交易，因此，这类股票不计入指数计算，成交数不计入市场统计，其转让信息也不在交易所行情中显示，只由指定报刊设专栏在次日公告。 在目前，PT股票已经被停止交易，仅供大家了解此概念。 红筹股、蓝筹股、 龙头股、黑马股、白马股、白菜股、妖股有什么区别什么是ST股和PT股金融100问：什么是ST股、PT股？ 常见股票术语 开盘价、收盘价、最高价、最低价、压力线、支撑线、K线、美国线、牛市、熊市、多头、空头、除息、除权、买空、卖空 日KDJ，周KDJ，月KDJ同时低价金叉。 K线就是指将各种股票每日、每周、每月的开盘价、收盘价、最高价、最低价等涨跌变化状况， 那么，为什么叫“K线”呢？实际上，在日本的“K”并不是写成“K”字，而是写做“罫”(日本音读kei)，K线是“罫线”的读音，K线图称为“罫线”，西方以英文第一个字母“K”直译为“K”线，由此发展而来。 K线的支撑线、压力线和趋势线 压力线(Resistance Line)、、 将两个或两个以上的相对低点连成一条直线即得到支撑线。 将两个或两个以上的相对高点连成一条直线即得到阻力线。 支撑线又称为抵抗线。当股价跌到某个价位附近时，股价停止下跌，甚至有可能还有回升。这个起着阻止股价继续下跌或暂时阻止股价继续下跌的价格就是支撑线所在的位置。 压力线又称为阻力线。当股价上涨到某价位附近时，股价会停止上涨，甚至回落。这个起着阻止或暂时阻止股价继续上升的价位就是压力线所在的位置。 支撑线与压力线相互转化 一条支撑线如果被跌破，那么这个支撑线将成为压力线；同理，一条压力线被突破，这个压力线将成为支撑线。这说明支撑线和压力线的地位不是一成不变的，而是可以改变的，条件是它被有效的足够强大的股价变动突破。 k线中支撑线、压力线、趋势线的画法分析 常见股票指数 我们常提到的股票指数（如沪深300、中证50等），是一种以股票价格为对象的价格指数。价格指数指的是统计学里的动态相对数，能够表现出当前指数价格相对于基期的涨跌变化。 国内 上海证券交易所综合股价指数（上证综指） 深圳证券交易所成份股价指数（深证成指） 沪深300指数 创业版指数 我们比较常看到的上证50、沪深300、中证500指数等就是按照规模分类的指数。 上证50就是上海市场市值前50的公司组成的指数，沪深300就是沪深两市市值前300的公司组成的指数。 但也有一些特殊的情况：比如中证500是沪深两市排名从301开始到800的这500只股票，而不是排名从1到500；中证1000是从801到1800这1000只股票。 富时中国A50指数 富时中国A50指数，是由全球四大指数公司之一的富时指数有限公司(现名为富时罗素指数)为满足中国国内投资者以及合格境外机构投资者需求所推出的实时可交易指数。富时中国A50指数是沪深交易所市值排名前50的A股公司的实时可交易指数，其总市值占A股总市值的33%，是最能代表中国A股市场的指数，是投资中国内地A股市场的一个基准，也是富时中国指数系列的旗舰指数。 道琼斯指数 道琼斯指数其实是一系列指数的统称，但通常指其中的道琼斯工业平均指数。道琼斯工业平均指数是根据美国股票市场上30只可靠而且重要的蓝筹股的加权平均数计算出来的，这30只股票来自不同的领域，目前包括美国运通、迪士尼、维萨、3M、苹果、微软、英特尔、IBM、思科、威瑞森、埃克森美孚、雪佛龙、陶氏杜邦、家得宝、沃尔玛、耐克、宝洁、强生、波音、卡特彼勒、可口可乐、麦当劳、辉瑞、默克制药、高盛、摩根大通、旅行者保险、联合健康保险、联合技术、沃尔格林博姿联合公司。 标普500指数 标准普尔指数是美国最大的证券研究机构即标准·普尔公司编制的股票价格指数。最初采选了230种股票，编制两种股票价格指数。从1976年7月1日开始，改为 400种工业股票，20种运输业股票，40种公用事业股票和40种金融业股票。几十年来，虽然有股票更迭，但始终保持为500种。标普500指数覆盖的是最受欢迎、持有者最多的美国股票，代表性很强。 纳斯达克指数 通常说的纳斯达克指数指纳斯达克综合指数，是以在NASDAQ市场上市的、所有本国和外国的上市公司的普通股为基础计算的。其中代表性的是纳斯达克100指数。 纳斯达克100指数做为纳斯达克的主要指数，其100只成分股均具有高科技、高成长和非金融的特点，可以说是美国科技股的代表。值得一提的是，纳斯达克100指数里，这些高成长性股票的良好业绩，都是各自内生性的高成长带来的，特别是创新业务，而非例如资产注入等外延式的增长。 从纳斯达克100指数十大权重成分股来看，他们主要为高科技企业，其中计算机行业的公司居多，目前权重最大的为苹果(Apple)，另外包括微软(Microsoft)、谷歌(Google)、思科(Cisco)、英特尔(Intel)等诸多知名公司。 罗素2000指数 美股市场的三大股指是指道琼斯指数、标普500指数和纳斯达克指数。除此之外，还有一个追踪小盘股的罗素2000指数。罗素2000指数是代表市场上的中、小型股的市值指标，在市场上总市值只有8100亿美元，不及标普500的十分之一。 香港恒生指数 恒生指数，由香港恒生银行全资附属的恒生指数服务有限公司编制，是以香港股票市场中的50家上市股票为成分股样本，以其发行量为权数的加权平均股价指数，是反映香港股市价幅趋势最有影响的一种股价指数。 恒生指数的成份股具有广泛的市场代表性，其总市值占香港联合交易所市场资本额总和的90%左右。为了进一步反映市场中各类股票的价格走势，恒生指数于1985年开始公布四个分类指数，把33种成份股分别纳入工商业、金融、地产和公共事业四个分类指数中。 日经指数 日经指数是日本代表性的股票指数，是代表日本股市或资本市场是好是坏的晴雨表，也是反映日元价值的因素之一，因此会对日元在外汇市场上的汇率造成相关的影响。日元目前是七大工业国的货币也是外汇市场上交投最活跃的外汇之一，而日经指数的升跌的影响可谓举足轻重。日经指数因延续时间较长，具有很好的可比性，成为考察日本股票市场股价长期演变及最新变动最常用和最可靠的指标，传媒日常引用的日经指数，指的是日经225指数。 全球最著名的16个股票指数，你知道几个？国内常见的股票指数，你知道多少 市盈率（静态市盈率，动态市盈率，TTM市盈率） PE（TTM）、PE（静）、PE（动） 市盈率（Priceearnings ratio，即P/E）也称“本益比”，理论上的计算方法是每股股价除以每股收益，但是股价/每股市盈率=总市值/净利润，通常为了方便就用当前总市值除以一年的总净利润来计算，是反映该股票估值水平的重要指标。 市盈率（Priceearnings ratio，即P/Eratio）是某种股票每股市价与每股盈利的比率，最直接地表达投资者的投入与产出的关系。简单的公式为，市盈率=当前股价÷每股收益率，或者市盈率=当前股票总市值÷上年度净利润 如果PE=15，意味着按现价买入该股票，假如该公司保持不变的盈利能力，需要15年时间公司所赚的净利润按照你所持有的股权份额计算，刚好等于初始投入买股票的钱。说通俗一点就是持有该股票15年才能收回你的投入成本。以常见的房产投资为例，假设房租15年回本，我们可以理解为该套房产现在的PE就是15。 静态市盈率 静态市盈率，简称PE LYR，计算方式：当前总市值除以去年一年的总净利润。但是这种方法就会出现一个问题，如果说2018年3月想要参考PE的时候,很有可能出现这家公司年报还没更新出来（年度报告由上市公司在每个会计年度结束之日起4个月内编制完成），那么我就无法得知2017年的总净利润了，数据还是需要统计的，所以一般的炒股软件都是以2016年的数据来填充。那么就是说，大家看到的是市盈率(静态)=2018年3月的当前总市值/2016年的总净利润，时隔两年，这种误差可想而知！所以就有了PE TTM 滚动市盈率(TTM市盈率) 滚动市盈率，简称PE TTM，计算方式：当前总市值除以前面四个季度的总净利润。“去年一年”和“前面四个季度”有什么区别，我就不需要多加解释了，简单点想就是PE TTM要比PE LYR更加准确一点，数据来得更新一些。那么PE TTM就是我们常见的PE（动）吗？很肯定地说“不是”，这个教滚动市盈率，区别等等下面讲PE（动）的时候你就知道了。一般PE TTM用在比较严谨的期刊、研报等地方，讲究数据的准确性，不用PE（动）的原因也就是其中的计算数据是“虚”的 TTM市盈率又称为滚动市盈率，与静态市盈率不同，其分母为最近四个季度（仍以一年为周期）的净利润之和。滚动市盈率也叫市盈率TTM(Trailing Twelve Month)，是以最近报告的12个月(四个季度)的净利润或者每股收益为基础来计算的，我们分别用PE3和PE4来表示：滚动市盈率(PE3)=当前股价÷最近4个季度基本每股收益之和，或者是：滚动市盈率(PE4)=当前市值÷最近4个季度归属于上市公司股东的净利润。 动态市盈率 动态市盈率，简称PE（动），计算方式：当前总市值除以预估今年全年总净利润。注意这个“预估今年全年总净利润”，说得难听点这就是“虚”的，这个数据具体怎么来的也不得而知，总是会有他的一套计算方式，据说是以6个月内券商预测的净利润取平均数 动态市盈率的计算公式分母为未来一年的预测净利润，计算的公式也稍微要复杂一点点 比如说该股票已经发布第一季度财报，这时我们的公式分母就要×4，半年度财报，这时我们的公式分母就要×2，三季度财报，这时我们的公式分母就要×4/3。 如果说静态市盈率看的股票的过去，那么动态市盈率则是预测该股票的未来 如果动态市盈率＞静态市盈率说明这只股票该季度或者一段时间公司的净利润降低了，公司发展有些担忧。 市盈率作为最常见的价值投资指标，经常给投资人的决策带来了许多盲点和误区。市盈率研究的核心是：如果我按照当前股价买入股票，那么我几年后才能回本？一般来说市盈率是多少，那就是几年后能回补，其实中里面就存在着两个致命的误区。 第一，没有考虑净利润的变动，不可能用企业一年的净利润来判断今后几年，甚至几十年的净利润，净利润是动态的，所以还需要结合净利润增加率来做进一步的判断 第二，“回本”是什么意思？光同净利润来算本金，而完全不考虑公司本身的净资产，这本身就是不合理的。 市盈率（静态市盈率，动态市盈率，TTM市盈率）你了解吗？市盈率如何找低估？PE（TTM）、PE（静）、PE（动）傻傻分不清 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/Stock/经济名词.html":{"url":"docs/Stock/经济名词.html","title":"经济名词","keywords":"","body":"经济名词 银行抽贷 银行贷款给企业，在还未到协议规定的还款期限期间，银行认为企业经营出现问题了，要提前收回贷款的行为叫“抽贷”或“银行抽贷”。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/history/历史.html":{"url":"docs/history/历史.html","title":"历史","keywords":"","body":"历史 历史书籍 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/history/中国历史.html":{"url":"docs/history/中国历史.html","title":"中国历史","keywords":"","body":"中国历史 中国朝代顺序表 夏商周介绍 新武侠四大宗师（金、古、梁、温） 晚清四大名臣:曾、李、左、张 钓鱼城为什么被称为“上帝折鞭处”和“东方麦加”？ 春秋战国 春秋五霸战国七雄 春秋五霸 战国七雄 战国四公子 战国四大名将 五国相王 合纵连横 欧冶子 干将莫邪 越五剑 越王八剑 欧冶子所铸各剑的去向 诸子百家 四书五经 三教九流 三姑六婆 鬼谷子 尸子 吴起 孙膑 庞涓 商鞅 廉颇 苏秦 张仪 公孙衍 芈月（芈八子） 白起 王翦 李牧 诸子百家人物 道家 老子 庄周（庄子） 列御寇（列子） 儒家 孔丘（孔子、孔夫子） 孟轲（孟子） 荀况（荀子） 墨家 墨翟（墨子） 禽滑釐 孟胜 墨家巨子 法家 管仲（管子） 子产（姬侨） 韩非（子） 商鞅（卫鞅、公孙鞅、商君） 申不害 慎到 李斯 名家 阴阳家 邹衍 兵家 孙武（孙子） 孙膑（孙伯灵） 吴起(兵家)) 医家 岐伯 扁鹊 淳于意（仓公） 农家 纵横家 杂家 吕不韦 刘安 尸佼（尸子） 小说家 虞初 屈原 字玉 中国朝代顺序表 夏商周、春秋战国、秦汉三国（魏）晋南北朝、隋唐五代十国、（唐）宋元明清、中华民国、中华人民共和国。 中国朝代顺序表： 夏、商、周【西周、东周（春秋、战国）】、 秦、汉（西汉、东汉）、东汉末年分三国、 三国（魏、蜀、吴）、三国归晋、 晋（西晋、东晋）、五胡乱华、南北朝：五胡十六国、南北朝【南朝（刘宋、萧齐、萧梁、南陈）、北朝（北魏、东魏、西魏、北齐、北周）】、 隋唐五代传：隋、唐、五代十国【五代（后梁、后唐、后晋、后汉、后周）、十国（前蜀、后蜀、杨吴、南唐、吴越、闽、马楚、南汉、南平、北汉）】、 宋（北宋、南宋）、元、明、清：唐宋元明清 夏商周（西周、东周）、秦汉（西汉、东汉）、三国（魏、蜀、吴）、晋（西晋、东晋）、南北朝（南朝(宋、齐、梁、陈)、北朝(北魏、东魏、西魏、北齐、北周)）、隋唐、五代(后梁、后唐、后晋、后汉、后周)、十国（前蜀、后蜀、吴、南唐、吴越、闽、楚、南汉、南平(荆南)、北汉）、（唐）宋(北宋、南宋)元明清、中华民国、中华人民共和国。 中国朝代顺序如下：夏、商、周[西周、东周(春秋、战国)]、秦、汉（西汉、新朝、玄汉、东汉）、三国时期(魏、蜀、吴)、晋(西晋、东晋)、南北朝[南朝(宋、齐、梁、陈)、北朝(北魏、东魏、西魏、北齐、北周)、隋、唐、五代(后梁、后唐、后晋、后汉、后周)、十国[前蜀、后蜀、吴、南唐、吴越、闽、楚、南汉、南平(荆南)、北汉]、宋(北宋、南宋)、辽、西夏、金、元、明、清、中华民国、中华人民共和国。 新武侠四大宗师 新武侠四大宗师（金、古、梁、温） 金庸,查良镛，GBM ，OBE（英语：Louis Cha Jing-yong，1924年3月10日－2018年10月30日） 古龙（1938年6月7日－1985年9月21日），原名熊耀华 梁羽生（本名陈文统，1924年4月5日－2009年1月22日） 温瑞安（原名温凉玉） 晚清四大名臣 晚清四大名臣:曾、李、左、张 （从左至右）曾国藩、李鸿章、左宗棠、张之洞 夏商周介绍 夏：鲧（ gǔn ）禹治水（大禹治水）、太康失国、少康中兴、商汤灭夏、鸣条之战、夏桀、妺喜 鸣条之战是约公元前1600年，商汤在鸣条（今山西省运城市夏县之西，一说今河南省洛阳市附近）与夏军进行的一场决战，战争导致夏朝灭亡，商汤建立了商朝。 鸣条之战，夏室被推翻，在方国部落的支持下汤在亳[注 108]称“王”，建立商王朝，成为中国历史上的第一次朝代更替。中国的首个世袭制政权，夏朝，传十四世、十七君[注 1]，历时四百七十一年[注 3]，于前17世纪末、前16世纪初灭亡。 夏朝统治了400多年，到夏桀履癸统治时期，已是危机四伏。他宠信王后妺喜，重用嬖臣，残杀忠臣关龙逄，并对民众及所属方国、部落进行残酷的压榨奴役，引起普遍的憎恨与反对。 在后世的传说中，夏后桀被描写成一代暴君，后人常将夏后桀与商纣王、周厉王和周幽王四个祸国殃民的暴君并称，但在较早的文献中关于桀的记载甚为简略。 妺喜被视为红颜祸水的第一例证，其后又陆续出现商代妲己、周代褒姒。因此，当越王勾践差范蠡把西施献给吴王夫差的时候，伍子胥进言：“臣闻：夏亡以妺喜，殷亡以妲己，周亡以褒姒。夫美女者，亡国之物也，王不可受。”[6] 商：殷商、商汤、比九世乱（九世之乱、兄终弟及）、盘庚迁殷、武丁中兴、祖甲改制、武乙射天、帝辛亡国、牧野之战（武王伐纣）、帝辛（纣王）、妲己、比干、西伯昌、伯邑考、周武王、 商朝又称殷、殷商 是中国历史上第一个有直接文字记载的朝代。这标志着中国历史离开了传疑时代。商朝前期屡屡迁都，直至盘庚定都于殷（今河南省安阳市），以后再没有迁都，所以商朝又叫殷朝 商代出现的甲骨文和金文（因多刻于青铜器上，亦称“铭文”）是目前已经发现的中国最早的有系统性的文字符号。 其后经历17代30王的统治，末代君王帝辛于牧野之战被从西方崛起的周人统治者周武王率领联军击败而亡。 牧野之战：史称“武王克殷”[1]、“武王克商”、“武王伐纣” 受命十一年（约前1046年），商纣（帝辛）不顾虑财政，持续发动征讨东南夷的战争，已把商朝弄得国困民乏。周武王见时机己到，便联合庸、蜀、羌、髳卢、彭、濮等部族，亲自率领战车三百辆，虎贲三千人、甲士四万五千人，进攻商朝首都朝歌，在牧野发动战斗，血流漂杵。 周： 周文王：西伯昌、长子伯邑考，次子周武王 周朝是中国历史上继商朝之后的王朝，也是最后一个完全施行封建制度的世袭王朝，也是中国历史上历时最长的朝代，分为西周（约前11世纪－前771年）与东周（前770年－前256年）两个时期。 钓鱼城为什么被称为“上帝折鞭处”和“东方麦加”？ 1、“上帝折鞭处bai”：蒙古大军的西征欧洲被du欧洲历史学家们认为是上帝派来惩罚zhi欧洲的，因此钓dao鱼城被称为。 2、“东方麦加”：钓鱼城之战延续了南宋王朝的历史，与穆罕默德拿下麦加城，从而为统一阿拉伯半岛奠定基础有相同之处。 3、历史：1258年，蒙哥大汗挟西征欧亚非40余国的威势，分兵三路伐宋。蒙哥亲率一路军马进犯四川，于次年2月兵临合川钓鱼城。蒙哥铁骑东征西讨，所向披靡，然而在钓鱼城主将王坚与副将张珏的顽强抗击下，却不能越雷池半步。 蒙古打到欧洲的：巴格达（伊拉克首都）、叙利亚的大马士革 清朝历史 清朝历代皇帝顺序表 1、清太祖——努尔哈赤（称汗） 2、清太宗——皇太极（称汗后称帝） 3、清世祖——顺治皇帝 4、清圣祖——康熙皇帝 5、清世宗——雍正皇帝 6、清高宗——乾隆皇帝 7、清仁宗——嘉庆皇帝 8、清宣宗——道光皇帝 9、清文宗——咸丰皇帝（皇后慈禧） 10、清穆宗——同治皇帝 11、清德宗——光绪皇帝 12、宣统皇帝（没有庙号） 春秋战国 春秋五霸战国七雄 春秋战国时期，同属于东周东周可分为春秋时期与战国时期，中国进入诸侯争霸的时代，周王威严扫地，仅有天下共主的虚名。春秋战国分界：三家灭智、三家分晋 春秋是春秋五霸（齐、晋、楚、吴、越；一说：齐、晋、宋、秦、楚），战国是战国七雄（齐、楚、燕、韩、赵、魏、秦）。 春秋时期：周王室名义存在，诸侯分裂 战国时期：周王室彻底衰微，诸侯兼并 在中国几千年的历史长河里，有三个比较典型的\"大乱世\"。一个是春秋战国时期，一个是三国两晋南北朝时期，一个是唐末五代十国时期。 春秋战国分为春秋时期和战国时期，其分水岭是在公元前453年，韩、赵、魏三家灭掉智氏，瓜分晋国为标志。 春秋时期，\"礼乐征伐自天子出\"向\"礼乐征伐自诸侯出\"过渡，周王室虽然已经在衰微，但依然是各诸侯国名义上的共主，诸侯依旧需要履行义务。譬如定期朝见、上供、协从作战等，周王室依然具有一定的号召力。 战国时期，由\"礼乐征伐自诸侯出\"转向\"礼乐征伐自卿大夫出\"，周王室彻底衰微，不仅表现在其统治的地域的缩小，不过局促于一个小地方苟延残喘，更表现在各国势力的坐大，不再听命服从于周王室，也不再主动履行义务，以至于周王室穷困衰微，为了生存甚至违反\"天子不可向诸侯索要供物\"的规矩。 春秋时期，所展现的更多是从诸侯在周王室统一管辖下治理地方到分裂为数个小国家，彼此混战，这时天下是分裂的。 战国时期，由于长期战乱，一方面加速着民族融合，一方面也使人民逐渐厌战，渴望出现一个强大势力统一全国。因而已经由分裂开始转向统一，国与国之间的战争，兼并性质更浓，为秦统一六国，建立中央集权国家铺垫。 春秋时期，简称春秋，指公元前770年-公元前476年，是属于东周的一个时期。春秋时代周王的势力减弱，诸侯群雄纷争，齐桓公、晋文公、宋襄公、秦穆公、楚庄王相继称霸，史称春秋五霸（另一说认为春秋五霸是齐桓公、晋文公、楚庄王、吴王阖闾、越王勾践）。 战国时期简称战国，指公元前475年~公元前221年，是中国历史上东周后期至秦统一中原前，各国混战不休，故被后世称之为“战国”。“战国”一名取自于西汉刘向所编注的《战国策》。 春秋五霸 齐桓公、晋文公、宋襄公、秦穆公、楚庄王相继称霸，史称春秋五霸（另一说认为春秋五霸是齐桓公、晋文公、楚庄王、吴王阖闾、越王勾践） 春秋时期（公元前770年－公元前476年/公元前403年），简称春秋， 是东周的前半段时期。周室在平王东迁后实力大减， 没有足够的威望号令诸侯，因而形成春秋初期之局面。 春秋时代周天子的势力减弱，群雄纷争，春秋霸政形成，齐桓公、宋襄公、晋文公、秦穆公、楚庄王相继称霸，史称“春秋五霸”。当时齐桓公提出“尊周室，攘夷狄，禁篡弑，抑兼并”(尊王攘夷)的思想，因此周天子于表面上仍获尊重。 春秋时期因孔子修订的《春秋》而得名。这部书记载了从鲁隐公元年（前722年）到鲁哀公十四年（前481年）的历史，共二百四十二年。后史学家为了方便起见，一般从周平王元年（前770年）东周立国，平王东迁到洛邑起，到周敬王四十三年（前477年）或四十四年（前476年）为止（也有学者认为应到《左传》记载之终（前468年）、三家灭智（前453年）或三家分晋（前403年）），称为“春秋时期”。春秋时期之后是战国时期。据史书记载，春秋二百四十二年间，有三十六名君主被臣下或敌国杀之，五十二个诸侯国被灭。[2]。有大小战事四百八十多次，诸侯的朝聘和盟会四百五十余次。鲁国朝王三次，聘周四次。 前771年，因周幽王宠信褒姒，废太子宜臼。宜臼逃至申国，他外公申侯联合曾侯、许文公及犬戎（外族）推翻周幽王，都城宗周被毁坏，后周平王上任，前770年周平王被迫将国都从镐京迁至成周（雒邑）。因雒邑在镐京之东，此后的周朝史称东周。 战国七雄 战国时期简称战国，指公元前475年~公元前221年，是中国历史上东周后期至秦统一中原前，各国混战不休，故被后世称之为“战国”。“战国”一名取自于西汉刘向所编注的《战国策》。 参考春秋和战国的根本区别是什么？3分钟看懂春秋和战国之间的区别 战国四公子 齐国孟尝君田文 赵国平原君赵胜 魏国信陵君魏无忌 楚国春申君黄歇 战国四大名将 《千字文》将白起与王翦、廉颇和李牧并称为战国四名将 白起（秦国） 王翦（秦国） 廉颇（赵国） 李牧（赵国） 五国相王 五国相王，指的是古中国时期中的战国时代中叶五个主要诸侯国互相承认对方君主王位的事件，该事件标志着周天子权威的彻底丧失。 合纵连横 合纵，或合从，合众弱以攻一强[1]，中国春秋时期及战国时期的外交及军事策略，是南北纵向诸个国家合作，抵挡西边秦国的东向发展。战略上即使倡议诸国组成被动的联合防御阵线，依然不是长远有效的方式。同时各国间存在着历史的矛盾，携手联手防御简直是空谈。合纵最主要的战略创新则是从联合抗秦，提升到合作攻秦灭秦。 根据《史记·苏秦列传》，苏秦在游说秦惠王连横不成后，转而游说六国联合起来对抗秦国。合纵之势形成，苏秦掌六国宰相印，然而各国之间也存在大小矛盾，苏秦在齐国被刺杀，合纵联盟随之瓦解。最后被连横所破解。在合纵抗秦基础建立后，亦有合纵灭齐之举。 纵横家，是中国战国时期连合政军外交联盟的一派，《汉书·艺文志》列为“九流十家”之一。纵横家出现于战国至秦汉之际，多为游说策辩之士，可称为中国史上最早之外交政治家。他们的出现主要是因为当时列国割据分争，需要在国力富足的基础上，利用联合、排斥、威逼、利诱不战而胜，或辅之以兵法以较少的损失获得最大的收益。纵横家朝秦暮楚，事无定主，反复无常，策计划谋多基于国际现实政治要求。合纵派的主要代表是公孙衍和苏秦，连横派的主要代表是张仪。 纵横家的鼻祖是鬼谷子。纵横家的代表人物有公孙衍、张仪、苏秦（其中苏秦、张仪二人为同门师兄弟，同属鬼谷子门生）。另有甘茂、司马错、乐毅、范雎、蔡泽、邹忌、毛遂、郦食其、蒯彻等，事皆详于《战国策》。 欧冶子 欧冶子（？－？），春秋末期至战国初期越国人。中国古代铸剑鼻祖。据《越绝书》记载，他曾为越王允常铸了五柄宝剑：湛卢、巨阙、胜邪、鱼肠、纯钧；为楚昭王铸了三柄名剑：龙渊、泰阿、工布。 其女儿名为“莫邪”，而“干将”为其女婿。“干将莫邪”这二把剑就是其女儿女婿铸成。 欧冶子，春秋末期至战国初期越国人，莫邪之父。中国古代铸剑鼻祖。据《越绝书》记载，他曾为越王勾践铸了五柄宝剑：湛卢（仁道之剑）、巨阙、胜邪、鱼肠（勇绝之剑）、纯钧（尊贵无双之剑）；也为楚昭王铸了三柄名剑：龙渊（诚信高洁之剑）、太阿（威道之剑）、工布。 1965年12月在湖北省江陵县望山1号楚墓出土的“越王勾践剑”据传也是欧冶子所铸[来源请求]。该剑出土时仍寒光四射，锋利无比，反映了中国古代高超的铸剑技术，为古代兵器中的奇宝。 越王允常献给吴王僚的三把宝剑胜邪，鱼肠，湛卢 巨阙相传为春秋时欧冶子所铸。干将，莫邪，巨阙，辟闾号称四大剑。巨阙钝而厚重。阙：通“缺”意为残缺，但其坚无比故号“天下至尊”就是其他宝剑亦不敢与之争锋。 巨阙钝而厚重，阙：通“缺”，意为残缺。相传是“越五剑”里面最垃圾的一把，但其坚硬无比，故号“天下至尊”。 干将莫邪 干将（上古汉语（沙—白构拟系统）：kˁa[r] tsaŋ-s）与莫邪（上古汉语（沙—白）：mˁak ɢa）是一对铸剑师夫妻，最早出现于春秋时代。莫邪之父欧冶子亦为当时铸剑大宗师。干将与莫邪亦是中国传说中的非常著名的两把名剑，最早出现于春秋时代，取名自舍身炼剑的干将莫邪夫妇。 越五剑 湛卢：（仁道之剑） 巨阙 胜邪、 鱼肠、（勇绝之剑） 纯钧（尊贵无双之剑） 越王八剑 据拾遗记卷十，越王勾践曾采昆吾山之铜，铸了八把名剑： 一名掩日，以之指日，则光昼暗。金阴也，阴盛则阳灭。 二名断水，以之划水，开即不合。 三名转魄，以之指月，蟾兔为之倒转。 四名悬翦，飞鸟游过触其刃，如斩截焉。 五名惊鲵，以之泛海，鲸鲵为之深入。 六名灭魂，挟之夜行，不逢魑魅。 七名却邪，有妖魅者，见之则伏。 八名真刚，以切玉断金，如削土木矣。 欧冶子所铸各剑的去向 1、湛卢剑：吴越争霸，越王勾践战败，将湛卢剑作为贡品敬献吴王阖闾，吴王视为国宝，终日佩带在身，后飞往楚国被楚昭王所得，后传到南宋名将岳飞手中，岳被害后，不知去向。 2、纯钧剑：吴国名将伍子胥所佩，伍曾用此剑指挥干军万马历沙场，后沉入杭州钱塘江，若干年后，伍子胥也葬身于此。 3、鱼肠剑：专诸所用，公子姬光指使专诸用此剑刺死吴王僚谋夺王位，公子姬光继位后称阖闾，吴王做贼心虚，害怕见物思情，总觉得鱼肠匕首是不祥之物，因而封藏不敢佩用。事过十八年之后，阖闾王在吴越战争中受伤死亡，吴太孙夫差于公元前495年嗣位，并在破楚门外的海涌山为其父做了坟墓，连同鱼肠剑一同埋葬海涌山。到了公元前221年秦始皇统一中国，命人掘阎阊的坟墓，以求取鱼肠剑，但“凿山求剑无所得，洞凿处成深洞”，现为虎邱剑池，今日苏州风景区之一。 4、龙渊、工布二剑：越王灭吴之后，北上会齐、晋诸侯称霸业(中原)。到公元前235年，越国被楚国消灭，公元前222年，楚国被秦国灭，秦始皇统一中国，楚王所用的“龙渊”“工布”被秦始皇缴获成了他腰中之物。 5、干将莫 剑：吴越争霸时沉入延平（今南平）剑溪（闽江）。 诸子百家 诸子百家是后世对华夏先秦学术思想人物和派别之总称。诸子是指中国先秦时期老子、庄子、孔子、孟子、荀子、墨子、列子、申子、韩非子等学术思想代表人物。春秋后期已出现颇有社会影响的道家、儒家、法家、墨家、兵家、名家、阴阳家等不同学术流派，而至战国中期，百家争鸣，众多学说纷呈，丰富多彩，为中华文化奠定了深厚基础。 西汉司马迁在《史记》中引述了司马谈（司马迁之父）对学术流派的见解，司马谈把先秦以来的学派总归纳为六家(论六家要旨)，即：道家、儒家、墨家、法家、名家、阴阳家。 东汉班固在《汉书》中则把先秦以来的学派归纳为十家(九流十家)，即：道家、儒家、墨家、法家、名家、阴阳家、农家、纵横家、杂家、小说家。 吕思勉认为“术数”、“方技”、“兵书”三略，亦可称为先秦诸子，可算为十二家[1]。 各家学派和人物代表 儒家 孔子、孟子、荀子、曾子、子思、子夏 《论语》、《孟子》、《荀子》、《孝经》、《中庸》、《大学》、《礼记》、《春秋》、《左传》等 法家 管仲、子产、韩非、商鞅、慎到、李斯、申不害、李悝 《商君书》、《韩非子》 、《法经》、《管子》、《申子》、《李子》、《慎子》 墨家 墨子、禽滑釐、孟胜、田襄子 《墨子》、《墨子闲诂》、《田俅子》、《我子》、《随巢子》、《胡非子》 道家 老子、庄子、列御寇 《老子》、《庄子》、《黄帝四经》、《淮南子》、《列子》 阴阳家 邹衍 《汉书‧艺文志》着录“阴阳家二十一家，三百六十九篇”，现代都已失传。 纵横家 鬼谷子、张仪、苏秦 《捭阖策》《战国策》 杂家 吕不韦、刘安、尸佼 《吕氏春秋》、《淮南子》、《尸子》 兵家 孙武、孙膑、吴起、尉缭 《孙子兵法》、《孙膑兵法》、《吴起兵法》、《尉缭子》 医家（有时归入方技家） 扁鹊、岐伯 、淳于意 《黄帝内经》、《难经》、《神农本草经》、《伤寒杂病论》 方技家 岐伯 、淳于意 《汉书・艺文志》持诸子百家出于王官论： “儒家者流，盖出于司徒之官（司徒掌教育）。” “道家者流，盖出于史官（史官掌纪录典籍）。” “阴阳家者流，盖出于羲和之官（羲和掌星历）。” “法家者流，盖出于理官（理官掌刑法）。” “名家者流，盖出于礼官（礼官掌礼秩）。” “墨家者流，盖出于清庙之守（清庙之守掌祀典）。” “纵横家者流，盖出于行人之官（行人掌朝觐聘问）。” “杂家者流，盖出于议官（议官乃谏官议郎之属）。” “农家者流，盖出于农稷之官（神农、后稷教民稼穑）。” “小说家者流，盖出于稗官（稗官乃小官) “九流十家”的“九流”与“三教九流”的“九流”不同。 四书五经 四书五经是四书和五经的合称，是中国儒家的经典书籍。 四书又称为四子书，是指《论语》、《孟子》、《大学》、《中庸》。 五经是《诗经》、《尚书》、《礼记》、《周易》和《春秋》。 三教九流 三教九流（亦作九流三教）泛指古代中国的宗教与各种学术流派，是古代中国对人的地位和职业名称划分的等级。在古代白话小说中，往往含有贬义。 三教，指中国三大传统宗教：儒、释、道。 九流，指尊卑不同的九种身份。由尊至卑依次是：帝王、文士、官吏、医卜、僧道、士兵、农民、工匠、商贾。 在《汉书·艺文志》分别指：儒家、道家、阴阳家、法家、名家、墨家、纵横家、杂家、农家。九流十家，是九流以外加上小说家。 上九流帝王、圣贤、隐士、童仙、文人、武士、农、工、商。 中九流举子(科举中省试被取录者)、医生、相命、丹青(画匠、买画人)、书生、琴棋、僧、道、尼。 下九流师爷、衙差、升秤(秤手)、媒婆、走卒、时妖(拐骗及巫婆)、盗、窃、娼。 三姑六婆 三姑：尼姑、道姑、卦姑 六婆：牙婆、媒婆、师婆、虔婆、药婆、稳婆 三姑六婆原本指的是古代中国民间女性的几种职业。语出元末明初陶宗仪的《南村辍耕录》。[1] 现代汉语中的“三姑六婆”常指社会上各式市井女性或喜爱搬弄是非的人。 三姑指的是三种宗教的出家女性。尼姑是佛教女性僧侣、道姑是道教女性教徒、卦姑是专门占卦的。 六婆中，牙婆即女性牙人，为包括贩卖人口在内之商业交易牵线搭桥的中介。媒婆是专为人介绍配偶的女性。师婆是专门画符施咒、请神问命的巫婆。虔婆是妓院内的鸨母。药婆是专门卖药的女人。稳婆则是专门接生的接生婆，六婆是各种专业的名称，有时一人可以身兼数职。 由于三姑六婆因职业关系，而其中的牙婆、虔婆、师婆多为恶行被人病垢，而且在中国古代人的观念中三姑六婆是不正当职业，因此三姑六婆负上恶名，而事实上，对于三姑六婆的歧视，是多个方面因素造成的，有古时男女不平等的思想因素，也有三姑六婆的职业因素造成的。 鬼谷子 鬼谷子（？－？），传说原名王诩，又作王禅、王利、王通，一说字诩[1][2]，道号玄微子，世称鬼谷先生、王禅老祖，是大约活跃于战国中期的显赫人物，为“诸子百家”之一、纵横家的鼻祖，亦有政治家、外交官、阴阳家、预言家、教育家等身份。 根据《史记 卷六十九 苏秦列传 第九》及《史记 卷七十 张仪列传 第十》记载，鬼谷子有苏秦与张仪两个叱咤战国时代的杰出弟子，另传说孙膑与庞涓亦为其弟子，故被喻为纵横家之鼻祖[3][4]。 尸子 《尸子》，东周战国尸佼撰，原书有二十卷，目录一卷[1]。 尸佼是秦相卫鞅上客，卫鞅死，尸佼恐并诛，逃至蜀国[2]，后来尸佼对法家思想进行反思，并取各家之长，著成《尸子》一书，思想兼宗儒、墨、名、法，是为杂家，如主张“节葬”、“非乐”是墨家思想。《尸子》中提出“四方上下曰宇，往古来今曰宙。”，是今日“宇宙”一词的由来。 吴起 吴起（前440年－前381年），中国战国初期军事家、政治家、改革家，兵家代表人物。卫国左氏（今山东省定陶县，一说山东省曹县东北）人。[1] 吴起历侍鲁、魏、楚三国，通晓兵家、法家、儒家三家思想，在内政、军事上都有极高的成就。仕鲁时曾击退齐国的入侵；仕魏时屡次破秦，尽取秦国的河西地区（今山西、陕西两省间黄河南段以西地区），成就魏文侯的霸业；仕楚时主持改革，史称吴起变法。但吴起的变法损害了楚国贵族的利益，他本人也遭到了旧势力的报复。前381年，楚悼王去世后，楚国贵族发动兵变杀害吴起。 吴起著有《吴子兵法》一书，由于他在军事理论上的贡献，后人将孙武、吴起并称为“孙吴”。[2]唐肃宗时将吴起等历史上十位武功卓著的名将供奉于武成王庙内，被称为武庙十哲。[3]宋徽宗时追尊吴起为广宗伯，位列宋武庙七十二将之一。[4]司马迁著《史记》时，将孙武和吴起合立于《孙子吴起列传》。现代学者马非百著《秦集史》时，将李悝和吴起合立于列传中。[5] 孙膑 孙膑（前382年－前316年），原名孙伯灵[注 1]，因受过膑刑，故世人习称“孙膑”。是活跃于战国中期的军事家，兵家代表人物。 孙膑曾与庞涓为同窗，二人一同拜师[注 5]学习兵法。庞涓后来出仕魏国，担任了魏惠王的将军，但是他认为自己的才能比不上孙膑，于是暗地派人将孙膑请到魏国加以监视。孙膑到魏国后，庞涓嫉妒他的才能，于是捏造罪名将孙膑处以膑刑和黥刑，砍去了孙膑的双足[注 6]并在他脸上刺字，想使他埋没于世不为人知。 桂陵之战 马陵之战（庞涓死） 围魏救赵 庞涓 庞涓（前385年－前342年），活跃于战国中期的军事家，魏国将军。因妒贤迫害同仕魏国的同学孙膑，孙膑逃至齐国。前354年在桂陵之战被孙膑俘虏，透过调停后释放。前342年马陵之战与太子申一并败于田盼，于此战阵亡。 相传与孙膑同拜于隐士鬼谷子门下，庞涓在魏国被拜为将军，引孙膑入魏国，向魏王推荐他，却恐其贤于己，因而诬陷孙膑罪名，处以膑刑和黥刑，砍去了孙膑的双足，并在其脸上刺青，因为古时这样的罪犯被士大夫所轻视，基本上不能任官[1]。孙膑于是逃奔齐国，在齐国获得田忌的赏识，担任其军师。 桂陵之战 马陵之战（死） 围魏救赵 商鞅 战国时代政治家。有人说他是尸子的徒弟。 商鞅（前390年－前338年），中国历史上战国时代政治家、统帅，法家法派[注 1]代表人物。卫国国君的后裔，姬姓，故称为卫鞅，又称公孙鞅。[3]后因在河西之战中立功获封于商[注 2]十五邑，号为商君，故称之为商鞅。 廉颇 廉颇（？－？），嬴姓，廉氏，名颇，晋系金文作𡉣波，籍贯有山西太原、山西运城、山东德州等说。封信平君，战国末期赵国之良将，与白起、王翦、李牧并称“战国四大名将”[1]。曾战胜齐国、魏国、燕国。 苏秦 苏秦，雒邑（今河南洛阳东）乘轩里人，战国时期著名纵横家，提倡合纵（联合六国对付秦国）。 苏秦（？－前284年），己姓，苏氏，字季子，东周雒邑（今河南洛阳东）乘轩里人，相传为鬼谷子徒弟。战国时期纵横家、外交官和谋略官。 苏秦与张仪同出自鬼谷子门下，跟随鬼谷子学习纵横之术。 有说法认为他和张仪两人彼此呼应，共同达到个人的目的。 苏秦游说完各个诸侯后，六国达成合纵联盟，团结一致。苏秦被任命为纵约长（合纵联盟的联盟长），并且担任了六国的宰相，同时佩戴六国相印。 张仪 张仪，魏国安邑（今山西夏县）人，战国时期著名纵横家。提倡连横，（由秦国联合其他诸侯国对抗其他诸侯国），多次破坏了苏秦的合纵（联合六国对付秦国），为秦惠王重用，后来亦就任秦国宰相，卒于魏国。《战国纵横家书》则记载张仪与当时提倡合纵的公孙衍对峙。 张仪（前373年－前310年），姬姓，张氏，魏国安邑（今山西夏县）人，战国时期著名的纵横家。提倡连横，即秦国联合其他诸侯国中的几个，然后对抗其他的诸侯国，多次破坏了公孙衍的合纵，为秦惠王重用，后来亦就任秦国宰相，卒于魏国。 1973年在长沙马王堆汉墓出土的《战国纵横家书》中所载，苏秦死于公元前284年，张仪死于公元前310年。与张仪的连横同时对峙的可能为犀首（即公孙衍）的合纵，而非苏秦的合纵；苏秦亦未用计入张仪于秦，这些都不同于《史记》与《资治通鉴》所言。 近代有学者认为苏秦活跃于张仪死后，《史记》关于苏秦用计让张仪入秦的记载有误，与张仪的连横同时对峙的应为公孙衍的合纵。 公孙衍 公孙衍（约前360年－约前300年），魏国阴晋（今华阴市东北）人。曾仕魏，任犀首之官（军官名），人因以犀首称之[1]，是战国时期出身于魏国的纵横家，和张仪同期，先后于秦国、魏国为官，为张仪的连横策略的主要对手。公孙衍在当时一些人的心目中是与张仪齐名的，但传下来的事迹不多。《史记》有公孙衍传，系附于张仪传。《战国策》也只有几条零星的记载。 芈月（芈八子） 宣太后（前337年－前265年），芈姓，又称芈八子、秦宣太后。战国时期秦国王太后，秦惠文王之妾，秦昭襄王之母，中国第一位号为“太后”者。 宣太后的本名、父母、出生时间、早年事迹均无详细记载，仅知宣太后是楚国人。而后在出土的文物中，发现刻有芈姓及月字。秦惠文王的妃嫔，位阶为“八子”，号称“芈八子”。秦国后宫分八级：王后、夫人、美人、良人、八子、七子、长使、少使。前325年，宣太后生下公子稷（即秦昭襄王），另有两子公子市和公子悝。 白起 白起（前332年？－前257年11月），赢姓白氏，公子白之后故称公孙，《战国策》作公孙起，[2][3][4]郿县（今陕西省眉县常兴镇白家村）人，中国战国时代军事家、秦国名将，兵家代表人物。 白起担任秦国将领30多年，攻城70余座，歼灭近百万敌军，未尝一败，被封为武安君。白起一生有伊阙之战、鄢郢之战、华阳之战、陉城之战和长平之战等辉煌胜利，《千字文》将白起与王翦、廉颇和李牧并称为战国四名将。[5] 王翦 王翦（？－？），战国时期秦国名将，关中频阳东乡（今陕西富平东北）人，主要战绩：破赵国都城邯郸，消灭燕和赵；以秦国绝大部分兵力消灭楚国后，接着率领平楚大军南下平定百越。与白起、廉颇、李牧并称战国四大名将。其曾孙是琅琊王氏和太原王氏的始祖。 李牧 李牧（？－前229年），名繓zuǒ[1]，字牧[2]，战国后期军事家，赵国名将，与白起、王翦、廉颇并称战国四大名将。 李牧驻守代郡、雁门郡期间，率军大破匈奴。在肥之战、番吾之战两次击败秦国，受封武安君，但最终被赵幽缪王杀害。而关于李牧的死因，史料记载也多有不同。李牧死后仅三个月，赵国首都邯郸（今河北省邯郸市）被秦军攻破，赵幽缪王成为阶下之囚。 诸子百家人物 道家 道家是中国诸子百家中重要的思想学派之一，也是九流十家之一，在春秋战国时期以老子、庄子为代表。 一般认为老子应是实质可考的道家始祖，经由庄子、列子、杨朱等人的发展，成为一门经典，其中法家，名家，纵横家也受道家的影响。 道家主张“顺其自然”，认为要用到法律时（法和法律有不同；法好比物理，而法律则是人为），大道已经废弃了。因此社会上没有道德仁义[1]，因此不主张要用法去治人；法家则主张要用法律去惩治人，认为人类本性顽劣，要用权威与固定的法条以治天下。道家思想与法家思想多有抵触，但到了法家的韩非子时，却利用道家《道德经》的章句，以阐发法家思想。 道家虽然学派上有所区别，但就其主旨来说是相通的：以“道”为本，自然无为。 老子思想的核心是“道”，老子曾在其著作中说：“有物混成，先天地生。寂兮寥兮！独立而不改，周行而不殆，可以为天地母。吾未知其名，字之曰道。”[2] “大邦以下小邦，则取小邦，小邦以下大邦，则取大邦”[3] 以大邦为世界，以大邦以下小邦为国家，小邦以下大邦为本土。道家是中国最早的本土独立思想，与董仲舒的春秋大一统思想大异旨趣。 庄子思想的核心是“逍遥”与“齐物”。主张“天地与我并生，万物与我为一”的哲学思想。杨朱据说是老子的弟子，但他非常激进，提出“贵己”，“为我”。主张“全性保真，不以物累形”。战国时期稷下学宫的《管子》诸篇，主张“守则重，不守则轻”与“一年树谷，十年树木，百年树人”自小入大的道家哲学思想。 老子提出“道”是宇宙本源，也是统治宇宙中一切运动的法则。这一观点被后来所有道家所有流派支持，成为道家最基础核心。道家贵生，存生，养生，轻视物质，以心灵的逍遥，万物的齐一为最高价值。 老子 老子（？－？），姓李，一说姓老又一说姓利，名耳或贞，字伯阳、外字聃，世人尊称为“老子”[注 1]，生于东周的楚国苦县厉乡曲仁里（原属陈国，今河南省鹿邑县），师从殷商末臣商容[2]，于东周春秋时周朝守藏室[注 2]任柱下史[注 3]。中国春秋时代思想家，隐居邢台广阳山。其著作被人们广泛称为《道德经》，是道家的经典，亦是全球文字出版发行量最大的著作之一。 老子的学说后被庄周、杨朱、列御寇等人发展[3]，后人奉为道家学派之开教宗师。《史记·老子韩非列传》中曾记载孔子向老子请教关于礼的问题。老子主张无为而治、天人合一、清静无为的统治理念，和庄子同样是道家的重要人物，合称“老庄”。 老子被尊为道家与道教始祖、东方三大圣人之首，唐朝追认李聃为李姓始祖。老子是世界文化名人，世界百位历史名人之一。 庄周（庄子） 庄子（约前369年－前286年）[1]，庄氏，名周，一说字子休，约与孟子同时，为战国时代宋国蒙（商丘民权庄子镇）人，曾任漆园吏。他是著名思想家、哲学家、文学家，是道家学派的代表人物，老子思想的继承和发展者，后世将他与老子并称为“老庄”。公元742年，唐玄宗天宝初，诏封庄周为南华真人，称其著书《庄子》为南华经[2]，在四库全书之中归类为子部道家类。宋徽宗时，追封为“微妙元通真君”。 列御寇（列子） 列御寇（前450年－前375年），或称列圄寇，春秋时期[1]郑国人，道家学派的先驱者，人称列子，主张“贵虚”。 儒家 儒家，又称儒学、孔孟思想、孔儒思想，诸子百家及九流十家之一，是一种起源于中国并同时影响及流传至其他周遭东亚地区国家的文化主流思想、哲理。前5世纪由孔子创立，脱胎自周朝礼乐传统，以仁、恕、诚、孝为核心价值，着重君子的品德修养，强调仁与礼相辅相成，重视五伦与家族伦理，提倡教化和仁政，轻徭薄赋，抨击暴政，力图重建礼乐秩序，移风易俗，保国安民，富于入世理想与人文主义精神。 儒家尊崇孔子为圣人，以四书五经为经典，得孟子、荀子、董仲舒、韩愈、二程、朱熹、王阳明、顾炎武、朝鲜李退溪、日本山崎闇斋等等大儒加以发扬，历久而犹新，对东亚政治文化与道德教育都有重大贡献。 孔丘（孔子、孔夫子） 孔丘（前551年9月28日[1][2]－前479年4月11日[3]），子姓，孔氏，名丘[4]，字仲尼，后代敬称孔子或孔夫子。生于鲁国陬邑，祖先为宋国人，东周春秋末期鲁国的教育家与哲学家，曾在鲁国担任官府要职。孔子为儒家创始人[5][6][7]，其德性论五行思想（仁义礼智信）对邻近地区，如：朝鲜半岛、琉球、日本、越南、东南亚等有深远影响，此等地区也被称为儒家文化圈。 孟轲（孟子） 孟子之弟子万章与其余弟子著有《孟子》一书。继承并发扬孔子的思想，成为仅次于孔子的一代儒家宗师，被尊称为孟亚圣，又称孟子林[2]，与孔子合称为“孔孟”。 孟子（公元前372年－公元前289年）[1]，名轲，邹国（今山东省邹城市）人，东周战国时期儒家代表人物。其字号在汉代以前的古书没有记载，但曹魏、晋代之后却传出子车、子居、子舆、子展等不同的字号，字号可能是后人的附会而未必可信。生卒年月因史传未记载而有许多的说法，其中又以《孟子世家谱》上所记载之生于周烈王四年（前372年），卒于周赧王二十六年（前289年）较为多数学者所采用。 荀况（荀子） 荀子（约公元前316年－约公元前237年至公元前235年），名况，被尊称为荀卿，又称孙卿、孙卿子[1]:273，中国战国时代儒家学者和思想家，赵国人，曾担任齐国稷下学宫祭酒、楚国兰陵令，到赵国、秦国游说诸侯，宣扬儒学和传授六经，批评子思、孟子等其他儒者及墨家、道家等其他学派，有韩非、李斯等弟子，著作后世编为《荀子》一书。 墨家 墨家逻辑是中国古代第一个逻辑学体系，全球三大古典逻辑体系之一，主要以三物论为代表，三物分别为故、理、类。《墨辩》是墨家逻辑的主要著作。 墨家的政治思想主要有以下十点（亦可称为“十论”）：兼爱、非攻、尚贤、尚同、天志、明鬼、非命、非乐、节用、节葬 墨翟（墨子） 墨子（前468年？－前376年[a]），子姓，墨氏，名翟，春秋末战国初期宋国（今河南商丘）人，一说鲁国（今山东滕州木石镇）人，是中国战国时期著名思想家、政治家、科学家、军事家。 提出了“非儒”、“兼爱”、“非攻”、“尚贤”、“尚同”、“天志”、“明鬼”、“非命”、“非乐”、“节葬”、“节用”、“交相利”等观点，创立墨家学说，并有《墨子》一书传世。墨家在当时影响很大，墨子因反儒，创立墨学。重视科学。《墨子》一书中体现的墨子的思想在后世仍具有一定影响，广为流传的《千字文》中便记载了出自《墨子·所染》的“墨悲丝染”的故事。到了清朝，随着诸子学的兴起，学者对墨子思想的研究又提升到新的高度。 禽滑釐 禽滑gǔ釐lí[1]（？－？），字慎子[2]，是战国时期魏国人，墨子弟子。 禽滑釐早年学于子夏[3]，后来拜墨子为师，曾询问墨子小国如何防守大国攻城的方法。墨子很信任他，“尽传其学，与墨子并称”。禽滑釐尝率墨者三百人[4]，协助宋国守城，以抵御楚国入侵。 孟胜 孟胜（？－？），中国东周末年的墨家钜子。其著名事迹是为了守义，与约180名弟子死于楚国阳城君（一说鲁阳文君）的封地。 墨家巨子 钜子又称巨子，墨学，在先秦时代和儒学同称显学，可惜在秦以后逐渐寝寂了，一直有很少的人在做墨子的研究，但是直到清朝中期墨学的中兴才开始。 墨家有着严密的组织，其领袖也就是巨子（钜子），墨子有没有当过巨子，这个无法考证，但方授楚《墨学源流》认为墨子是墨家第一任巨子，禽滑釐（qín gǔ xī）是第二任巨子，这也只是一家之言，从先秦典籍中可考证的墨家巨子只有三人：孟胜，田襄子，腹䵍，见于《吕氏春秋》。 法家 法家中有三派：慎到重“势”、申不害重“术”，商鞅重“法”[2]。 法家是中国历史上研究提倡用法治理国家的思想学派，春秋战国时期从未有一个组织或学派叫“法家”，而只是在西汉司马谈的《论六家要指》将韩非子、管子等理念相似的人归类为一派并命名“法家”。《汉书·艺文志》列为“九流”之一。法家成熟很晚，但成型很早，其思想源头可上追溯于夏商时期的理官。春秋、战国等时期管仲、李悝、子产、吴起、商鞅、慎子、申子、乐毅、剧辛等人予以发展，遂成为一个学派，到了战国末期由韩非集其大成。汉代时对他们的学说加以总结、综合，其思想则成治理国家的基础。 法家的治国思想完全从统治者的角度出发，来审视战国时期的问题[1]。法家学说的作者本身并不是统治者，但希望通过其思想，被统治者任用。法家指出统治者如何有效地组织和控制政府，使国家财富和领土得到最大限度的增加。法家认为，要扩大疆域、增加财富，只能以君主专制，即统治者在其领域内的绝对个人权力，才能实现。 在战国时期盛行的所有关于个人和政治的思想学派中，如果有一个赢家，那只能是法家[1]。依靠法家思想，秦国宰相商鞅在公元前360-338年期间，在秦国推行了一系列改革。商鞅变法是秦国能统一六国的重要原因。 管仲（管子） 管仲（前725年？－前645年），姬姓，管氏，名夷吾，字仲，谥敬，被称为管子、管夷吾、管敬仲，颍上（今安徽省颍上县）人，春秋时代法家代表人物。齐国的政治家，哲学家，与乐毅齐名，周穆王的后代[1]。管仲虽然仅是齐国下卿[2]，却被视为中国历史上宰相的典范，任内大兴改革，重视商业。[3]《国语·齐语》、《史记·管晏列传》、《管子》、《左传》等都载有他的生活传记，《论语》中也有几处关于孔子对他的评论，北宋苏洵的《管仲论》也对管仲做出了分析和批判。 管鲍之交：年轻时家境贫困，鲍叔牙与管仲往来，发现管仲有才能，胜过自己[4]，往来过程中，管仲常占小便宜，鲍叔牙不以为意，反为他设想，蔚为美谈，史称“管鲍之交”。后来，管仲辅佐齐国公子纠，鲍叔牙辅佐其弟公子小白。 子产（姬侨） 子产（？－前522年），姬姓，国氏，名侨，字子产，又字子美，谥成[2][注 1]，又称公孙侨、公孙成子、东里子产、国子、国侨、郑乔，是春秋末期郑国的政治家、思想家、改革家。 子产执政期间，改革内政，慎修外交，捍卫郑国利益，极受郑国百姓爱戴，后世对其评价甚高，将他视为中国历史宰相的典范，清朝的王源更推许他为春秋第一人。 韩非（子） 韩非（约前281年－前233年），生活于战国末期时期的韩国（今属河南省新郑市）的思想家，为中国古代法家思想的代表人物，认为应该要“法”、“术”、“势”三者并重，是法家的集大成者。 韩非总结法家三位代表人物商鞅、申不害、慎到的思想，主张君王应该用“法”、“术”、“势”三者结合起来治理国家，此为法家之博采众长之集大成者。韩非也是先秦诸子百家史料可证中最后一位子学思想人物。 韩非（约公元前280年－公元前233年），又称韩非子，战国末期韩国新郑（今属河南）人。中国古代思想家、哲学家和散文家，法家学派代表人物。 [1] 韩非是法家思想之集大成者。他将商鞅的“法”、申不害的“术”和慎到的“势”集于一身，并且将老子的辩证法、朴素唯物主义与法融为一体，为后世留下了大量言论著作。其学说一直是中国封建统治阶级治国的思想基础。 韩非著有《孤愤》《五蠹》《内储说》《外储说》《说林》《说难》等文章，后人收集整理编纂成《韩非子》。 [2] 商鞅（卫鞅、公孙鞅、商君） 参考 [商鞅](#商鞅 申不害 申不害（前420年－前337年），尊称申子，中国战国时代郑国京邑（今河南荥阳）人，郑国被韩国所灭之后，以法家学说，成为韩昭侯的宰相，为中国先秦诸子百家中法家‘术’派代表人物。著作《申子》。 慎到 慎到（前395年－前315年），赵国邯郸人，时期约稍早于孟子，为战国时道家、法家思想家。法家中有三派：慎到重“势”、申不害重“术”，商鞅重“法”[1]。 慎到早年学黄老道术，也受到儒家西河学派（子夏学派）的影响，曾到齐国稷下讲学而负盛名，受上大夫之禄。齐湣王十七年（前284年）慎到离齐至韩，为韩大夫，和田骈、接子、环渊同时[2]。《庄子·天下》把他与田骈同归一派，后成为从道家分化出来的法家，主张“尚法”和“重势”。由“弃知去己”观点，提出“大君任法而弗躬，则事断于法矣。”[3]的法家政治主张，强调“官不私亲，法不遗爱”。同时重视“势治”，以为“贤智未足以服众，而势位足以蹳贤者”[4]，权势者应“抱法处势”，“无为而治天下”。《史记·孟子荀卿列传》谓其著有十二论。 李斯 李斯（前284年－前208年）[2]，字通古，楚国上蔡（今河南省上蔡县西南方）人，是秦朝著名的政治家、文学家和书法家。李斯曾任秦朝左丞相，司马迁著《史记》，将李斯和赵高并写于《李斯列传》。 名家 阴阳家 邹衍 兵家 兵家[1]，为中国春秋战国时期诸子百家中的一家，研究讨论的主要是军事哲学思想（西方近似的称作：The philosophy of war），学说重点在于“用兵”，即战略战术问题。春秋战国之后，那些通晓军事的用兵者，学者也往往归入或称为“兵家”。[2]在中国古代指拥兵一方的豪强或军将，亦为部曲私兵之称。 《汉书·艺文志·兵书略》将兵家著作分为四类： 兵权谋类，侧重于军事思想、战略策略； 兵形势类，专论用兵之形势； 兵阴阳类，以阴阳五行论兵，且杂以鬼神助战之说； 兵技巧类，以兵器和技巧为主要内容。 兵家的主要代表人物在春秋战国时期主要有孙武、吴起、孙膑、尉缭、田穰苴等。兵家的思想源头可以追溯到商周时期的吕尚（即史上著名的姜太公）。 孙武（孙子） 孙武（前544年－前470年或前496年），字长卿，春秋时期齐国人，著名军事家、政治家，兵家代表人物。兵书《孙子兵法》的作者，后人尊称为孙子、兵圣、东方兵圣，山东、苏州等地尚有祀奉孙武的庙宇兵圣庙。其族人为乐安孙氏始祖，次子孙明为富春孙氏始祖。 孙武年轻时阅读古代军事典籍《军志》，了解黄帝战胜四帝的作战经验以及古代名相伊尹、姜尚、管仲的用兵策略，出仕吴国。 其著有巨作《孙子兵法》十三篇，为后世兵法家所推崇，被誉为“兵学圣典”，置于《武经七书》之首。他撰著的《孙子兵法》在中国乃至世界军事史、军事学术史和哲学思想史上都占有极为重要的地位，并在政治、经济、军事、文化、哲学等领域被广泛运用。被译为日文、法文、德文、英文，该书成为国际间最著名的兵学典范之书。 [4] 孙膑（孙伯灵） 参考 孙膑 吴起(兵家) 参考 吴起 医家 医家，学术学派，诸子百家之一，代表人物为仓公、扁鹊[1]。 有时医家被归入方技家，后者于先秦至汉初成形，主要研究养生和医药。《汉书·艺文志》将方技家分为“医经”、“经方”、“神仙”、“房中”四大派。方技家是以医学为理论基础，但研究范围宽于医学，包括医家与方士。而房中、神仙二家后世多归入道家[2]。 岐伯 岐伯，传说中的上古时代医家。白天识药、尝药性，晚上习养生之道，掌握经络医术。黄帝在崆峒山问道于广成子时，中南子向黄帝推举了岐伯。岐伯后来成为黄帝的大臣。他受黄帝的命令品尝百草。传说他曾经驾驭由12只白鹿拉的绛云车赴蓬莱山问不死之药[1]。“岐黄”为岐伯与黄帝二人的合称，相传为医家之祖。 扁鹊 扁鹊（约前407年－约前310年），原姓秦（姬姓秦氏，秦朝以前，姓氏分离，男子称氏，女子称姓。），名越人[3]，一名缓，号卢医、扁鹊，中国战国时代医师。约生于周威烈王十九年（公元前407年）前后，卒于周赧王五年（公元前310年）。传说中东周战国时期姜齐勃海郡莫州（今河北省任丘市鄚州镇）人。[4]与华佗、张仲景、李时珍并称中国古代四大名医。 学界一说扁鹊乃古代良医的称号，非特定一人。[7] 淳于意（仓公） 淳于意（前205年－前150年），临淄（今山东淄博）人，汉初著名医学家，因其曾任太仓令（或曰太仓长），故世称仓公。 农家 纵横家 杂家 吕不韦 刘安 尸佼（尸子） 小说家 虞初 屈原 字玉 名人名将 大的会议 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/history/中国近现代历史.html":{"url":"docs/history/中国近现代历史.html","title":"中国近现代历史","keywords":"","body":"中国近现代历史 https://github.com/programthink/books https://github.com/programthink/zhao 十大元帅 中华人民共和国元帅（通称开国元帅、十大元帅），依序为朱德、彭德怀、林彪、刘伯承、贺龙、陈毅、罗荣桓、徐向前、聂荣臻及叶剑英十人。 是中华人民共和国建立后于1955年授予第一次国共内战、中国抗日战争、第二次国共内战中贡献良多的十位中国共产党军事领导人的最高军衔。 十大将军 中国人民解放军大将（通称十大将军），依序为：粟裕、徐海东、黄克诚、陈赓、谭政、萧劲光、张云逸、罗瑞卿、王树声、许光达。 中华人民共和国建立后于1955年授予大将军衔给在土地革命、抗日战争、第二次国共内战中作出巨大贡献的十位中国人民解放军军事家。同时授予的还有十名元帅。 青帮代表人物 杜月笙 张啸林 黄金荣 上海三大亨上海人民间流传有“黄金荣爱钱，张啸林善打，杜月笙会做人”的说法。 洪门，又称天地会（红帮），与袍哥会、青帮为清朝三大秘密结社 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/文人/王勃.html":{"url":"docs/fiction/文人/王勃.html","title":"王勃","keywords":"","body":"王勃 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/文人/苏轼.html":{"url":"docs/fiction/文人/苏轼.html","title":"苏轼","keywords":"","body":"苏轼 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/文人/毛泽东诗词.html":{"url":"docs/fiction/文人/毛泽东诗词.html","title":"毛泽东诗词","keywords":"","body":"毛泽东诗词 《忆秦娥·娄山关》 西风烈， 长空雁叫霜晨月。霜晨月， 马蹄声碎， 喇叭声咽。 雄关漫道真如铁，而今迈步从头越。从头越，苍山如海，残阳如血。 《菩萨蛮·黄鹤楼》 茫茫九派流中国， 沉沉一线穿南北。 烟雨莽苍苍， 龟蛇锁大江。 黄鹤知何去？剩有游人处。把酒酹滔滔，心潮逐浪高！ 《贺新郎·别友》 挥手从兹去。更那堪凄然相向，苦情重诉。眼角眉梢都似恨，热泪欲零还住。知误会前番书语。过眼滔滔云共雾，算人间知己吾和汝。人有病，天知否？ 今朝霜重东门路，照横塘半天残月，凄清如许。汽笛一声肠已断，从此天涯孤旅。凭割断愁丝恨缕。要似昆仑崩绝壁，又恰象台风扫寰宇。重比翼，和云翥。 《浪淘沙·北戴河》 大雨落幽燕，白浪滔天，秦皇岛外打鱼船。一片汪洋都不见，知向谁边？ 往事越千年，魏武挥鞭，东临碣石有遗篇。萧瑟秋风今又是，换了人间。 《采桑子·重阳》 人生易老天难老，岁岁重阳，今又重阳，战地黄花分外香。 一年一度秋风劲，不似春光，胜似春光，廖廓江天万里霜。 《清平乐·六盘山》 天高云淡，望断南飞雁。不到长城非好汉，屈指行程二万。 六盘山上高峰，红旗漫卷西风。今日长缨在手，何时缚住苍龙？ 《蝶恋花·答李淑一》 我失骄杨君失柳，杨柳轻扬直上重霄九。问讯吴刚何所有，吴刚捧出桂花酒。 寂寞嫦娥舒广袖，万里长空且为忠魂舞。忽报人间曾伏虎，泪飞顿作倾盆雨。 《减字木兰花·广昌路上》 漫天皆白，雪里行军情更迫。头上高山，风卷红旗过大关。 此行何处？赣江风雪迷漫处。命令昨颁，十万工农下吉安。 《沁园春·长沙》 独立寒秋，湘江北去，橘子洲头。 看万山红遍，层林尽染；漫江碧透，百舸争流。 鹰击长空，鱼翔浅底，万类霜天竞自由。 怅寥廓，问苍茫大地，谁主沉浮？ 携来百侣曾游，忆往昔峥嵘岁月稠。 恰同学少年，风华正茂；书生意气，挥斥方遒。 指点江山，激扬文字，粪土当年万户侯。 曾记否，到中流击水，浪遏飞舟！ 《卜算子·咏梅》 风雨送春归，飞雪迎春到。已是悬崖百丈冰，犹有花枝俏。 俏也不争春，只把春来报。待到山花烂漫时，她在丛中笑。 《清平乐·会昌》(东方欲晓，莫道君行早) 东方欲晓，莫道君行早。踏遍青山人未老，风景这边独好。 会昌城外高峰，颠连直接东溟。战士指看南粤，更加郁郁葱葱。 《菩萨蛮·大柏地》(赤橙黄绿青蓝紫，谁持彩练当空舞？) 赤橙黄绿青蓝紫，谁持彩练当空舞？雨后复斜阳，关山阵阵苍。 当年鏖战急，弹洞前村壁，装点此关山，今朝更好看。 《水调歌头·游泳》(才饮长沙水，又食武昌鱼) 才饮长沙水，又食武昌鱼。 万里长江横渡，极目楚天舒。 不管风吹浪打，胜似闲庭信步，今日得宽馀。 子在川上曰：逝者如斯夫！ 风樯动，龟蛇静，起宏图。 一桥飞架南北，天堑变通途。 更立西江石壁，截断巫山云雨，高峡出平湖。 神女应无恙，当惊世界殊。 《沁园春·雪》 北国风光，千里冰封，万里雪飘。 望长城内外，惟余莽莽；大河上下，顿失滔滔。 山舞银蛇，原驰蜡象，欲与天公试比高。 须晴日，看红妆素裹，分外妖娆。 江山如此多娇，引无数英雄竞折腰。 惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。 一代天骄，成吉思汗，只识弯弓射大雕。 俱往矣，数风流人物，还看今朝。 《七律·长征》 红军不怕远征难，万水千山只等闲。 五岭逶迤腾细浪，乌蒙磅礴走泥丸。 金沙水拍云崖暖，大渡桥横铁索寒。 更喜岷山千里雪，三军过后尽开颜。 《七律·人民解放军占领南京》 钟山风雨起苍黄，百万雄师过大江。 虎踞龙盘今胜昔，天翻地覆慨而慷。 宜将剩勇追穷寇，不可沽名学霸王。 天若有情天亦老，人间正道是沧桑。 《水调歌头·重上井冈山》 久有凌云志，重上井冈山。 千里来寻故地，旧貌变新颜。 到处莺歌燕舞，更有潺潺流水，高路入云端。 过了黄洋界，险处不须看。 风雷动，旌旗奋，是人寰。 三十八年过去，弹指一挥间。 可上九天揽月，可下五洋捉鳖，谈笑凯歌还。 世上无难事，只要肯登攀。 《七律·到韶山》 别梦依稀咒逝川，故园三十二年前。 红旗卷起农奴戟，黑手高悬霸主鞭。 为有牺牲多壮志，敢叫日月换新天。 喜看稻菽千重浪，遍地英雄下夕烟。 《七律·将革命进行到底》 古今多少苍茫事，前车历历未能忘。 鸿门宴上宽纵敌，乌江边头何仓惶！ 秀全空坐失良机，天京终于烟灰场。 急世英雄行大劫，莫顾尘界百创伤。 参考如果《沁园春·雪》写在两宋，能排在什么档次？「毛泽东」诗词全集(89)首) Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/古诗词/满江红·写怀.html":{"url":"docs/fiction/古诗词/满江红·写怀.html","title":"满江红·写怀","keywords":"","body":"满江红·写怀 满江红·写怀 宋·岳飞怒发冲冠，凭栏处，潇潇雨歇。抬望眼、仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲、白了少年头，空悲切。靖康耻，犹未雪。臣子恨，何时灭？驾长车踏破，贺兰山缺。壮志饥飧胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，朝天阙。 满江红为一词牌名，此调为双调93字，前阕4仄韵，后阙5仄韵，前阕5、6句、后阕7、8句要对仗。后阕3字4字也可对仗。 白话译文我怒发冲冠登高倚栏杆，一场潇潇细雨刚刚停歇。抬头放眼四望辽阔一片，仰天长声啸叹。壮怀激烈，三十年勋业如今成尘土，征战千里只有浮云明月。莫虚度年华白了少年头，只有独自悔恨悲悲切切。靖康年的奇耻尚未洗雪，臣子愤恨何时才能泯灭。我只想驾御着一辆辆战车踏破贺兰山敌人营垒。壮志同仇饿吃敌军的肉，笑谈蔑敌渴饮敌军的血。我要从头彻底地收复旧日河山，再回京阙向皇帝报捷。 [5] 词句注释⑴满江红：词牌名，又名“上江虹”“念良游”“伤春曲”等。双调九十三字。⑵怒发（fà）冲冠：气得头发竖起，以至于将帽子顶起。形容愤怒至极。⑶凭阑：身倚栏杆。阑，同“栏”。⑷潇潇：形容雨势急骤。⑸长啸：大声呼叫。啸，蹙口发出的叫声。⑹壮怀：奋发图强的志向。⑺“三十”句：谓自己已经三十岁了，得到的功名，如同尘土一样微不足道。三十，是约数。功名，或指岳飞攻克襄阳六郡以后建节晋升之事。⑻“八千”句：形容南征北战、路途遥远、披星戴月。八千，是约数，极言沙场征战行程之远。⑼等闲：轻易，随便。⑽空悲切：即白白的痛苦。⑾靖康耻：宋钦宗靖康二年（1127），金兵攻陷汴京，虏走徽、钦二帝。靖康，宋钦宗赵桓的年号。⑿贺兰山：贺兰山脉，位于宁夏回族自治区与内蒙古自治区交界处，当时被金兵占领。一说是位于邯郸市磁县境内的贺兰山。⒀胡虏：对女真贵族入侵者的蔑称。⒁匈奴：古代北方民族之一，这里指金入侵者。⒂朝天阙：朝见皇帝。天阙，本指宫殿前的楼观，此指皇帝居住的地方。明代王熙书《满江红》词碑作“朝金阙”。 译文我愤怒得头发竖了起来，帽子被顶飞了。独自登高凭栏远眺，骤急的风雨刚刚停歇。抬头远望天空，禁不住仰天长啸，一片报国之心充满心怀。三十多年来虽已建立一些功名，但如同尘土微不足道，南北转战八千里，经过多少风云人生。好男儿，要抓紧时间为国建功立业，不要空空将青春消磨，等年老时徒自悲切。靖康之变的耻辱，至今仍然没有被雪洗。作为国家臣子的愤恨，何时才能泯灭！我要驾着战车向贺兰山进攻，连贺兰山也要踏为平地。我满怀壮志，打仗饿了就吃敌人的肉，谈笑渴了就喝敌人的鲜血。待我重新收复旧日山河，再带着捷报向国家报告胜利的消息！ 注释 怒发冲冠：气得头发竖起，以至于将帽子顶起。形容愤怒至极，冠是指帽子而不是头发竖起。 潇潇：形容雨势急骤。 长啸：感情激动时撮口发出清而长的声音,为古人的一种抒情举动。 三十功名尘与土：年已三十，建立了一些功名，不过很微不足道。 八千里路云和月：形容南征北战、路途遥远、披星戴月。 等闲：轻易，随便。 靖康耻：宋钦宗靖康二年（1127年），金兵攻陷汴京，虏走徽、钦二帝。 贺兰山：贺兰山脉位于宁夏回族自治区与内蒙古自治区交界处。 胡虏（lǔ）：秦汉时匈奴为胡虏,后世用为与中原敌对的北方部族之通称。 朝天（阙）：朝见皇帝。天阙：本指宫殿前的楼观，此指皇帝生活的地方。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/古诗词/满江红·登黄鹤楼有感.html":{"url":"docs/fiction/古诗词/满江红·登黄鹤楼有感.html","title":"满江红·登黄鹤楼有感","keywords":"","body":"满江红·登黄鹤楼有感 满江红·登黄鹤楼有感 宋·岳飞遥望中原，荒烟外、许多城郭。想当年、花遮柳护，凤楼龙阁。万岁山前珠翠绕，篷壶殿里笙歌作。到而今、铁骑满郊畿，风尘恶。兵安在？膏锋锷。民安在？填沟壑。叹江山如故，千村寥落。何日请缨提锐旅，一鞭直渡清河洛。却归来、再续汉阳游，骑黄鹤。 满江红为一词牌名，此调为双调93字，前阕4仄韵，后阙5仄韵，前阕5、6句、后阕7、8句要对仗。后阕3字4字也可对仗。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/名言名句.html":{"url":"docs/fiction/名言名句.html","title":"名言名句","keywords":"","body":"名言名句 横渠四句 “横渠四句”出自张载《横渠语录》，原文如下： “为天地立心，为生民立命，为往圣继绝学，为万世开太平。” 译文：为天地确立起生生之心，为百姓指明一条共同遵行的大道，继承孔孟等以往的圣人不传的学问，为天下后世开辟永久太平的基业。 横渠四句，即“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，为北宋大家张载的名言。当代哲学家冯友兰将其称作“横渠四句”。由于其言简意宏，一直被人们传颂不衰。 张载（1020-1077）字子厚，北宋大儒，哲学家，理学创始人之一，理学支脉“关学”创始人，封先贤，奉祀孔庙西庑第38位。 《西铭》又名《订顽》，是张载作品《正蒙•乾称篇》中的一篇文章。在四库全书中为子部儒家类。提出“民吾同胞，物吾与也”。 “为天地立心，为生民立命，为往圣继绝学，为万世开太平”（张子四句）。作为儒学的经典文献之一，张载的《西铭》在传统社会即备受赞誉而传诵不绝，其根本原因在于，这篇铭文虽然仅有250余字，但却为人们安身立命构筑了一个共同的精神家园，而且为社会理想蓝图的构建提供了一个弘阔的境界。 北宋张载著。原为《正蒙·乾称篇》的一部分。作者曾于学堂双牖各录《乾称篇》的一部分《砭愚》和《订顽》分别悬挂于书房的东、西两牖，作为自己的座右铭。程颐见后，将《砭愚》改称《东铭》、《订顽》改称《西铭》。 [1] 文中提出“民胞物与”的思想，把宇宙看作一个大家族，说明个人的道德义务，宣扬“存，吾顺事，没，吾宁也”的乐天顺命思想。 [2] Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/近现代小说.html":{"url":"docs/fiction/近现代小说.html","title":"近现代小说","keywords":"","body":"近现代小说 近现代武侠小说 网络小说 鬼吹灯 盗墓笔记 《盗墓笔记》是中国作家南派三叔于2006年6月26日首发于鬼吹灯百度贴吧的网络小说，并同年7月6日在起点中文网连载。单行本全9卷。《盗墓笔记》的完结篇于2011年12月19日上市。 南派三叔作品《盗墓笔记》中提到的老长沙的九个盗墓世家，称为老九门，又称九门提督。《老九门》是《盗墓笔记》的前传，即讲述吴邪等人祖辈的故事，以平和简短的风格，讲述各自人物的日常片段，最早发表于《超好看》。 科幻小说 三体 黑暗森林法则 费米悖论 赡养人类 刘慈欣作品： 三体：三体 ( 2006) ▪ 三体Ⅱ：黑暗森林 ( 2008) ▪ 三体Ⅲ：死神永生 ( 2010) ▪ 赡养上帝 ( 2005) ▪ 赡养人类 ( 2005) 流浪地球 ( 2000) 三体 三体 ( 2006) ▪ 三体Ⅱ：黑暗森林 ( 2008) ▪ 三体Ⅲ：死神永生 ( 2010) 《三体》是中国大陆作家刘慈欣于2006年5月至12月在《科幻世界》杂志上连载的一部长篇科幻小说，出版后成为中国大陆最畅销的科幻长篇小说之一[1]。2008年，该书的单行本由重庆出版社出版。 本书是三体系列（系列原名为：地球往事三部曲）的第一部，该系列的第二部《三体II：黑暗森林》已经于2008年5月出版。2010年11月，第三部《三体III：死神永生》出版发行。 2011年，“地球往事三部曲”在台湾陆续出版。小说的英文版获得美国科幻奇幻作家协会2014年度“星云奖”提名[2]，并荣获2015年雨果奖最佳小说奖。 黑暗森林法则 黑暗森林法则：一旦某个文明被发现，就必然遭到其他文明的打击。 点评：一旦被发现，能生存下来的是只有一方，或者都不能生存。 解析：可以从地球中的国家间文明发展，以小看大分析宇宙文明发展方向。 宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼：他必须小心，因为林中到处都有与他一样潜行的猎人，如果他发现了别的生命，能做的只有一件事：开枪消灭。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭，这就是宇宙文明的图景，这就是对费米悖论的一种解释。 黑暗森林法则，科幻小说作家刘慈欣在《三体II 黑暗森林》引入的法则。罗辑（三体2中的主人公）在人类当前的科技水平和社会状况下，受到叶文洁启发，从两条不证自明的基本公理出发，借由引入两个重要概念——猜疑链和技术爆炸，从理论上建立起的一套关于描述当前宇宙社会大图景的大体系的一门学科——宇宙社会学。 黑暗森林法则在《三体》系列中共有四个版本，分别为：叶文洁-罗辑理论、咒语实验理论、概率理论、宇宙战争理论。 费米悖论 黑暗森林法则的相关内容。 1950年的一天，诺贝尔奖获得者、物理学家费米在和别人讨论飞碟及外星人的问题时，突然冒出一句：“他们都在哪儿呢？”这句看似简单的问话，就是著名的“费米悖论”。 “费米悖论”隐含的意思是，从理论上讲，人类能用100万年的时间飞往银河系的各个星球，那么，外星人只要比人类早进化100万年，就应该已经来到地球了。换言之，“费米悖论”表明了这样的逻辑悖理：A.外星人是存在的——科学推论可以证明，外星人的进化要远远早于人类，他们应该已经来到地球并存在于某处了；B.外星人是不存在的——迄今为止，人类并未发现任何有关外星人存在的蛛丝马迹。 “费米悖论”自成，在天文学界就有着相当的影响，因为它是基于科学探知的事实：古老的银河系，已有约100多亿年的年龄，而银河系的空间直径却只有大约10万光年，就是说，即使外星人仅以光速的千分之一翱翔太空，他们也不过只需1亿年左右的时间就可以横穿银河系——这个时间远远短于银河系的年龄。而且仅从数学概率上分析，在浩瀚的宇宙里，应该有着众多的类似地球的适合于生命存在的星体。并且这其中，有些星体的年龄要远远大于地球，因此，它们上面的生命进化，也要远远早于地球上的人类。 “费米悖论”生成几十年来，人类对太空的探索已有长足的进展。宇宙飞船已经参观或探测了太阳系中绝大部分的行星及其主要卫星，天文学家还追踪了成千上万颗星球发出的微波信号。但是，这些搜寻行动一无所获，人类并没有发现能够证明外星人存在的生命信号。“费米悖论”的实质就是否定外星文明的存在：既然我们至今还未发现外星人的蛛丝马迹，为什么还要相信它呢？ “费米悖论”在天文学界广有市场，许多著名的科学家对此持赞成的态度。 赡养人类 首先，我们要清楚大刘的《赡养人类》是作为《赡养上帝》的续集而存在的。 先来个书中预言与现实对比。 在我曾祖父的时代，第一地球60%的财富掌握在一千万人手中；在爷爷的时代，世界财富的80%掌握在一万人手中；在爸爸的时代，财富的90%掌握在四十二人手中。 ——《赡养人类》2005年作品 《赡养人类》里第一地球有20亿人口，曾祖父时代1000万人，即0.5%人口掌握60%财富。 现实中：地球目前是前1%人口掌握50%财富。（【更新数据】2017年前1%人口掌握全球82%财富，已经符合书中数据了。） 刘慈欣短篇小说剧情梳理——《赡养人类》 新武侠四大宗师 新武侠四大宗师（金、古、梁、温） 金庸,查良镛，GBM ，OBE（英语：Louis Cha Jing-yong，1924年3月10日－2018年10月30日） 古龙（1938年6月7日－1985年9月21日），原名熊耀华 梁羽生（本名陈文统，1924年4月5日－2009年1月22日） 温瑞安（原名温凉玉） 金庸 射雕三部曲 射雕三部曲是作家金庸所著的武侠小说中最先发表的三部长篇小说的统称[1]。这三部中角色与情节有一定的连贯性，依背景时间顺序分别是： 《射雕英雄传》（南宋宋宁宗年间） 《神雕侠侣》（南宋宋理宗年间） 《倚天屠龙记》（元末元顺帝年间） 而有人认为应当包括到创作较晚但时代较早的姐妹作，背景时间为北宋宋哲宗年间的《天龙八部》称为射雕四部曲。 温瑞安 《四大名捕》系列 《神州奇侠》系列 《说英雄，谁是英雄》系列 逆水寒 (电视剧) 逆水寒是2004年上映的中国大陆电视剧，由鞠觉亮执导，温豪杰编剧，张智霖、锺汉良、李小冉、于娜、宋佳等主演，改编自温瑞安的同名武侠小说，讲述了北宋时期江湖大侠戚少商蒙冤逃亡，在神捕铁手、昔日情敌霹雳堂主雷巻...等义士的帮助下，冤案得雪的故事。共40集，每集40分钟。 逆水寒 (游戏) 《逆水寒》以温瑞安《四大名捕》、《说英雄谁是英雄》、《神州奇侠》三大系列小说为游戏背景，讲述北宋末年一段惨烈的大追捕，并牵扯出江湖恩怨、朝堂纷争、帮派仇杀、感情纠葛、市井百态等北宋生活画卷。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/鬼吹灯.html":{"url":"docs/fiction/鬼吹灯.html","title":"鬼吹灯","keywords":"","body":"鬼吹灯 《鬼吹灯》是一部中国的网络小说，主要内容是盗墓寻宝，作者为天下霸唱。第一部小说包括四卷，分别是《精绝古城》、《龙岭迷窟》、《云南虫谷》和《昆仑神宫》。随后作者继续创作鬼吹灯第二部，内容涉及陈瞎子和鹧鸪哨（杨雪莉之外公）之盗墓往事。第二部包括四卷，分别是《黄皮子坟》、《南海归墟》、《怒晴湘西》和《巫峡棺山》，全八卷简体中文版由安徽文艺出版社发行，但对原书中部分“封建迷信”、“恐怖灵异”的内容进行删改。 本书在台湾由高宝国际出版集团出版繁体中文版，每卷分配内容进度与简体中文版略有不同，在第二部将《巫峡棺山》分成《不死地仙》及《巫峡棺山》。 盗墓派系 1、摸金校尉：摸金的雏形始于战国时期，精通“寻龙诀”和“分金定穴”。门人有摸金符。 2、发丘将军：又名发丘中郎将、发丘天官、发丘灵官。到了后汉才有，与摸金同出一脉，其手段和摸金校尉几乎完全一样，只是多了一枚铜印“发丘印”。 3、搬山道人：始于西域孔雀河双黑山流域，其辈皆同宗同族。本为扎格拉玛后人，搬山者善独门“搬山分甲术”，此术可细分为“搬山填海术”并“分山掘子甲”两门，合称“搬山之术”。平时用道士的身份伪装，以“搬山道士”自居，以寻找“雮尘珠”为己任。 4、卸岭力士：始自汉末农民军盗发帝陵，众力取利，分赃聚义，人数少则成百、多可千数。平日分散，各自为匪为盗或为官军，盗墓者中半官半匪者皆属此辈，彼此间有消息相通，中有盗魁，一呼百应，逢古墓巨冢，则聚众以图之。其行事不计后果，大铲大锄、牛牵马拽、药石土炮，无所不用其极，其辈所盗发之冢，即便斩山做廊、穿石为藏、土坚如铁、墓墙铜灌金箍，亦皆以外力破之。 5、观山太保：少数人组成的不为人知的盗墓门派，起源于明代。 鬼吹灯之精绝古城 鬼吹灯之龙岭迷窟 鬼吹灯之云南虫谷 鬼吹灯之昆仑神宫 鬼吹灯之黄皮子坟 鬼吹灯之南海归墟 鬼吹灯之怒晴湘西 鬼吹灯之巫峡棺山 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/三国演义.html":{"url":"docs/fiction/三国演义.html","title":"三国演义","keywords":"","body":"《三国演义》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/上帝的指纹.html":{"url":"docs/fiction/上帝的指纹.html","title":"上帝的指纹","keywords":"","body":"《上帝的指纹（God's fingerprint）》 作者： 葛瑞姆·汉卡克(Graham Hancock) 科幻小说 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/地球编年史.html":{"url":"docs/fiction/地球编年史.html","title":"地球编年史","keywords":"","body":"《地球编年史》:共七册 《第十二个天体》ISBN：9787229006747 《通往天国的阶梯》ISBN：9787229011659 《众神与人类的战争》ISBN：9787229013752 《失落的国度》ISBN：9787229018153 《当时间开始》ISBN：9787229026677 《宇宙密码》ISBN：9787229035945 《完结日》ISBN：9787229046576 《地球编年史指南》ISBN：9787229046873 作者： 撒迦利亚·西琴（俄语：Заха́рия Си́тчин；英语：Zecharia Sitchin，1920年7月11日－2010年10月9日） 科幻小说不属算伪科学 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/橘子不是唯一的水果.html":{"url":"docs/fiction/橘子不是唯一的水果.html","title":"橘子不是唯一的水果","keywords":"","body":"《橘子不是唯一的水果》 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/fiction/红楼梦.html":{"url":"docs/fiction/红楼梦.html","title":"红楼梦","keywords":"","body":"《红楼梦》 石头记、情僧录、风月宝鉴、金陵十二钗、金玉缘 1987年首播的央视版《红楼梦》贾宝玉---欧阳奋强林黛玉---陈晓旭薛宝钗---张莉 《红楼梦》故事主线为贾宝玉、林黛玉及薛宝钗三人的爱情与婚姻悲剧，以及贾宝玉亲戚贾府、史家、王家、薛家等四大家族的兴衰。 女娲炼石补天，用了三万六千五百颗石头，剩一块石未用，是为顽石，顽石经过修炼已经有了灵性。 一僧一道携它变幻为美玉带入尘世，变成“通灵宝玉”。 适逢神瑛侍者对一株绛珠仙草有浇灌之恩，又动了凡心下凡游历人间。绛珠仙草后修炼成女体，闻讯亦随之下凡，打算把一生所有的眼泪还他。 神瑛侍者浇灌绛珠草使其化为绛珠仙子，而神瑛侍者动了凡心要去凡间，绛珠仙子为报答恩情，就也要求去凡间，用自己的眼泪来报答神瑛侍者的灌溉之情。石头被夹带于中，跟随神瑛、绛珠等经历“花柳繁华”、“温柔富贵”。于是，神瑛侍者化为贾宝玉，绛珠仙子化为林黛玉，那块顽石化成为贾宝玉口中的那块美玉。 所以全书把她和贾宝玉的关系称为“木石前盟”。“还泪”之说则预示了宝黛爱情的悲剧结局。 生来口中就含有一块通灵宝玉（补天顽石）的孙儿贾宝玉（神瑛侍者） 林黛玉（绛珠仙草） 贾雨村，甑士隐（假语存真事隐） 假作真时真亦假； 无为有处有还无。--曹雪芹撰 太虚幻境联 满纸荒唐言，一把辛酸泪！都云作者痴，谁解其中味？ 一个是阆苑仙葩，一个是美玉无暇。若说没奇缘，今生偏又遇着他。若说有奇缘，如何心事终虚化？——第五回 苦绛珠魂归离恨天，病神瑛泪洒相思地。 世事洞明皆学问，人情练达即文章。--曹雪芹对王熙凤的评价 好了歌世人都晓神仙好，只有功名忘不了！古今将相在何方，荒冢一堆草没了！世人都晓神仙好，只有金银忘不了！终朝只恨聚无多，及到多时眼闭了！世人都晓神仙好，只有娇妻忘不了！君生日日说恩情，君死又随人去了！世人都晓神仙好，只有儿孙忘不了！痴心父母古来多，孝顺子孙谁见了！ 葬花吟---林黛玉尔今死去侬收葬，未卜侬身何日丧？侬今葬花人笑痴，他年葬侬知是谁？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/VPN的使用.html":{"url":"docs/commonsense/搭建梯子VPN/VPN的使用.html","title":"VPN的使用","keywords":"","body":"VPN的使用 Shadowsocks影梭 V2Ray 常见名词 VPS和VPN 常用的VPS 翻墙VPN/机场/梯子 代理服务器 域名污染—DNS域名解释 什么是VPN 隧道协议TP和点对点隧道协议PPTP 什么是Shadowsocks（ss｜影子代理｜机场｜酸酸乳） 科学上网V2Ray VPN协议 OpenVPN IPsec IKEv2/IPSec WireGuard PPTP L2TP/IPSec SSTP SoftEther Lightway Nordlynx 常见名词 Shadowsocks（ss｜影子代理｜机场｜酸酸乳） 先有V2ray(Project V)，然后是V2fly，最后才出来Xray(Project X) 翻墙VPN/机场/梯子 科学上网（翻墙） 简单地说，V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网（翻墙）学习国外先进科学技术。 翻墙软件VPN推荐，中国仅2款好用(2021年10月最新) VPS和VPN VPS (Virtual Private Server)：虚拟专用服务器 VPN (Virtual Private Network)：虚拟专用网络 使用VPS创建您自己的VPN 可以租用VPS，并在其上安装VPN软件以获取您自己的VPN。 What is the Difference Between a VPS and VPN? 常用的VPS 搬瓦工VPS云主机Linode VPS云主机 翻墙VPN/机场/梯子 Just My Socks（搬瓦工机场）ExpressVPNNordVPN官网光年VPNPandaVPN（熊猫VPN）Surfshark VPN快帆VPNPureVPN ExpressVPN默认采用军事级别的AES-256位加密方式，这是目前全球范围内最强的加密方式，美国政府和全球大部分银行都采用的是这种加密技术。此外，ExpressVPN支持多种VPN协议，包括OpenVPN、IKEv2、L2TP/IPaec、WireGuard、PPTP、SSTP、Lightway。其中OpenVPN是最强大的VPN协议，而IKEv2主要为移动端设备提供加密服务，这两种VPN协议都是目前使用最广泛，也是最标准、最安全VPN协议。 实际测试，自己提供的客户端不够智能，无法选择性代理网站（没有类似V2Ray的PAC模式），网速也一点都不快，查资料还可以，看视频，youtube就不行了【我只试用了一两天，主要是只能全局代理，让我在公司访问公司内网，或者在家里使用，爱奇艺、淘宝、JD等因为全局代理，定位错误，都被导到国际站，让我苦不堪言，就只能退费了】 代理服务器 计算机通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用，例如代理，它扮演了位于服务器和客户端 “中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。 代理服务器中有一类叫缓存服务器，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 了解代理服务器的原理，对理解下面要讲的翻墙、科学上网非常有帮助。因为目前所有的翻墙工具，都是基于代理服务的原理建立的，都可以称为“代理软件”。而我们日常的上网活动，其实都要通过代理服务器中转，包括帮我们装宽带的服务商(ISP)就是个代理。 域名污染—DNS域名解释 DNS 协议提供通过域 名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 早期GFW(中国国家防火墙) 就是干扰一下 DNS解释，行话叫–域名污染。效果就是：你访问某些网站的时候，获取到的 IP 地址是错误的，这样自然你就去不到了。 对付域名污染是很简单的：因为操作系统–比如windows，在系统目录中有个host 文件，里面保存了域名和 IP地址的对应表。当浏览器去解析一个域名时，会先从本地的 host 文件中读取。当存在的时候，就直接访问网站的IP地址，不需要 DNS 请求。这样就避免了 DNS 污染。 这招有个条件：首先你要知道，要访问的网站的真实IP地址。 后来，GFW 开始在国际出口的路由器上，定向干扰某些服务器的数据。这些路由器都是大名鼎鼎的思科出品的。思科被曝出参与美国的棱镜计划，爱德华·斯诺登曾经揭露过，美国国家安全局通过思科路由器监控中国的网络和电脑。这就是为什么我们要使用华为的网络设备。 不过，现在修改host文件这招早已经没用了。所以，大概了解一下就好，我们继续看。 什么是VPN 虚拟私人网络（英语：virtual private network，缩写：VPN）是上个20世纪90年代，互联网开始流行时出现的技术。当时的数据传输是不加密的广播传播，通信数据都是不加密的。后来，为了保障数据安全，大型跨国企业尤其是银行业，为此要铺设昂贵的数据专线。而vpn技术就是在这种情况下出现的：用于连接大型企业间私人网络的通讯方法，它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能。 而VPN技术变成了翻墙的工具，是无奈之下的选择。因为翻墙需要使用代理服务器，而VPN技术是为了安全的登陆公司的服务器，如果这个服务器又具备代理功能，那么它成为翻墙工具也就顺理成章了。 VPN 有这么几个方案或者叫协议：PPTP、L2TP 、OpenVPN、IPsec、WireGuard，还有 Cisco AnyConnect，以及它们的一些变种。 我们看看这几种方案的特点： PPTP 最简单轻快，服务端部署简单，但是由于加密比较薄弱，在逐渐升级的 GFW 面前，经常不堪一击。 OpenVPN 是加密强度最高的，因为他不是通过用户名密码验证的，而是需要服务端生成客户端证书来认证的。但是 OpenVPN 的服务端部署还是比较复杂的。L2TP 就介于两者之间。 Cisco AnyConnect 可以参考我的文章详细介绍，他是思科公司的解决方案，使用非常方便，而且还是苹果设备默认支持的几种方式之一，所以随着苹果设备的大卖，用的也多了起来。 VPN 还有个设计上的问题，它是全局的解决方案，虽然有些VPN代理软件可以在客户端做到部分代理，但是翻墙之后，连国内的网站还是会变慢一些。这和VPN的设计原理有关：VPN目的是为了保护数据、隐私，翻墙只是副业。 隧道协议TP和点对点隧道协议PPTP 隧道协议（英语：Tunneling Protocol）[1]是一种网络协议，在其中，使用一种网络协议（发送协议），将另一个不同的网络协议，封装在负载部分。使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。 隧道则是对比分层式的模型，如OSI模型或TCP/IP。隧道协议通常（但并非总是）在一个比负载协议还高的层级，或同一层。要了解协议堆栈，负载和发送协议都须了解。传统的分层式协议，如OSI模型或TCP/IP模型，HTTP协议 ，并不被认为是隧道协议。隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 点对点隧道协议（英语：Point to Point Tunneling Protocol，缩写为PPTP）是实现虚拟专用网（VPN）的方式之一。PPTP使用传输控制协议（TCP）创建控制通道来发送控制命令，以及利用通用路由封装（GRE）通道来封装点对点协议（PPP）数据包以发送资料。这个协议最早由微软等厂商主导开发，但因为它的加密方式容易被破解，微软已经不再建议使用这个协议。 隧道协议点对点隧道协议PPTP 什么是Shadowsocks（ss｜影子代理｜机场｜酸酸乳） Shadowsocks是2012、2013年左右出现，ShadowsocksR是它的一个分支。由于它的logo是架纸飞机，所以又叫它“机场”。这货的出现，才真正称得上科学上网，因为它就是为翻墙而生的。 Shadowsocks 的基本工作原理是利用一个可以访问境外的服务器做的中转。但是现在，通常 Shadowsocks 的服务端都是部署在国外的 VPS 上。Shadowsocks 包括：客户端、服务器端，客户端从 Windows、Linux、Mac OS X，到手机端的 Android、iOS，甚至有路由器的版本。 上图是对shadowsocks技术的简单诠释，技术原理很简单：就是通过代理服务器访问，不过shadowsocks在防火墙内外都有个服务器，所以才形象的称它：影子代理。 Android 平台大多用 Shadowsocks 了。由于 Android 平台的开放性，装个 Shadowsocks 客户端，各种分 IP 代理、分应用代理，简直不能更爽。 苹果手机iOS 就比较特殊了，由于苹果的政策比较严格，为iOS开发软件，还要得到苹果开发人员认证，每年还要向苹果公司缴纳保护费。所以，大多iOS翻墙软件要收费。在 iOS 平台，翻墙还是用 VPN 和 Cisco AnyConnect。 这段时间还有一些类似的技术，比如：trojan、ssr都是shadowsocks技术的改进版，最稳定还是v2ray。 科学上网V2Ray V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 简单地说，V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网（翻墙）学习国外先进科学技术。 V2Ray 的简单示意图如下： 首先，V2Ray 本身只是一个内核，V2Ray 上的图形客户端大多是调用 V2Ray 内核套一个图形界面。对于我们终端用户，需要各种图形界面的客户端比如：Qv2ray、V2RayN，然后加V2Ray 内核添加进去。有些客户端是将V2Ray 内核捆绑在一起的，这样将方便使用了。 其次，V2Ray 使用了新的自行研发的 VMess 协议，改正了 Shadowsocks 一些已有的缺点，更难被墙检测到。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 v2ray包括：内核和图形客户端。内核就是翻墙的核心，图形客户端是为了我们用户方便使用。 v2ray内核是一个开源软件，安全性是非常有保证的，因为它公开源码，大神们都是火眼金睛，有什么后门一早就被发现了。v2ray的内核大小一般20–40M。下面是内核的截图。内核是使用go语言编写的，加上用户界面，总容量不会超过100M。超过100M的，里面一定加料。 科学上网V2Ray VPN协议 其中OpenVPN是最强大的VPN协议，而IKEv2主要为移动端设备提供加密服务，这两种VPN协议都是目前使用最广泛，也是最标准、最安全VPN协议。 PPTP、L2TP、OpenVPN三种隧道协议的概念 针对VPN加密，目前AES（高级加密标准）是当今使用的最常见的加密密码之一。大多数VPN使用密钥长度为128位或256位的AES加密。即便是在量子计算方面取得进步，AES-128也被认为是安全的。 隧道分离 · SSL/TLS OpenVPN的技术核心是虚拟网卡，其次是SSL协议实现。（推荐，目前是主流） IKEv2/IPSec（推荐，尤其是手机） PPTP(Point to Point Tunneling Protocol，点对点隧道协议)默认端口号：1723（过时，不推荐） L2TP/IPSec(Layer 2 Tunneling Protocol，第二层隧道协议)(互联网安全协议IPsec，Internet Protocol Security)（过时，偶尔可用） WireGuard:WireGuard是一种较新的VPN协议，旨在提供比现有协议更好的性能和更高的安全性。它于2020年从Beta正式发布，由于其性能优于传统协议，超越了OpenVPN和IKEv2/IPSec，因此被认为是今后VPN的发展方向。（推荐，只有少数顶级VPN服务商实现了） SSTP SoftEther Lightway：是ExpressVPN开发的VPN协议。 Nordlynx：另一家大牌VPN厂商NordVPN也在进行相关的布局。目前NordVPN推出的新协议是Nordlynx（基于WireGuard协议），并已在其客户端广泛部署。 Ipsec（互联网协议安全）：此协议的安全性分为两个阶段：它对会话进行认证，然后加密数据。 L2TP（第2层隧道协议）：隧道协议，通常与IPSec组合，以优化VPN连接的安全性。L2TP基本上在这个协议的两个不同连接之间创建了一个隧道。 PPTP（点到点隧道协议）：该协议基本上创建了一个隧道来放入数据包。 SSL/TLS（安全套接字层/传输层安全性：此协议在电子商务网站中非常常见。 Open VPN：此协议是一个开源VPN，它创建点对点和站点到网络连接。它还使用另一种基于SSL / TLS的自定义协议。 SSH（安全Shell）：此协议创建一个隧道，同时加密所有数据。 WireGuard：WireGuard是开放源代码VPN程序及协议，基于Linux内核实现，利用Curve25519进行密钥交换，ChaCha20用于加密，Poly1305用于数据认证，BLAKE2用于散列函数运算，支持IPv4和IPv6的第3层。 最全VPN协议详解与对比（协议类型+区别+优缺点）- 如何选择合适的VPN协议？VPN三种协议PPTP、L2TP、OPENVPN对比分析不同VPN协议的优缺点VPN 协议——从最好到最坏，以及您需要知道的一切WireGuard vs OpenVPN vs L2TP vs IKEv2 vs SSTP vs PPTP：2021年的差异/优缺点VPN协议比较Comparison of VPN protocols比较前 6 种 VPN 协议：哪种 VPN 协议最适合您？OpenVPN 与 IPSec、WireGuard、L2TP 和 IKEv2（VPN 协议）VPN Protocols: The Differences Between PPTP, L2TP, OpenVPN, IKEv2, Lightway, and WireGuard (Networking FAQ) OpenVPN OpenVPN官网OpenVPN社区OpenVPN GithubOpenVPN wikiTunnelblick free software for OpenVPN on macOS OpenVPN是一个用于创建虚拟私人网络加密通道的软件包，最早由James Yonan编写。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名／密码来进行身份验证。 它大量使用了OpenSSL加密库中的SSL/TLS协议函数库。 它不与IPsec兼容。 原理：OpenVPN的技术核心是虚拟网卡，其次是SSL协议实现。 OpenVPN使用OpenSSL库来加密数据与控制信息。这意味着，它能够使用任何OpenSSL支持的算法。它提供了HMAC功能以提高连接的安全性。此外，OpenSSL的硬件加速也能提高它的性能。2.3.0以后版本引入PolarSSL。 OpenVPN － OpenVPN是为多种身份验证方法开发的开源项目。它是一种非常通用的协议，可以在具有不同功能的许多不同设备上使用，并可以通过UDP或TCP在任何端口上使用。OpenVPN使用OpenSSL库和TLS协议提供出色的性能和强大的加密。 IPsec 互联网安全协议（英语：Internet Protocol Security，缩写：IPsec）是一个协议包，透过对IP协议的分组进行加密和认证来保护IP协议的网络传输协议族（一些相互关联的协议的集合）。 IPsec主要由以下协议组成： 一、认证头（AH），为IP数据报提供无连接数据完整性、消息认证以及防重放攻击保护[3][4]； 二、封装安全载荷（ESP），提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性[5]； 三、因特网密钥交换（英语： Internet Key Exchange ，简称IKE或IKEv2)，为 AH、ESP 操作所需的 安全关联（SA） 提供算法、数据包和密钥参数[6]。 IPsec协议工作在OSI模型的第三层，使其在单独使用时适于保护基于TCP或UDP的协议（如安全套接子层（SSL）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，SSL/TLS依靠更高层的TCP（OSI的第四层）来管理可靠性和分片。 IPsec实现 FreeS/WAN项目已经开发了一个开源的GNU/Linux操作系统下的IPsec实现。Free S/WAN项目的开发在2004年时被中止。Openswan、strongSwan和libreswan是Free S/WAN延续。 reeS/WAN，名称来自于自由安全广域网络（英语：Free Secure Wide-Area Networking）的缩写，一个自由软件专案，在Linux平台上实作了IPsec功能，希望能为互联网提供机会性加密（Opportunistic encryption）功能。这个专案由约翰·吉尔摩提出，大多数时候由休·丹尼尔管理，主要的技术领导者为亨利·斯宾塞。1997年秋天，这个专案的程式码在美国境外建立。 在2004年4月22日，释出2.06版后，这个专案停止活动。在2.04版时，分支为Openswan、libreswan与strongswan。 IPsec wiki How IPsec works, why we need it, and its biggest drawbacks网络安全之IPsec详解技术点详解---IPSec VPN基本原理IPsec vpn 详解IPSec VPN基本原理 IKEv2/IPSec IKEv2 and your VPN – together for a speedy connection IKEv2 (Internet Key Exchange v2) IKEv2（Internet 密钥交换版本 2）是 IPSec 堆栈的一部分，用于在 VPN 协议中建立客户端和服务器之间的安全通信。由微软和思科开发。IKEv2 支持 IPSecs 的最新加密算法。 IKEv2是一种提供安全密钥交换会话的隧道协议。该协议是微软和思科合作的成果。与L2TP类似，它通常与IPsec配对使用以提供身份验证和加密功能。 IKEv2非常适合移动版VPN解决方案。这是因为它可以在任何暂时失去互联网连接的情况下重新连接。其次，它很擅长在网络交换期间重新连接（例如，从移动数据到WiFi网络时）。 IKEv2不像OpenVPN，PPTP或L2TP/IPsec协议那样受欢迎，但也有很大的VPN市场，特别是那些专注于移动版VPN的公司。因为它是专有软件，所以只支持Windows，iOS和Blackberry。 IKEv2/IPSec －带有Internet密钥交换版本2（IPSec / IKEv2）的Internet协议安全性是一种快速且安全的VPN协议。它已在许多操作系统（例如Windows、Mac OS和iOS）中自动进行预配置。它特别适合与移动设备重新建立连接。IKEv2的一个缺点是它是由Cisco和Microsoft开发的，不是像OpenVPN这样的开源项目。对于需要快速、轻量级VPN（该VPN安全且可以暂时断开连接以快速重新连接）的移动用户而言，IKEv2 / IPSec是一个不错的选择。 WireGuard WireGuard官网 Wireguard 是市场上可用的开源 VPN 协议的最新成员。Wireguard 于 2020 年 3 月发布稳定版本，是一种专注于简单性和易用性的 VPN 协议。仅使用 4000 行代码来实现整个协议，与 OpenVPN 等具有 1,00,000 行代码的其他协议相比，Wireguard 的规模确实很小。 WireGuard 是一种较新的 VPN 协议，旨在提供比现有协议更好的性能和更高的安全性。它于 2020 年从测试版正式发布，并且由于在比较传统协议中具有更好的性能而继续受到欢迎。 WireGuard具有现代化，极快的速度和极简的体系结构，使用最先进的加密技术，并有详尽的学术研究支持。通过此组合，它超越了当前领先的协议– OpenVPN和IPSec。WireGuard仅包含4000行代码，因此易于部署，审核和发现错误。进行比较：OpenVPN在40万行代码上运行，这意味着WireGuard仅占OpenVPN代码体积的1％。 WireGuard － WireGuard是一种较新的VPN协议，与现有VPN协议相比，旨在提供更高的安全性和更好的性能。默认情况下，WireGuard在隐私方面存在一些问题，尽管大多数支持WireGuard的VPN已经克服这些问题。 PPTP PPTP(Point to Point Tunneling Protocol，点对点隧道协议)默认端口号：1723 PPTP（点对点隧道协议）是最古老的 VPN，由微软在九十年代后期发布。该协议嵌入在 Microsoft 设备中使用 Windows 95 及更高版本的操作系统中，并且可以看到与 Linus 和 Android 设备捆绑在一起。因此，您无需在设备上安装任何第三方应用程序即可使用 PPTP，并且在大多数客户端设备上都可以轻松配置。 PPTP，即PPTF协议。该协议是在PPP协议的基础上开发的一种新的增强型安全协议，支持多协议虚拟专用网(VPN)，可以通过密码身份验证协议(PAP)、可扩展身份验证协议(EAP)等方法增强安全性。可以使远程用户通过拨入ISP、通过直接连接Internet或其他网络安全地访问企业网。 点对点隧道协议(PPTP)是一种支持多协议虚拟专用网络的网络技术，它工作在第二层。通过该协议，远程用户能够通过 Microsoft Windows NT工作站、Windows xp 、Windows 2000 和windows2003、windows7操作系统以及其它装有点对点协议的系统安全访问公司网络，并能拨号连入本地ISP，通过Internet 安全链接到公司网络。 PPTP协议是点对点隧道协议，其将控制包与数据包分开，控制包采用TCP控制。PPTP使用TCP协议，适合在没有防火墙限制的网络中使用。 PPTP －点对点隧道协议是一种基本的较旧的VPN协议，内置在许多操作系统中。不过，PPTP具有已知的安全漏洞，出于隐私和安全原因，就不太建议选择。 L2TP/IPSec L2TP VPN基本原理第二层隧道协议 wiki L2TPv3 L2TP / IPSec －具有Internet协议安全性也是不错选择。该协议比PPTP更安全，但是由于数据包是双重封装的，因此它并不总能提供最佳响应速度。它通常与移动设备一起使用，并内置在许多操作系统中。 L2TP（第 2 层隧道协议）协议是对 PPTP 协议的更新，由 Cisco 和 Microsoft 开发。的L2TP协议是一种封装/隧穿协议，该协议不提供加密因此它被耦合以用于IPSec的（因特网协议安全）协议的加密和认证。 第二层隧道协议（英语：Layer Two Tunneling Protocol，缩写为L2TP）是一种虚拟隧道协议，通常用于虚拟专用网。L2TP协议自身不提供加密与可靠性验证的功能，可以和安全协议搭配使用，从而实现数据的加密传输。经常与L2TP协议搭配的加密协议是IPsec，当这两个协议搭配使用时，通常合称L2TP/IPsec。 SSTP [MS-SSTP]: Secure Socket Tunneling Protocol (SSTP)关于PPTP协议、L2TP协议和SSTP协议的定义 安全套接字隧道协议（SSTP）与OpenVPN非常相似，唯一的区别在于它是Microsoft在Windows Vista中开发和引入的专有软件。 与OpenVPN一样，SSTP支持AES 256位密钥加密，并使用2048位SSL/TSL证书进行身份验证。该协议同样支持Linux，Windows和BSD系统。而对于Android和iOS等，仅通过第三方客户端提供支持。 SSTP 或安全套接字传输协议是 Microsoft 创建的一种补偿算法。与 PPTP 和 L2TP/IPSec 相比，它提供了更多的安全性，如今它在很多 VPN 中使用，但由于协议的性质，它只能在 Windows、路由器、Android 和 Linux 上使用。 SoftEther SoftEther VPNSoftEtherVPN GithubSoftEther VPN wiki SoftEther VPN是一个由日本程序员登大游（日语：登 大遊）因就读筑波大学时的硕士论文研究主题而开发的开源、跨平台、多重协议之虚拟专用网方案，此方案让一些虚拟专用网协议像是SSL VPN、L2TP、IPsec、OpenVPN以及微软SSTP都由同一个VPN服务器提供。在2014年1月4日以GNU通用公共授权条款的方式转变为开源软件。2019年1月21日转变为Apache License 2.0授权。 Lightway ExpressVPN官网Lightway协议网站 Lightway：ExpressVPN 的现代 VPN 协议 Lightway是全球著名VPN厂商ExpressVPN主导研发的新一代VPN协议，它的目的是要超越传统的IKEv2/IPsec，以及OpenVPN等协议。与旧的VPN协议相比，Lightway具有的一些全新特点或优势包括：代码更加精简高效，连接和运行速度更快，且安全性及稳定性更好。此外，还可提供不同移动网络间的无缝切换，为移动用户提供更佳的使用体验。 根据ExpressVPN官方消息，Lightway未来还将开放源代码（开源），以便使得该协议更加透明、并接受更为广泛的检验。其实，不仅ExpressVPN在尝试新一代VPN协议，另一家大牌VPN厂商NordVPN也在进行相关的布局。目前NordVPN推出的新协议是Nordlynx（基于WireGuard协议），并已在其客户端广泛部署。 Lightway是ExpressVPN开发的VPN协议。 Lightway设计轻巧，运行速度更快，耗电量更少，并且易于审核和维护。 VPN协议构成了VPN服务的基础，将会大大提升VPN使用体验。 大多数提供商都使用相同的现成协议，但是ExpressVPN现在已经设计了自己的协议：Lightway。Lightway使用wolfSSL，其完善的加密库已受到第三方的广泛审查，包括针对FIPS 140-2标准的审查。 与其他主要VPN协议相比，它具有更少的代码行，这使审核发现和修复问题变得容易。并且，Lightway VPN协议目前也计划将公开源代码。 ExpressVPN介绍 ExpressVPN默认采用军事级别的AES-256位加密方式，这是目前全球范围内最强的加密方式，美国政府和全球大部分银行都采用的是这种加密技术。此外，ExpressVPN支持多种VPN协议，包括OpenVPN、IKEv2、L2TP/IPaec、WireGuard、PPTP、SSTP、Lightway。其中OpenVPN是最强大的VPN协议，而IKEv2主要为移动端设备提供加密服务，这两种VPN协议都是目前使用最广泛，也是最标准、最安全VPN协议。 个人使用测试 个人两天测试，ExpressVPN并没有网上说的那么好，可能是我使用的姿势不对 实际测试，自己提供的客户端不够智能，无法选择性代理网站（没有类似V2Ray的PAC模式），网速也一点都不快，查资料还可以，看视频，youtube就不行了【我只试用了一两天，主要是只能全局代理，让我在公司访问公司内网，或者在家里使用，爱奇艺、淘宝、JD等因为全局代理，定位错误，都被导到国际站，让我苦不堪言，就只能退费了，账号给我另一个小伙伴尝试过，也反馈网速不太好】 Nordlynx NordVPN官网What is NordLynx? 目前NordVPN推出的新协议是Nordlynx（基于WireGuard协议），并已在其客户端广泛部署。 知名VPN提供商 NordVPN 公司率先推出了基于 WireGuard VPN 协议服务 NordLynx 。建立在下一代VPN协议WireGuard®的基础上，NordLynx提供超快速的VPN连接。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/V2Ray.html":{"url":"docs/commonsense/搭建梯子VPN/V2Ray.html","title":"V2Ray","keywords":"","body":"V2Ray V2Ray介绍 基于V2Ray的衍生版本Xray 基于V2Ray的工具 V2RayX V2rayU Qv2ray Just My Socks详细讲解 V2Ray Server搭建 如何更新PAC中最新GFW清单 V2Ray介绍 Project V 是一个工具集合，它可以帮助你打造专属的基础通信网络。Project V 的核心工具称为V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。V2Ray 可以单独运行，也可以和其它工具配合，以提供简便的操作流程。 2019年2月，V2Ray项目创始人Victoria Raymond突然消失，其Twitter、Telegram以及知乎。 随后开源社区进行重组成立 V2Fly 社区，并于2019年6月2日表示：“由于原开发者长期不上线，其他维护者没有完整权限。为了方便维护，我们创建了新的organization：https://github.com/v2fly 原organization中的仓库：v2ray/v2ray-core将会一直同步更新。” V2Ray官网Project V V2Ray下载安装 V2fly社区官网V2fly新手指南 V2Fly地址，V2Ray原作者离开后社区维护版（新）V2Ray官网原版（老） V2Ray安装包 Homebrew安装V2Ray V2Ray下载安装指南 科学上网V2RayV2Ray教程 基于V2Ray的衍生版本Xray Project X 社区 Project X Github 一个Debian包维护者发现XTLS库的LICENSE不是BSD许可，提了一个issue希望作者 @rprx 能修改方便打包，详见 https://github.com/XTLS/Go/issues/9。由这个issue引发了广泛讨论，rprx认为目前许可不是问题，也有不少人认为协议是立场的体现，各执一词。 最终V2ray(V2fly社区)维护者经过投票确认XTLS不符合V2ray的MIT协议，并在V2ray-core 4.33.0版本移除了XTLS。rprx和其拥护者行动起来，很快就创建了Project X项目和Xray子项目（Xray取名来自XTLS和V2ray的结合），并发布了Xray-core的多个版本。这便是Xray的大致由来。 2020年11月，因为开源许可证等原因[12]XTLS被V2Ray社区从V2ray core移除，VLESS及XTLS的作者和支持者基于V2Ray另行组建了Project X 组织，开发了基于V2Ray的衍生版本Xray[13]。该软件完全兼容V2Ray的配置文件和传输协议，由于Project X社区非常活跃，大部分新版图形化客户端已支持Xray。 Project X originates from XTLS protocol, provides a set of network tools such as Xray-core and Xray-flutter. Project X源于XTLS协议，提供了Xray-core、Xray-flutter等一套网络工具。 Xray-core 是 v2ray-core 的超集，含更好的整体性能和 XTLS 等一系列增强，且完全兼容 v2ray-core 的功能及配置。 Xray-flutter 是一个优雅的跨平台图形界面工具 Xray教程 Xray和V2ray的区别 在说明Xray和V2ray区别之前，先说一下三个相近但不同的概念： V2ray：Project V 是用于构建基础通信网络的工具合集，其核心工具称为V2Ray。V2ray主要负责网络协议和功能的实现，既可以单独运行，也可以和其它工具配合。V2ray官网是：https://v2ray.com/，Github项目主页是：https://github.com/v2ray，TG讨论组是：@projectv2ray； V2fly：出现一些科学上网作者被喝茶事件后，V2ray原开发者长期不上线，其他维护者没有完整权限，导致V2ray项目维护困难。因此社区在2019年组建了V2fly组织，继续维护V2ray，也是目前V2ray发展的主力。V2fly官网是：https://www.v2fly.org，Github项目主页是：https://github.com/v2fly，TG通知频道：@v2fly，TG交流群为：@v2fly_chat； Xray：因许可理念之争，VLESS和XTLS的作者单独创建了Xray项目，目前是V2ray的超集，后续可能有不同的发展路线。Xray文档官网（测试中）：https://xtls.github.io/， Github项目主页：https://github.com/XTLS，TG交流群：@projectXray。 从上面可以看到，先有V2ray(Project V)，然后是V2fly，最后才出来Xray(Project X)。其中V2fly是V2ray的社区，可以认为两者是同一个组织。 基于V2Ray的工具 其实目前在苹果电脑的MAC系统下面，V2RAY的客户端最常用就也就两种。一个是V2RayX，另一个是V2RayU。 V2Ray维基百科 基于V2Ray的工具地址 神一样的V2Ray工具们V2Ray客户端参考V2Ray客户端 V2Ray Mac 客户端下载，用于科学上网。V2RayX、V2RayU下载安装及使用教程 V2RayX 基于V2Ray的工具地址 V2RayW 是一个基于 V2Ray 内核的 Windows 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。 V2RayX 是一个基于 V2Ray 内核的 Mac OS X 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。V2RayX 还可以配置系统代理。 Windows客户端V2RayWMac OS X 客户端V2RayXAndroid上的V2rayNG V2RayX客户端下载 V2rayU V2rayU GithubV2rayU下载地址 V2rayU,基于v2ray核心的mac版客户端,用于科学上网,使用swift编写,支持vmess,shadowsocks,socks5等服务协议,支持订阅, 支持二维码,剪贴板导入,手动配置,二维码分享等 V2RayX 是一个基于 V2Ray 内核的 Mac OS X 客户端。 用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。 V2RayX 还可以配置系统代理。 Qv2ray Qv2ray Github Just My Socks详细讲解 Just My Socks 详细图文购买教程 ，搬瓦工官方出品的代理服务 Just My Socks配置讲解Android [shadowsocks]Android [v2ray]Mac [shadowsocks]Mac [v2ray] V2Ray Server搭建 一键安装命令（然后就都是中文，你随便设置，复制最后反馈给你的ssr信息） bash https://git.io/v2ray.sh) V2Ray下载安装指南 一键安装V2Ray V2Ray新脚本安装服务器V2Ray一键安装脚本如何搭建一个 V2Ray Server小白也可以搭建的V2Ray服务器安装教程面向新手的V2Ray搭建指南 如何更新PAC中最新GFW清单 gfwlist地址 更新 pac.js 的 bash 脚本建议：加强pac功能 pac.js更新python版本脚本 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/trojan.html":{"url":"docs/commonsense/搭建梯子VPN/trojan.html","title":"trojan","keywords":"","body":"trojan trojan地址trojan Github trojan是近两年兴起的网络工具，项目官网 https://github.com/trojan-gfw。与强调加密和混淆的SS/SSR等工具不同，trojan将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。在敏感时期，基本上只有trojan和 v2ray伪装 能提供稳如狗的体验。 trojan教程 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/Shadowsocks影梭.html":{"url":"docs/commonsense/搭建梯子VPN/Shadowsocks影梭.html","title":"Shadowsocks影梭","keywords":"","body":"Shadowsocks影梭 Shadowsocks介绍 VPS搭建Shadowsocks（ss）教程 Shadowsocks介绍 Shadowsocks官网Shadowsocks原版 GithubShadowsocks分支ShadowsocksRR（SSRR） Yet another SIP003 plugin for shadowsocks, based on v2ray 客户端下载链接（GitHub）：Mac客户端Win客户端Android客户端 什么是Shadowsocks（ss｜影子代理｜机场｜酸酸乳） Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用Python、C、C++、C#、Go语言、Rust等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。 Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。 在中国大陆，本工具广泛用于突破防火长城（GFW），以浏览被封锁、遮蔽或干扰的内容。2015年8月22日，Shadowsocks原作者Clowwindy称受到了网络审查的压力，宣布停止维护此计划（项目）并移除其个人页面所存储的源代码[4][5]。 为了避免关键词过滤，网民会根据谐音将ShadowsocksR称为“酸酸乳”[注 1]（SSR），将Shadowsocks称为“酸酸”（SS）。另外，因为Shadowsocks(R)的标志均为纸飞机，所以专门提供Shadowsocks(R)或类似服务（如V2Ray）的网站则就被称为了“机场”。 特点 Shadowsocks使用自行设计的协议进行加密通信。[6]加密算法有AES、Blowfish、ChaCha20、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，无需保持“一直连线”的状态，因此在移动设备上相对较为省电。 所有的流量都经过算法加密，允许自行选择算法。 Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。 客户端覆盖多个主流操作系统和平台，包括Windows、macOS、Android、Linux和iOS系统和路由器（OpenWrt）等[7]。 ShadowsocksR ShadowsocksR（简称SSR）是网名为breakwa11的用户发起的Shadowsocks分支，在Shadowsocks的基础上增加了一些资料混淆方式，称修复了部分安全问题并可以提高QoS优先级。[25]后来贡献者Librehat也为Shadowsocks补上了一些此类特性，[26]甚至增加了类似Tor的可插拔传输层功能。[27] ShadowsocksR开始时曾有过违反GPL、发放二进制时不发放源码的争议，使得原开发作者不满[28]。不过后来ShadowsocksR项目由breakwa11转为了与Shadowsocks相同的GPL、Apache许可证、MIT许可证等多重自由软件许可协议。 2017年7月19日，ShadowsocksR作者breakwa11在Telegram频道ShadowsocksR news里转发了深圳市启用SS协议检测的消息并被大量用户转发，引发恐慌[29]。 7月24日，breakwa11发布了闭源的SS被动检测程序，引发争议[30]。7月27日，breakwa11遭到自称“ESU.TV”（恶俗TV）的不明身份人士人身攻击，对方宣称如果不停止开发并阻止用户讨论此事件将发布更多包含个人隐私的资料[31]，随后breakwa11表示遭到对方人肉搜索并公开个人资料的是无关人士，为了防止对方继续伤害无关人士，breakwa11将删除GitHub上的所有代码、解散相关交流群组，停止ShadowsocksR项目。但项目已被多人fork，并有人在其基础上继续发布新的版本，例如较为知名的SSRR（页面存档备份，存于互联网档案馆）（ShadowsocksRR）。 参考Shadowsocks介绍 VPS搭建Shadowsocks VPS搭建Shadowsocks（ss）教程 科学上网：Vultr VPS 搭建 Shadowsocks（ss）教程（新手向） 搭建shadowsocks连接上之后，就可以开始搭建了。 1.安装锐速 / 谷歌 BBR 加速优化 1.2、谷歌 BBR 推荐装这个，执行下面命令安装谷歌BBR： wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && chmod +x bbr.sh && ./bbr.sh 显示 “Press any key to start…” 按回车确认。回车后会出现一列内核版本让我们选择，输入序号 61 并回车开始安装。 然后开始选择内核版本 安装完后，按提示重启 VPS，输入 Y 回车重启。稍候 1min 等待重启完成，再重新连接 Xshell。 重启后输入 lsmod | grep bbr ，出现 tcp_bbr 即说明 BBR 已经启动。 2.安装SS 依次运行下面三行命令，如下图所示按要求输入相应信息。（建议：端口选择大于 1000 的。） 下载脚本： wget — no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 更改权限： chmod +x shadowsocks.sh 运行脚本，开始安装： ./shadowsocks.sh 2>&1 | tee shadowsocks.log 安装完成，把标红的连接信息记录下来，就可以关闭 xshell 了。（出现这几行就说明安装成功） 服务端搭建完成！(^▽^) 3.多用户配置 强烈不建议小白操作此步！自己用的话不需要配置这一步，因为不熟悉操作的话，很容易在这一步出问题，大概率失败！ 如果想和一两个亲友一起用的话，可以继续本步。先说注意事项： 输入法切英文 核对正确在保存不要漏 配置好后重启shadowsocks才会生效 首先，我们把配置信息准备好（# 开头的是注释，不要复制进去），把下面的代码复制到记事本中，按要求把 \"port_password\"{……} 中的端口和密码改为自己需要的。 # 1.先设置好端口和对应的密码 # 2.添加或删除的用户都在 \"port_password\"{……} 中 # 3.用户信息格式，注意末尾的英文逗号：\"端口\"：\"密码\", 如 \"8006\": \"123456\", # 4.\"method\" 为加密方式，可修改，默认也可以，客户端的加密方式也是这个 { \"server\":\"0.0.0.0\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":{ \"8989\":\"password0\", \"9001\":\"password1\", \"9002\":\"password2\", \"9003\":\"password3\", \"9004\":\"password4\" }, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false } 然后，在 /etc 下新建 shadowsocks.json 配置文件： 创建配置文件 vi /etc/shadowsocks.json 出现一列波浪线即进入 vim。 注意，敲黑板了！！！下面的操作很重要： 按 a ，然后把刚才准备好的 “配置信息” 粘贴进去，检查无误； 再按 Esc，输入 :wq 保存退出。 比如下面这个配置，设置了 3 个用户，分别使用 8000,8001,8002 端口，后面是对应的密码。 重启 shadowsocks 生效： /etc/init.d/shadowsocks restart 多用户配置完成！ 4.其他命令 卸载： ./shadowsocks.sh uninstall 控制： /etc/init.d/shadowsocks start # 启动 /etc/init.d/shadowsocks stop # 停止 /etc/init.d/shadowsocks restart # 重启 /etc/init.d/shadowsocks status # 状态 四、使用 下面只要下载客户端连接就行了。包含 win、mac 和 安卓客户端。（IOS 需要在商店中安装） 客户端下载链接（GitHub）：Mac客户端Win客户端Android客户端 参考Vultr VPS 搭建 Shadowsocks（ss）教程（新手向） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/SOCKS.html":{"url":"docs/commonsense/搭建梯子VPN/SOCKS.html","title":"SOCKS","keywords":"","body":"SOCKS SOCKS介绍 SOCKS介绍 SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是\"SOCKet Secure\"的缩写[注 1]。 当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。 这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。 根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。 SOCKS协议不提供加密。 与HTTP代理的对比 SOCKS工作在比HTTP代理更低的层次：SOCKS使用握手协议来通知代理软件其客户端试图进行的SOCKS连接，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。 虽然HTTP代理有不同的使用模式，HTTP CONNECT方法允许转发TCP连接；然而，SOCKS代理还可以转发UDP流量（仅SOCKS5），而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）。 SOCKS是一组由Internal工程工作小组（IETF）所开发出来的开放软件开放标准，用来处理网络安全的事宜。SOCKS像一堵墙被夹在 Internal服务器和客户端之间，对于出入企业网络的资讯提供流量和安全的管理。 SOCKS这个名词并不是一组英文字头的缩写，而是一个和 TCP/IP的Socket端口有关的安全标准，一般防火墙系统通常是象网关（Gateway）一样是作用在OSI模型的第七层也就是应用层上，对 TCP/IP的高级协议，如Telnet、FTP、HTTP和SMTP加以管制，而SOCKS作用在OSI模型的第五层也就是会话层上，像一个代理一样对客户端到服务器端或服务器和服务器之间的数据联系提供安全上的服务。 由于SOCKS作用在会话层上，因此它是一个提供会话层到会话层间安全服务的方案，不受高层应用程序变更的影响。 Socks代理只是简单地传递数据包，而不必关心是何种应用协议(比如FTP、HTTP和NNTP请求)，所以Socks代理服务器比应用层代理服务器要快。 SOCKS介绍SOCKS Protocol Version 5Socks5协议中文文档 Java SOCKS 4/5 server implementation for JavaJava Socks Server Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/搭建梯子VPN/内网穿透.html":{"url":"docs/commonsense/搭建梯子VPN/内网穿透.html","title":"内网穿透","keywords":"","body":"内网穿透 内网穿透 内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机 UDP 内网穿透的实质是利用路由器上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽。 网络地址转换（Network Address Translation，NAT）机制的问题在于，NAT设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被NAT设备丢弃，这使得位于不同NAT设备之后的主机之间无法直接交换信息。这一方面保护了内网主机免于来自外部网络的攻击，另一方面也为P2P通信带来了一定困难。Internet上的NAT设备大多是地址限制圆锥形NAT或端口限制圆锥形 NAT，外部主机要与内网主机相互通信，必须由内网主机主动发起连接，使 NAT设备产生一个映射条目，这就有必要研究一下内网穿透技术。 NAT穿透的原理 内网穿透的原理很简单的说就是: 两台计算机A和B都处于不同的局域网中，A想要访问B, 就需要通过一台服务器做桥接的， 桥接的方式有两种， 一种是服务器相互转发流量 到A和B， 另一种是告诉对方公网IP地址，自己充当一个介绍人的角色, 专业术语叫DNAT目标地址转换。 NAT设备（或软件）维护一个状态表，用来把内部网络的私有IP地址映射到外部网络的合法IP地址上去。每个包头中的IP地址和端口信息在NAT设备（或软件）中都被修改并翻译成一正确的IP地址发往下一级。 当一个内网主机通过NAT打开一个“外出”的TCP或UDP会话时，NAPT分配给这个会话一个公网IP和端口，用来接收外网的响应的数据包，并经过转换通知内部网的主机。这样，NAPT在[私有IP：私有端口]和[公网IP：公网端口]之间建立了一个端口绑定 中转服务器发送 打洞命令或者说是打洞数据包 内网穿透百度百科什么是内网穿透？ 内网穿透原理是什么？ 内网穿透工具 NPS 一款轻量级、高性能、功能强大的内网穿透代理服务器。支持tcp、udp、socks5、http等几乎所有流量转发，可用来访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析、内网socks5代理等等……，并带有功能强大的web管理端。 a lightweight, high-performance, powerful intranet penetration proxy server, with a powerful web management terminal. frp frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 Ngrok ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。 蜻蜓映射 蜻蜓映射是一款完全免费的端口映射工具，集成了动态域名解析和内网穿透。 支持多种类型的应用程序服务（办公OA、ERP、视频监控、微信开发等）。蜻蜓映射可以轻松的实现外网访问内网服务器，而无需运营商分配的公网IP地址，也无需动态域名。 natapp 基于ngrok的内网映射工具，免费版本提供http,tcp,udp全隧道穿透、随机域名/随机TCP,UDP端口、不定时强制更换域名/端口和自定义本地端口。 花生壳 简单好配置，可以下载客户端配置，也可以直接在他们官网注册，web页面上直接配置，简单快捷，重点不收费。 推荐5款最好用的内网穿透工具内网穿透的几款工具 内网穿透原理总结与工具推荐实现内网穿透的十几种方法 比较好用的内网穿透工具ngrok内网穿透工具frp好用吗 ngrok搭建指南10分钟教你搭建自己的ngrok服务器 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/电脑组装/电脑DIY.html":{"url":"docs/commonsense/电脑组装/电脑DIY.html","title":"电脑DIY","keywords":"","body":"电脑DIY 电脑发烧友需要了解的常识 自已动手攒一台整机，所需要的配件分别为：CPU、主板、内存、硬盘、显卡、显示器、机箱、电源、键盘、鼠标、光驱等。 主板 、CPU、显卡、声卡、机箱、鼠标、键盘、内存条、网卡、CPU风扇、光驱、硬盘、电源、IDE数据线、软驱数据线、音箱、螺丝刀、螺丝钉、橡皮筋/尼龙扎带、程序安装光盘/u盘等 电脑组装需要考虑的： CPU主板 内存 硬盘：HDD、SSD 网卡 散热：风扇、水冷（噪音） 机箱：防震 电源 CPU方面一般低端的Celeron或者Pentium就能轻松胜任 集成主板 专业的会上C236或C246芯片主板（华擎C236 wsi），这些主板支持ECC内存，而且自带8个SATA接口，省了安装扩展卡来增加SATA接口。 网络方面，集成的万兆网口还不太普及，一般只在高端的工作站主板才有，如果真的需要万兆网络，可以使用PCIE来扩展。 出于机箱散热的限制和需要24小时不断运行的考量，CPU的功耗不能太高，因此选了8700T【1】。虽然是阉割版的8700K，但价格并没有阉割，淘宝正式版都要2000，最后花了1400元在闲鱼找到QS版的8700T。 主板是在闲鱼收了一块华硕的B360i主板【2】。主板两个M2接口（NVME和NVME+SATA），四个SATA接口。后置有HDMI、DP，USB 3.0 type C及type A和一个千兆网口。内存也是二手平台上买的2个三星的8GB 2666Mhz的DDR4。系统盘方面，用的是512GB 的Intel 660p。虽然是QLC，但估计我有生之年应该用不到擦写极限。目测这套配置的性能作为NAS可以运行至少10年不被淘汰（硬件故障或翻车除外）。 机箱方面，选择并不多，基本就是黑群晖专用机箱，唯一能选的就是2/4/6/8盘位。淘宝89元买了二手的4盘位机箱还带电源。只是使用痕迹有点多，灰尘也没清理，不少地方还带刮痕。但只要花个下午的功夫清理及喷漆，机箱就和新的没差别了。CPU散热因为机箱限制只能选低于40mm的。我用的是Noctua的NH-L9i，除了要求在这个狭小的空间里达到散热，对静音的要求也不能忽视。 存储硬盘 品牌的选择上，基本上就是Seagate、Western Digital（WD）、日立（HGST）及东芝等。 出于性价比的考量我最后入手了两个4TB东芝的N300（4TB）【5】，价格约700元。至于硬盘的可靠性方面，只能等我用了一段时间后才能评价。 Linux的话广泛使用的就是Ubuntu了（题外话：近几年基于Arch的Manjero崛起，以后有时间打算去折腾下）， 保护措施 电子零件怕潮湿，因为住的地区比较潮湿，因此在机箱里加了干燥剂。而震动对机械盘的寿命会有影响，因此在机箱底下垫了海绵以减少共振。另外突然·断电也会机械盘造成伤害，因此还是需要考虑买一个无间断电源，减少断电所带来的危害。 主板换成了Supermicro的X11SCL-IF（C242芯片）[20]。主板带有NVME及4个SATA接口。网络方面则是2个千兆网口及一个IPMI管理接口。同时内存也升级成ECC内存。而CPU则换上支持ECC内存的G4900。 查看了一下配置J3455的主板平台，4盘位不带硬盘居然要4500大洋以上。 主板范围就很小了。ITX板子（17cm*17cm），本着低功耗的需求（布局对散热不是非常友好，没有下面CPU的穿堂风，而且我不想安装CPU风扇），我选择了大众推荐的J3455-ITX平台（539元）。集成CPU性能稍微差一些，但也已经与之前提到4500+大洋的那款齐平,价格还低，不错。 关于主板，网络上也看了很多内容，都说到最新款已经是j4205，j4105，但是我几乎没有找到卖的ITX板子。销量高一点的只有这一款，所以就3455了。兼容性对小白来说是排行第一位的。目前J3455集成CPU应对NAS文件共享所需性能应该是够了，如果后期有更高的需求，可以考虑再次升级。 配件就按照机箱要求，电源采用益衡7025B FLEX小1U电源，耐用性非常好。我查阅了很多电源型号。我一直想找一块更好的电源，因为我的方案中NAS要24小时开机，一年365天不休息。后来发现，这种工业电源其实已经很能打了，况且机箱受限，应该也没办法采取其他型号的电源了，就这款了。 建议使用固态硬盘（我选择系统为windows server 2019，原因见后文），我有一块希捷的500g固态，主要考虑未来如果兼职下载器，可以作为下载缓存，这一点也是参考了网上的一些说法，建议大家如果想购买可以考虑金士顿的120g（175元）。 机械硬盘市场细化程度非常高。目前市场中主流的主要有西部数据，希捷，东芝。对比而言，网络上推荐NAS使用的主要是酷狼、酷狼PRO，红盘，红盘PRO。这一点我不是很认同。 网线建议用超细超六类网线，JD有售，颜值，走线都很美观，不必使用屏蔽线。 风扇如果有超静音需求，建议更换猫扇，那感觉谁用谁知道，确实不错。当然同等档位，风量也有所降低。我目前仅需要NAS的文件共享功能，没有高度散热需求，可以接受。 路由器或交换机十分建议多千兆网口，不比追求万兆网口，除非有特殊需求。因为即使有万兆网口， PC也得同样配备万兆网口，之后还得磁盘读写跟得上。一连串的升级，好比木桶原理，最短的短板决定你的网络传输速度。 随后希捷、西数、东芝都公布了SMR硬盘的具体型号。对西数来说，3.5寸蓝盘中的2TB（WD20EZAZ）、6TB（WD60EZAZ）为SMR、2.5寸蓝盘中的1TB（WD10SPZX）、2TB（WD20SPZX）是SMR，2.5寸黑盘中的1TB（WD10SPSX）也是SMR。 4月30日开始，西数的官网规格表也升级了，目前可以详细查看旗下硬盘是否为SMR硬盘。 电脑组装和自建各种服务 科学上网（翻墙）/翻墙VPN/机场/梯子 内网穿透 硬盘分类、组成、自建NAS等 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/电脑组装/CPU和主板.html":{"url":"docs/commonsense/电脑组装/CPU和主板.html","title":"CPU和主板","keywords":"","body":"CPU和主板 基于 CPU 架构和工艺提升的创新日益趋缓，已无法满足新场景下多样化算力快速增长的需求，算力提升的核心动力正从 CPU 扩展到以 NPU、ISP、VPU、GPU 等为代表的计算单元。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/电脑组装/内存和硬盘.html":{"url":"docs/commonsense/电脑组装/内存和硬盘.html","title":"内存和硬盘","keywords":"","body":"内存和硬盘 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/电脑组装/帧率FPS和分辨率和像素.html":{"url":"docs/commonsense/电脑组装/帧率FPS和分辨率和像素.html","title":"帧率FPS和分辨率和像素","keywords":"","body":"帧率FPS和分辨率和像素 什么是FPS(Frames per second) 在视频格式中经常会看到24fps/60fps这类的词语出现，Frames per second是每秒帧数的意思，简称fps。除此之外，FPS这个词出现最多的是在游戏圈，特指第一人称视角的射击游戏（First Person shooter）。 人眼可以每秒可以处理10-12个静止画像，其中动态补偿功能也会欺骗我们。在12fps或更低的fps帧率下时，我们就能快速区分这是一堆静止的图像，而不是动画。一旦画面播放速率（每秒帧数）达到16-24fps时，我们的大脑就会认为这些画面是一个连续运动的场景，看起来就会是影片的效果了。 如果说影片的画质由分辨率dpi来决定，那fps就是衡量影片或者游戏是否流畅的基准，我们俗称的“画面卡顿”就是指在fps过低时画面给我们的不流畅感觉，相反，当fps前的数字越大（每秒帧数越高），画面就会越平滑流畅。因此我们得出：同等时长下，帧率越高，所包含的画面约丰富，因此所占用的储存空间越大。 刷新率：刷新率是指电子束对屏幕上的图像重复扫描的次数。刷新率越高，所显示的图象（画面）稳定性就越好。刷新率高低将直接决定其价格，但是由于刷新率与分辨率两者相互制约，因此只有在高分辨率下达到高刷新率这样的显示器才能称其为性能优秀。 FPS（每秒传输帧数(Frames Per Second)） FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数越多，所显示的动作就会越流畅。通常，要避免动作不流畅的最低是30。某些计算机视频格式，每秒只能提供15帧。 FPS也可以理解为我们常说的“刷新率（单位为Hz）”，例如我们常在游戏里说的“FPS值”。我们在装机选购显卡和显示器的时候，都会注意到“刷新率”。一般我们设置缺省刷新率都在75Hz（即75帧/秒）以上。例如：75Hz的刷新率刷也就是指屏幕一秒内只扫描75次，即75帧/秒。而当刷新率太低时我们肉眼都能感觉到屏幕的闪烁，不连贯，对图像显示效果和视觉感观产生不好的影响。 电影以每秒24张画面的速度播放，也就是一秒钟内在屏幕上连续投射出24张静止画面。有关动画播放速度的单位是fps，其中的f就是英文单词Frame（画面、帧），p就是Per（每），s就是Second（秒）。用中文表达就是多少帧每秒，或每秒多少帧。电影是24fps，通常简称为24帧。 画面帧率fps是否越高越好？ 我们已知在影片和游戏中，运动的画面是由一帧一帧的精致图像，在快速的连续展示中形成的。fps前的数值越高，画面展示的动作就会越流畅，那是不是我们要一味的追求越来越高的画面播放速率呢？ 当然不是，当画面帧数过高，所储存的资讯就越多，因此在储存和传输时所占“空间”就越大 如果做过影片编辑、动画制作、后期渲染的朋友就知道，帧数越高的画面不仅会让文件“体积”大，后期渲染时间明显翻倍，甚至会让电脑罢工。 另外，人眼在观看超过100fps时的影片时，并不会有明显的流畅度提升。更高的帧率只有用在超慢镜头时才会用到，也就是升格。这样会让画面有慢动作的效果，让人们关注到运动细节。 什么叫做升格拍摄，什么叫做降格拍摄，以及什么叫做延时摄影 升格与降格是电影摄影中的一种技术手段，电影摄影的拍摄标准是每秒24格，也就是每秒拍摄24张，这样在放映时才能是正常速度的连续性画面。 但为了实现一些简单的技巧，比如慢镜头效果，就要改变正常的拍摄速度，比如高于24格/秒，这就是升格，放映效果就是慢动作。 如果降低拍摄速度（低于24格/秒），就是降格，放映效果就是快动作。 升格拍摄 “电影是每秒钟24画格的真理。” 而当电影的拍摄速度超过了24画格/秒时，我们便称之为升格拍摄，升格拍摄的画面到了银幕上以正常速度放映，自然也就造成了电影时空上的延展放大，这便是我们口中常说的慢镜头。 降格拍摄 降格拍摄又称低速摄影，就是利用低于24 格每秒来拍摄，使画面中运动物体的运动速度加快。 由于降格后曝光速度慢，每一格捕获的运动轨迹多带有虚影，最终形成影像独特的拖尾运动幻觉。 在宣传片的降格技法的使用中，常常利用其格数降至较低时的拖尾效果 降格拍摄的手法在以前通常是作为一种喜剧效果来应用的，但这个手法在现在已经逐渐不被使用了。 在以前胶片时代，降格拍摄的方法是在拍摄时降低过卷的速度，而在播放时以正常速度播放来实现的。而现在，大家都是在后期中加速快放素材来实现了。 拖尾镜头 宣传片的夜景拍摄中多数会使用这种拖尾镜头，拖尾镜头是一种在广告和 MV 中常见的摄影手段，经常用来拍摄夜景街道中车流的快速穿梭或者发光物体的快速运动。 营造出画面中的光束效果，使得整体画面极具动感与科技感，形成一种运动幻觉。 延时摄影 而延时摄影可以认为是和高速摄影（高速摄影即拍摄升格镜头）相反的一个过程。延时摄影通常应用在拍摄城市风光、自然风景、天文现象、城市生活、建筑制造、生物演变等题材上。 也可以理解为延时摄影就是超级降格镜头。 分辨率和像素是什么关系 像素（pixel,缩写px） 像素：是指在由一个数字序列表示的图像中的一个最小单位，称为像素。 像素是指由图像的小方格组成的，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。 可以将像素视为整个图像中不可分割的单位或者是元素。不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在 [1] 。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 像素，为影像显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。仔细处理的话，一幅影像中的像素可以在任何尺度上看起来都不像分离的点或者方块；但是在很多情况下，它们采用点或者方块显示。每个像素可有各自的颜色值，可采三原色显示，因而又分成红、绿、蓝三种子像素（RGB色域），或者青、品红、黄和黑（CMYK色域，印刷行业以及打印机中常见）。照片是一个个取样点的集合，在影像没有经过不正确的/有损的压缩或相机镜头合适的前提下，单位面积内的像素越多代表分辨率越高，所显示的影像就会接近于真实物体。 数码像素 数码像素是一种虚拟化的数字，大小可以任意，或者说没有实际的物理尺寸大小 像素大小是去适配显示屏的像素大小，或适配打印的大小。如图2，左图表示显示屏的像素点很小，右图表是显示屏的像素点很大，当然是同一幅图），无固定形式，就单个像素来说，本身的形状是任意的，没有被明确定义的，或者是被捕获时的摄像机或相机、或扫描仪等定义的，本身不具备显示功能，数码像素要显示必须依赖显示设备，包括显卡，显示屏。通常我们理解的一个像素是1：1的正方形块，这只是它最常见的一种形式，有的摄像机捕获的像素并不是1：1的正方向，比如：1：1.21，1：1.09，1：1.46等等，但摄像机或相机的光感器形状都是矩形（正方形或长方形，其实也可以是圆形，不规则图形，但没人会用圆形或不规则图形）如下图 屏幕像素 。屏幕像素是指显示屏的像素，包括电视机，电脑显示屏，手机显示屏等等，这些像素不是虚拟的，是实实在在存在的，具有物理尺寸大小，通常是英寸-inch, 这些像素通常来说只有一种比列1：1的正方形，并且像素点之间是紧挨着的。但是我们经常会看到户外显示屏的像素点，通常人们叫LED屏幕，这些屏幕的像素点就有不同比例的，还有圆形的，因为人们观看广告的距离不是近距离，而是几十米上百米远，所以他们的像素点并不是一颗紧挨着另一颗，像素点之间有空隙和距离。如下图，黑色缝隙挺大的。 分辨率 分辨率(数码图像分辨率Resolution，数码打印分辨率或屏幕分辨率ppi，打印机分辨率或物理世界dpi, ppi=pixels per inch, dpi=dots per inch) 首先指出一个误解：通常我们会看到“分辨率1920*1080”，此处分辨率=Resolution,是数码图像的分辨率，与屏幕分辨率ppi和打印机分辨率dpi无关，它表示的是“像素数量”不要理解为面积，跟面积无任何关系。数码打印或屏幕或打印机的分辨率只与长度相关，ppi=pixels per inch，表示每英寸有多少个像素点（通常指屏幕点或屏幕像素点，也是数码图像的打印分辨率，但对数码图像的显示不起作用），dpi=dots per inch，表示每英寸有多少个点（通常指打印点，与屏幕像素点无关）总结是：ppi作为屏幕分辨率时与dpi打印机分辨率无任何关系；ppi作为数码图像打印分辨率时与dpi关系是输入和输出。 数码图像分辨率Resolution。 数码图像的分辨率就是指这幅图的像素多少，究竟有多少个像素。数码图像的物理尺寸可以是任意的（参考前面：数码像素）比如3ppi,100ppi,表示打印的时候一英寸打3个和100个像素点。如果我的图像分辨率是5000x4000px，打印分辨率是100ppi,那么这幅图打印出来的实际尺寸是宽=5000/100=50inch，和高=4000/100=40inch 如72ppi表示1英寸包含72个像素点，300ppi表示每英寸含300个像素点。分辨率决定了位图细节的精细程度，通常情况下，分辨率越高包含的像素就越高，图像就越清晰。 既然刷新率越快越好，为什么还要强调没必要追求太高的刷新率呢？ 其中原因是在显示“分辨率”不变的情况下，FPS越高，则对显卡的处理能力要求越高。 电脑中所显示的画面，都是由显卡来进行输出的，因此屏幕上每个像素的填充都得由显卡来进行计算、输出。 当画面的分辨率是1024×768时，画面的刷新率要达到24帧/秒，那么显卡在一秒钟内需要处理的像素量就达到了“1024×768×24=18874368”。 如果要求画面的刷新率达到50帧/秒，则数据量一下子提升到了“1024×768×50=39321600”。 FPS与分辨率、显卡处理能力的关系如下： 处理能力=分辨率×刷新率。这也就是为什么在玩游戏时，分辨率设置得越大，画面就越不流畅的原因了。 分辨率建议设置为显示器分辨率，过高或过低可能造成画面变形。 参考什么是FPS(Frames per second)？FPS （每秒传输帧数(Frames Per Second)）百度百科干货 |常说的升格降格到底是什么？分辨率和像素是什么关系？像素 维基百科 RGB（颜色系统） RGB、CMYK、HSB、Lab颜色模式而我们最常用的是RGB和CMYK模式。 显示器是通过发射红绿蓝三种光束来创建颜色的，使用RGB颜色模式；而为了打印出连续色彩的图像， 打印机使用了青色（cyan）、洋红色（magenta）、黄色（yellow）、黑色（black）这四种颜色，通过叠印这四种颜色，反射和吸收各种光波，达到模拟自然色彩的目的，由于蓝（blue）和黑（black）的开头字母相同，黑做出了让步，使用k表示自己，就有了cmyk颜色模式。 RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是运用最广的颜色系统之一。 三原色、次混合色、互补色 三原色：红、绿、蓝，这三种光波是自然界所有颜色的基础，任何颜色都可以由这三种颜色混合而来。 次混合色：如果将这三种颜色两两交叠，就得到了次混合色（上图交叠部分），红+蓝=洋红、红+绿=黄、绿+蓝=青。 互补色，以红色和青色为例，青色是由绿色和蓝色混合而来，是不含红色的，红色和青色就是一对互补色，绿色和洋红也是互补色，蓝色和黄色也是互补色。 RGB颜色模式表达方式 每种颜色按亮度分为0~255共256个等级（不了解亮度可以看第一节），0表示亮度为0%，255表示亮度为100%，这是我们首先要知道的，数值表示的是颜色的亮度。 三种颜色的不同亮度相互组合成立大千世界，这些数值可以表示256256256=1678万中颜色，对于电脑再现大千世界绰绰有余了。但为什么是255呢，这关于到色彩位数2^8=256,，表示这是8位色彩深度，色彩深度是计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，位数越多，能表示的颜色越多。 十六进制颜色码 这种颜色表示方式在前端开发很常用，我理解为RGB 的简写模式，其实就是将十进制的0~255用两位十六进制表示，十进制与十六进制转化不会的伙伴要去学一下哦。十六进制颜色码共六位，前两位表示红色、中间两位表示绿色、最后两位表示蓝色。 RGB 常用颜色对照表颜色模式之RGB（你知道0～255表示什么吗？） 鼠标DPI是什么意思 相信大家在购买或者使用鼠标时，都会留意到一个重要的参数，那就是鼠标的DPI，一般来说，鼠标的可调DPI范围越大，也就意味着这个鼠标的精度越高，相应的价格就会越贵。那么这里的鼠标DPI到底是什么意思呢？ 其实我们所说的鼠标DPI其实就是鼠标CPI，只不过许多商家因为原本用于打印分辨率方面的DPI这个名词的传播广泛，就一直在宣传时使用DPI来代替了原本的鼠标CPI进行宣传。 而所谓的鼠标DPI或者是鼠标CPI，就是指的鼠标在使用移动中，每移动一英寸，大概也就是2.54厘米位置时所能准确定位的最大信息数。可以理解为鼠标实际每移动一英寸的距离在电脑上反应出来的点数。 说的更加直观和通俗一点，鼠标的DPI数值越大，往往给我们的感受就是鼠标移动的越快，灵敏度也就越高，而当然也不是鼠标的DPI越大越好，在使用鼠标的过程中，每个人的习惯不同，所以根据自己的习惯喜好来选择最适合自己的DPI数值就好了。 如何更改鼠标灵敏度 (DPI)？ DPI 是用于测量鼠标灵敏度的标准，表示设备可以检测的 DPIs (每线性) 英寸的点数。 通过更改 DPI，你可以立即调整精度任务的指针速度，例如，游戏定位或照片编辑。 DPIs 数越大，鼠标灵敏度越高，指针速度越快。 某些鼠标模型包括专用按钮 (DPI 的 \"动态\" 按钮) 可用于立即调整鼠标灵敏度 (DPI) 。 更改鼠标灵敏度 (DPI) 设置 如果你的鼠标具有 \"动态\" 按钮，请按下一个 DPI 的 \"动态\" 按钮，为每个 DPI 按钮创建新设置。 鼠标液晶显示屏将短暂显示新的 DPI 设置。 如果鼠标没有 \"动态\" 按钮，请启动 \"Microsoft 鼠标和键盘中心\"，选择要使用的鼠标，单击 \"基本设置\"，找到 \"灵敏度\"，进行更改。 鼠标dpi多少合适如何评价罗技的 G Pro Wireless （GPW、狗屁王）？2022年游戏鼠标推荐（罗技/雷蛇/赛睿等品牌有线、无线鼠标评测） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/硬盘知识/硬盘知识.html":{"url":"docs/commonsense/硬盘知识/硬盘知识.html","title":"硬盘知识","keywords":"","body":"硬盘知识 硬盘和闪存的概念 USB介绍 怎么区分USB2.0和USB3.0的 USB分类 USB HUB SD卡(内存卡、存储卡)) 闪存Flash 闪存分类 存储单元电位阶数划分 NAND分类 内存和闪存的区别 USB闪存盘、固态硬盘和闪存卡中的SLC、MLC、TLC和3D NAND之间的区别 传统机械硬盘（HDD）和固态硬盘（SSD） 未来的闪存存储 U盘和固态硬盘 那么闪存与固态具体的相似和不同有哪些呢？ 固态硬盘SSD分类 SSD按接口分类 IDE和SCSI SAS与SATA的区别 SSD按颗粒分类 S.M.A.R.T概述 UASP协议与TRIM指令 SSD固态硬盘的的GC和TRIM、写入放大简介 NAS 机械硬盘LMR、PMR、CMR、SMR 参考IDE、SATA、SCSI、SAS、FC、SSD硬盘区别.pdf 硬盘和闪存的概念 USB：通用串行总线（英语：Universal Serial Bus，缩写：USB） SD卡：Secure Digital，缩写为SD，全名为Secure Digital Memory Card，中文翻译为安全数码卡 闪存Flash：快闪存储器（英语：flash memory） 闪存又分为NOR与NAND两型：NOR Flash和NAND Flash 一至四阶存储单元为SLC、MLC、TLC和QLC NAND：2D NAND和3D NAND 传统机械硬盘（HDD）和固态硬盘（SSD） SSD:固态驱动器 (Solid-State Drive, SSD) HDD:硬盘驱动器 (Hard Disk Drive, HDD) U盘：U盘是USB(universal serial bus)盘的简称，据谐音也称“优盘”。U盘是闪存的一种，故有时也称作闪盘。U盘与硬盘的最大不同是，它不需物理驱动器，即插即用，且其存储容量远超过软盘，极便于携带 USB介绍 概念： USB：通用串行总线（英语：Universal Serial Bus，缩写：USB）是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被 最新一代的USB是USB4，传输速度为40Gbit/s。物理接头USB Type-A、Type-B接头分正反面，新型USB Type-C接头不分正反。 USB 3.0在实际设备应用中将被称为“USB SuperSpeed”，顺应此前的USB 1.1 FullSpeed和USB 2.0 HighSpeed。 USB-IF（USB开发者论坛）是位于美国的USB标准化组织，全称USB Implementers Forum。 USB-IF官网 怎么区分USB2.0和USB3.0的 黑色是USB 2.0，蓝色或其它颜色是USB 3.0? USB 2.0只有一排4针脚，USB 3.0上边5个，下边4个，一共9个针脚 SS是SuperSpeed的意思，带SS标示即为USB3.0接口。 上面这种也是 USB TYPE-A 接口, 不过因为 USB 3.0 标准的推出, 为了方便区分 USB 2.0, 所以接口的颜色通常使用蓝色. 所以如果你的主板背板有黑色和蓝色两种 USB 接口, 通常表示黑色的是 USB2.0, 而蓝色的是 USB3.0或更高标准. USB分类 USB Type A一般用于个人电脑中，是应用于最广泛的接口标准。上述举例图片的接口全部为USB Type A。 USB Type B一般用于3.5寸移动硬盘、打印机、以及显示器等的连接。 USB Type C由于支持正反插、可选功能多也越来越受到广泛使用。 同样 Micro USB 是我们通常叫法, 严谨的叫法是 USB 2.0 Micro-B, 也是因为还有一个 USB 2.0 Micro-A, 不过几乎看不到. 这种接口相比 Mini USB 要更加小巧, 在 USB Type-C 普及之前, 几乎市面上所有的安卓机采用此接口. 比如，若USB Type C支持PD协议，可以给笔记本供电； 若支持DP，可以连接外接显示器支持显示（一般会有标示“D”，示例图片为灵耀U4100UN）； 若支持Thunderbolt3更是不得了（一般会有标示“带箭头的闪电”，示例图片为灵耀X）。 Thunderbolt3(雷电3)是啥？ “Thunderbolt”(雷电)接口是Intel发布的Light Peak技术，Thunderbolt3的理论传输速度为40Gb/s，且可以支持USB3.1、DisplayPort、PCI Express和Thunderbolt四种协议。 USB维基百科USB接口你想了解的USB知识，都在这里了！USB接口详细读解, 更新USB3.2/USB4标准与Gen2和Gen1的区别USB Type-C / Type-A等有什么不同？一次关于USB的研究手记(V1.3） USB HUB USB Hub，指的是一种可以将一个USB接口扩展为多个，并可以使这些接口同时使用的装置。USB HUB根据所属USB协议可分为USB2.0 HUB、USB3.0 HUB与USB3.1 HUB。 USB集线器（英语：USB hub）是一个让多个USB设备连接到计算机上一个USB接口或另一个USB集线器上某个接口的设备。 第一、USB是英文Universal SerialBus的缩写,中文就是“通用串行总线”，也称通用串联接口。 第二、Hub是大家常说的集线器，它使用星型拓扑结构连接多个USB接口设备。 可将一个USB接口扩展成多个独立工作的USB接口。 SD卡(内存卡、存储卡) Secure Digital，缩写为SD，全名为Secure Digital Memory Card，中文翻译为安全数码卡[1][2]，为一种存储卡，被广泛地于便携式设备上使用，例如数字相机、个人数码助理和多媒体播放器等。SD卡的技术是建基于MultiMedia卡格式上。SD卡有比较高的资料发送速度，而且不断更新标准。大部分SD卡的侧面设有写保护控制，以避免一些资料意外地写入，而少部分的SD卡甚至支持数字版权管理的技术。SD卡的大小为32mm×24mm×2.1mm，但官方标准亦有记载“薄版”1.4mm厚度，与MMC卡相同。 中文界有时会把SD卡称为内存卡[3][4]、存储卡，但此“内存卡”、“存储卡”与“内存”、“存储器”其实是两个完全不同的概念。 SD卡 闪存Flash 闪存usb flash disk 快闪存储器（英语：flash memory） 快闪存储器（英语：flash memory），是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在计算机与其他数字产品间交换传输数据，如储存卡与U盘。闪存是一种特殊的、以宏块抹写的EPROM。早期的闪存进行一次抹除，就会清除掉整颗芯片上的数据。 闪存是一种非易失性存储器，即断电数据也不会丢失。因为闪存不像RAM（随机存取存储器）一样以字节为单位改写数据，因此不能取代RAM。 闪存卡（Flash Card）是利用闪存（Flash Memory）技术达到存储电子信息的存储器，一般应用在数码相机，掌上电脑，MP3等小型数码产品中作为存储介质，所以样子小巧，有如一张卡片，所以称之为闪存卡。根据不同的生产厂商和不同的应用，闪存卡大概有SmartMedia（SM卡）、Compact Flash（CF卡）、MultiMediaCard（MMC卡）、Secure Digital（SD卡）、Memory Stick（记忆棒）、XD-Picture Card（XD卡）和微硬盘（MICRODRIVE）这些闪存卡虽然外观、规格不同，但是技术原理都是相同的。 闪存分类 闪存又分为NOR与NAND两型 NOR Flash需要很长的时间进行抹写，但是它提供完整的寻址与资料总线，并允许随机存取存储器上的任何区域，这使的它非常适合取代老式的ROM芯片。 NAND Flash具有较快的抹写时间，而且每个存储单元的面积也较小，这让NAND Flash相较于NOR Flash具有较高的存储密度与较低的每比特成本。同时它的可抹除次数也高出NOR Flash十倍。然而NAND Flash的I/O接口并没有随机存取外部地址总线，它必须以区块性的方式进行读取，NAND Flash典型的区块大小是数百至数千比特。 NAND Flash广泛应用在各种存储卡，U盘，SSD，eMMC等等大容量设备中。它的颗粒根据每个存储单元内存储比特个数的不同，可以分为 SLC（Single-Level Cell）、MLC（Multi-Level Cell） 和 TLC（Triple-Level Cell） 三类。 杂谈闪存二：NOR和NAND FlashNAND Flash和Nor Flash到底有什么区别 存储单元电位阶数划分 通过对闪存内最小的物理存储单元的电位划分不同的阶数，可以在一个存储单元内存储一至多个二进制位数。常见的一至四阶存储单元为SLC、MLC、TLC和QLC。 存储单元电位阶数划分 单阶存储单元（Single-Level Cell,SLC） 多阶存储单元（Multi-Level Cell,MLC） 三阶储存单元（Triple-Level Cell, TLC） 四阶储存单元（Quad-Level Cell, QLC） NAND分类 2D NAND和3D NAND 3D NAND指的是闪存芯片的存储单元是 3D 的。此前的闪存多属于平面闪存 (Planar NAND)，而3D NAND，顾名思义，即是指立体结构的闪存。 如果平面闪存是平房，那 3D NAND 就是高楼大厦。把存储单元立体化，意味着每个存储单元的单位面积可以大幅下降。 顾名思义，2D NAND SD 闪存是扁平的。可以存储数据的单元格是并排放置的。在 2D NAND SD 闪存中，闪存是根据放置在设备上的单元数量和包含的存储位数量来计算的。 什么是3D NAND？与2D NAND相比有什么优势？What Is The Difference Between 2d And 3d Nand 内存和闪存的区别 内存RAM使用寄生电容充放电来表示0和1，充了电的电容需要不断的被充电维持状态，否则很快漏电，所以需要持续供电，但是速度块。 Flash闪存使用MOS管中间的一个绝缘体包括层来储备电子，充电之后可以长期保存，外部使用sense amp比较放大器来感受每个MOS管内的状态，从而输出0和1状态，断电后数据依然保存，比RAM慢一个数量级，但是比磁盘快多个数量级。 内存在计算机里是一个临时缓存空间数据无法保存，也就是RAM-RamdomAccessMemory易挥发性随机存取存储器，高速存取，读写时间相等，且与地址无关，如计算机内存等。 而闪存是电子可擦除只读存储器（EEPROM）的变种，闪存与EEPROM不同的是，EEPROM能在字节水平上进行删除和重写而不是整个芯片擦写，而闪存的大部分芯片需要块擦除。由于其断电时仍能保存数据，闪存通常被用来保存设置信息； 内存Ram, 和闪存Flash 这个电脑的运行内存（=内存=Ram=Random-access memory）是8GB，而物理内存（=闪存=Flash memory）是256GB 闪存内存和闪存的区别是什么？ USB闪存盘、固态硬盘和闪存卡中的SLC、MLC、TLC和3D NAND之间的区别 存储单元电位阶数划分 单阶存储单元（Single-Level Cell,SLC） 多阶存储单元（Multi-Level Cell,MLC） 三阶储存单元（Triple-Level Cell, TLC） 四阶储存单元（Quad-Level Cell, QLC） 五级单元（PLC）SSD 3D NAND（多层数存储） 它们的每个存储单元的存储容量是不一样的，它们的单元存储容量分别为： SLC ——1bit/单元； MLC——2bit/单元； TLC ——3bit/单元； QLC——4bit/单元； PLC——5bit/单元； NAND Flash广泛应用在各种存储卡，U盘，SSD，eMMC等等大容量设备中。它的颗粒根据每个存储单元内存储比特个数的不同，可以分为 SLC（Single-Level Cell）、MLC（Multi-Level Cell） 和 TLC（Triple-Level Cell） 三类。 现在高端SSD会选取MLC甚至SLC，低端SSD则选取TLC。SD卡一般选取TLC。 NAND 是一种非易失性闪存，可在未连接电源时存储数据。断电后保留数据的能力使得 NAND 成为内置设备、外置设备和便携设备的理想选择。USB 闪存盘、固态硬盘和 SD 卡均利用闪存技术，为手机或数码相机等设备提供存储。 市场上存在多种类型的 NAND。简言之，不同类型之间的区别在于每个单元可以存储的位数。位代表电荷，电荷只能存储 0 和 1 两个值（代表开/关）中的一个。 各种 NAND 类型之间的关键区别在于成本、容量和耐久性。耐久性是由一个闪存单元在开始磨损前可以完成的程序擦除 (P/E) 周期数量决定的。一个 P/E 周期是指擦除和写入一个单元的过程，NAND 技术支持的 P/E 周期越多，设备的耐久性越高。 NAND 闪存的常见类型是 SLC、MLC、TLC 和 3D NAND。本文将探讨各种 NAND 类型的不同特征。 SLC NAND 优点：最高耐久性 - 缺点：价格贵、容量低 单级单元 (SLC) NAND 每个单元存储一位信息。一个单元存储 0 或 1，因此可以更快地写入和检索数据。SLC 提供最佳性能和最高耐久性，高达 100,000 个 P/E 周期， 因而比其他类型的 NAND 更加耐用。不过，低数据密度使得 SLC 成为最贵的 NAND 类型，因此通常不用于消费类产品。它通常用于服务器以及其他要求速度与耐久性的行业应用。 MLC NAND 优点：比 SLC 便宜 - 缺点：速度和耐久性不如 SLC 多级单元 (MLC) NAND 每单元存储多个位，尽管 MLC 一词通常意味着每单元两位。MLC 的数据密度比 SLC 高，因此可以实现更大的容量。MLC 在价格、性能和耐久性之间取得良好平衡。不过，MLC 对数据错误更加敏感，拥有 10,000 个 P/E 周期， 因此耐久性比 SLC 低。MLC 通常用于对耐久性要求不算高的消费类产品。 TLC NAND 优点：最便宜、高容量 - 缺点：低耐久性 三级单元 (TLC) NAND 每单元存储三个位。通过向每单元添加更多位，可以降低成本并提高容量。不过，这对性能和耐久性具有负面影响，只有 3,000 个 P/E 周期。许多消费类产品采用 TLC，因为这是最便宜的方案。 3D NAND 近十年来，3D NAND 是闪存市场最大创新之一。闪存制造商开发了 3D NAND 来解决缩小 2D NAND 时面临的问题，从而以更低成本实现更高密度。在 2D NAND 中，用于存储数据的单元水平并排放置。这意味着，可用于放置单元的空间量有限，试图缩小单元则会降低其可靠性。 因此，NAND 制造商决定在另一个维度叠放单元，从而促成纵向叠放单元的 3D NAND 的产生。更高存储密度可实现更高的存储容量，同时不会导致价格大幅上升。3D NAND 还提供更高的耐久度和更低功耗。 总体而言，NAND 是一项非常重要的闪存技术，能以较低的每位成本提供更快的擦除和写入速度。随着游戏行业的发展，NAND 技术料将进一步发展，帮助满足消费者日益增长的存储需求。 USB 闪存盘、固态硬盘和闪存卡中的 SLC、MLC、TLC 和 3D NAND 之间的区别SLC vs MLC vs TLC固态硬盘颗粒：SLC/MLC/TLC有什么区别？多层SSD：什么是SLC，MLC，TLC，QLC和PLC？SSD闪存颗粒类型分类——SLC、MLC、TLC、QLC和PLC 传统机械硬盘（HDD）和固态硬盘（SSD） SSD:固态驱动器 (Solid-State Drive, SSD) HDD:硬盘驱动器 (Hard Disk Drive, HDD) 机械硬盘（HDD）、固态硬盘（SSD）以及混合硬盘（SSHD） HDD 存储采用旋转磁盘、电机和读写磁头，通过电磁机制在旋转盘片中存储数据。 机械硬盘(HDD)是传统硬盘，为电脑主要的存储媒介之一。由一个或者多个铝制或者玻璃制成的磁性碟片，磁头，转轴，控制电机，磁头控制器，数据转换器，接口和缓存等几个部分组成。工作时，磁头悬浮在高速旋转的碟片上进行读写数据。机械硬盘是集精密机械、微电子电路、电磁转换为一体的电脑存储设备。 固态硬盘（SSD）是由多个闪存芯片加主控以及缓存组成的阵列式存储，属于以固态电子存储芯片阵列制成的硬盘。相对机械硬盘，读取速度更快，寻道时间更小，可加快操作系统启动速度和软件启动速度。 未来的闪存存储 过去，SSD 一直采用与硬盘驱动器 (Hard Disk Drive, HDD) 相同的 I/O 接口设计连接到主计算机，例如 SATA 和 SAS 接口。尽管如今大多数 SSD 都使用基于 3D TLC NAND 的闪存存储，但非易失性内存标准 (Nonvolatile Memory Express, NVMe)、基于网络结构的 NVMe (NVMe over Fabrics, NVMe-oF) 以及存储级内存 (Storage Class Memory, SCM) 技术给数据中心带来了无限可能。 NVMe 是一款用于通过 PCI Express (PCIe) 总线访问闪存存储的接口协议。不同于只能使用单一串行命令序列的传统全闪存架构，NVMe 支持成千上万个并行序列，每一个序列都能支持成千上万个并发命令。 NVMe-oF 是存储系统中的一个主机端接口，可以通过远程直接内存访问 (Remote Direct Memory Access, RDMA) 或光纤通道网络结构提供许多相关的 NVMe 功能。利用 NVMe-oF，可以横向扩展到许多 NVMe 设备，甚至支持远距离 NVMe 设备。 也称持久内存 (Persistent Memory, PMEM)，是一种新型介质技术，它模糊了内存与存储之间的界线，可作为其中任何一种介质使用。SCM 的示例包括 Intel 的 3D XPoint 和三星的 Z-NAND 介质。 广泛部署 NVMe 和 NVMe-oF，特别是结合 SCM 使用时，可以大幅加快下一代应用程序的性能，将延迟降低到原来的 1/10，并提供最高 IOPS。 NetApp 率先向市场推出基于 3D NAND 技术的大容量 15 TB SSD。目前，NetApp 引领闪存的未来发展，在其强有力的愿景中，基于 NVMe、NVMe-oF 和 SCM 的全新闪存系统将可以无中断集成到现有基础架构中。 什么是闪存存储？硬盘分类详解 U盘和固态硬盘 U盘，全称USB闪存驱动器，英文名“ USB flash disk”。 U盘：U盘是USB(universal serial bus)盘的简称，据谐音也称“优盘”。 U盘是闪存的一种，故有时也称作闪盘。U盘与硬盘的最大不同是，它不需物理驱动器，即插即用，且其存储容量远超过软盘，极便于携带 U盘=USB控制器+闪存控制器+FLASH 固态硬盘=硬盘控制器+FLASH FLASH一般就是各种闪存芯片，一般都是NAND的片子。 所以，U盘和SSD是加了控制器的闪存，而影响闪存速度的是控制器的性能，比如SSD性能高于U盘，主要靠的不是闪存的速度而是控制器的实现。 补充一点：高速U盘用的其实是硬盘机的主控芯片，所以才比一般U盘速度要快，SSD的主控一般都是32位的芯片，而山寨U盘一般是量产的8位芯片，性能差别是非常大的。 我们日常生活中所使用的U盘、还有一些高速的读写卡，都属于闪存产品，其实固态硬盘也属于闪存产品，毕竟是基于闪存颗粒基础上研发出来的硬盘，我们通常把一些性能不太好的固态笑称为大号U盘，由此可见U盘和固态的相似之处还是蛮大的。 U盘 （USB闪存盘）闪存盘 那么闪存与固态具体的相似和不同有哪些呢？ 相同点： 都采用闪存颗粒作为存储的主体，主控+闪存芯片这样的结构。 基本运作原理相似，可以视为同一类产品的简化版和高配版 不同点： 闪存通常的输出接口是USB，固态硬盘是SATA接口或其他接口，比如sata固态硬盘、msata固态硬盘、M.2固态硬盘等 闪存通常是单闪存颗粒，偶尔有两个颗粒做双通道，固态硬盘是多颗粒，所以闪存通常容量不大，而固态硬盘可以以比较大的容量起步，比如256G固态硬盘。 闪存的主控非常简单，通常只包含读写策略和缓存机制；而固态除了这两个以外，还要进行各个方面的优化，比如读写、策略、缓存、电气特性、垃圾回收机制等等 闪存的体积较小，通常只有手指大小，便于携带，不怕摔；固态硬盘通常较大，不算硬盘盒，一个msata的固态都要大半张银行卡的大小，一些M.2和PCIe的还要长一些 性能上差异较大，普通的闪存产品，同一时间内，只能进行读或者写其中一项操作，因为闪存颗粒的电压变化收到主控的影响，通常只能有一种；固态硬盘主控更复杂，能够同时控制不同的电压变化，读和写几乎没有影响，可以同时进行。 闪存和固态硬盘的区别 固态硬盘SSD分类 按接口分类 按颗粒分类 SSD按接口分类 首先还是从SSD的结构来说起，SSD最基本的组成部件分为：主控芯片、闪存芯片、固件算法 当下主流的固态硬盘接口有M.2、U.2、PCIe、SATA、SATA Express、SAS等。M.2和U.2可选PCIe接口。NVMe协议是目前最高效的PCIe SSD协议标准。 目前SSD的主流接口分为，SATA 3.0、M.2、PCI-E三种，U.2和mSATA目前并不多见，这里不过多介绍。 SATA和M.2或PCI-E的主要区别在于：二者采用不同的通道。 可以把两种通道理解成两辆相同的汽车，PCI-E通道的汽车就像是在高速上行驶，而SATA通道的汽车就像是在崎岖山路上行驶，你说哪个速度快？ M.2最初叫做NGFF，全名是Next Generation Form Factor。这个接口很特殊，同时支持SATA和PCI-E两个通道，很容易让人误解。 其实并不是所有的M.2固态硬盘读写速度都很快，如果是采用SATA通道的M.2接口固态硬盘，读写速度不会超过550MB/s。还要注意的是，主板厂商的M.2接口有的选择了CPU原生的PCI-E通道，有的是通过PCH南桥扩展出来的，这可能对固态硬盘的速度产生影响。 总线：总线在电脑的主板上，这样理解，固态硬盘这个大仓库在郊外，CPU需要数据，但是内存条容量太小，没有存储，只有从固态硬盘这边调取，总线＝运输数据的公路， 固态硬盘送货给CPU和内存需要走的路就是总线。 这条路又分为两种：SATA总线、PCI-E总线。 SATA总线：“乡村公路” PCI-E总线：“高速公路” 第一种：SATA接口，SATA接口的固态硬盘是老式接口，走SATA总线，这种固态硬盘的速度不会超过550MB/S PCIe无疑是最为流行的传输总线标准，这几年的更新换代也十分频繁：PCIe 3.0目前还是最普及的，PCIe 4.0正在快速崛起，PCIe 5.0即将和大家见面，PCIe 6.0规范已经完成了0.5版本，并提供给组织成员，将在明年按期发布最终正式版。 NVMe是一种协议，是一组允许SSD使用PCIe总线的软硬件标准；而PCIe是实际的物理连接通道。 IDE和SCSI IDE(Integrated Drive Electronics 集成驱动器电子)的缩写，它的本意是指把控制器与 盘体集成在一起的硬盘驱动器，是一种硬盘的传输接口，它有另一个名称叫做 ATA (Advanced Technology Attachment)，这两个名词都有厂商在用，指的是相同的东西。 SCSI 的英文全称为“Small Computer System Interface”(小型计算机系统接口)，是同 IDE(ATA)完全不同的接口，IDE 接口是普通 PC 的标准接口，而 SCSI 并不是专门为硬 盘设计的 接口，是一种广泛应用于小型机上的高速数据传输技术。SCSI 接口具有应用范 围广、多任务、带宽大、CPU 占用率低，以及热插拔等优点，但较高的价格使得 它很难 如 IDE 硬盘般普及，因此 SCSI 硬盘主要应用于中、高端服务器和高档工作站中。 SAS与SATA的区别 SAS(Serial Attached SCSI)即串行连接SCSI，是新一代的SCSI技术 SATA（Serial Advanced Technology Attachment）即串行高级技术附件，SAS是新一代的SCSI技术。 SAS接口可向下兼容SATA，在物理层和协议层实现兼容，实现SAS控制器直接操控SATA硬盘，但SAS不可使用与SATA的环境中。SAS接口理论传输速度为12Gb/s，SATA理论传输速度为6Gb/s，SAS接口支持热插拔。 SAS(Serial Attached SCSI)即串行连接SCSI，是新一代的SCSI技术，和现在流行的Serial ATA(SATA)硬盘相同，都是采用串行技bai术以获得更高的传输速度，并通过缩短连结线改善内部空间等。 SAS是并行SCSI接口之后开发出的全新接口。此接口的设计是为了改善存储系统的效能、可用性和扩充性，并且提供与SATA硬盘的兼容性。 SAS的接口技术可以向下兼容SATA。具体来说，二者的兼容性主要体现在物理层和协议层的兼容。 在物理层，SAS接口和SATA接口完全兼容，SATA硬盘可以直接使用在SAS的环境中， 从接口标准上而言，SATA是SAS的一个子标准，因此SAS控制器可以直接操控SATA硬盘， 但是SAS却不能直接使用在SATA的环境中，因为SATA控制器并不能对SAS硬盘进行控制; 在协议层，SAS由3种类型协议组成，根据连接的不同设备使用相应的协议进行数据传输。 其中串行SCSI协议(SSP)用于传输SCSI命令; SCSI管理协议(SMP)用于对连接设备的维护和管理; SATA通道协议(STP)用于SAS和SATA之间数据的传输。 因此在这3种协议的配合下，SAS可以和SATA以及部分SCSI设备无缝结合。 NL-SAS是采用了SAS的磁盘接口和SATA的盘体的综合体 NL-SAS和SAS从技术上来说，没啥大区别。就像上面阿超说的，NL-SAS更注重容量和价格，SAS更注重性能上的考虑 SAS与SATA的区别 SATA与SAS的区别? SSD按颗粒分类 NAND闪存的常见类型是SLC、MLC、TLC 和3D NAND 存储单元电位阶数划分 单阶存储单元（Single-Level Cell,SLC） 多阶存储单元（Multi-Level Cell,MLC） 三阶储存单元（Triple-Level Cell, TLC） 四阶储存单元（Quad-Level Cell, QLC） 3D NAND（多层数存储） 干货！史上最全SSD科普贴：科学购买SSD花几分钟，了解SSD分类，让你买固态硬盘不再吃亏——《分类篇》科普讲堂——固态硬盘(SSD)扫盲 S.M.A.R.T概述 S.M.A.R.T.（Self-Monitoring Analysis And Reporting Technology），意思为“自我检测分析与报告技术”，从名字也能看出其作用是故障预警，固态硬盘可以通过监测自身的健康状态，并将参数值反馈给监控软件或者操作系统，事实上，大部分的参数仅仅对工程师而言有意义，对于最终用户而言，只关注一些关键指标即可，如：新增坏块统计，剩余使用寿命，擦除次数等即可。 一些常用的测试软件也可以获取到SSD的S.M.A.R.T信息： 经过多年HDD硬盘厂商的完善，S.M.A.R.T已经形成了一些标准，但对于SSD来说，大多数SATA协议的S.M.A.R.T都是自定义的，以至于每个厂商所提供的参数并不一致，但大体都会参考HDD S.M.A.R.T来设定。 SSD S.M.A.R.T信息保存在特定的区域中，由Firmware安排，有可能保存在OP区中，也有可能保存在任何FW工程师想要放置的地方，或者由单独的表来存放。 固态硬盘的S.M.A.R.T与HDD不完全相同，网络上常用的测试软件提供的S.M.A.R.T都是基于HDD设置的，SSD厂商通常会自行根据Nand Flash的特性设定S.M.A.R.T。 SATA协议固态硬盘的S.M.A.R.T详解 UASP协议与TRIM指令 UASP协议与TRIM指令到底是什么意思？能提升硬盘读写速度吗？ USAP是什么？ USAP，是USB-IF所制定用于透过USB接口连接序列设备的一个传输协议，能让大容量储存设备传输速度提升20％，并降低CPU利用率、数据延迟和等待时间等。 而实现UASP加速需要满足以下条件： 1、电脑主板上的USB3.2 Gen 1或者Gen2主控芯片要支持UASP； 2、电脑系统要必须是Win8、10或者Mac OS 8 & 9以上的系统版本； 3、外接设备比如移动硬盘盒要支持UASP传输协议； 具备条件才能开启UASP加速协议，而且一般是自动开启。 Trim是什么？ Trim指令，也叫disable delete notify（禁用删除通知），是为了增强SSD主控垃圾回收效率、解决硬盘降速问题而引入的ATA指令。其正常工作的三个前提：操作系统、驱动程序和固态硬盘三个层面的共同支持，缺一不可。 电脑办公时，删除数据文件并非真正意义上的“清除”，只是将其标记为可覆盖区块，这样操作对于可以直接进行数据覆盖写入的机械硬盘来说是没有问题的，但对于采用NAND（闪存）作为存储介质的固态硬盘（SSD）来说并不友好。 由于NAND（闪存）不支持覆盖写入，而是先擦除旧数据后再写入新资料，也就是说固态硬盘（SSD）在对“已删除文件对应的位置”再次写入新数据时，才会知道“已删除文件”是无效数据，这种特性会让导致固态硬盘（SSD）陷入越用越慢的窘境。 而TRIM命令则是由操作系统(OS)对固态硬盘（SSD）下指令，来标记出哪些数据是可以擦除，从而提升垃圾回收的效率可以在一定程度上避免SSD掉速的情况，又能减轻了固态硬盘的损耗。 简单来说，TRIM指令的存在，让固态硬盘能够更科学的进行垃圾文件的删除、整理、回收，是固态硬盘维持长期稳定性能的重要依赖。需要注意的是，固态硬盘上删除的数据不能通过软件恢复，建议大家养成数据备份的良好习惯。 SSD固态硬盘的的GC和TRIM、写入放大简介 操作系统： 其实并没有删除数据； 事实上，它只是在硬盘前的索引区里标记这块文件占用的区域为无效的， 所以等该区域被擦除后，下次数据将要再次写入的时候，可以写入这块被标记的区域。 这也就是为啥那 些所谓的文件恢复软件能恢复的道理。（数据依然存在）。 固态硬盘： 在固态硬盘闪存内，数据存储一般是以page（页）为最小单位存储的（典型的为4KB），而128个page组成了一个block（块）， 数据以页（page）为单位来读取和写入，但却只能以块（Block）为单位来删除。 当读取数据或者写入到一个没有被使用过的page上时，固态硬盘的速度是很快的， 但是在无效数据区上的话，就比较复杂了，需要许多步骤来完成。 GC：要覆写（这里指在无效数据区域写）一个4KB 页的文件系统，首先要把整个512KB 块复制进缓存里。 然后，在缓存里删除这个4KB页，替换成新的数据。 接下来，清空整个闪存内的这个512KB区域，并从缓存里把新的数据写回去。 Trim：SSD一样会复制整个包含删除数据的块到缓存，清空块并写入有效数据的页回去， 区别是这样等于把这个延迟时间从覆写数据的那个时间提前到了删除数据的时候 也就是GC在新的数据写入的时候，才开始删除数据，如果有之前没清除干净的数据，所有写入的页的操作都要先清除块再改写，将严重影响写入速度。 当数据删除时候让系统告诉SSD数据没了，让SSD立即擦掉那些数据占用的块，这就是Trim命令做的事。提前在删除数据的时候就删除数据 SSD的GC和写入放大 GC是（Garbage Collection，垃圾回收）的缩写，是固态硬盘（SSD）的一个基本技术，它对SSD的性能和寿命有直接的影响。这里主要介绍一下GC是如何工作的。 当使用机械硬盘时，文件系统可以直接将新数据写入到旧数据存储的位置，即可以直接覆盖旧数据。 在固态硬盘中，境况有所不同。如果想让存储无用数据的块写入新数据，就需要先把整个块删除，才可以写入新的数据，也就是说固态硬盘并不具备直接覆盖旧数据的能力。 对于固态硬盘来说，GC（垃圾回收）是指把现存数据重新转移到其他闪存位置，并且把一些无用的数据彻底删除的过程。 上面介绍了，数据写入的方式，即以页面为单位写入，但是要想删除数据却需要以块为单位。 因此要删除无用的数据，固态硬盘首先需要把一个块内包含有用的数据先复制粘贴到全新的块中的页面内，这样原来块中包含的无用数据才能够以块为单位删除。 删除后，才能够写入新的数据，而在擦除之前是无法写入新数据的。 写入放大： 说了GC之后，再说一下经常听到的SSD的写放大问题。因为当写入新数据时，如果SSD控制器找不到可以写入的page时，会执行GC过程，然后GC机制会将一些block中的有效数据合并写入其他的block中，然后将这些block的无效数据擦出，再将新数据写入到这些block中，而在整个过程中除了要写入用户的数据之外，实际上SSD还写入了一些其他block合并过来的数据，所以这就叫写入放大。 TRIM或DISCARD 了解了GC和写入放大之后，再来说一下TRIM和DISCARD。 TRIM（或者DISCARD）的出现主要为了提高SSD垃圾资源的回收效率以及减少写入放大的发生。 我们知道，在文件系统上删除某个文件时候，它只是简单的在逻辑数据表内把存储要删除的数据的位置标记为可用而已，而并不是真正将磁盘上的数据给删除掉。使用机械硬盘的系统根本就不需要向存储设备发送任何有关文件删除的消息，因为在将来，系统可以随时把新数据直接覆盖到无用的数据上。 固态硬盘的情况就不同，只有当系统准备把新数据要写入那个位置的时候，固态硬盘才意识到原来这写数据已经被删除了！（无用数据。），而如果在这之前，SSD执行了GC操作，那么GC会把这些实际上已经删除了的数据还当作是有效数据进行迁移写入到其他的block中，这是没有必要的。 TRIM和DISCARD的支持，不仅仅要SSD实现这个功能，而是整个数据链路中涉及到的文件系统、RAID控制卡以及SSD都需要实现。要使用这个功能必须要在mount文件系统时，加上discard选项。如果想要确认SSD是否支持，可以通过hdparm -I命令检查。 SSD的GC和TRIM、写入放大简介 SSD固态硬盘的GC与Trim NAS NAS（Network Attached Storage）网络附属存储，可以理解为长时间连网的存储设备，其功能基本和市面上的各种云盘相似。NAS或云盘除了提供大容量的资料存储，也帮一般人省了携带移动硬盘的麻烦，因为资料或数据可以随时访问（只要能连网）。 如果打算搭建自己的NAS，最容易的方案还是FreeNAS或群晖，所需的时间也就大概下班后的一个晚上就可以完成上线。 除非是喜欢自己折腾尝试，那可以安照自己喜欢的方式去搭建，估计大家可以玩出更多花样。 收费：群晖（Synology）和 威联通（QNAP） 免费：黑裙（黑群晖） 、FreeNAS 、自建NAS 纵观NAS市场，系统层面几乎是被群晖和威联通所垄断的，只要你使用NAS基本都逃不过这两个系统。所以只要能够玩转这两个系统就基本上通吃市面所有的NAS了。 目前主流的文件共享方案有FTP、SFTP、SMB、NFS和WebDav。 UPS也很重要，不然停电了，硬盘就很容易损坏 不间断电源（或称UPS，即 Uninterruptible Power System）是在电网异常（如停电、欠压、干扰或浪涌“也称：涌浪电流”）的情况下不间断的为电器负载设备提供后备交流电源，维持电器正常运作的设备。通常情况下不间断电源被用于维持计算机（尤其是服务器）或交换机等关键性商用设备或精密仪器的不间断运行，防止计算机数据丢失，电话通信网络中断或仪器失去控制。 搞机日常 – 搭建私人云存储NAS2020年家用NAS DIY指南（小白篇） 群晖（Synology）和 威联通（QNAP） 群晖 nas 有些什么基本和好玩的功能？群晖Synology官网威联通（QNAP）官网 TrueNAS（FreeNAS） TrueNAS（12.0版前称为FreeNAS）是一套基于FreeBSD操作系统核心的开放源代码的网络存储设备（英语：NAS）服务器系统，支持众多服务，用户访问权限管理，提供网页设置接口。FreeNAS当前版本整个系统总共需2GB以上USB驱动器进行安装，并支持USB存储设备、LiveCD、CF卡（转接成IDE设备）及硬盘等引导方式。目前有LiveCD、镜像档、VMware磁盘映像档三种发行方式。 原本的FreeNAS定位为单纯的网络文件服务器，但在发布0.684版本之后，由于市面上小型的NAS系统功能越来越多的情况下，FreeNAS渐渐加入P2P、iTunes、PHP Webserver等等的功能。 从2009年之后原开发者Olivier Cochard-Labbe宣布由于作者不能拿出大量时间进行版本更新，从0.7版本以后FreeNAS将转为维护模式，不会发布新的版本。新版本开发及发布由iXsystem公司负责。新版本FreeNAS工程开始于2010年，在2011年5月2日FreeNAS 8.0成功发布。由于需要与FreeBSD版本号进行匹配，FreeNAS主版本号更新为8，紧跟FreeBSD发行。 TrueNASTrueNAS Github FreeNASFreeNAS Github RAID 既然是存储，那就可能涉及组RAID（Redundant Array of Independent Disk）。 除了一般提到的RAID 0,1,10,5,6等，RAID又分硬RAID和软RAID。 硬RAID是在硬件层面（RAID扩展卡，主板Bios）实现硬盘冗余， 而软RAID则是在操作系统层面完成。 正常情况（条件允许）下，推荐使用的都是硬RAID。而我在买回来后才发现主板不支持RAID，而原本的PCIE槽打算预留给万兆网卡，因此只能使用软RAID。 RAID是什么？ RAID 是英文 Redundant Array of Independent Disk 的首字母缩写，中文意思是：独立磁盘冗余阵列。通俗的讲就是把多块硬盘组成一个独立的磁盘阵列进行管理。 RAID 白皮书上的解释：RAID（独立冗余磁盘阵列）是一项能提升外部存储解决方案性能的简单技术。它能让您根据自己的需要选择最佳的设备使用方式。简单地说，RAID 技术可以将一个硬盘上的任务分散或复制到多个（少则两个）磁盘上，借此来提高性能或建立数据冗余以防驱动器发生故障。您可以通过设定设备的 RAID 模式来决定设备以何种方式处理数据。 使用RAID的好处是什么呢？ 对于普通用户而言，使用 RAID 技术管理硬盘其实是没有多大必要，但是对于企业用户，尤其是要使用高可用、稳定等解决方案保证硬盘数据稳定、安全、可靠时，RAID 就显得尤为重要。因为 RAID 技术可以为硬盘提供安全性和稳定性的保障，保证硬盘数据容错性或者读写性能的提升等。 RAID的实现方式分类 RAID 可以按照硬盘数量和组织方式不同分为不同类型的 RAID 实现。 常见的有： RAID 0、RAID 1、RAID 5、RAID 6、RAID 01、RAID 10。 不常见的有：RAID 2、RAID 3、RAID 4、RAID 7、RAID 50、RAID 53。 RAID术语 每个方块代表一个磁盘，竖的叫块或磁盘阵列，横称之为带区。 条带化：指将数据分到多个驱动器上。条带 RAID 阵列通常用于将最大的容量合并到单个卷中。 镜像：指将数据复制到多个磁盘上。镜像 RAID 阵列通常能在阵列中有磁盘（至少一个）发生故障时确保数据不丢失，具体取决于阵列的 RAID 级别。 容错：指可让 RAID 阵列在磁盘发生故障时继续工作（即用户仍然可以使用阵列中存储的数据）。 各类RAID实现详解 RAID0：无差错控制的带区组，非冗余，读写性能好，数据可靠性低于单个磁盘。 RAID1：镜象结构，读性能好，写性能与单个磁盘相当，数据可靠性高，成本高。 RAID2：带海明码校验 RAID3：带奇偶校验码的并行传送 RAID4：带奇偶校验码的独立磁盘结构 RAID5：分布式奇偶校验的独立磁盘结构 RAID6：带有两种分布存储的奇偶校验码的独立磁盘结构 RAID7：优化的高速数据传送磁盘结构 RAID 01： RAID 0和RAID 1的组合形式，先做RAID 0再将RAID 0组合成RAID 1，拥有两种RAID的特性。 RAID 10： RAID 0和RAID 1的组合形式，先做RAID 1再将RAID 1组合成RAID 0，拥有两种RAID的特性，安全性能高。 RAID2~RAID7：各种数据校验机制+磁盘结构上的变化 RAID 0又称为Stripe或Striping，中文称之为条带化存储，它代表了所有RAID级别中最高的存储性能。 原理： 是把连续的数据分散到多个磁盘上存取，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能。 RAID 1又称为Mirror或者Mirroring，中文称之为镜像存储。RAID 1是磁盘阵列中单位成本最高的，磁盘利用率最低，但提供了很高的数据安全性和可用性。 原理： 将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”通过镜像实现数据冗余，成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。最大允许互为镜像内的单个磁盘故障，如果出现互为镜像的两块磁盘故障则数据丢失。 RAID 01： RAID 0和RAID 1的组合形式 原理： 先做RAID 0再将RAID 0组合成RAID 1，拥有两种RAID的特性。 RAID 10： RAID 0和RAID 1的组合形式 原理： 先做RAID 1再将RAID 1组合成RAID 0，拥有两种RAID的特性，安全性能高。 Linux中RAID配置 在Linux系统中，主要提供RAID 0、RAID 1、RAID 5三种级别的RAID。mdadm是 linux下标准的的软raid管理工具，是一个模式化工具（在不同的模式下）；程序工作在内存用户程序区，为用户提供RAID接口来操作内核的模块，实现各种功能。 RAID方案 Ubuntu可以通过MDADM和ZFS来组RAID。 ZFS ZFS（Zettabyte File System）其实是集合文件系统+磁盘管理+RAID管理三项功能一个的软件。ZFS的Snapshot、Copy-on-write及大容量等都是它比一般的RAID方案有优势的地方。 ZFS是一个拥有逻辑卷管理功能的文件系统，最早源自于Oracle为Solaris操作系统开发的文件系统。ZFS具有可扩展性，并且包括大量保护措施防止数据损坏，支持高存储容量、高效数据压缩、集成文件系统、卷管理、快照和写时复制、连续完整性检查与自动修复、RAID-Z、原生NFSv4 ACL等功能，并且能被精确配置。 ZFS有两个主要实现，分别来自Oracle和OpenZFS，它们之间极度相似，这使得ZFS在类Unix系统中广泛可用。 ZFS的基本使用教程、替换损坏的硬盘以及增加扩展容量 MDADM mdadm 是 多磁盘和设备管理(Multiple Disk and Device Administration) 的缩写。它是一个命令行工具，可用于管理 Linux 上的软件 RAID 阵列。 使用 mdadm 管理 RAID 阵列mdadm命令详解 OpenZFS OpenZFS is an advanced file system and volume manager which was originally developed for Solaris and is now maintained by the OpenZFS community. This repository contains the code for running OpenZFS on Linux and FreeBSD. OpenZFS 是一种高级文件系统和卷管理器，最初是为 Solaris 开发的，现在由 OpenZFS 社区维护。该存储库包含在 Linux 和 FreeBSD 上运行 OpenZFS 的代码。 OpenZFSOpenZFS Github 各种 RAID 详解 各类RAID详解 Raid 详解 linux中RAID详解 RAID原理详解 机械硬盘LMR、PMR、CMR、SMR 水平磁性记录的方法，LMR（Longitudinal magnetic recording） 垂直磁性记录的方法，叫做PMR（Perpendicular Magnetic Recording） Shingled Magneting Recording（SMR）技术，又叫叠瓦式磁记录技术。 随着技术的发展，现在PMR的磁记录方式里，又细分出了两种形式：CMR和SMR (这两者是相互的一对概念) CMR称为传统磁记录方式，这种方式保留了最早PMR替代LMR时的传统技术，即：磁道间留有保护间距，数据不会被重复叠写。(按照这个说法，在上文中，我朋友问我买的是PMR还是SMR硬盘，其实问题的本质是在问，买的是CMR还是SMR技术硬盘) 那么，为什么说CMR与SMR是一对相互概念呢？或许可以这么来解答：正是因为PMR阵营中随着技术的创新，出现了两种同属于PMR技术的磁记录方式，一种是保留传统的未经改变的技术CMR，另一种是新技术叠瓦磁记录SMR。这样一来，仅仅说一款硬盘采用PMR磁记录方式，就显得很笼统，没有细化描述磁记录方式的具体分类，为了避免这种模糊不清的概念，采用了CMR和SMR这一对称谓来区分。 我们已经知道，磁头通过感应盘片上磁场的变化来读取数据；通过改变盘片上的磁场来写入数据，以磁场方向的不同来记录0和1。 在早期，磁盘上每个存储位的磁性粒子是平铺在盘面上的，磁感应的方向也是水平的。这种感应记录方式被称为LMR（Longitudinal magnetic recording），也就是水平磁性记录，这种方式有一个缺点，就是比较占面积，另外当磁粒过小，相互靠得太近，磁性就很容易受到热能的干扰，令方向发生混乱。 所以，LMR的时代，单个磁盘能够存储的数据有限，整个硬盘的容量也就存在瓶颈。 为了解决这个问题，后来人们想了一个办法，原来磁感应的方向不是水平的吗？如果让磁性粒子和磁感应的方向相对盘片垂直，这样不就能腾出很多空间了？于是人们发明了这种垂直磁性记录的方法，叫做PMR（Perpendicular Magnetic Recording），在此基础上，科学家还利用了热辅助磁记录技术，来提高在高密度下的信息写入能力。这种技术采用了一种热稳定记录介质，通过在局部进行激光加热，来短暂减小磁阻力，从而有效提高磁头在微场强条件下的高密度信息写入能力。 在PMR技术的帮助下，硬盘的存储容量得到了很大的提升，3.5英寸的硬盘，单碟磁盘的容量高可达1TB左右，这本质上是磁盘内信息存储的密度大大提升。 SMR硬盘是不适合用来当做系统盘或者需要频繁读写的硬盘来用的，它更适合当做小编在开头所说的仓储盘来使用，用来备份、留存一些数据。尽管现在硬盘的整体寿命已经有了很大的提升，但是当你要选购硬盘作为计算机主力硬盘时，还是应该尽可能避免买到SMR硬盘。 CMR和SMR是机械硬盘的两种不同数据记录方式。CMR翻译过来的中文意思是传统磁记录方式，采用该技术的硬盘会在磁道间保有保护间距，数据不会被重复叠写，安全稳定性更高。这里再延申一下，其实在更早之前还有一种叫PMR的垂直磁道记录技术，后来随着技术的发展，PMR细分出了CMR和SMR，一般我们认为PMR=CMR。 CMR 传统磁记录方式 SMR被称为叠瓦式磁记录方式，顾名思义该技术是把硬盘中的磁道像瓦片一样重叠堆放在一起，它的优点是提升硬盘的存储密度，从而增加约25%的容量。但是SMR也有缺点，就是它不适合频繁改写（数据），由于其磁头读头小、写头大，叠瓦磁道密度高的原因，会影响磁盘的写头工作，在随机写入或改写内容时，会把相邻磁道也一起改掉，因此叠瓦通常叠几圈以后会有一行正常宽度的磁道，把磁盘分成一个个区域。要改写内容，需要把这个数据所在的整个区域的内容先转存到缓存里，在缓存里改好，再一起写回去。 由于SMR硬盘并不适合频繁读写，，我们应尽量避开SMR硬盘。适合备份。 SMR称为叠瓦式磁记录方式，也就是网上很多人口中的坑王，它的“威名”相信很多人都已经了解，不详细阐述了。 机械硬盘避坑大法：一文搞懂PMR和SMR有什么区别关于机械硬盘的 CMR 和 SMR 。不买叠瓦盘！！！[HDD] 零售3.5'' SATA HDD汇总列表 (2018-10-24更新)机械硬盘LMR、PMR、CMR、SMR的解惑和自己购买西数企业硬盘经历 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/买房购房/买房子购房.html":{"url":"docs/commonsense/买房购房/买房子购房.html","title":"买房购房","keywords":"","body":"买房子购房 参考买预售商品房须知.doc 南京买房经历 房子不好的地方，毒地是：板桥，麒麟，燕子矶 目前卖房比较多的板块： 上坊那一片：靠近墓地，还有高速路，地铁规划还很早，卖房子遮遮掩掩，这个是为什么了 岱山 江北浦口 看过的楼盘： 1、电建洺悦华府： 均价3-3.1W，89和113平两种户型，89平的高层的总价要277万 2、世贸璀璨蓝湾： 之前的均价都在3W左右，新推的可能要涨价，只有95平和117平两种，95平的，总价要300万上下 1、中南上悦城：中南上悦花苑 对面是万安陵园和江宁殡仪馆 遮遮掩掩，均价都是2.6W以上， 2、金地都会学府： 均价都是2.6W以上，都是18层的小高层楼， 3、招商名筑： 98和108两种户型，均价2.6W左右，可以一次性减7W的优惠，108的总价279W 招商名筑离殡仪馆和万安陵园*近 4、璟悦名邸 璟悦名邸3#楼收官加推，预约报名中！共计120套房源，户型建筑面积约122㎡三房、约77㎡两房。前期少量房源销售，均价约26500元/㎡！城东一环旁，地铁10号线（规划中），万科物业，详询售楼处。 6、江宁金茂悦： 距离绕城高速很近 7、朗诗玲珑郡： 在招商名筑上面， 8、上东逸境：旁边是江宁殡仪馆 不考虑了，不看了 9、东城金茂悦Ⅱ期： 暂时不考虑了，具体绕城高速近 10、融侨观澜 都会学府北边,对面就是殡仪馆 1、蓝光睿创新筑 毛坯交付，100平，其他的都是大户型130、140的，均价2.7W 2、熙悦 蓝光睿创新筑旁边 身份证、户口本、社保证明 招商万金自己的物业 1、荣盛隽峰雅苑 正方中路地铁站两三公里， 2、誉峰苑 2号线南大仙林校区旁边 3、五矿澜悦方山 五矿澜悦方山在售少量叠墅，中叠建筑面积约142㎡，总价460万；上叠面积约125㎡，赠送露台，总价420万左右，均价29500元/㎡；主力小高层房源，户型建筑面积约115㎡，毛坯交付，销许均价约26500元/㎡；项目位于江宁大学城，具体一房一价，现房销售，详情可咨询售楼处。 交通，学校，商业，周边房价对比，得房率，电梯楼梯，小区开发商，物业品牌 直接找贝壳的人和直接找售楼处销售有什么区别 直接找你和找上次接待我的领导有什么区别 不把房源信息放出来什么意思 💁总高：25层 ，2梯4户 💁交付时间/标准：2021年10月底交付，精装+地暖+新风 💁 精装品牌：立邦，圣象，科勒，欧神，方太，奥普等 💁物业公司：万科物业（1.9/元/月） 💁绿化率: 30% 贝壳2%优惠 看清楚认购协议上的土地抵押、房屋抵押的描述 杭州买房经历 参考 https://github.com/houshanren/hangzhou_house_knowledge https://github.com/dujuncheng/hangzhou_buy_house Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/买房购房/收房前预攒钱.html":{"url":"docs/commonsense/买房购房/收房前预攒钱.html","title":"收房前预攒钱","keywords":"","body":"收房前预攒钱： 契税：2.35W（房价1%~1.5%） 公共维修基金：1.08W（120 x 面积） 物业费：2K~3K（1.9 x 面积 x 12） 公摊水电预存款：2K 车位费：（感觉暂时不需要） 验房师 若干元（看个人） 网络 若干元（看个人） 封阳台：若干K~若干W（看个人） 家具家电（床、柜子、桌子、冰箱、洗衣机、灯具、窗帘）：若干W（看个人） Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/汽车.html":{"url":"docs/commonsense/汽车.html","title":"汽车","keywords":"","body":"汽车 汽车品牌 汽车油耗 汽油种类 汽车车辆排放标准 买车注意事项 汽车品牌 汽车油耗 一般就是指百公里油耗多少升 一般就是7、8、9、10 汽车油耗该怎么计算？ 如何开车更省油？学会这些很简单！汽车油耗应该怎么计算？多少算高，多少算低呢？ 汽油种类 93号与97号汽油是按国IV的汽油标准生产，而现在推行国V标准，92与95号汽油便是按国V标准生产的。 标号越高，价格越高。 那么汽油的标号到底是依据什么划分的呢？为什么标号越高，价格越高呢？其实标号代表的就是辛烷值，是汽油的抗爆性指数，辛烷值越高，抗爆性越好。汽油内有多种碳氢化合物，辛烷值则直接取决于汽油内各种碳氢化合物的成分比例。 不同标号汽油，除了价格还有什么差别？老司机告诉你92、93、95、97号汽油到底有什么区别？那几号油最好呢？ 汽车车辆排放标准 汽车是一个流动的污染源，排放的主要污染物有一氧化碳（CO）、碳氢化合物（HC）、氮氧化物（NOx）和颗粒物（PM）等，都是污染环境的物质，需要加以控制。汽车污染物的排放源来自排气管、曲轴箱和燃油系。 随着汽车工业的快速发展，汽车保有量迅速增加，尾气污染问题也日益严重，从上世纪六七十年代开始，各国逐步针对汽车尾气排放立法，通过严格的法规推动汽车排放控制技术的进步。 汽车排放是指从汽车废气中排出的CO（一氧化碳）、HC+NOx（碳氢化合物和氮氧化物）、PM（微粒，碳烟）等有害气体。它们都是发动机在燃烧作功过程中产生的有害气体。 如今，世界汽车排放标准主要以欧洲、日本、美国标准为主，中国排放标准在很多年时间内参考了欧洲标准。直到上世纪九十年代末开始制定国家机动车第一阶段排放标准，即俗称的“国一”。需要强调的是，通常所说的排放标准，指的是轻型汽车的排放标准，重型载货汽车则另有规定。此外，截至目前的六版排放标准全国实施的时间也不统一，具备条件的或者环保政策相对严格的省市往往提前实施。 “国一”制定于1999年，于2001年7月1日开始在全国范围实施。“国一”标准参考“欧一”标准，主要是针对一氧化碳，碳氢化物和微粒排放有限值要求，一氧化碳为3.16克每千米，碳氢化物为1.13克每千米等。 “国二”标准于2004年7月1日开始在全国范围实施。为了迎接奥运会，北京提前至2004年1月1日起实施。“国二”标准对汽车排放的要求进一步提高，单车污染物排放一氧化碳降低30%，碳氢化物和碳氧化物降低55%。 “国三”标准于2007年7月1日开始在全国范围实施。为了降低污染物排放，在技术方面对发动机和排气系统进行了升级和改造，增加了车辆自诊断系统和对三元催化进行了升级。“国三”较“国二”的污染物排放总量要降低40%。 “国四”标准于2010年7月1日开始在全国范围实施。在排放后处理系统进行了升级，污染物排放标准较“国三”降低50%到60%。 “国五”标准于2018年1月1日开始在全国范围实施。该标准对氮氧化物、碳氢化合物、一氧化碳和悬浮粒子等机动车排放物的限制更为苛刻。相比“国四”标准，氮氧化物排放量要降低25%，还增加了非甲烷碳氢和PM的排放限制，降低了大气污染。 “国六”与前五个标准不同，“国六”标准设置了“国六a”和“国六b”两个阶段。其中“国六a”于2020年7月1日开始在全国范围实施，“国六b”则于2023年7月1日开始在全国范围实施。相比“国五”排放标准限值，“国六a”要求一氧化碳（CO）限值下降50%，而“国六b”要求总烃（THC）、非甲烷烃（NMHC）以及氮氧化合物（NOx）限值分别下降50%、48.53%和41.67%。 从国一到国六：燃油车越来越难 买车注意事项 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/信用卡分类.html":{"url":"docs/commonsense/信用卡分类.html","title":"信用卡分类","keywords":"","body":"信用卡分类 普卡 金卡(Gold) 白金卡(Platinum) 无限卡(Infinite) 普卡 金卡(Gold) 钛金卡(Titanium) 白金卡(Platinum) 世界卡(World) 绿卡(Green) 金卡(Gold) 白金卡(Platinum) 黑金卡(Centurion) 普卡 金卡(Gold) 白金卡(Platinum) 尊尚白金卡(Priority Platinum) 钻石卡diamond 普卡、金卡、白金卡、钻石卡 包括人民币账户黄金、人民币账户白银、人民币账户铂金、人民币账户钯金、美元账户黄金、美元账户白银、美元账户铂金、美元账户钯金等。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/生活小常识.html":{"url":"docs/commonsense/生活小常识.html","title":"生活小常识","keywords":"","body":"生活小常识 糖的分类 红糖 白糖 冰糖 单晶冰糖 多晶冰糖 糖的分类 在日常生活中，我们经常提起的几种味道“酸、甜、苦、辣、咸”，甜味是我们平时接触到的最多的一种味道，也是很多人喜欢的一种味道。平时我们吃到的甜味，一般都是来自糖，糖只是一个广义的称呼，如果细分起来，有红糖、白糖、冰糖三种。三种糖，说起对身体最有保健作用的，那就是冰糖，可是大部分人对于冰糖的了解并不多，下面就来给大家分享一下这方面的知识。 白糖、红糖、冰糖的区别。 冰糖中单晶冰糖和多晶冰糖的区别。 红糖 先说一下红糖，红糖是做法最简单的一种糖，红糖的原料是甜度比较高的甘蔗，将甘蔗汁经过简单加工、浓缩，即成红糖。红糖的特点是，没有经过进一步的提纯和加工，里面含有大量的维生素和各种微量元素，营养价值很高。在以前的民间，红糖可是很重要的一种补身体的食材。 白糖 白糖我们平时也叫它白砂糖，制作白糖使用的原料是甘蔗和甜菜，将甘蔗汁和甜菜汁榨出来之后，经过很多次地去色和提纯，最终做成白糖。白糖相比红糖来说，营养要差很多，但是味道甜，颜色纯净，一般做菜的时候用的比较多，加入少量白糖，对菜品的颜色影响不大，还能够给菜提鲜。 冰糖 冰糖说得简单一点，就是白糖的升级版。白糖在水中加热，然后冷却后结晶，就成了冰糖。冰糖的食疗效果很好，具有润肺止咳、清火降燥的功效，对身体极为有益，比如说大家常做的冰糖雪梨。因为结晶的原因，冰糖分为单晶冰糖和多晶冰糖，但是在现实中，很多人并不知道这两种糖的区别，其实它们最大的区别，还是在于功效的不同，所以下面主要就来介绍一下这两种冰糖到底区别在哪里。 冰糖是砂糖的结晶再制品，它是砂糖的结晶再制品，是以白砂糖为原料，经加水溶解、除杂、清汁、蒸发、浓缩后，冷却结晶制成。自然生成的冰糖有白色、微黄、淡灰色等，此外市场上还有添加含色素的各种彩色冰糖（主要用于出口），比如绿色、蓝色、橙色、微红、深红等多种颜色。由于其结晶如冰状，故名冰糖。冰糖以透明者质量最好、纯净。 普通的单晶冰糖，是加工整齐的、颗粒均匀的白冰糖，它和白砂糖的性质差不多，不是传统意义上的冰糖。 传统意义上的老冰糖，买的时候是一大块，有白色的，也有淡黄色的，有的里面含有白线，那样的并不是假的。不管是什么颜色的，多晶冰糖都有很好的食疗效果。 淡黄色的多晶冰糖，工艺复杂、成本高，如果买的时候价格比较低，尽量别买。希望上面介绍的，能够帮助到大家。 单晶冰糖 单晶冰糖就是将白砂糖溶于水中，水温控制在80°左右，然后降温、结晶，大概7天后成型，最后用机器切割成小块。这种结晶就是最简单的物理变化，整体而言，单晶冰糖在营养上来说和白砂糖没有什么区别，只是甜度和颜色的纯度大了一点。大家平时买到的冰糖，就是这种单晶冰糖。这里强调一下，单晶冰糖并不是传统意义上的冰糖，不具备传统冰糖的食疗功效。 单晶冰糖是由砂糖提纯溶解后结晶而成，呈单晶体状 （构成整个晶体的各种离子或原子全都是按照一定的方向和顺序排列的叫单晶体。如果由多个单晶体混乱地结合在一起，晶体之间有明显的界限，这样的晶体就叫多晶体）。 单晶冰糖又称单晶体冰糖，根据颜色分为白单晶冰糖和黄单晶冰糖。 多晶冰糖 多晶冰糖的做法，整体来说比较复杂。白砂糖溶于水中，水的温度要加热到110-120°左右，然后冷却结晶。多晶冰糖最传统的做法，就是利用白线结晶，不知大家注意到没有，有时买来的冰糖，里面会有一根根白线，有的人认为买到了假冰糖，其实不是，传统的多晶冰糖就是加入了白线进行结晶。多晶冰糖做好后，是那种一大块的状态，买回来后需要用工具将它敲开来食用。这里强调一点，多晶冰糖才是传统意义上的冰糖，具有极好的食疗效果。 多晶冰糖在有些地方，也被老辈人称为老冰糖。但是它并不是仅仅只有一种颜色，除了上面说的白色多晶冰糖外，还有颜色为淡黄色的多晶冰糖。有些人认为这种冰糖是用红糖制作的，其实不对，关键原因那还是制作工艺的不同。上面说到的白色多晶冰糖，一般是“一水”或者“二水”熬制结晶，就是说熬制结晶一到两次，而经过三到四次的熬制，冰糖就会变成淡黄色的了。淡黄色的多晶冰糖，是最有营养的冰糖，老工艺做出来的冰糖都是这种。不过现在市面上的黄冰糖很少，很多厂家都是直接在白冰糖里加色素。买的时候可以看价格，价格低的黄冰糖，最好不要买。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/眼镜.html":{"url":"docs/commonsense/眼镜.html","title":"眼镜","keywords":"","body":"眼镜 镜片品牌 镜片膜层 镜片折射率 镜片材质分类 镜片品牌 一，依视路（Essilor） 二，蔡司（Zeiss） 三，豪雅（Hoya） 四，罗敦司得（Rodenstock） 五，精工（Seiko） 六，凯米(Chemilens) 1 Carl Zeiss 卡尔·蔡司（德国） 2 Rodenstock 罗敦司得（德国） 3 HOYA 豪雅（日本） 4 Essilor 依视路（法国） 5 Nikon 尼康（日本） 6 CHEMI 凯米（韩国） 7 Conant 康耐特 8 明月光学（中国） 9 WX 万新（中国） 10 Pulais 普莱斯 一线：蔡司，罗敦司得，尼康，豪雅（价格RMB1000+） 二线：依视路（推荐依视路钻晶A3或A4，八九百左右），凯米（据说是韩国第一的品牌，不知道算几线，暂且放这里） 三线：国产品牌。出货量最大的是明月和万新（RMB100-200+） 浅谈六大镜片品牌的差异眼镜镜片什么牌子好？10大镜片品牌排行榜 最实用配眼镜攻略：如何选近视镜片？99%的人都被坑过 镜片膜层 膜层，是对眼镜片表面多层光学薄膜的总称。镜片为了获得一些新的、原本不具备的优良性能，在眼镜片的表面用物理和化学的方法，镀上一定厚度的单层或多层光学薄膜。 镜片膜层 镜片关注点之膜层 网上配镜之镜片膜层全解析 镜片折射率 镜片折射率，镜片上标的1.49、1.56、1.60、1.67、1.71、1.74指的就是镜片的折射率，对于近视配镜来说，在其他参数相同的前提下，镜片折射率越高，镜片的边缘厚度越低薄。 目前市面上主流的镜片折射率有：1.56、1.60、1.67、1.71、1.74等几种。 在选购镜片的时候，并非是折射率越高越好，镜片越薄越好。 反而折射率越高的镜片，阿贝数越低，透过镜片看东西也越不清晰。 有的眼镜店因为折射率高的镜片价格贵，利润高，所以不停的给用户推销，这是非常不可取的。 400度以下选购1.56的折射率就可以了，400度以上根据个人需求可以选购1.60或1.67的。 选择适合自己的镜片才是最好的，贵并非唯一选择标准。 镜片折射率配眼镜时候的镜片折射率到底是什么？选哪个才合适？不同度数的近视如何选择镜片折射率？ 镜片材质分类 市场上常见的镜片按照材质大体分为玻璃片、树脂片、PC片等。 目前，市面上常见的镜片材质有玻璃、PC、树脂三种。 镜片材料分类 眼镜镜片都有哪些主流材料？怎么选？ 请问眼镜片什么材质的好？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/运动健身.html":{"url":"docs/commonsense/运动健身.html","title":"运动健身","keywords":"","body":"运动健身 有氧运动和无氧运动 热量的计量单位和换算 常用的食品的热量 体脂秤的原理 手表和手机记步数原理 心率监测原理 小米手环是用什么原理来测试步数的 跑步的配速 运动健康锻炼减肥健身知识 有氧运动和无氧运动 有氧运动 有氧运动是指人体在氧气充分供应的情况下进行的体育锻炼。即在运动过程中，人体吸入的氧气与需求相等，达到生理上的平衡状态。 简单说，是指富韵律性的运动，运动时长约15分钟及以上，中等及中上运动强度(最大运动心率值在60%至80%之间)。 特点是强度低、节奏感强、持续时间较长，要求每次锻炼的时间不少于30分钟，每周坚持3到5次。比如：快走、慢跑、长距离慢速游泳等。 运动强度比较低时，耗能也小，氧气有时间被输送到组织细胞中，身体内的「燃料」得到了充分的氧化「燃烧」，满足运动的能量需要，这样的运动就是有氧运动。 低强度、能长时间进行的运动，基本上都是有氧运动，比如：快走、慢跑、长距离慢速游泳、慢骑自行车等。 有氧运动需要大量呼吸空气，对心、肺是很好的锻炼，可以增强肺活量和心脏功能。 无氧运动 是指肌肉在\"缺氧\"的状态下高速剧烈的运动。大部分是负荷强度高、瞬间性强的运动，所以很难持续长时间，而且疲劳消除的时间也慢。 因为当我们从事的运动非常剧烈或者是急速爆发时，例如举重、百米冲刺、摔跤等，机体在瞬间需要大量的能量，而在正常情况下，有氧代谢是不能满足身体此时的需求的，于是糖就进行无氧代谢，以迅速产生大量能量。这种状态下的运动就是无氧运动。 而当人们在做剧烈的运动时，比如 100 米跑，10 多秒钟就已经跑过了终点，而起跑时吸的那口氧气，却根本还来不及到达细胞当中去参加「燃烧」的活动。也就是说，氧气还没有起作用，而运动就已经结束了。 人在利用氧气的过程中，有一个相当大的时间差，这个时间差决定了剧烈的、短时间的运动，成为了无氧运动。比如 100 米短跑，200 米短跑，100 米游泳，举重等都是无氧运动。 有氧无氧怎么选择？ 没有哪一个运动适合所有人。具体哪种运动方案适合你，还要根据自己的情况来定。这些具体情况包括：年龄、体质、运动基础、体型目标、有无疾病等。 比如，没有运动基础的人刚开始运动，可以从有氧运动开始，提高心肺功能，增强体能，然后再加上无氧训练。 有些人天生偏瘦，想强壮肌肉、健美体形，那么应该以无氧训练为主。反之，有些人是「肌肉体质」，很容易就长肌肉，如果想瘦身，那么应该以有氧训练为主。 2 型糖尿病患者、肥胖症患者以及脂肪肝患者，以及年龄大的人，应该以有氧运动为主。预防骨质疏松、骨质软化，那么应当做无氧运动为主。 如果你时间充裕，那么最好的是无氧与有氧都做（一般建议先无氧再有氧），收获两种运动的好处。如果你工作生活繁忙，运动时间有限，那么你也可以把有氧无氧结合起来，做高强间歇运动（HIIT， High Intensity Interval Training），减脂塑形的效果非常好。 有氧运动和无氧运动有哪些区别？有氧运动VS无氧运动，哪个更易减脂？无氧运动 热量的计量单位和换算 能量的单位是焦耳，简称焦(J)，1000焦=1千焦(KJ)。 日常摄入热量的单位一般用“卡路里”来计算，简称卡，1千卡=1000卡（也称为1大卡）。 千焦和千卡的换算关系是：1千焦=238.9卡，1 大卡（千卡）=4.18千焦（KJ），一般千焦换算成大卡可以直接除以4.18来计算。 1卡=1卡路里=4.184焦耳； 1千卡=1大卡=1000卡=1000卡路里 =4184焦耳=4.184千焦。 卡路里 (简称“卡”，缩写为\"calorie\")的定义为将1克水在1大气压下提升1摄氏度所需要的热量。 1千卡等于1000卡路里，约4184焦耳. 脂肪的热量约900大卡每百克；糖类和蛋白质的热量都只有400大卡每百克。 这里建议全部把单位换算成大卡（千卡），方便计算。 平时我们所使用的加工食物，都有标注热量，其实很好计算，以低脂牛奶为例，100ml的能量是182千焦，所以一瓶250ml的牛奶，热量是：182KJ/100ML×2.5=455KJ，455÷4.18=109大卡。 掌握了这个计算公式之后，一些有标注热量的包装食品就可以计算出来了。 常用的食品的热量 另外，还有一些没有标注出来的日常常用食品的热量我也整理如下： 主食类： 米饭：116大卡/100g，每100克米饭含碳水化合物25.86克，脂肪0.33克，蛋白质2.6克 肉类： 鸡蛋：147大卡/100g，每100克鸡蛋含碳水化合物0.77克，脂肪9.94克，蛋白质12.58克 猪肉热量：271大卡/100g，每100克猪肉含碳水化合物0克，脂肪17.04克，蛋白质27.34克 牛肉热量：288大卡/100g，每100克牛肉含碳水化合物0克，脂肪19.54克，蛋白质26.33克 鸡肉热量：188大卡/100g，每100克鸡含碳水化合物0克，脂肪7.35克，蛋白质28.69克 鸡胸肉：133大卡/100g 果蔬类（大卡/每100克）： 蔬菜：苦瓜19、黄瓜15、韭菜26、菠菜24、茄子21、西红树19、西蓝花38 水果：苹果50、橙48、梨45、奇异果30、番茄35、西瓜31、芒果35 高热量水果：香蕉115、椰子241、牛油果171、榴莲150、荔枝桂圆71 饮料类（大卡/每100毫升）： 纯净水/矿泉水0、茶水1、美式咖啡2、拿铁咖啡110、摩卡咖啡180、速溶咖啡115、可乐43、奶茶65、柠檬汁27、红酒96、啤酒32 零食类（大卡/每100克）： 巧克力589、饼干433、方便面436、薯片547、牛奶糖433、奶油蛋糕344 卡路里、千焦、大卡傻傻分不清楚？关于热量看这一篇就够了 体脂秤的原理 健身房的体成分测量仪，使用的方法属于“生物电阻抗法”。瘦体重和脂肪的含水率不同，电阻也不一样，通过测量电极之间的电阻率，可以计算出体成分的大致数据。 人体因为含有大量水分，所以是可以导电的（人体内的水含有电解质，所以是可以导电的，一堆说水不能导电的朋友不知道非要杠个啥）。 但是又因为人体各部分含水量不同，所以导电率也是不同的，导电率不同即电阻率不同。 当人站在体脂秤上时，体脂秤会通过电极片/导电膜发出人体无感知的微弱电流，流经人体，从一只脚到另一只脚，这样就形成了一个闭合的回路，这个过程体脂秤就可以获取到人体不同部分的电阻率，体脂秤拿着这些数据，通过其BIA芯片内设的算法模型，就可以大致估算出人体各个部分的含量。 目前市面上的家用体脂秤一般都是用“生物电阻抗分析法（BIA）”技术来实现测脂，脂肪不导电，肌肉含水分多，导电性好，通过两点间电流和电压的变化，测算电阻，阻力越高，脂肪含量越高。为了能精确测量人体数据，小米体脂秤采用了304L不锈钢金属电极，通过脚部皮肤充分接触电极片后才可精准获取数据。不过我感觉这些数据也是只能作为参考的，因为我发现穿不同的衣服，结果是不一样的。 小米体脂称的原理，这个就专业了，小编需要去看看厂家说明书。 目前市面上的体脂称都是使用人体分成仪等测料工具的测量方法，而小米使用的是BIA生物电子抗测量法。具体的原理就是让体脂称上面的电极片发出小电流，人裸露脚底板，踩到电极片上，进行通电，整体形成一个闭环。然后通过肌肉容易导电，但是脂肪不容易导电的方法原理，得到一些数值，这个数值就是电阻数值，系统就可以根据这些数值计算出体质量，脂肪率等等数据 体脂秤的原理是什么？体脂秤到底是不是智商税？测完8款告诉你答案人体脂肪秤 手表和手机记步数原理 腕带测距离是依照身高（推估步长）X手腕震动次数，所以这两项的误差值很大步长X次数=距离 2.腕带测距离运动量是依照体重X心率X距离去换算个人体重X心率X距离 去算运动时的卡路里的消耗 (1)体重原理距离和运动量每70公斤时一般步行或运动在心跳100以下每一公里约消耗70卡路里 (2)但心跳到140甚至180时，代表是高耗能的运动，也和每人的体质以及体型有关，消耗的卡路里可以高达80-90卡路里所以和心跳有极大的关系 工作原理是工作核心就是震动传感器,一般根据传感器的形式可分为2D计步器和 3D 计步器. 按功能分又可以分为单功能计步器, 计步器手表, 脂肪测量计步器等等.手 手表有六轴传感器,可以识别走路,跑步,爬楼梯,站立这些运动状态. 心率监测原理 心率监测原理是，人的心跳会造成血管的扩张和收缩，这款手环就通过背部凸起处发射的两颗绿色LED光源（之所以使用绿色，是因为科学研究发现绿色光源可以产生最有效的监测心率的波长）对皮下血管的血液流量来监测心率跳动。 小米手环是用什么原理来测试步数的 硬件是指小米手环里内置的那枚强悍的三轴加速度传感器ADXL362，军用级，大家知道想要达到军用级，这得有多苛刻。 其实三轴加速度传感器不神秘，在大多数中高档手机里都有配备加速度传感器，只是在侦测精度上达不到到小米手环的级别。 三轴加速度传感器的三轴是指空间中的X,Y,Z三个维度，有了这3个维度，手环就可以捕捉到手环在使用中的加速度变化，从而生成数据。 跑步的配速 配速是指每公里所需的时间。 跑步机一般用“时速”，也就是每小时跑多少公里。时速10公里/小时，换成配速就是6分钟/公里。 速度越快，单位时间内消耗脂肪自然是越多的，但速度快难以持久，所以长时间的慢跑在燃脂总量上还是会更多。 所以跑步机上的“时速”就是60分/配速，就是每公里所需要的分钟数 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/常见的游戏.html":{"url":"docs/commonsense/Game/常见的游戏.html","title":"常见的游戏","keywords":"","body":"常见的游戏 英雄联盟LOL 王者荣耀 魔兽争霸 魔兽世界WoW DOTA 传奇（世界） 诛仙 魔域 劲舞团AU/QQ炫舞 跑跑卡丁车/QQ飞车 CS反恐精英/CF穿越火线 红警 DNF地下城与勇士 大话西游 梦幻西游 暴力摩托 QQ华夏 问道 梦幻西游 梦三国 泡泡堂 逆水寒 原神 逆战 三国杀 绝地求生/和平精英 永恒之塔 冒险岛Online 使命召唤 炉石传说 守望先锋 刺客信条 我的世界 极品飞车 windows xp 自带游戏： 扫雷、纸牌、三维弹球、空当接龙、红心大战和 网络小游戏翻转棋、黑桃王、红心大战、跳棋、双陆棋 俄罗斯方块 扫雷 超级马里奥 红警 拳皇 魂斗罗 劲舞团AU/QQ炫舞 葬爱家族、杀马特 杀马特，是2000年代出现在中国大陆的一种次文化，流行于城市移民青年。这个词从英文单词“smart”音译。 外观上受哥德次文化或视觉系影响，以夸张的发型为主要特点。 《外交政策》网站分析认为，这一群体缺乏高等教育，在城市中从事收入不高的工作，其外形表达了他们对城市的疏离感。 葬爱家族，网络词语，葬爱家族是《劲舞团》中传出来的“网络组织”，好多玩家以杀马特造型示人，造型夸张，喜欢斗舞，并组成一个群体接纳另一个她(他)。现在大多指发型夸张，打扮狰狞且特立独行的反潮流的洗剪吹人士。 释义：葬，即埋葬，爱，即爱情，属网络用语，也指代一个梗。 流行语 高端大气上档次，低调奢华有内涵，奔放洋气有深度，简约时尚国际范，低端粗俗甩节操，土憋矫情无下限，装模作样绿茶婊，外猛内柔女汉子，卖萌嘟嘴剪刀手，忧郁深沉无所谓，狂拽帅气吊炸天，冷艳高贵接地气，时尚亮丽小清新，可爱乡村非主流，贵族王朝杀马特。 提及“杀马特”、“肥猪流”等，很多人都认为这些造型夸张、衣着奇特的年轻人是受到日韩文化的影响。这话有对有不对。首先要从外国寻找模仿对象，最合适的应该是日本的“视觉系”人群，和韩国并没有关系。确实，如果到日本东京的涩谷、原宿等地，也可以看到和“杀马特”有一定类似的，染着红红绿绿的头发、衣着夸张、化妆惊悚的年轻人，大部分都在从事街头音乐表演活动，但是很难说这些人和中国的“杀马特”们存在严格的“继承”关系。 杀马特遇见洗剪吹 在杀马特以一种哗众取宠的方式出现后，又有一批人在用自己的方式嘲讽他们。而其中较有代表性的当属2013年五色石南叶 改编翻唱的《杀马特遇见洗剪吹》，原曲为韩国组合SHINee的《Ring Ding Dong》。其中出现了王老吉，金坷垃等词语和多首流行歌曲的歌词。在网络上一夜爆红之后，网友们纷纷发挥创意想象，制作出各种逆天神作。 同时走红的还有洗剪吹遇见焗染烫。 「杀马特」亚文化是如何形成的？ 朋克文化 朋克（Punk），又译为庞克，诞生于七十年代中期，一种源于六十年代车库摇滚和前朋克摇滚的简单摇滚乐。它是最原始的摇滚乐——由一个简单悦耳的主旋律和三个和弦组成，经过演变，朋克已经逐渐脱离摇滚，成为一种独立的音乐。朋克音乐不太讲究音乐技巧，更加倾向于思想解放和反主流的尖锐立场，这种初衷在二十世纪七十年代特定的历史背景下在英美两国都得到了积极效仿，最终形成了朋克运动。同时，朋克音乐在年轻人中十分流行，为世界多地青年所喜爱。 亚文化/次文化 亚文化又称集体文化或副文化，指与主文化相对应的那些非主流的、局部的文化现象，指在主文化或综合文化的背景下，属于某一区域或某个集体所特有的观念和生活方式，一种亚文化不仅包含着与主文化相通的价值与观念，也有属于自己的独特的价值与观念。 现代次文化 御宅族 资深ACGN爱好者的泛称，由于ACGN不为主流文化接受，故该族群常为大众误解。 火星文 为网民发明的符号字体，用于减省字数及笔划，本意是提高输入速度。 Brony 美国动画《彩虹小马》爱好者，一般不属于ACG范围内，其分布之广泛足以形成一种次文化。 兽迷 是指受到欧美国家的卡通文化之影响，喜好具有人格或其他人类特质的拟人化动物之虚构角色的一群人。 四平青年 四平青年为原四平市人民剧场经理李平执导的网络电影，该片讲述了“二龙湖浩哥”等几位青年原本去寻仇，却因为一名舞女而忘记寻仇，并参与黑社会的打斗。该片因为剧情幽默以及参演人员被辞退而引起广泛关注。 《二龙湖浩哥》是《四平青年》系列电影的第一部，该片由张浩执导，张浩、蓝波领衔主演。 《四平青年》作为一部史诗乡村电影，讲了这样一个故事，一个叫做二龙湖浩哥的四平郊县青年带着几个兄弟在玉米地里骑摩托，本来是去找人寻仇，但是在路上偶遇一个漂亮姑娘，由此忘记了寻仇，开始到四平市区寻找这个路上遇到过的姑娘，进而被卷入一场不太上档次的“帮派混战”中。 《四平青年》剧中所有演职人员都是吉林省四平市人民剧场外聘的一些跑场二人转演员及职工，不是人民剧场有事业编制的正式职工。 辞退事件 2012年11月，四平市文化广电新闻出版局以“对四平市产生负面影响”为由，要求四平市人民剧场辞退该片演员，并删除网上视频，后该片演员被辞退，而影片在网上得以保留。 绝地求生/和平精英 《绝地求生》(PUBG) 是由韩国Krafton工作室开发的一款战术竞技型射击类沙盒游戏 在该游戏中，玩家需要在游戏地图上收集各种资源，并在不断缩小的安全区域内对抗其他玩家，让自己生存到最后 《和平精英》的前身为《绝地求生：刺激战场》，当时与《绝地求生》存在合作关系。直到2019年5月8日，《绝地求生：刺激战场》宣布停服，《和平精英》正式发行。 吃鸡游戏 首先这叫大逃杀游戏，那为什么要叫吃鸡呢？因为pubg里面，最后的胜利中文叫大吉大利，今晚吃鸡。受到这个影响大家就开始叫吃鸡游戏了。这种类型的游戏核心就是，在众多玩家活下来，成为唯一的幸存者。（也不是所有游戏都是最后一个，比如某雪地逃杀就是最后三个上飞机的玩家。） 吃鸡是指在游戏 绝地求生大逃杀 中取得第一因为赢得第一之后，界面会显示八个大字“大吉大利，今晚吃鸡！”这其实是“Winner winner, chicken dinner!”的中文翻译，感觉很直译。。但是官方就是这么翻译的因此，很多玩家，主播就开始用“吃鸡”来称呼此游戏。 传说很早之前在拉斯维加斯的赌场中有一种包含三块鸡肉和土豆蔬菜的饭，价值$1.79。而当时的标准赌注是2美元，对于那些落魄的赌徒来说，赢下一场，就能够吃\"鸡肉晚餐\"了。所以Winner Winner Chicken Dinner，这就是胜利的欢呼声。 在游戏中，如果最终获得了第一名，会显示“Winner Winner, Chicken Dinner”的字样，该句台词是美国赌场中赌徒的常用语，相传是指赌赢一把，晚上就可以享用鸡肉晚餐了； 另说这句话可能起源于英国伦敦暗巷赌徒的俚语，传至澳洲后，一些上年纪的澳洲人会用“Chicken Dinner”来代替“Winner”。 无论来源是美国或英国，这句话的盛行与电影《决胜21点》息息相关，该部电影带起了全世界对于此句台词的热潮，电影中文版译为“大吉大利，晚上吃鸡”，《绝地求生》简体中文版沿用了这一翻译，“吃鸡”也成为《绝地求生》在华人玩家中的代名词 嗯一百个人被丢在一块大陆(岛屿)上，然后游戏范围不断缩小强迫你争夺最后的生存名额，成功作为最后一个存活下来的人屏幕上的庆贺是“WinnerWinnerChickenDinner”，翻译过来就是“大吉大利今晚吃鸡”。 《绝地求生：大逃杀》是一款大逃杀类型的游戏，每一局游戏将有100名玩家参与，他们将被投放在绝地岛(battlegrounds)的上空，游戏开始跳伞时所有人都一无所有。相信很多普通玩家在游戏中拿第一肯定是少有的事情，因此关于“吃鸡”梗更多的是从直播间们主播的口头禅中听来的。要论究该词最早的出处在哪的话，其实更早源于电影《决胜21点》中的一段台词，英文版第一台词winner winner,chicken dinner，来自拉斯维加斯赌场。因为几十年前，赌钱最低赢一把能赚2刀，一份鸡肉饭是1.75刀，因此该词常常成为当时求好运的一个说法。 使命召唤 《使命召唤》（英语：Call of Duty）是一款以二战为背景的第一人称射击游戏，采用了强化过的重返德军总部之游戏引擎（即再次强化过的雷神之锤III引擎）。这款游戏模拟了盟军士兵在二战时的作战情形。 《使命召唤》的独特之处在于单人故事中玩家并非如当时其他FPS的主角一般孤军作战，游戏过程中大部分时间均有大量的NPC队友支持。同时队友之间的互动亦给予玩家一种投入感，而这点亦成为往后续作的卖点之一。而另外一大卖点就是游戏里时常出现的对好莱坞战争大片场面的致敬。 《使命召唤》的发售时间为2003年10月29日，开发工作由Infinity Ward进行，并由Activision负责出版。Mac OS X版的使命召唤由Aspyr进行移植。 使命召唤系列（英语：Call of Duty，香港和台湾译作“决胜时刻”，缩写为COD），是由美国动视所推出的一系列第一人称射击游戏（FPS）。 Infinity Ward（简称IW）是一家电子游戏和电脑游戏的开发商，位于加利福尼亚州的洛杉矶。Infinity Ward成立于2002年，由原本是开发《荣誉勋章：联合袭击》（Medal of Honor: Allied Assault）的开发商2015公司的员工组成。2003年，美国动视（Activision）公司成功收购了IW，成为了美国动视的子公司。其代表作为使命召唤系列。 守望先锋 《守望先锋》（英语：Overwatch，香港和台湾译作“斗阵特攻”），也常简称为守望，是一款由暴雪娱乐开发并发行的多人第一人称射击游戏，于2016年5月24日在Microsoft Windows、PlayStation 4和Xbox One平台发行，后于2019年10月15日在任天堂Switch平台发行。 《守望先锋》把玩家分为两支队伍，每队1-6人[注 1]。不同模式有不同的队伍人数。玩家可从几个预定英雄人物中选择，每个英雄有自己独特属性和技能；这些英雄分为三类：输出型、重装型和支援型。队员合力保护并捍卫地图上的控制点，或在有限时间内护送载具到达指定地点。 玩家获得的诸如人物造型或胜利姿势等个性装扮不会影响游戏平衡。只会影响外观。 刺客信条 《刺客信条》（英语：Assassin's Creed）是由育碧公司的蒙特利尔工作室开发的一款第三人称隐蔽类游戏，本系列始于2007年11月在PlayStation 3和Xbox 360上发行。Windows平台版本则于2008年4月在北美发行。 《刺客信条》（英语：Assassin's Creed，台港译《刺客教条》）是一部2016年美国动作冒险片，由贾斯汀·克佐执导，比尔·克尔吉、亚当·库珀与迈克尔·莱斯利编剧。改编自育碧软件开发的游戏《刺客信条系列》，且电影与游戏存在于共同宇宙中。由迈克尔·法斯宾德、玛丽昂·歌迪亚、杰里米·艾恩斯、布兰顿·葛利森、夏洛特·兰普林与迈克尔·K·威廉姆斯主演。 拍摄开始于2015年8月末，并定于2016年12月21日在北美上映。 我的世界 《我的世界》（英语：Minecraft）是微软旗下Mojang Studios开发的沙盒游戏。游戏中，玩家可以在一个3D世界内与方块进行交互。游戏中的特色功能包括探索世界、采集资源、合成物品及生存冒险等。《我的世界》有多种模式：生存模式中玩家必须维持生命并采集资源以打造自己的世界；创造模式中玩家拥有无限的资源并可自由地创作建筑；而冒险模式中玩家可在其他玩家定制的地图中游玩。 《我的世界》最初由瑞典游戏设计师马库斯·佩尔松开发，之后由其成立的Mojang Studios开发，主机版则与4J Studios合作开发。游戏最初使用Java编写，其Alpha版本在2010年6月30日公开发布，经逐步更新之后正式版本1.0.0在于2011年11月18日发布。Android版和iOS版分别于2011年10月7日及11月17日发售。 《我的世界》获得业界的一致好评，赢得众多奖项和荣誉。游戏的Java版以其强大的第三方拓展模组而知名，它们可以为游戏添加各种新的对象、角色和功能。2014年9月，微软公司宣布以25亿美金收购Mojang及游戏的知识产权，收购于两个月后完成。2016年5月，网易宣布代理《我的世界》中国版[14]，2017年8月开启公测[15]。 截至2021年5月，《我的世界》拥有2.38亿销量，1.4亿月活跃用户[16]，并和ROBLOX机器方块的模仿游戏不相上下[17]，为有史以来最畅销的电子游戏。 极品飞车 极品飞车（英语：Need for Speed，香港和台湾译作“极速快感”，简称“NFS”），是艺电推出的一系列赛车游戏，包括PC、GBA、PSP、NDS、PSVita、PlayStation、Xbox、Wii、iPhone、iPad、Android及其它各游戏机版本。玩家可在不同赛道与不同车辆竞赛，甚至在某些版本里可以与警车进行追逐。是较为经典的一款游戏。目前极品飞车系列游戏的全球出货量已达到1.5亿套，为全球最畅销的赛车游戏系列。 《极品飞车》系列最初是由加拿大温哥华的游戏公司Distinctive Software所开发。在美商艺电于1991年将其收购之前，该小组已经制作了Stunts和Test Drive II: The Duel等受欢迎的赛车游戏。 公司被收购之后改名为EA Canada。凭借着在该领域的经验，该公司于1992年开始开发《极品飞车》系列。2005年的大作《全民公敌》已成为大家所知的知名赛车游戏。而后，极品飞车也成为电视游乐器线上玩家最喜欢玩的游戏，并且玩家常在线上跟两名以上玩家竞速。 逆水寒 《逆水寒》是由杭州网易雷火科技有限公司开发的一款武侠题材电脑客户端游戏，属大型多人在线角色扮演游戏，该作于2018年6月29日开启不限号不删档内测。 《逆水寒》以温瑞安《四大名捕》、《说英雄谁是英雄》、《神州奇侠》三大系列小说为游戏背景，讲述北宋末年一段惨烈的大追捕，并牵扯出江湖恩怨、朝堂纷争、帮派仇杀、感情纠葛、市井百态等北宋生活画卷。 原神 游戏发生在一个被称作“提瓦特”的幻想世界，在这里，被神选中的人将被授予“神之眼”，导引元素之力。玩家将扮演一位名为“旅行者”的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘“原神”的真相 [6] 。 跑跑卡丁车/QQ飞车 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/游戏公司.html":{"url":"docs/commonsense/Game/游戏公司.html","title":"游戏公司","keywords":"","body":"游戏公司 任天堂 Blizzard暴雪 艺电EA 育碧SA 任天堂 任天堂（日语：任天堂／にんてんどう Nintendō */?）是一家主要从事电子游戏和玩具的开发、制造与发行的日本公司。于1889年在日本京都创立，至今公司总部仍设于京都。 Blizzard暴雪 美国动视（Activision） 动视暴雪（Activision Blizzard） Infinity Ward 暴雪被纳入维旺迪旗下子公司维旺迪游戏 2003年，美国动视（Activision）公司成功收购了IW 2008年维旺迪游戏与动视合并，暴雪更名动视暴雪。 动视暴雪公司（英语：Activision Blizzard, Inc.）是由动视合并维旺迪游戏后更名而来的控股公司，是一家美国电子游戏开发商、发行商和经销商。 2009年，动视暴雪成为世界上收入仅次于任天堂的第二大游戏公司。其著名游戏包括动视旗下的《使命召唤系列》、《托尼·霍克系列》、《宝贝龙世界系列》等等，以及暴雪旗下的《魔兽世界》、《星际争霸系列》、《暗黑破坏神系列》等等。 2008年7月9日动视与维旺迪游戏合并成立新的动视暴雪公司。2013年7月25日，动视暴雪宣布从维旺迪所有人手中购买价值23.4亿美元的4.29亿股票，使得动视暴雪成为独立公司。 1994年发行商戴维森合伙公司收购暴雪娱乐，之后四年又发生连串收购、并购，暴雪最后纳入维旺迪旗下子公司维旺迪游戏。2008年维旺迪游戏与动视合并，暴雪更名动视暴雪。2013年动视暴雪恢复独立公司地位后没有改名，暴雪娱乐即便在子公司期间也始终保持独立经营 暴雪娱乐现在是美国电子游戏发行商动视暴雪的部门。 暴雪娱乐公司的产品出品的游戏虽然不多，但是多数较受欢迎。其中，如魔兽争霸、星际争霸、暗黑破坏神等游戏受到玩家好评，并被多个电子竞技赛事列为比赛项目。 Infinity Ward（简称IW）是一家电子游戏和电脑游戏的开发商，位于加利福尼亚州的洛杉矶。Infinity Ward成立于2002年，由原本是开发《荣誉勋章：联合袭击》（Medal of Honor: Allied Assault）的开发商2015公司的员工组成。2003年，美国动视（Activision）公司成功收购了IW，成为了美国动视的子公司。其代表作为使命召唤系列。 艺电EA 艺电（英语：Electronic Arts，台湾译作“美商艺电”，简称“EA”，曾用译名“电子艺界”）是美国一家跨国性的互动娱乐软件制作与发行公司，由特里普·霍金斯于1982年5月28日创立，总部位于美国加利福尼亚州的红木城，在美国、加拿大、英国、澳大利亚、中国等地区均设有分公司或子公司，世界各地雇员总数超过9700人。主要进行电脑游戏、游戏机游戏、网络游戏、手机游戏等的开发、出版以及销售业务活动。 育碧SA 育碧娱乐公司（英语：Ubisoft Entertainment SA），2003年前名为“育碧娱乐软件”（Ubi Soft Entertainment Software），简称“育碧”（Ubisoft），是一家总部设于法国雷恩[6]的电子游戏开发商和发行商，1986年成立。育碧在全世界拥有23间游戏开发工作室，是2008年欧洲第三大独立游戏开发商、北美第四大独立游戏出版商。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/游戏名词.html":{"url":"docs/commonsense/Game/游戏名词.html","title":"游戏名词","keywords":"","body":"游戏名词 游戏术语 游戏类型 游戏平台 游戏公司 MVP和SVP KDA MVP和SVP MVP是胜利方评分最高，SVP是失败方评分最高。 MVP的全称为Most Valuable Player，意思是全场最佳玩家。代表胜利方评分最高，最有价值的玩家。 SVP是Second Valuable Player 或者Smallest Valuable Player 的简称，代表失败方评分最高，第二有价值的玩家。 SVP的全称是Second Valuable Player Award或者Smallest Valuable Player Award，意思分别是全场第二有价值的玩家或者废物。 MVP：most最 valuable有价值的 Player玩家 SVP：Second第二 valuable有价值的 Player玩家 KDA kDa指的是KILL DEATH ASSIST（杀人率，死亡率，支援率），平常以KD RATIO（KDR）表示杀人率和死亡率的比率。出自游戏《DotA》《英雄联盟》《反恐精英》《王者荣耀》以及《风暴英雄》。 一般公式是（杀人数+助攻数）/死亡数； (若死亡数为0则默认 为1)。 在dota2中为（K+A）/ D。 在CSGO中虽然有KILL DEATH ASSIST,但是计算时只计算K/D（即杀人数/死亡数）。 在彩虹六号中杀人数为【杀人数/死亡数】 在彩虹六号围攻中助攻不算入KDA计算，KD_0.4结算。 游戏术语 开黑：开黑是一个游戏用语，是指玩游戏时，可以语音或者面对面交流。 NPC：非玩家角色（Non-Player Character）的简称，指游戏中非玩家控制的角色。NPC可以是主角的协助者、敌对者或群众角色。 HP、MP：生命值、魔法值 红蓝：红一般形象地指代游戏人物的生命值，蓝则指魔法值。有的游戏中红也可表示能恢复生命值的药水，蓝表示能回复魔法值的药水。 【Buff】主要指辅助类角色为别人施加的有益状态，通俗的说法就是“加状态” 【SOLO】单独杀怪、做任务等 【CD】技能冷却时间 +++：加加血的简写 奶妈：可以加血的职业，一般被称作奶妈（男角色即奶爸），奶我，奶我 二奶：辅助加血，并非主力加血的就叫二奶 打手：专门对怪物输出伤害的叫打手 BB：宝宝，即游戏中的宠物，或者召唤类傀儡 DPS：每秒输出的伤害量 AFK：暂离 MT：main tank的缩写，主坦克，指专门承受怪物伤害的人，一般是高血高防御 宕机：游戏服务器停机，或者重启。也写作“当机” 掉线：无法连接上游戏服务器 更新：游戏版本的升级，或者游戏内容的增加及修改，一律被称之为更新 回档：服务器回到开机前某一时段，玩家的数据也回到那时。 密：或“M”，着急的时候可作“MMM……”指玩家与另一名玩家单独聊天，第三个看不到聊天内容。即私聊 秒杀：概念量词，一般只在第一时间，以最快的速度，一招之内杀死对方(或击败) 群秒：同秒杀一样 只是杀低数量上增加 叫群秒 达人：非常厉害的人，也可称作强人、牛人 跳票：未按预告时间推出游戏 骨灰：形容非常资深，非常专业的玩家。 小白：新手，初学者，骨灰的反义词。 菜鸟：游戏水平不高的玩家，比小白稍微好那么一点点。 人品问题：“运气不好”的幽默表达方式，可缩写为RPWT。 BOSS：非常强大的怪物，一般是一群怪物的首领，被形象地称为BOSS。BOSS会提供相当多的经验和非常好的装备。 刷新：怪物被杀死后，过了一段时间系统再次生成一个怪物，这就叫刷新。 神器：极珍稀的游戏道具就叫神器。 游戏术语表 电子游戏术语列表菜鸟扫盲贴：这些常见游戏术语你知道多少？ 游戏类型 游戏分类游戏分类大赏电子游戏类型游戏类型 MOBA和FPS/ACT无论是计算（CPU）还是渲染（GPU） MMORPG游戏 大型多人在线角色扮演游戏（英语：massively multiplayer online role-playing game，缩写：MMORPG）为电子游戏的一种，是电子角色扮演游戏按电子游戏人数分类分别出来的一种网络游戏。 在所有MMORPG中，玩家都可扮演一个或多个虚拟角色，并控制该角色的在游戏中虚拟世界的活动与行为。 大型多人在线角色扮演游戏与单机游戏（例如三国志、魔兽争霸系列）和其他小型的、由多人参加的角色扮演游戏（例如反恐精英）的区别在于： 大型多人在线角色扮演游戏具有一个持续运行的虚拟世界，玩家离开游戏之后，这个虚拟世界仍在网络游戏运营商提供的主机服务器里继续存在，并且不断演进，直至游戏终止运作。 RTS游戏 即时战略游戏（Real-Time Strategy Game），简称RTS。游戏是策略游戏（Strategy Game）的一种。游戏是即时进行的，而不是策略游戏多见的回合制。另外玩家在游戏中经常会扮演将军，进行调兵遣将这种宏观操作。 即时战略（英语：Real-time Strategy，简称RTS）游戏是战略游戏的一种[1]。顾名思义，游戏的过程是即时进行而不是采用回合制。通常，标准的即时战略游戏会有资源采集、基地建造、科技发展等元素。在玩家指挥方面，即时战略游戏通常可以独立控制各个单位，而不限于群组式的控制。 一个常见的误解是认为：“只要是即时的战争游戏就算是即时战略游戏”，其实即时战略游戏在真正意义上（或者说狭义上）的认定是比较严格的。即时战略游戏在战略（Strategy）的谋定过程上必须是即时的。所以当一款战争游戏只有战斗时是采即时制，而在采集、建造、发展等战略元素是采回合制，那就不能算是即时战略。另外，如果该游戏完全没有上述的战略元素。那也只能算是即时战术游戏。 RTS从未衰亡：浅谈RTS游戏的内核与未来 MOBA游戏 MOBA是英文Multiplayer Online Battle Arena Games的简写，意为多人联机在线竞技游戏。而MOBA类游戏的开山鼻祖是1998年横空出世的《星际争霸》。 MOBA（英文全称：Multiplayer Online Battle Arena，缩写：MOBA，中文翻译：多人在线战术竞技游戏 [1] ），又被称为Action Real-Time Strategy（缩写：Action RTS，ARTS）动作即时战略游戏。 这类游戏的玩法是：在战斗中一般需要购买装备，玩家通常被分为两队，两队在分散的游戏地图中互相竞争，每个玩家都通过一个RTS风格的界面控制所选的角色。但不同于《星际争霸》等传统的硬核的RTS游戏，这类游戏通常无需操作RTS游戏中常见的建筑群、资源、训练兵种等组织单位，玩家只控制自己所选的角色 多人在线战斗竞技场游戏（MOBA，multiplayer online battle arena）或称作多人在线战斗擂台游戏，又可定义为动作即时战略游戏（ARTS，action real-time strategy）。玩家被分为两队，通常每个玩家只能控制其中一队中的一名角色，以打垮对方队伍的阵地建筑为胜利条件。 但有些多人在线战斗竞技场游戏1个玩家可以控制2至3名角色[1][2]，或2位玩家控制1名角色[3]，例如风暴英雄中的失落的维京人、雷克萨与丘加利，王者荣耀中的元歌，决战！平安京中的傀儡师等。 最详尽的MOBA类游戏发展史 FPS游戏 第一人称射击游戏（英语：First-person shooter，简称FPS）是以玩家的第一人称视角为主视角进行的射击类电子游戏的总称，通常需要使用枪械或其他武器进行战斗。玩家会直接从游戏的主人公的眼中观察周围环境，并进行射击、运动、对话等等活动。大部分第一人称射击游戏会采用三维或伪三维技术来使玩家获得身临其境的体验，并达成多人游戏的需求。 第一人称射击类游戏，FPS(First-person shooting game)，严格来说第一人称射击游戏属于动作游戏的一个分支，但和RTS类游戏一样，由于其在世界上的迅速风靡，使之发展成了一个单独的类型。 FPS(First-person Shooting game)第一人称视角射击游戏顾名思义就是以玩家的主观视角来进行射击游戏。玩家们不再像别的游戏一样操纵屏幕中的虚拟人物来进行游戏，而是身临其境的体验游戏带来的视觉冲击，这就大大增强了游戏的主动性和真实感。早期第一人称类游戏所带给玩家的一般都是的屏幕光线的刺激，简单快捷的游戏节奏。随着游戏硬件的逐步完善，以及各种游戏的不断结合。第一人称射击类游戏提供了更加丰富的剧情以及精美的画面和生动的音效。 ACT、RPG、ARPG游戏 ACT——动作游戏 RPG——角色扮演游戏 ARPG——动作角色扮演游戏，角色扮演游戏的一个子集，兼有角色扮演和动作游戏的特质 ACT:action game 动作游戏强调打击感、操作、即时反馈，以动作为主要特色。 RPG:role playing game 角色扮演游戏强调代入感、收集、成长，以精彩的故事为主要特色。 ARPG:action role playing game 动作角色扮演游戏兼顾以上两者，往往适当的降低ACT游戏所要求的操作部分，放大RPG的剧情及成长部分（ARPG最佳参考：黑暗之魂） 游戏平台 PC主要就是Steam，除了Steam，EA有自家的Origin，育碧有自家的Uplay，暴雪有自家的暴雪游戏平台战网，腾讯有自己的wegame。gog比较小众，最早卖老游戏的，现在啥也会卖了。杉果是个key商，要说是个平台也算是个平台吧。 全球最知名的PC游戏平台有V社旗下的Steam，育碧的Uplay，EA公司的Origin，　EPIC games，以及GOG游戏平台。 PC游戏平台大全 Steam游戏平台（蒸汽平台） Steam游戏平台（蒸汽平台）是美国电子游戏商威尔乌（Valve）于2003年9月12日推出的数字发行平台，提供数字版权管理、多人游戏、流媒体和社交网络服务等功能。 借助Steam，用户能安装并自动更新游戏，也可以使用包括好友列表和组在内的社区功能，还能使用云存储、游戏内语音和聊天功能。 Steam软件免费提供了一个应用程序接口，称为Steamworks，开发商可以用来集成Steam的功能到自己的产品中，例如网络、在线对战、成就、微交易，并通过Steam创意工坊分享用户创作的内容。 Steam被认为是全世界的电脑游戏界最大的数位发行平台。 Steam是Valve公司旗下的游戏平台 Origin Origin是著名游戏厂商EA的平台，也被许多人吐槽为烂橘子平台，原因是因为Origin平台在国内并没有自己的区服，玩家们想要使用Origin的话，只能通过外网，但是在国内，如果不开加速器的话，这个平台根本没法用，网速低到让人绝望。 Upaly Epic GOG Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/魔兽争霸和魔兽世界.html":{"url":"docs/commonsense/Game/魔兽争霸和魔兽世界.html","title":"魔兽争霸和魔兽世界","keywords":"","body":"魔兽争霸和魔兽世界 魔兽系列：魔兽争霸、魔兽世界 魔兽争霸 魔兽世界WoW DotA（DOTA） 英雄联盟LOL 王者荣耀 MMORPG游戏 RTS游戏 Steam游戏平台（蒸汽平台） 魔兽系列：魔兽争霸、魔兽世界 魔兽系列（英语：Warcraft）是由暴雪娱乐所发布的一整套包括长篇小说、电子游戏及基于其他媒介的跨媒体系列作品。 该系列由四款核心游戏： 1、魔兽争霸：人类与兽人、 2、魔兽争霸II：黑潮、 3、魔兽争霸III：混乱之治、 4、魔兽世界及一款卡牌游戏炉石传说：魔兽英雄传组成。 前三款都是即时战略类游戏，对阵双方的玩家需要控制一整支虚拟队伍进行对战，是史上最成功的即时战略游戏系列之一。 而后的一款是MMORPG游戏。 除魔兽争霸：人类与兽人之外的其他游戏版本都有资料片，资料片中通常包含了新的内容以延长游戏寿命。 魔兽争霸II的资料片是魔兽争霸II：黑暗之门， 魔兽争霸III的资料片是魔兽争霸III：冰封王座， 魔兽世界的资料片有燃烧的远征、巫妖王之怒、大地的裂变、熊猫人之谜、德拉诺之王及军团再临。 系列作品 魔兽争霸：人类与兽人 魔兽争霸II：黑潮 魔兽争霸II：黑暗之门 魔兽争霸III：混乱之治 魔兽争霸III：冰封王座 魔兽世界 魔兽世界：燃烧的远征 魔兽世界：巫妖王之怒 魔兽世界：大地的裂变 魔兽世界：熊猫人之谜 魔兽世界：德拉诺之王 魔兽世界：军团再临 魔兽世界：争霸艾泽拉斯 魔兽世界：经典版 衍生产品 炉石传说：魔兽英雄传 《炉石传说》（英语：Hearthstone，港台译作“炉石战记”，港台旧译“炉石战记：魔兽英雄传”，中国大陆旧译“炉石传说：魔兽英雄传”）是暴雪娱乐发行的一款集换式卡牌游戏。 魔兽争霸 《魔兽争霸：人类与兽人》（英语：Warcraft: Orcs & Humans） 于1994年1月15日在美国首次发布 《魔兽争霸II：黑潮》（英语：Warcraft II: Tides of Darkness） 发行于1995年12月 《魔兽争霸II：黑暗之门》（英语：Warcraft II: Beyond the Dark Portal） 在1996年4月30日 《魔兽争霸III：混乱之治》（英语：Warcraft III: Reign of Chaos） 于2002年发行 《魔兽争霸III：冰封王座》（英语：Warcraft III: The Frozen Throne，港台译作“魔兽争霸III：寒冰霸权”） 2003年5月 魔兽世界WoW 《魔兽世界》（英语：World of Warcraft，缩写作 WoW），简称魔兽，是由暴雪娱乐制作的一款大型多人在线角色扮演游戏。魔兽世界的剧情开端点是在《魔兽争霸3：冰封王座》结束之后的故事。 魔兽世界 《魔兽世界：燃烧的远征》（World of Warcraft: The Burning Crusade） 2007年1月16日晚在欧美地区发行 《魔兽世界：巫妖王之怒》（英语：World of Warcraft: Wrath of the Lich King） 2007年8月3日在BlizzCon 2007首日发布 《魔兽世界：大地的裂变》（英语：World of Warcraft: Cataclysm，港台译作“魔兽世界：浩劫与重生”） 2009年8月21日于美国加州安纳海姆举行的2009暴雪嘉年华中被正式公布。 《魔兽世界：熊猫人之谜》（英语：World of Warcraft: Mists of Pandaria） 于2012年9月在欧美地区首发，10月在韩国和中国大陆发售。 《魔兽世界：德拉诺之王》（英语：World of Warcraft: Warlords of Draenor，港台译作“魔兽世界：德拉诺之霸”，通常简称为Warlords 或 WoD） 于2013年在美国加州举行的BlizzCon 2013上公布 《魔兽世界：军团再临》（英语：World of Warcraft: Legion，港台译作“魔兽世界：军临天下”） 于2015年8月6日的德国科隆游戏展上正式公布。 魔兽世界：争霸艾泽拉斯 《魔兽世界：争霸艾泽拉斯》（英语：World of Warcraft: Battle for Azeroth，港台译作“魔兽世界：决战艾泽拉斯”） 于2017年11月3日的暴雪嘉年华上正式公布 《魔兽世界：经典怀旧服》（英语：World of Warcraft Classic，港台译作“魔兽世界：经典版”） 2017年11月3日的暴雪嘉年华上正式公布 目前已发布七部资料片： 第一部资料片《燃烧的远征》于2007年1月16日发布； 第二部资料片《巫妖王之怒》于2008年11月13日发布； 第三部资料片《大地的裂变》于2010年12月7日发布； 第四部资料片《熊猫人之谜》于2012年9月25日发布； 第五部资料片《德拉诺之王》于2014年11月13日发布[2]； 第六部资料片《军团再临》于2015年8月6日公布计划，并在2016年9月1日正式发行[3]； 第七部资料片《争霸艾泽拉斯》于2017年11月4日发布消息，在2018年8月14日上线[4]。 第八部资料片《暗影国度》于2019年11月1日暴雪嘉年华开幕式公布，将在2020年上线。 DotA（DOTA） 《遗迹保卫战》（英语：Defense of the Ancients）[1]，通常简称DotA，中文也译刀塔，是以《魔兽争霸III》资料片《魔兽争霸III：冰封王座》为基础制作的一系列角色扮演（RPG）类型自定义地图。 《Dota 2》是一款由Valve开发免费的多人在线战斗竞技类游戏。2011年Dota 2开始在Windows平台上进行测试， 它的前身《DotA》是《魔兽争霸III》及扩展版本冰封王座中的一张自定义游戏地图。 截至2019年6月，Dota 2支持Windows系统、MacOS系统及Linux系统。Dota 2是Steam平台上活跃人数最多的游戏之一，最高在线人数超过120万。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/英雄联盟LOL.html":{"url":"docs/commonsense/Game/英雄联盟LOL.html","title":"英雄联盟LOL","keywords":"","body":"英雄联盟LOL 《英雄联盟》（英语：League of Legends，简称LoL）是由Riot Games开发及发行的一款多人在线战术擂台（MOBA）游戏，游戏为免费模式进行并提供付费道具服务。该游戏是受到《魔兽争霸III：冰封王座》中一个名为DotA第三方自定义地图启发而诞生[1]，且至今仍不断定期更新。 Riot Games，又称拳头公司或拳头社或R社，于台湾注册商号为“锐玩游戏”[5]，是一间美国电子游戏开发商和发行商。公司成立于2006年，其总部位于美国加利福尼亚州圣莫尼卡。 Riot Games的著名作品《英雄联盟》发行于2009年10月[6]，在2013年有近3千万的日活跃玩家[7]。 2015年12月17日，腾讯公司收购 Riot Games 全数股权，Riot Games 继而成为了腾讯旗下的子公司。 1.1 游戏地图 1.1.1 召唤师峡谷 1.1.2 嚎哭深渊 1.1.3 水晶之痕 1.1.4 扭曲丛林 1.1.5 云顶之弈 Riot Games将英雄分为六大类： 1、射手（Marksman）：射手俗称ADC或AD，是主要造成远程物理伤害的英雄，这些英雄有较高的每秒伤害（DPS）而不是爆发能力，他们通常是破坏防御塔的主力，不过他们的防御力偏低，容易遭到火力瞄准。 2、法师（Mage）：法师俗称AP或APC，是具有强大魔法伤害技能、但防守能力和移动能力偏低的英雄。一些法师可以在短时间内造成巨大伤害，一些则是以长期持续伤害为主，爆发性的法师和刺客间的界线很模糊。 3、刺客（Assassin）：刺客是专精于迅速地杀死另一个英雄的英雄[27]。这些英雄往往会追着对方的射手和法师跑，因为他们的防御力较差。虽然刺客的防御也不怎么高，但他有着迅速移动的能力。刺客的攻击依赖的是短时间内的瞬间伤害，在攻击结束之后，他们会比较虚弱。 4、坦克（Tank）：坦克是难以被杀死的英雄，他们有着高防御、高生命值或高护盾。不过他们的伤害偏低。有些坦克具有控场能力，可以迫使敌人分散或使敌人僵直，也能迫使敌人攻击自己。 5、战士（Fighter）：战士是能输出伤害的坦克，相较于坦克，战士的攻击力较高但生命值较低；相较于刺客，战士的攻击力较低而生命值较高。 6、辅助（Support）：俗称SUP，辅助类英雄的能力是通过治疗队友、牵制对手等方式来辅佐团队，辅助在游戏早期通常会与射手英雄搭配，并试图让与他搭配的队友尽可能地生存下去，偶尔还必须骚扰对手。辅助的另一个重要工作是提供团队更大的视野。 德玛西亚，是《英雄联盟》宇宙中的地区，位于瓦洛兰大陆西端。同时也是《英雄联盟》中国服务器“网通二区”的名称，简称“网二”。 英雄联盟 lol（League of Legends）中有一些常用名词的简写: AP是指法术伤害 AD是指物理伤害 ADC是指远程物理输出 DPS是指近战物理输出 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Game/王者荣耀.html":{"url":"docs/commonsense/Game/王者荣耀.html","title":"王者荣耀","keywords":"","body":"王者荣耀 王者荣耀介绍 《王者荣耀》（《英雄战迹》（2015年7月）、《王者联盟》（2015年10月））简称“HOK”（Honor Of Kings）是由腾讯旗下天美工作室群L1工作室开发并运行在iOS、Android平台的多人在线快节奏竞技游戏。 《王者荣耀》是一款由天美工作室群研发的多人在线竞技游戏，曾用名《英雄战迹》（S1赛季）、《王者联盟》（S2赛季）， 该游戏日活跃人数最高破5000万,最高同时在线人数破500万,总下载次数逾2亿次，注册用户数亦突破2亿。 2016年全年收入为68亿元人民币，占2016年中国大陆手机游戏总收入的17.7%[4]。 2016年9月启动王者荣耀职业联赛[5]。 2017年5月取得全球手游综合收入榜冠军[6]。 王者荣耀于2015年11月26日推出公测版 技能----闪现技能（）、属性技能（1键、2键、3键） 装备 经济、经验 游戏共有6种类型的英雄可供玩家选择，分别是 坦克（防御）、 战士（近战）、 刺客（突进）、 法师（法术伤害）、 射手（远程物理伤害）与 辅助（增益）。 英雄：6种类型 坦克（防御）、（上路、对抗路） 战士（近战）、（上路、对抗路） 刺客（突进）、（中路、打野） 法师（法术伤害）、（中路、辅助） 射手（远程物理伤害）:（下路、发育路、打野） 辅助（增益）。 1、射手（Marksman）：射手俗称ADC或AD，是主要造成远程物理伤害的英雄，这些英雄有较高的每秒伤害（DPS）而不是爆发能力，他们通常是破坏防御塔的主力，不过他们的防御力偏低，容易遭到火力瞄准。 2、法师（Mage）：法师俗称AP或APC，是具有强大魔法伤害技能、但防守能力和移动能力偏低的英雄。一些法师可以在短时间内造成巨大伤害，一些则是以长期持续伤害为主，爆发性的法师和刺客间的界线很模糊。 3、刺客（Assassin）：刺客是专精于迅速地杀死另一个英雄的英雄[27]。这些英雄往往会追着对方的射手和法师跑，因为他们的防御力较差。虽然刺客的防御也不怎么高，但他有着迅速移动的能力。刺客的攻击依赖的是短时间内的瞬间伤害，在攻击结束之后，他们会比较虚弱。 4、坦克（Tank）：坦克是难以被杀死的英雄，他们有着高防御、高生命值或高护盾。不过他们的伤害偏低。有些坦克具有控场能力，可以迫使敌人分散或使敌人僵直，也能迫使敌人攻击自己。 5、战士（Fighter）：战士是能输出伤害的坦克，相较于坦克，战士的攻击力较高但生命值较低；相较于刺客，战士的攻击力较低而生命值较高。 6、辅助（Support）：俗称SUP，辅助类英雄的能力是通过治疗队友、牵制对手等方式来辅佐团队，辅助在游戏早期通常会与射手英雄搭配，并试图让与他搭配的队友尽可能地生存下去，偶尔还必须骚扰对手。辅助的另一个重要工作是提供团队更大的视野。 王者荣耀KPL 王者荣耀KPL晋级流程 全国大赛---》K甲---》KGL---》KPL（S组、A组、B组） K甲、KGL、KPL K甲：王者荣耀甲级职业联赛 KGL：王者荣耀甲级职业联赛（英语：King G-League），现为王者荣耀职业联赛的次级联赛，创立初为王者荣耀职业联赛（KPL）和王者荣耀职业联赛国际巡回赛（KPLGT）的青训及二队联赛，为王者荣耀顶级赛事输入更多选手。 KPL：王者荣耀职业联赛（英语：King Pro League，简称KPL），是王者荣耀官方顶级职业联赛，于2016年9月举行第一届联赛，并分为春季及夏季联赛两个赛季，每季联赛分为2个部分：常规赛和季后赛，目前共有18支队伍参赛。2022年起KPL将秋季赛取消，并将比赛月份改为2至5月举办春季赛，6至8月举办夏季赛。 在王者荣耀游戏中，KGL指的是王者荣耀职业发展联赛KPL G-League，简称KGL，KPL是指王者荣耀职业联赛。与KPL不同的是，KGL发展联赛旨在为职业联赛体系长期持续培养新俱乐部和新秀选手，对接KPL选秀大会。 KPL的S组、A组、B组 首先S组、A组、B组，指的就是【战队评级】，S组相当于【第一梯队的战队】，A组相当于【第二梯队的战队】，B组相当于【第三梯队的战队】。(PS：这个战队评级，是从21年KPL春季赛开始引入的。) 评级规则：组合进行BO5单循环，结束后根据组内积分排名直接升降换位。S组5、6名降至A组，A组1、2名晋升S组。A组5、6名降至B组，B组1、2名晋升A组 S组的好处：有机会和实力更为强劲的战队【练习】，对手越强，选手才能在战斗中快速成长。每一场和S组战队的实战，都是不可多得的锻炼机会。如果和A组或者B组战队打，锻炼的效果可能就会有所下降。 御三家 本身“御三家”就是个舶来词，从来都不是联盟钦点的，而是粉丝和观众潜移默化，口口相传才有的，当然实力和荣誉也是一部分，但更多的还是自身的“影响力”，从这个角度看就好理解多了。 御三家是在2020年初巅峰王者会时产生的说法，指的是2019年夺得冠军的三支队伍。estarpro 在2019年两冠一亚，QG获得一冠一亚，AG获得一冠。当然除了2019年的大丰收，还有他们在KPL上的超人气和实力。 前提说明，御三家这个称呼是从日本传来的，日本女团akb48每年总选的前三名叫御三家，在国内用的多的是snh48一年一度的总决选，每年总选的前三名也是御三家。 在kpl里我认为是实力和人气综合的排名，2019年ag，qg，es分别瓜分四个冠军，实力有了，人气上各种比赛的助威霸榜，人气也有了。所以这三家被称为御三家。 比起直接称呼御三家，我更喜欢叫做2019kpl御三家，因为今年实力还能打的就ag了，春季赛qg和es季后赛没进去，世冠也勉强止步八强。可是这两家在前两天ag输给ts后觉得ag不配御三家，才一个冠军，没有他们五冠三冠牛，所以还衍生出来了新称呼御二家。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/电影评分网站.html":{"url":"docs/commonsense/movie/电影评分网站.html","title":"电影评分网站","keywords":"","body":"电影评分网站 豆瓣 Metacritic IMDB 烂番茄 Metacritic Metacritic 有的也简写MTC评分 Metacritic是一个专门收集对于电影、电视节目、音乐专辑、游戏的评论的网站，网站会整合每个评价的分数再做出一个总评分作为这个项目的评分，在项目的多项短评中，从最好的分数到最坏的分数由下排列，最好的评价分数是绿色到最低的评价分数的黄色、红色排列。 烂番茄 烂番茄（英语：Rotten Tomatoes） 烂番茄（英语：Rotten Tomatoes）是一家美国电影和电视评论线上聚合网站。该网站于1998年8月由杨生（Senh Duong）、帕特里克·李（Patrick Y. Lee）和史蒂芬·王（Stephen Wang）等加州大学伯克利分校三名大学生创办[2]。虽然“烂番茄”这个名称与观众在反对糟糕的舞台表演时扔烂番茄的做法有关，但最初的灵感却来自1992年上映的加拿大电影《莱奥洛》（Léolo）中一个以番茄为主题的场景[3]。 IMDB IMDB 互联网电影资料库（英语：Internet Movie Database，简称IMDb）是一个关于电影演员、电影、电视节目、电视艺人、电子游戏和电影制作小组的在线数据库。IMDb开办于1990年10月17日，从1998年开始成为亚马逊公司旗下的网站，在2020年10月17日时，IMDb庆祝了他们30周年的纪念。 截至2020年6月，IMDb收录了共6,534,894部作品以及130,735,536个人物的资料 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/美剧.html":{"url":"docs/commonsense/movie/美剧.html","title":"美剧","keywords":"","body":"美剧 S02-E07（第2季第7集） “S\"指”season“，季 \"E\"指”episode“，集 \"S\"指的是季，Season 的缩写 \"E\"指的是集，Episode的缩写 越狱 行尸走肉 权力的游戏 《哈利·波特》 指环王 死亡笔记 《绝命毒师》（英语：Breaking Bad） 老白White (沃尔特·怀特( Walter White))小粉Pinkman (杰西·平克曼（Jesse Pinkman）) 《卫报》21世纪100部最佳电视剧 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/冰与火之歌/冰与火之歌-权利的游戏.html":{"url":"docs/commonsense/movie/冰与火之歌/冰与火之歌-权利的游戏.html","title":"冰与火之歌-权利的游戏","keywords":"","body":"冰与火之歌-权利的游戏 参考冰与火之歌.graffle 《冰与火之歌》（英语：A Song of Ice and Fire）是由美国作家乔治·R·R·马丁所著的史诗奇幻小说系列。 权力的游戏（A Game of Thrones） 冰与火之歌 小说 七部 权力的游戏 电视剧 八季 七部曲： 权力的游戏 A Game of Thrones 列王的纷争 A Clash of Kings 冰雨的风暴 A Storm of Swords 群鸦的盛宴 A Feast for Crows 魔龙的狂舞 A Dance with Dragons 凛冬的寒风 The Winds of Winter 春晓的希望 A Dream of Spring 故事主要发生在一个名为维斯特洛的虚幻大陆上分布的七大王国。维斯特洛是一片大约有南美洲那么大的大陆，有可以上溯到12000年前的悠久历史。在那里每一个季节通常持续数年。这片大陆的原住民是森林之子。森林之子与大自然和谐共处，并且使用魔法。 最早的人类先民们与最早期的武士带着青铜武器和骑术。他们通过维斯特洛与东方厄斯索斯大陆相连的陆桥登陆维斯特洛。他们自登陆后就与森林之子之间展开了一系列长久的战争。在随后的战争中，陆桥被森林之子用魔法摧毁。自此维斯特洛与厄斯索斯因此分隔，成为现在的多恩群岛和石阶群岛。 战争最后以在千面屿签订的和平协议结束，根据协议，先民得到了所有的开阔地，而森林之子则保有森林。 四千年之后，异鬼的入侵削弱了和平协议。异鬼是个来自于极北之地的神秘种族。他们横扫过维斯特洛北部，留下了无尽的死亡和废墟。随之而来的是几乎长达一代人的寒夜和持续几十年的冬季。最终先民和森林之子决议联合起来，在黎明之战中将异鬼击溃，并且在其南下必经之路上建立起了巨大的绝境长城，以防异鬼再次南侵。 大约在黎明之战两千年后，来自东方厄斯索斯大陆的安达尔人挥舞著铁制兵器，骑着战马，带着对七神的信仰穿越狭海而来。他们在艾林谷登陆，并且迅速击败了南部王国。但是他们并没能征服占有地利的北部王国。随后在维斯特洛大陆上出现了七个强大的王国：北境王国、谷地王国、河屿王国、凯岩王国、河湾王国、风暴王国和多恩王国等七个王国。之后在厄斯索斯出现一个称为瓦雷利亚帝国的力量增长。从此大批居住于厄斯索斯大陆洛伊拿河畔的居民成为难民，并且在他们的战士女王娜梅莉亚带领下穿过狭海，在维斯特洛最南端登陆。洛伊拿人和当地领主莫尔斯·马泰尔结盟，征服了多恩，建成了另外一个强大的王国。 五个世纪之后，瓦雷利亚自由堡不断扩张，并达到狭海，与维斯特洛建立了联系，并且使用龙石岛作为通商口岸。 尽管如此，仅仅一个世纪之后，瓦雷利亚自由堡便在一场巨大的被称作末日浩劫的灾难中被彻底摧毁。控制龙石岛的瓦雷利亚家族，坦格利安家族，花了一个多世纪来储备力量，随后在征服者伊耿的带领下登陆维斯特洛，开始征服之路。尽管他们的军队数量不多，因着拥有西方世界中最后的三条龙，他们征服了整个维斯特洛大陆。 七大王国中的六个在最初的战争中便被降服，唯独多恩激烈的反抗，以至于伊耿同意他们保持独立。坦格利安家族同样放弃了原来的信仰，改为信仰七神（尽管他们还是违背信仰，按照瓦雷利亚的传统实行兄妹通婚 ），并遵守维斯特洛的风俗。 在接下来的数十年中坦格利安家族扑灭了所有反对他们统治的叛乱。龙在伊耿征服维斯特洛后的150年灭绝，但是坦格利安家族依然作为维斯特洛的统治者统治著整个维斯特洛，他们的统治地位也并未受到实质性的威胁。 在本书故事发生的十五年前，因坦格利安王朝末代国王“疯王”伊里斯二世疯狂残暴行为，以及其子雷加·坦格利安对北境守护艾德·史塔克之妹、风暴守护劳勃·拜拉席恩之爱人——莱安娜·史塔克的诱拐导致了一场内战，最终导致坦格利安家族统治地位的终结。 一个由劳勃·拜拉席恩，琼恩·艾琳和艾德·史塔克领导的贵族联盟击败了坦格利安家族的军队，随后他们杀掉了伊里斯的继承人和其绝大部分后嗣，除了伊里斯怀孕的妻子和他的孩子韦赛里斯逃到了龙石岛。伊里斯本人被其御林铁卫詹姆·兰尼斯特杀死。詹姆也因此得到了弑君者的外号。 伊里斯妻子在生下丹妮莉丝·坦格利安的过程中死去，随后丹尼莉丝被依然效忠坦格利安家族的家臣送到了狭海对面的自由城邦中。与此同时劳勃‧拜拉席恩成为了新国王，并迎娶了瑟曦·兰尼斯特。她的父亲泰温则在战争中将维斯特洛首都君临送给了劳勃。 冰与火之歌：权利的游戏（作者：乔治·R·R·马丁） 维斯特洛大陆：原住民是森林之子 东方厄斯索斯大陆：人类先民们 维斯特洛大陆上出现了七个强大的王国：北境王国、谷地王国、河屿王国、凯岩王国、河湾王国、风暴王国和多恩王国等七个王国。 坦格利安王朝第一代国王：征服者伊耿（七王国）（坦格利安家族） 坦格利安王朝末代国王“疯王”伊里斯二世（坦格利安家族） 其子雷加·坦格利安对北境守护艾德·史塔克之妹、风暴守护劳勃·拜拉席恩之爱人——莱安娜·史塔克的诱拐 劳勃·拜拉席恩，琼恩·艾琳和艾德·史塔克领导的贵族联盟 韦赛里斯（疯王之子，龙母哥哥）和 丹妮莉丝·坦格利安（龙母） 泰温（父亲）：詹姆·兰尼斯特（弑君者）、瑟曦·兰尼斯特、提利昂·兰尼斯特（小恶魔） 主要角色： 兰尼斯特家族： 泰温·兰尼斯特/Tywin Lannister 瑟曦·兰尼斯特/Queen Cersei Lannister（瑟后） 詹姆·兰尼斯特/Jaime Lannister（弑君者） 提利昂·兰尼斯特/Tyrion Lannister（小恶魔） 史塔克家族： 奈德·斯塔克/Eddard 'Ned' Stark 凯瑟琳·徒利·史塔克/Lady Catelyn Stark 罗柏·史塔克/Robb Stark（少狼主） 珊莎·史塔克/Sansa Stark（三傻） 艾莉亚·史塔克/Arya Stark（二丫） 布兰·史塔克/Bran Stark（三眼乌鸦） 琼恩·雪诺/Jon Snow（白狼主） 拜拉席恩家族： 史坦尼斯.拜拉席恩/Stannis Baratheon 蓝礼·拜拉席恩/Renly Baratheon 乔佛里·拜拉席恩/Joffrey Baratheon 坦格利安家族： 韦赛里斯·坦格利安/Viserys Targaryen 丹妮莉丝·坦格利安/Daenerys Targaryen（龙之母） 培提尔·贝里席（小指头） 瓦里斯（八爪蜘蛛） 桑铎·克里冈（猎犬） 戴佛斯·席握斯（洋葱骑士） 梅丽珊卓（红袍女巫） 七大王国： 北境王国（Kingdom of the North） 山谷王国（Kingdom of Mountain and Vale） 河屿王国（Kingdom of the Isles and the Rivers） 凯岩王国（Kingdom of the Rock） 河湾王国（Kingdom of the Reach） 风暴王国（Kingdom of the Storm） 多恩（Dorne） 家族： 史塔克家族（House Stark） 兰尼斯特家族（House Lannister） 拜拉席恩家族（House Baratheon） 艾林家族（House Arryn） 马泰尔家族（House Martell） 徒利家族（House Tully） 葛雷乔伊家族（House Greyjoy） 提利尔家族（House Tyrell） 坦格利安家族（House Targaryen） 海塔尔家族（House Hightower） 波顿家族（House Bolton） 弗雷家族（House Frey） 民族： 先民 安达尔人 罗伊拿人 背景种族和特殊物种： 森林之子 冰原狼 龙 异鬼 影子山猫 巨人 雪熊 长毛象 其他势力： 守夜人军团 学城（学士） 御林铁卫 无旗兄弟会 其他： Winter Is Coming 凛冬将至 Red Wedding 血色婚礼，红色婚礼 私生子之战（Battle of the Bastards） 篡夺者战争（War of the Usurper），或称劳勃的反叛 黑水河之役（Battle of the Blackwater） 黑城堡之战（Battle of Castle Black） 参考 https://zh.wikipedia.org/wiki/%E5%86%B0%E8%88%87%E7%81%AB%E4%B9%8B%E6%AD%8C https://zh.wikipedia.org/wiki/%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/哈利·波特七部.html":{"url":"docs/commonsense/movie/哈利·波特七部.html","title":"哈利·波特七部","keywords":"","body":"哈利·波特七部 《哈利·波特》（Harry Potter）是英国作家J·K·罗琳（J. K. Rowling）于1997～2007年所著的魔幻文学系列小说，共7部。 按电影数量算，电影共有8部，分别是： 1、哈利·波特与魔法石（英：Harry Potter and the Philosopher's Stone，美：Harry Potter and the Sorcerer's Stone），台译：哈利波特 — 神秘的魔法石 2、哈利·波特与密室（Harry Potter and the Chamber of Secrets），台译：哈利波特 — 消失的密室 3、哈利·波特与阿兹卡班的囚徒（Harry Potter and the Prisoner of Azkaban），台译：哈利波特 — 阿兹卡班的逃犯 4、哈利·波特与火焰杯（Harry Potter and the Goblet of Fire），台译：哈利波特 — 火杯的考验 5、哈利·波特与凤凰社（Harry Potter and the Order of Phoenix），台译：哈利波特 — 凤凰会的密令 6、哈利·波特与混血王子 （Harry Potter and the Half-Blood Prince），台译：哈利波特 — 混血王子的背叛 7、哈利·波特与死亡圣器上（Harry Potter and the Deathly Hallows），台译：哈利波特 — 死神的圣物 8、哈利·波特与死亡圣器下（Harry Potter and the Deathly Hallows），台译：哈利波特 — 死神的圣物 霍格沃茨魔法学校（Hogwarts School of Witchcraft and Wizardry） 伏地魔（Lord Voldemort），原名汤姆·马沃罗·里德尔（Tom Marvolo Riddle）或小汤姆·里德尔（Tom Riddle Jr.） 主要人物： 哈利·波特（Harry James Potter） 赫敏·格兰杰（Hermione Jean Granger） 罗恩·韦斯莱（Ronald Bilius \"Ron\" Weasley） 霍格沃兹魔法学校教授 阿不思·邓布利多（Albus Percival Wulfric Brian Dumbledore），变形术教授兼霍格沃茨魔法学校校长，被公认为是当代最伟大的巫师，哈利最尊敬的人之一。第六卷时为了得到魂器牺牲 西弗勒斯·斯内普（Severus Snape），魔药课教授，斯莱特林学院院长，哈利六年级黑魔法防御术教授。在莉莉死后就成为凤凰社正式成员，在伏地魔要杀死哈利父母前是食死徒，之后为邓布利多的密探。邓布利多死后升为校长。深爱着莉莉·伊万斯 米勒娃·麦格（Minerva McGonagall），变形术教授兼霍格沃茨魔法学校副校长和格兰芬多学院院长，并在最后邓布利多和斯内普死后成为校长 鲁伯·海格（Rubeus Hagrid），保护神奇生物课教授、猎场看守、钥匙管理员 奇洛（Quirell），哈利一年级时的黑魔法防御术课教授。食死徒成员，企图帮伏地魔偷取魔法石，在最后因为触碰哈利·波特而死 吉德罗·洛哈特（Gilderoy Lockhart），哈利二年级时的黑魔法防御术课教授。其实是个大骗子，把别的魔法师的成就算在自己身上，然后对对方施用遗忘咒，使对方忘记，后被自己的遗忘咒反弹，住在圣芒戈 莱姆斯·卢平（Remus John Lupin），哈利三年级时的黑魔法防御术课教授，狼人。当年格兰芬多“劫盗者”四人组成员，哈利·波特父亲的好友，第一次凤凰社成员 阿拉斯托·穆迪（Alastor Moody），外号“疯眼汉”（MAD-EYE），哈利四年级时的黑魔法防御术课教授 [16] 。曾是魔法部里十分优秀的傲罗（捕快），大部分的阿兹卡班囚犯都由穆迪逮捕。被食死徒小巴蒂·克劳奇冒充（服用复方汤剂），后被发现，第七卷时在转移哈利的途中在飞行时被咒语击中杀死 多洛雷斯·乌姆里奇（Dolores Umbridge），哈利五年级时的黑魔法防御术课教授，魔法部高级副部长，霍格沃茨高级调查官。 霍拉斯·斯拉格霍恩（Horace Slughorn），哈利六年级时的魔药课教授，斯内普教授任校长时为斯莱特林院长 波莫娜·斯普劳特（Pomona Sprout），赫奇帕奇学院院长，草药课教授 菲利乌斯·弗立维（Filius Flitwick），拉文克劳学院院长，魔咒课教授 罗兰达·霍琦（Rolanda Hooch），飞行课教授，魁地奇裁判 西比尔·特里劳妮（Sybill Trelawney），占卜课教授，在卷五中曾被乌姆里奇开除，这段时间由马人费伦泽上课；第六集之后两人同时授课。 费伦泽（Firenze），马人， 占卜课教授 宾斯教授（Cuthbert Binns），幽灵， 魔法史教授 奥罗拉·辛尼斯塔（Aurora Sinistra），天文课教授 薇尔米娜·格拉普兰（Wilhelmina Grubbly-Plank），保护神奇生物课代课教师 塞蒂玛·维克多（Septima Vector），数字占卜课教授 阿米库斯·卡罗（Amycus Carrow），食死徒成员，斯内普任校长时教授黑魔法防御术 阿莱克托·卡罗（Alecto Carrow），食死徒成员，斯内普任校长时教授麻瓜研究 历史人物 戈德里克·格兰芬多（Godric Gryffindor），霍格沃茨创始人之一，格兰芬多学院创始人。 赫尔加·赫奇帕奇（Helga Hufflepuff），霍格沃茨创始人之一，赫奇帕奇学院创始人。 罗伊纳·拉文克劳（Rowena Ravenclaw），霍格沃茨创始人之一，拉文克劳学院创始人。 萨拉查·斯莱特林（Salazar Slytherin），霍格沃茨创始人之一，斯莱特林学院创始人。 阿芒多·迪佩特（Armando Dippet），邓布利多前任校长。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/指环王.html":{"url":"docs/commonsense/movie/指环王.html","title":"指环王","keywords":"","body":"指环王 魔戒 （英国作家J.R.R.托尔金著长篇小说） 《魔戒》（The Lord of the Rings）又译《指环王》，是英国作家、牛津大学教授约翰·罗纳德·瑞尔·托尔金创作的长篇奇幻小说。 全书分为三部：《护戒同盟》《双塔奇兵》《王者归来》。 指环王 系列电影包括三部： 《指环王：护戒使者》（2001年12月19日在美国上映） 《指环王：双塔奇兵》（2002年12月18日在美国上映） 《指环王：国王归来》（2003年12月17日在美国上映） 全书分为六篇： 中文 英文 第一篇：黑影重临 I: The Return of the Shadow 第二篇：护戒同盟 II: The Fellowship of the Ring 第三篇：艾辛格的背叛 III: The Treason of Isengard 第四篇：魔多之行 IV: The Journey to Mordor 第五篇：魔戒圣战 V: The War of the Ring 第六篇：王者归来 VI: The Return of the King 主要人物： 迈雅：迈雅原先是埃努，帮助维拉塑造阿尔达。迈雅的数目极其庞大，并不是每一位都被命名。 甘道夫/米斯兰达（Gandalf/Mithrandir，1000－3021） 萨鲁曼（Saruman/Curunír Lán，1000－3019） 索伦（Sauron/Gorthaur，3400 Y.L－3019）：曾是魔苟斯·包格力尔最信赖的副手。 霍比特人： 佛罗多·巴金斯（Frodo Baggins，2968－3021） 山姆卫斯·詹吉/山姆（Samwise Gamgee \"Sam\"，2980－61 F.A） 皮瑞格林·图克/皮聘（Peregrin Took \"Pippin\"，2990－65 F.A） 梅里雅达克·烈酒鹿/梅里（Meriadoc Brandybuck \"Merry\" , 2982－65F.A） 比尔博·巴金斯（Bilbo Baggins，2908－3021） 咕噜/史麦戈（Gollum/Smeagol，?－3019） 人类： 。。。 精灵 。。。 矮人 。。。 半兽人和强兽人 。。。 树人 。。。 精灵三戒、矮人七戒和人类九戒 至尊魔戒 the one ring 迈雅（Maiar）是J.R.R.托尔金的小说《精灵宝钻》系列中虚构的世界一个种族。单数是Maia。他们与维拉同类，但力量与等级次于维拉。他们被称为迈雅，意思是“维拉的下属”，是他们的仆从和助手。迈雅原先是埃努，帮助维拉塑造阿尔达。虽然迈雅的数目极其庞大，但并不是每一位迈雅都被命名。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/死亡笔记.html":{"url":"docs/commonsense/movie/死亡笔记.html","title":"死亡笔记","keywords":"","body":"死亡笔记 《死亡笔记》（Death Note）是大场鸫原作，小畑健作画的漫画。 电影三部：前面两部是正片，最后一步是讲L把自己名字写入死亡笔记后，最后23天的故事，有点鸡肋 动漫37集，另有特别篇2话 该系列共有四部：后面2部类似番外篇，有点鸡肋， 金子修介（第一二部导演）、中田秀夫（第三部导演）、佐藤信介（第四部导演） 第一部《死亡笔记》于2006年6月17日在日本上映 第二部《死亡笔记：最后的名字》于2006年11月3日在日本上映 第三部《死亡笔记：L改变世界》于2008年2月9日在日本上映 第四部《死亡笔记：点亮新世界》于2016年10月29日在日本上映。 死神4个： 琉克（ 流克 ） 雷姆、杰拉斯：与杰拉斯观察人间时，发现杰拉斯为救喜欢的弥海砂而化为沙子，知道了杀死死神的方法。 斯多：死神，性格懦弱，甚至害怕人类。将笔记丢失后被流克捡到，夜神月所使用笔记的真正主人。 L、M、N 渡 夜神月 弥海砂 夜神总一郎 夜神幸子：夜神月的母亲，夜神总一郎的妻子 夜神妆裕：夜神月的妹妹 KIRA（基拉） 被信徒称为“kira（译为基拉，来源于英文单词killer）”，将L杀死后，成为了“第二代L”。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/movie/动漫.html":{"url":"docs/commonsense/movie/动漫.html","title":"动漫","keywords":"","body":"动漫 小时候看过的 1984 《黑猫警长》 1986-1 《葫芦娃》 1989 《舒克和贝塔》 《大头儿子小头爸爸》 蜡笔小新 刺客伍六七 《画江湖之不良人》 《画江湖之杯莫停》 《麦兜》 秦时明月 《十万个冷笑话》 《死亡笔记》 三大动漫评分网站BGM 中国最大ACGN评分网站MAL 全世界最大动漫评分网站Anikore 日本最大动漫评分网站 中国动漫评分网站：BGM（Bangumi）日本动漫评分网站：Anikore、SAIT（animesachi）欧美动漫评分网站：MAL（MyAnimeList）、ANIDB、ANN 之前B站有位up参考BGM、Anikore、MAL的评分排出了动漫前100名，这三家的评分比较有代表性。 ACGN为英文Animation（动画）、Comic（漫画）、Game（游戏）、Novel（小说）的合并缩写，是从ACG扩展而来的新词汇，主要流行于华语文化圈。由于传统的ACG划定的范围早已不足以覆盖现代青少年文化娱乐相关领域，因此衍生出添加了轻小说等文学作品的ACGN这个词汇。 ACG即Animation（动画）、Comics（漫画）与Games（游戏）的首字母缩写，来源不是英语，也不是一个英语单词，并没有完全对应的广泛使用的中文翻译。 [1-2] ACG一词为中国台湾省创造，流行于华语文化圈，ACG文化发源于日本，但在日本从不使用这个词，在英语文化圈里也并不普及。 100、朝花夕誓——约定之花 99、樱花庄的宠物女孩 98、王牌投手 振臂高挥 97、幼女战记 96、花开伊吕波 95、我的青春恋爱物语果然有问题 94、全金属狂潮 校园篇 93、好想告诉你92、悠久之翼91、幸运星 90、TIGER & BUNNY 89、斩服少女 88、怪物 87、蓝色恐惧 86、来自风平浪静的明天 85、从零开始的异世界生活 84、声之形 83、鬼灭之刃 82、Angel Beats 81、莉兹与青鸟 80、百变之星 79、月刊少女野崎君 78、辉夜大小姐想让我告白 77、JOJO的奇妙冒险 星尘斗士 76、空之境界 第五章 矛盾螺旋 75、刀语74、夏日大作战73、昭和元禄落语心中 第二季 72、游戏人生零 71、紫罗兰永恒花园 70、悠哉日常大王 69、黑之契约者68、黑礁67、男子高中生的日常 66、寒蝉鸣泣之时 解65、秒速五厘米64、狼与香辛料63、轻音少女 第二季 62、狼的孩子雨和雪 61、排球少年 第三季 60、乒乓 59、吹响吧上低音号2 58、为美好的世界献上祝福2 57、十二国记 56、猎人1999 55、无头骑士异闻录54、钢之炼金术师 53、月色真美 52、棋魂 51、穿越时空的少女 50、心理测量者 49、一拳超人 48、交响诗篇47、混沌武士 46、混沌武士 45、来自新世界 44、龙猫 43、摇曳露营 42、冰菓 41、未闻花名 40、水星领航员 第三季 39、浪客剑心 追忆篇 38、数码兽大冒险 37、白兔糖 36、龙与虎35、永生之酒 34、歌牌情缘2 33、日常 32、夏目友人帐 参 31、海贼王 30、星空清理者 29、风之谷 28、进击的巨人 第三季 Part.2 27、四叠半神话大系 26、Fate Zero 25、死亡笔记 24、灌篮高手 23、物语系列 第二季 22、魔法少女小圆 21、天空之城 20、四月是你的谎言 19、你的名字 18、幽灵公主 17、千与千寻 16、虫师 15、来自深渊 14、比宇宙更远的地方 13、新世纪福音战士 12、天元突破 红莲螺岩 11、白箱 SHIROBAKO 10、3月的狮子 第二季 9、反叛的鲁路修 第二季 8、凉宫春日的消失 7、银河英雄传说 6、攻壳机动队 第一季（2002） 5、银魂 4、命运石之门 3、星际牛仔 2、钢之炼金术师FA 1、CLANNAD 第二季 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Bible/圣经介绍.html":{"url":"docs/commonsense/Bible/圣经介绍.html","title":"圣经介绍","keywords":"","body":"圣经Bible 圣经介绍 参考圣经创世记.graffle耶稣十二门徒.xmind 《圣经》是犹太教与基督教的共同经典，出于希伯来文kethubhim，意为“文章”，后衍意为“经”；希腊文作graphai，拉丁文作Scripturoe，汉译作“经”。 圣经起始：创世记（旧约）---启示录（新约） 作者：摩西、马太 摩西（希伯来语：מֹשֶׁה‎ ）；是犹太人的民族领袖，史学界认为他是犹太教的创始者。 在犹太教、基督教、伊斯兰教、巴哈伊教里都被认为是极为重要的人物，按照以色列人的传承，摩西五经便是由其所著。 摩西受上帝之命率领被奴役的以色列人逃离古埃及，前往一块富饶之地迦南，经历40多年的艰难跋涉，他就要到达目的地的时候就去世了。在摩西的带领下古以色列人摆脱了被奴役的悲惨命运，学会遵守十诫，并成为历史上首个尊奉一神宗教的民族。 圣玛窦 St. Matthew （圣徒兼任早期基督教传教史家，又译马太），生于犹太的加利勒亚，跟随耶稣三年，传教于巴勒斯坦一带。 公元42年写福音，后人称之为“马太福音”，是圣经新约卷中四大福音书之一。该福音记述了耶稣的一生，用亚拉麦文字，即当时犹太人的通用语言。公元91年马太被刺致死殉教。是耶稣的十二使徒之一。 圣经讲述古时犹太人的历史，并记录先知预言。￼ 当犹太教经典大量译成希腊文本后，希腊文ta biblia（复数，意为“诸书”）遂被用以专指这些经典；拉丁文衍为单数词Biblia，后成为犹太教、基督教正式经典的专称，汉译作“圣经”。 《圣经》是一本相当厚的书，页数跟字典差不多，但其实《圣经》不只是一本书，而可以说是一套有66本的丛书。其中有长有短；有古老的作品，也有较近期的作品，内容包括：历史、诗歌、哲学，甚至私人信件和讲章。￼ 犹太教的正式经典，包括律法书5卷、先知书8卷、圣录11卷三个部分，故通称《泰纳克》（Tanak，系Torah、Neviim、Ketuvim三部分的首字母组成），又称“二十四书”。 基督教的经典，包括《旧约圣经》和《新约圣经》。 《旧约圣经》即犹太教的《圣经》，是从犹太教传承下来的。全书卷数和次序，基督教各派略有不同。 《新约圣经》是基督教的经典，共27卷，包括记载耶稣生平、言行的“福音书”，叙述早期教会情况的《使徒行传》，传为使徒们所写的《书信》和《启示录》。 《旧约圣经》里面有39卷，《新约圣经》里有27卷。 自中世纪以来，《圣经》有“唯一的书”和“书中之书”之称。作为基督教的经典，它是一部伟大的巨著。 《圣经》包括《旧约全书》和《新约全书》，共66卷。 所谓的“约”就是“誓约”，指上帝和他的百姓之间的约定。 其中《旧约全书》是犹太人的经书，共39卷。它记述了犹太民族的历史、犹太人对其唯一之神的信仰及其发展经历，记载了犹太民族的律法、诗歌和先知的预言。 《新约全书》是基督教的经典，记载的是耶稣及其使徒的言行和故事、早期教会的情况等，有27卷。 《旧约全书》和《新约全书》完成于不同的年代：前者大约成书于公元前1200年至公元前100年间，是用古希伯来文写的；后者大约完成于公元1至2世纪，是用希腊文写的。整部《圣经》的成书，前后跨历了约1300年。 《旧约全书》和《新约全书》的内容虽然有所不同，却有其内在的联系，这是因为犹太教和基督教都信奉上帝，认为上帝耶和华是宇宙唯一的真神。 有人据此理解为，这两种宗教有同一条主脉相连：按照犹太教的说法，上帝允诺把一位救世主赐给他的百姓；基督教徒认为，耶稣的诞生就是救世主降临，耶稣的生、死和复活，就是上帝允诺的应验。 公元4至5世纪，《圣经》被译成拉丁文。16世纪宗教改革运动前后，欧洲很多国家又将《圣经》翻译为本国文字。可以说，《圣经》是世界上流传最广、影响最大的图书之一，有人统计过，它有上千种不同文字的译本。 《圣经》对世界，尤其是对西方思想文化传统的形成和发展有着深刻的影响。 1、笼统地说，旧约是讲希伯来人的历史，和三体一体中圣父的作为；新约是记载圣子耶稣基督的事迹、公元初期教会的发展，基督教的教义和关于末后的启示 2、从语言使用上来说，旧约基本是用希伯来文写成（和极少量亚兰文），新约是用古希腊文（从专业角度讲，叫新约希腊文，其中很受闪族语影响） 3、从时间跨度来说，旧约讲了上下四千年左右的历史，新约跨度只有一百来年 4、从写作群体来说，旧约共有2、30位作者，新约作者只有10位。一般认为前者写成用了1000多年，后者则是5、60年左右 新约全书和旧约相对。旧约是记载人类的诞生,发展,以及摩西（梅瑟）时代的故事,就是记载公元前的人们有关耶和华（雅威）的历史,世界通用的公历是以耶稣出生的时间记载的,耶稣出生前为公元前,耶稣出生时为公元元年。 而新约是记载耶稣出生,在传道,钉十架,受死,升天,复活的事情,新约圣经并非用犹太人的母语希伯来文写成，乃是由希腊文写成，因为新约时代的巴勒斯坦早已被希腊化了。新约的原文是希腊文但语法受一点亚拉姆语（或称“亚兰文”）的影响。 《圣经》分为旧约和新约两大部分，新旧约以耶稣出生为界限的。 《圣经》新约部分的数量比较一致，天主教、东正教、新教都承认27卷。新约全书（New Testament），由福音书：马太福音（马窦福音）、马可福音（马尔谷福音）、路加福音、约翰福音（若望福音）、使徒行传（宗徒大事录）、使徒书信（宗徒书信）和启示录（默示录）组成。 使徒书信（宗徒书信）分保罗书信（保禄书信）和一般书信；保罗（保禄）书信又分教会书信、个人书信、监狱书信和希伯来书。新约与旧约恰成对比。 旧约是基督教对《圣经》前一部分的常用称呼，是用希伯来语写成的 。后一部分称为新约。《圣经》旧约部分原是犹太教主要经籍《塔纳赫》，是希伯来民族文学遗产的总集。 扩展资料 新约全书包括福音书、历史书、使徒书信（宗徒书信）和启示录（默示录）。其中福音书有《马太福音》（马窦福音）《马可福音》（马尔谷福音）《路加福音》《约翰福音》（若望福音）四卷；历史书有使徒行传（宗徒大事录）； 书信共有二十一卷，其中确定为使徒保罗（保禄）所写的有十三卷，它们是《罗马书》、《哥林多前书》、《哥林多后书》、《加拉太书》（迦拉达书）、《以弗所书》（厄弗所书）、《腓立比书》（弟铎书）、《歌罗西书》、《帖撒罗尼迦前书》（得撒洛尼前书）、《帖撒罗尼迦后书》（得撒洛尼后书）、《提摩太前书》（弟茂德前书）、《提摩太后书》（弟茂德后书）、《提多书》（犹达书）、《腓利门书》（费肋孟书）；《希伯来书》的作者是谁，已不可考。 正如古教父奥利金有针对这个问题的名言说：“《希伯来书》的作者是谁，只有上帝知道”！所以本书和《雅各书》、《彼得前书》（保禄前书）、《彼得后书》（保禄后书）、《约翰壹书》（若望壹书）、《约翰贰书》（若望贰书）、《约翰叁书》（若望叁书）和《犹大书》归类为普通书信；新约最后一卷《启示录》（默示录）属于启示文学类。 赵悦圣经分享： 1、世界分为看得见的【科学已知的，科学未知的】和看不见的【神的世界，灵】 2、为什么说神是存在的 3、圣经是神的话，通过圣经可以和神交流 4、为什么说升级是神的话【预言】 5、万物是进化的还是神创造的，世界万物特别精密，不可能是进化的和爆炸的，一定是创造的，为什么说是神创造的，因为圣经很早就说明了世界万物的各种特性，当时的文明是没有办法知道这些的，因为是神创造的，所以神比较了解，所以说是神创造的 6、圣经就是神之道的明确见证？ 1、圣经的开始就写到：起初，神创造天地。 2、圣经是有预言的 3、 7、 8、 9、 10、 各种翻译版本： 1、圣经和合本是在华语区广泛使用的中文圣经版本。“和合本”，又称“和合译本”，全称“国语和合译本”。现在在网上能搜索到的圣经几乎都是和合本。 2、圣经思高本（SiGaoShengJing）正名称为思高圣经译释本（现通称“思高圣经”，下称“思高本”），是今日华语天主教（罗马公教）教友最普遍使用的圣经。此译释本的出版起源自1924年在上海举行的天主教会议决定翻译《圣经》。 由思高圣经学会（StudiumBiblicumO.F.M.）所出版的思高圣经译释本（SiGaoShengJing），是梵蒂冈教廷唯一认可法定的中文版本圣经。 3、。。。 创世记（旧约）---启示录（新约） 汉语-和合本： 我们在天上的父， 愿人都尊你的名为圣。 愿你的国降临， 愿你的旨意行在地上， 如同行在天上。 我们日用的饮食， 今日赐给我们。 免我们的债， 如同我们免了人的债。 不叫我们遇见试探， 救我们脱离凶恶。 因为国度，权柄，荣耀，全是你的， 直到永远。 阿门！ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/mythology/中国神话传说.html":{"url":"docs/commonsense/mythology/中国神话传说.html","title":"中国神话传说","keywords":"","body":"中国神话传说 参考中国神话传说.xmind 三皇五帝 盘古、女娲、 九天玄女 封神榜和西游记 三清四帝六御 九曜星官 中国佛教四大名山，传说是四大菩萨的道场 世传三皇五帝，多以为 伏羲 、神农为二皇，古代传说中的伏羲和神农。谓天皇、地皇。 炎帝，是中国上古时期姜姓部落的首领尊称，号神农氏 伏羲，华夏民族人文先始、三皇之首，亦是百王之先，乃是福佑社稷之正神，同时也是我国文献记载最早的创世神。 相传伏羲人首蛇身，与女娲兄妹相婚，生儿育女 中国上古神话中的创世女神，又称娲皇，是华夏民族人文先始，福佑社稷之正神。 女娲不但是补天救世的英雌和抟土造人的女神 盘古 ：（中国上古神话人物）中国民间神话传说人物，在昆仑山开天辟地， 刑天（炎帝大将）原是一个无名的巨人，他在与黄帝的大战中，被黄帝砍掉了脑袋，这才叫刑天。刑天舞干戚（干就是盾牌，戚就是斧子） 据《山海经·海外西经》当中记载：“刑天与帝至此争神，帝断其首，葬之於常羊之山，乃以乳为目，以脐为口，操干戚以舞。” 祝融，是三皇五帝时夏官火正的官名，火神 共工，为氏族名，又称共工氏。为中国古代神话中的水神，掌控洪水。据说共工氏姓姜，是炎帝的后代 共工怒触不周山，天柱折，地维绝，女娲于是炼五色石补天----《李凭箜篌引》（此为唐代作品）。 人们要解释日月西行、江河东去的现象，就幻想出“共工头触不周山”，“天柱折，地维绝”，“天倾西北”，“地不满东南”的故事，以此说明日月西行、江河东去的现象。 天不足西北，地不满东南是个俗语，释义是中国地势东南低西北高，西北地多天少 夸父是中国上古时期神话传说人物之一，在黄帝时期，北方大荒中，有座名叫成都载天的大山，居住着大神后土的子孙，称夸父族。夸父族人都是热心公益，善于奔跑，身怀巨力的人。因为他们长的个个身材高，力气大，所以又称巨人族。他们仰仗这些条件，专喜替人打抱不平。夸父族的人帮助蚩尤部落对抗黄帝部落，但是后来被黄帝打败。 共工的儿子后土，后土的子孙夸父 夸父逐日（夸父追日） 禺谷：古代传说日落的地方。 古代神话认为昆仑山中居住着一位神仙“西王母”，人头豹身，由两只青鸟侍奉，是道教正神，与东王公分掌男女修仙登引之事。 后土：后土，又称後土。源于母系社会自然崇拜中的土地与女性崇拜。全称承天效法厚德光大后土皇地祇，是道教尊神“四御/六御”中的第四位天帝，她掌阴阳，育万物，因此被称为大地之母。相传她是最早的地上之王。后与主持天界的玉皇大帝相配合，为主宰大地山川的的女性神。与玉皇大帝管理天上相反，她是主宰大地之神。她是一位女神，被人们称为地母，而玉皇大帝就被称为天公。 相当于希腊神话中的盖娅 道教传说： 盘古 ：（中国上古神话人物）中国民间神话传说人物，在昆仑山开天辟地， 太元圣母：又称“太元玉女”。传其出于天地构成之后，出而能言，是东王公和西王母的母亲。 道教三清：即玉清、上清、太清 ：他们是道教最高神灵“三清”，分别玉清元始天尊，上清灵宝天尊和太清道德天尊。 玉皇大帝：是道教神话传说中的天地的主宰 西王母（王母娘娘） 东王公（东华帝君） 太元圣母，道教神话人物。又称太元玉女、玉清神母元君、玄妙玉女，全称 万炁祖母太玄玉极元景自然九天上玄玉清神母。道教早期的至高女神，盘古的妻子。 乃至以后的全真道道统渊源，仍称太上老君传于金母，金母传白云上真，白云上真传王玄甫，王玄甫传钟离权。钟离权授吕洞宾和刘海蟾，吕洞宾授王重阳，重阳授北七真。 金母（西王母（王母娘娘）） 王玄甫，天下道教全真道始祖，又名王少阳、东华帝君 钟离权（汉钟离，八仙之一） 全真七子为道教全真道创始人王重阳的七位嫡传弟子。即马钰（丹阳子）、丘处机（长春子）、谭处端（长真子）、王处一（玉阳子）、郝大通（太古子）、刘处玄（长生子）和马钰之妻孙不二（清静散人）。 道教一贯有“六御”之说，“六御”分别为为：玉皇大帝、勾陈上宫天皇大帝、中天北极紫微大帝 [1] 、东极青华大帝、南极长生大帝、承天效法后土皇地祇。 四御为道教天界尊神中辅佐“玉皇”的四位尊神，所以又称“四辅”。他们的全称是：北极紫微大帝、南极长生大帝、勾陈上宫天皇大帝、承天效法土皇地祇。《修真十书》卷七《丹诀歌》中说：“九九道至成真日，三清四御朝天节。 《山海经》四方之神东方句芒、南方祝融、西方蓐收、北方禺疆。 《帝王世纪》帝喾“以句芒为木正，祝融为火正，蓐收为金正，玄冥为水正，后土为土正。是五行之官分职而治诸侯......”颛顼时有“南正重”、“火正黎”，帝喾设“五行之官”可信。 玉皇大帝：是道教神话传说中的天地的主宰 玉皇大帝犹如人间的皇帝，上掌三十六天，下辖七十二地，掌管神、仙、佛、圣、人间、地府的一切事，权力无边，有穹苍圣主，诸天宗王之称，赞玉帝之尊，权大化，得元始天尊秘授赤字玉文而开天执符，主承太上无极大道之法旨而含真御历，金阙四御辅助，北极四圣佐护，神霄九宸大帝拱卫，妙相庄严，法身无上，统御诸天，统领万圣。 九天玄女 “天”在中国原本按方位分为中央钧天、东方苍天、东北旻天、北方玄天、西北幽天、西方浩天、西南朱天、南方炎天、东南阳天（《淮南子》） 道教三清：即玉清、上清、太清 ：他们是道教最高神灵“三清”，分别玉清元始天尊，上清灵宝天尊和太清道德天尊。 道教初创时，是以老子为其始祖，称之为太上老君又称太上道君，尊奉为最高神灵。 《道德经》说：“道生一，一生二，二生三，三生万物。”意思是道化生为混沌元气，由混沌元气化生为阴、阳二气，再由阴阳二气衍化为天、地、人三才，由此产生天下的万事万物，一化为三，三即是一，因此，三清尊神就是“道”的人格神化。 王母娘娘（西王母），另称九灵太妙龟山金母、太灵九光龟台金母、瑶池金母、西王母、金母、王母、西姥等，是古代中国神话传说中掌管不死药、罚恶、预警灾厉的长生女神。 东王公（东华帝君）：又称木公、东皇公、东华帝君等。东王公在道教被认为常常在丁卯日登台四处观察天下修道学仙之人的情况。所以凡是得道入仙之人，都得先拜东王公．然后再拜见西王母，然后才能飞升进入九天，再入三清境谒拜元始天尊、灵宝天尊和道德天尊。 至明代吴元泰《东游记》始定为：铁拐李（李玄）、汉钟离（钟离权）、张果老（张果）、吕洞宾（吕岩）、何仙姑（何琼）、蓝采和（许坚）、韩湘子、曹国舅（曹景休） 八仙每人都有一至二样宝物或法器，一般称为“暗八仙”或八宝，常出现于刺绣、民间艺术之中，均代表吉祥之意，而且随场景不同而变换。其中较为通俗的暗八仙为：葫芦（铁拐李）、芭蕉扇（钟离权）、鱼鼓（张果老） 、荷花（何仙姑） 、花篮（蓝采和）、剑（吕洞宾） 、笛子（韩湘子）、玉板（曹国舅） 八仙排序　至明吴元泰《八仙出处东游记》始定为：铁拐李、汉钟离、张果老、何仙姑、蓝采和、吕洞宾、韩湘子、曹国舅。相沿至今，再无变动。 自从盘古开天地，三皇五帝到如今 三皇分别是：燧人氏、伏羲氏、神农氏。 五帝分别是：黄帝、颛顼（zhuan xu ）、帝喾（ku）、尧帝、舜帝。 三皇五帝 三皇： 燧人氏 - 传说燧人氏教人钻木取火、用火。 伏羲氏 - 传说伏羲教民结网进行渔猎畜牧。 神农氏 - 传说神农是农业和医药的发明者，教人医疗与农耕。 五帝： 黄帝 - 史记记载，五帝之首为黄帝。黄帝被誉为中华民族的始祖，最后打败蚩尤，统一各部落(此时发明指南车)。 颛顼 - 相传颛顼是黄帝的孙子，是九黎的首领。 帝喾 - 相传喾是黄帝的曾孙，颛顼的侄子。 尧 - 相传帝喾死后传位于平庸的挚，于是各部族首领纷纷背离挚，而拥立尧。 舜 - 相传舜的时代是农耕时代的高度发展期，并是道德观的开始。 炎帝部落后来和黄帝部落结盟，共同击败了蚩尤。 中国人自称是“炎黄子孙”，“黄”是指黄帝，而“炎”就是指神农。炎帝与黄帝是华夏始祖。 三皇：燧人取火、伏羲画卦、神农尝百草 三皇之首是燧人氏。燧人氏被称为“火祖”。因为据说他教会了百姓钻木取火。 伏羲氏是燧人氏之子（燧人氏女儿是女蜗）。伏羲是有文献记载的第一位创世神。因为制定了大量的礼仪制度，让百姓得以有纪律的生活。 神农氏是是农业、医药、商贸的发明者。据说，他的肚皮是透明的，可以看见各种植物在肚子里的反应。 五帝：黄帝制衣冠、颛顼划九州、帝喾顺民意、尧舜称“圣王” 黄帝。姓公孙，名轩辕。是华夏部落联盟首领。据说，黄帝首先联合炎帝打败了强悍的蚩尤，后又打败炎帝，征服东夷，九黎族，从而成为华夏民族的共主。 颛顼是黄帝的孙子。姓姬，号高阳氏。颛顼最让人铭记的，应该是关于九州的建置区划，他将中国的区域确定为兖、冀、青、徐、豫、荆、扬、雍、梁九州，影响深远。 帝喾是黄帝的曾孙。颛顼的侄子，名叫姬俊，史称高辛氏。帝喾聪明好学，德行高尚，顺从民意，对待百姓，仁威兼施。他在位70年间，深受百姓爱戴。 尧帝是帝喾之子。本来他不应该即位，但是因为帝喾长子帝挚太过荒淫无度，才立了尧帝。尧帝在位28年期间，制定四时历法，颁授农耕时令，并任命鲧和禹父子治理水患。年老后，自动禅位给了舜。 舜帝是颛顼的六世孙。虽然是颛顼的六世孙，但是到了舜帝时，已经成为了平民。舜帝少时在山上躬耕，但是因为有孝顺谦让的美德，早已经名声在外。尧帝知道后，不但将自己的女儿嫁给他，还禅位于他（关于禅位争议，暂且不论）。舜帝即位后，在农业、五教（五种伦理教育：父义、母慈、兄友、弟恭、子孝）、刑法等方面都颇有建树。在历史上，与尧齐名，并称为圣王。 神话故事： 盘古开天地 女娲造人、女娲补天、大禹治水 伏羲画卦 神农尝百草 雷泽华胥 精卫填海 羲和御日、常羲沐月 后羿射日、夸父逐日 嫦娥奔月、吴刚伐桂、玉兔捣药 劈山救母（二郎救母） 封神榜（封神演义）和西游记：比较系统描述中国神话传说，里面有很多重复的神仙（神仙是不同的） 封神榜： 鸿钧老祖，又称鸿元老祖、玄玄上人、鸿钧老祖，有一说是道教徒所信仰的最高神祇。(最早出现在明代的神话小说《封神演义》中，是元始天尊、道德天尊、通天教主、佛教接引佛、佛教菩提老祖、女娲娘娘的师父。在中国远古神话典籍中并不存在。)另一说是中国神话中盘古(道教神话中盘古是元始天尊) 在小说《封神演义》中称为鸿钧道人，为三大教祖：太上老君、元始天尊、通天教主的师父。也是佛教中接引佛(阿弥陀佛)和菩提老祖的师父。亦是女娲娘娘的师父 “三尸”，指道教的三尸神。尸者，神主之意。道教认为人体有上中下三个丹田，各有一神驻跸其内，统称“三尸”，也叫三虫、三彭、三尸神、三毒。上尸好华饰，中尸好滋味，下尸好淫欲。早期道教认为斩“三尸”，恬淡无欲，神静性明，积众善，乃成仙。也有指痴，贪，嗔欲望产生的地方。 当人死亡后，三尸则从人的尸体脱离出来，变为游离状态，其形象为人生前形象，称之为“鬼”（《云笈七签》卷八十一曰：“（人）死后魂升于天，魄入于地，唯三尸游走，名之曰鬼。”）。因此，鬼并不是死人灵魂，而是游离的三尸。 据说，上尸名“踞”，中尸名\"踬\"，下尸名\"蹻\"。 上尸名 彭踞 中尸名 彭踬 下尸名 彭蹻 上尸名彭琚，好宝物，中尸名彭瓒，好五味，下尸名彭矫，好色欲。而且上尸居脑宫，中尸居明堂，下尸居腹胃，三尸常居在人体，是欲望产生的根源，是毒害人体的邪魔。由于三尸是在人体中是靠谷气生存的，如果人不食五谷，断其谷气，那么三尸虫在人体中就不能生存了。 元始天尊 燃灯古佛、接引道人 通天教主 玉虚宫，碧游宫 昆仑山 创始元灵四徒弟：鸿钧、女娲、鲲鹏、陆压 准提 神仙人 道阐截 三清 梅山七怪：袁弘 四大灵猴 菩提老祖 昆仑山散人陆压 周天之内有五仙：天地人神鬼，有五虫：赢鳞毛羽昆，但是有四种猴子不在这十类之中：第一位为灵明石猴（孙悟空），第二位为赤尻马猴，第三位是通臂猿猴（袁洪），第四位是六耳猕猴 千里眼顺风耳：妈祖林默娘身边的驾前将军。民间传说“千里眼”及“顺风耳”原本是一对兄弟。兄名“高明”，弟名“高觉”，原为棋盘山的桃精与柳精幻化成人形。 乾元山金光洞太乙真人 唐僧一行路经时，镇元子正好应玉清元始天尊之邀，到上清天弥罗宫去听讲“混元道果”。 西游记： 三清四帝：还有称“三清”、“四御”为“七宝”，此外还有“六御”之说 三清，道教的三位至高神。总称为“虚无自然大罗三清三境三宝天尊”，指道教所尊的玉清、上清、太清三清胜境，也指居于三清胜境的三位尊神，即：玉清圣境无上开化首登盘古元始天尊、上清真境玉晨道君灵宝天尊、万教混元教主太上老君道德天尊。 三清，即玉清、上清、太清，原本指“三清境”：太清境大赤天，上清境禹余天，玉清境清微天，位于道教天界“种民天”之上。后来指称三清尊神，玉清之主元始天尊，上清之主灵宝天尊，太清之主道德天尊。这三清尊神乃是道教中，世界创造之初的大神，故号称三清道祖。 三清是道教哲理“三位三体”的象征。道教中有“一炁化三清”之说。《道德经》说：“道生一，一生二，二生三，三生万物。”意思是道化生为混沌元气，由混沌元气化生为阴、阳二气，再由阴阳二气衍化为天、地、人三才，由此产生天下的万事万物，一化为三，三本于一，因此，三清尊神就是“道”的人格化。 四帝是道教所崇奉的地位仅次于三清的四位天帝的合称，分别是指中央紫微北极太皇大帝、南极长生大帝、勾陈上宫天皇大帝、后土皇地祇。 第一位 是中央紫微北极太皇大帝，被视为协助玉皇大帝执掌天经地纬、日月星辰，统御诸星和四时气候的神灵。 第二位 是南极长生大帝，居高上神霄府，号玉清真王，而于九天界化身九天应元雷声普化天尊居玉枢府统御雷部。 第三位 是勾陈上宫天皇大帝，被视为辅助玉皇大帝掌管南北级和天地人三才，并主宰人世间兵革的神灵。 第四位 是后土皇地祇，被视为掌管阴阳生育、万物之美和大地河山之秀的女神。 对于四御，还有说是四极大帝的。 即：总领万星的北极紫微大帝，总领万灵的南极长生大帝，总领万神的西方太极天皇大帝，总领万类的东极青华大帝。 四御为道教天界尊神中辅佐“三清”的四位尊神，所以又称“四辅”。他们的全称是：中天紫微北极大帝、南极长生大帝、勾陈上宫天皇大帝、承天效法后土皇地祇。 《道法会元》称“三清”、“四御”为“七宝”，认为三清是宇宙万物的创造者，四御是统率天地的万神者。此外，四御还协助玉皇执掌天道。中天紫微北极大帝协助玉皇执掌天经地纬、日、月、星、辰、四时气候；南极长生大帝协助玉皇执掌人间寿天祸福，勾陈上宫天皇大帝协助玉皇执掌南北极与天、地、人三才，并主宰人间兵革之事；承天效法后土皇地祇协助玉皇执掌阴阳生育，万物生长，与大地河山之秀。 道教一贯有“六御”之说，“六御”分别为：玉皇大帝、勾陈上宫天皇大帝、中天北极紫微大帝 [1] 、东极青华大帝、南极长生大帝、承天效法后土皇地祇。 此外，道教还有“六御”之说。他们为：统御万天的玉皇大帝、统御万雷的勾陈大帝、统御万星的紫徽大帝、统御万类的青华大帝(又称太乙救苦天尊)、统御万灵的长生大帝、统御万地的后土皇地祇。这种说法源于中国古代“六合”观念，所谓“六合”，指宇宙的巨大空间，即上、下、四方(东、西、南、北)。 南宋刘用光《无上黄箓大斋立成仪》对此的排列顺序为： 玉清上帝、上清上帝、太清大帝、昊天至尊玉皇上帝、勾陈上宫天皇大帝、中天紫微北极大帝、东极太乙救苦天尊(即青华大帝)、南极长生大帝、后土皇地祇。 前三尊为三清，后六尊则构成了上(玉皇)、下(后土)、四方的“六合”布局。道教称之为“昊天六御宸尊”，加上三清，合为“九皇御号”。后来，为了符台道经四辅(太清、太平、太玄、正一)的分类，去掉了“玉皇大帝”和“青华大帝”，成今日之“四御”。 九曜星官 中国佛教四大名山，传说是四大菩萨的道场。 浙江普陀山是观音菩萨的道场， 山西五台山是文殊菩萨的道场， 四川峨眉山是普贤菩萨的道场， 安徽九华山为地藏菩萨道场。 以上四处也合称“四大菩萨道场”。 西游神话里，万寿山五庄观镇元大仙身世之谜 其实，仙有天仙，地仙，人仙，鬼仙。狭义的仙即指天仙，地仙。从这个对仙的等级划分上我们可以知道，地仙是仙等级中的中乘，即使镇元子是地仙之祖，从等级上也是中级职称。 三清是家师的朋友，四帝是家师的故人；九曜是家师的晚辈，元辰是家师的下宾。 按照《西游记》中的仙人等级设定，有天仙、神仙、地仙、人仙和鬼仙。那么，天仙之祖、神仙之祖、人仙之祖是谁呢？ https://zhuanlan.zhihu.com/p/33761749 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/mythology/佛教.html":{"url":"docs/commonsense/mythology/佛教.html","title":"佛教","keywords":"","body":"佛教 尊称释迦牟尼佛、佛陀（意为“觉悟者”）、世尊、释尊等；简称释迦如来、释迦文佛、释迦佛，从明朝开始汉地还尊称他为如来佛祖或佛祖，即“佛教之创祖”，简称如来佛，清代的满人则称之为佛爷；出生于今尼泊尔南部的王族家庭，为刹帝利种姓。 在佛教中是世间出世间最尊贵之人，并非神；在中国民间信仰中，被神化而视为至高神明，故在一般道教、民间信仰之庙宇也往往设有大雄宝殿供奉之，甚至是三宝殿，供奉含有释迦牟尼佛之三宝佛及菩萨、罗汉、祖师等；然而在佛教中，神属于六道众生中的天众，释迦牟尼佛是已经解脱出离六道轮回的圆满智者。 三界（梵语：त्रैलोक्य，trailokya），佛教用语。三界为：欲界、色界、无色界。有情众生都在三界中生死轮回，三界外无有众生、无有法。三界构成世间，相当于三有。此概念被道教借入，也称三界二十八天。 六道轮回 《法华经》指出：“六道众生生死所趣。”十界中由上而下的六道分别指：天道、阿修罗道、人间道、畜生道、饿鬼道、地狱道。 六道可分为三善道和三恶道（又称三途、三恶趣）。三善道为天、阿修罗、人； 三恶道为畜生、饿鬼、地狱。 天龙八部（梵语：Aṣṭasenā；标准藏语：lha srin sde brgyad），是佛教概念，指佛教护法神队伍中以天、龙为首的八种神话种族，包含天众、龙众、夜叉、乾闼婆、阿修罗、迦楼罗、紧那罗、摩睺罗迦。因八部以“天众”和“龙众”为首，故称“天龙八部”[1]，又称龙神八部、八部鬼神、八部众、八部神将、天龙八将等。金庸曾以此为名，写成小说《天龙八部》 。 中国佛教四大名山，传说是四大菩萨的道场。 浙江普陀山是观音菩萨的道场， 山西五台山是文殊菩萨的道场， 四川峨眉山是普贤菩萨的道场， 安徽九华山为地藏菩萨道场。 以上四处也合称“四大菩萨道场”。 参考《西游记》 身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃 菩提本无树，明镜亦非台，本来无一物，何处惹尘埃 《坛经》说过这样一个故事：佛门五祖弘忍让弟子们以偈显明自己修行的心得。首座神秀偈曰：“身是菩提树，心如明镜台。时时勤拂拭，莫使惹尘埃。”踏碓僧惠能偈曰：“菩提本无树，明镜亦非台。本来无一物，何处惹尘埃?“据此，弘忍认为神秀未能明心见性，而惠能已然明心见性。是夜，五祖将惠能叫到自己房中，为其讲《金刚经》，并将圣物袈裟传承给他，惠能就此成为禅宗六祖。 菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。 原文解释：这个是六祖惠能大师的一个四句偈这是从神秀和惠能那两个偈子引申出来。神秀说：“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”惠能说：“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。”的确，要能够参透这两个偈子的确很难，就是正确的理解也不易。 一、身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃释义：弟子就如同是菩提树，（释迦牟尼佛当年在菩提树下觉悟）弟子的心灵就像一座明亮的台镜。（捻花微笑，禅宗以心传心的第一宗公案（典故））要时时不断地将它掸拂擦试，不让它被尘垢污染障蔽了光明的本性。 二、菩提本无树，明镜亦非台，本来无一物，何处惹尘埃释义：菩提原本比喻智慧，明亮的镜子比喻清静心。本来清静，哪里会染上什么尘埃? Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/mythology/希腊神话.html":{"url":"docs/commonsense/mythology/希腊神话.html","title":"希腊神话","keywords":"","body":"希腊神话 参考希腊神话.graffle 第一代： 盖娅/盖亚（希腊语：Γαία、英语：Gaia (Gaea)），是古希腊神话中的大地之神，是众神之母，所有神灵中德高望重的显赫之神，她是混沌中诞生的第一位创世神，也是能创造生命的原始自然力之一。万神之母盖亚，也正是这位大母神生出了所有光明宇宙的天神。 乌拉诺斯（英语：Uranus） 是古希腊神话中的天空之神，从母亲盖娅的指端诞生，最初作为统治者的众神之王、即天空的神格化 乌拉诺斯是盖娅的受造物（由于乌拉诺斯从盖娅指端生出，类似于米开朗琪罗笔下的上帝创造亚当，所以他应该算作盖娅的受造物而非儿子），也是盖娅的丈夫和十二泰坦神（Titans)、独眼巨人（Cyclopes）与百臂巨人（Hekatonchires）的父亲。乌拉诺斯和盖娅生了六男六女，就是十二泰坦神。 兄弟姐妹：卡俄斯、塔耳塔洛斯、厄瑞波斯、倪克斯 配偶 天神：乌拉诺斯 十二泰坦神（六男六女） 三个独眼巨人 三个百臂巨人 第二代： 克洛诺斯(Cronus)：盖亚与乌拉诺斯的十二个提坦神儿女中最年幼者。神性不明，在密教中跟时间有关，推翻父神而成为第二任神王。 瑞亚（Rhea）：十二提坦之一，地母神。克洛诺斯的妻子第二任神后。 父 母：乌拉诺斯（父亲）、盖亚（母亲） 配 偶：瑞亚、菲吕拉 子女： 灶神：赫斯提亚（长女）农业女神：得墨忒尔（次女）天后：赫拉（三女） 冥王：哈迪斯（长子）海王：波塞冬（次子） 第三代： 宙斯（古希腊语：Ζεύς、希腊语：Δίας、英语：Zeus），是古希腊神话中的众神之王，奥林匹斯十二主神之首，统治宇宙万物的至高无上的主神（在古希腊神话中主神专指宙斯），人们常用“众神和人类的父亲”、“神王”来称呼他，是希腊神话诸神中最伟大的神。罗马神话中对应宙斯的神祇是朱庇特（Jupiter或Jove），被视为射手座的守护神。 他的兄弟波塞冬和哈迪斯分别掌管海洋和冥界。 父 母：克洛诺斯（父亲）、瑞亚（母亲） 配 偶：墨提斯、忒弥斯、欧律诺墨、德墨忒耳、谟涅摩绪涅、勒托、赫拉等 子 女 ： 智慧女神：雅典娜、机遇之神：波洛斯狩猎女神：阿尔忒弥斯、光明之神：阿波罗 火神：赫菲斯托斯、战神：阿瑞斯神使：赫尔墨斯、冥后：珀耳塞福涅酒神：狄俄尼索斯、大力神：赫拉克勒斯 青春女神：赫柏、助产女神：厄勒梯亚残忍女神：厄倪俄、英雄：帕尔修斯等 奥林波斯十二神（希腊语直译）（英语：Twelve Olympians），是古希腊宗教中最受崇拜的十二位神，他们分别是：宙斯（众神之王、雷霆之神）、赫拉（天后、婚姻和生育女神）、赫斯提亚（炉灶和家庭女神）、波塞冬（海神）、德墨忒尔（农业和丰收女神）、雅典娜（战争和智慧女神）、阿波罗（光明，音乐，预言与医药之神）、阿尔忒弥斯（狩猎女神）、阿瑞斯（战争和暴力之神）、阿佛洛狄忒（爱情和美丽女神）、赫菲斯托斯（火焰和工匠之神），以及赫尔墨斯（神使，小偷，旅者和商人之神），其中赫斯提亚因与人类住在一起，便把位置让给了狄俄尼索斯（酒神）。哈迪斯（冥王）和珀耳塞福涅（冥后）有时也会包括在奥林匹斯十二神中（厄琉西斯密仪），但一般哈迪斯都被排除在外，因为他是冥界的统治者。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/mythology/西游记.html":{"url":"docs/commonsense/mythology/西游记.html","title":"西游记","keywords":"","body":"西游记 1、明作家吴承恩、章回小说《西游记》 2、唐朝玄奘法师 3、西游记原型人物 参考西游记.xmind 明作家吴承恩、章回小说《西游记》 唐三藏或唐僧 唐三藏或唐僧，是中国著名古典小说《西游记》的主要角色之一，孙悟空等人的师父，其原型是唐代的玄奘法师。小说里的唐僧被设定为佛祖弟子罗汉金蝉子转世，由于食用唐僧身上的肉可以长生不老，所以唐僧在西天取经的路上总被妖怪掳走。在取得佛教佛经后，唐三藏修成正果，被封为“旃檀功德佛”。 今日不明佛教的大众受到《西游记》影响，常误解三藏为玄奘专属的称号。实际上三藏法师是一种敬称，指精通佛教圣典三大类别“经、律、论”三藏的法师，又称三藏比丘、三藏圣师，或略称三藏。因此三藏之号用在一人身上是错误的，称一位高僧为唐三藏，其实是为了避其名讳，故尊称为“中国的三藏法师”之意。除了玄奘之外，历史上著名的三藏法师尚有东汉的安世高、东晋的鸠摩罗什与法显、南朝宋的求那跋陀罗、唐代的实叉难陀、义净与大广智不空等；日本历史上唯一的三藏法师为灵仙法师。唐三藏着作至今即佛经心经与药师经，当时唐三藏奉唐太宗令，走陆路出新疆葱岭（今帕米尔高原）到印度约一年初时间取经，当时三藏法师日记即《大唐西域记》，到1560年代中，明作家吴承恩改写成章回小说《西游记》。 孙悟空 孙悟空，是在小说《西游记》中登场主要角色之一，为一只法力高强的石猴，别名孙行者。曾自封花果山美猴王、齐天大圣、任天官弼马温。在取经完成后被如来佛祖授为斗战胜佛。 在小说中，孙悟空出身花果山，是由灵石中吸收天地灵气、日月精华，经风吹日晒孕育而成之石猴，并在出海后自须菩提祖师处修得七十二变地煞术。 孙悟空曾先后闯龙宫、地府，取得能随使用者心意自由变化大小的如意金箍棒、并自阎罗王的生死簿上除籍取得永寿。经天界玉皇大帝招安后，由于未受邀蟠桃会并遭讥讽，孙悟空以“齐天大圣”之名大闹天宫、只身与天兵天将相持，后遭释迦如来镇压于五行山（五指山）下。 他在封印五百年后被南海观世音点化，保护唐三藏法师前往西天取经，协同猪八戒、沙悟净和白龙马艰辛克难伏魔降妖。旅途中，孙悟空屡次运用其武艺与智慧，拯救为妖怪所劫的唐僧师徒。历经九九八十一难后，终至西天取得真经功成正果。 孙悟空在东亚汉字文化圈中为智勇兼备的代表性角色，被诸多文学、戏曲、影视作品重新演绎。此类作品在设计上多所沿用原著中孙悟空所使用之金箍棒、斤斗云、七十二变等等法宝神通，或是参考其本身聪明、调皮、活泼、忠诚、善良、嫉恶如仇、追求自由等性格特征。 根据中国《四大名著》之一《西游记》原著描述，孙悟空是东胜神洲傲来国花果山灵石孕育迸裂、见风而成之石猴。乃一仙石吸收天地之气孕育而生。在花果山占山为王三五百载（《西游记》第三回中提到生死簿上注明孙悟空“该寿三百四十二岁”）。 后为了寻求长生不老的方法，历经八九载，跋山涉水，在西牛贺洲灵台方寸山斜月三星洞拜须菩提老祖[1]为师，习得地煞七十二变和筋斗云，并首次取姓为孙（菩提祖师以猢狲起姓），取名孙悟空。 此后，孙悟空为了寻一件称手的兵器，大闹龙宫，终寻得到东海龙王的天河定海神针如意金箍棒 （北海龙王敖顺送一双藕丝步云履，西海龙王敖闰送一副锁子黄金甲，南海龙王敖钦送一顶凤翅紫金冠），因阳寿已尽而大闹地府，吓得十殿阎王和牛头马面躲东躲西，修改了生死簿，返回人间。 后来孙悟空第一次受天界招安，玉帝承认了他自封的封号齐天大圣，并封为弼马温。因嫌官小受骗受辱，反叛下凡，自封为齐天大圣，打败了哪吒三太子。 后被天界第二次招安，又偷吃蟠桃、御酒、仙丹。玉帝发十万天兵都无法收服，后被二郎真君杨戬加梅山六怪和太上老君合力擒拿，刀劈雷击皆不得伤，被封于八卦炉七七四十九日，练就火眼金睛。（《西游记》第七回提到孙悟空本体其实是“光明一颗摩尼珠”）。出来后继续大闹天宫，被如来佛祖压于五行山下五百年（山上贴有唵嘛呢叭咪吽六字真言）。 五百年[2]后唐僧西天取经，路过五行山，揭去符咒，才救下孙悟空，收起为徒弟。同往西天取经。取经路上，孙悟空降妖除怪，屡建奇功，然而数次被师傅唐僧误解、受到紧箍咒的惩罚，两次被驱逐。孙悟空在玉华州收其王的长子为徒弟。历经八十一难，终于大功告成，师徒四人到达西天雷音寺，取得三藏佛经。孙悟空修得正果，被封为斗战胜佛。 猪八戒 猪八戒，法号悟能，是中国古典小说《西游记》当中唐僧的四个徒弟之一，排行第二，猪脸人身，黑猪模样[1]。孙悟空常呼其为“呆子”。 根据吴承恩《西游记》故事，猪八戒原是天庭中统领八万天河水兵的天蓬元帅，由于蟠桃会上喝酒醉后调戏月宫仙女嫦娥，被玉帝判罚，打了两千锤后被贬下凡，投错胎变成猪模样。他咬杀母猪，打死群彘，占领了福陵山，吃人度日。后入赘该山云栈洞的卵二姐（有版本作“卯二姐、卯二姊”）家，一年后，卵二姐死。此后，在福陵山上遇到观世音菩萨，与观音弟子木叉交战，后经观音指点，教他作取经人的徒弟，并起名猪悟能，从此持斋把素，断了五荤三厌专等取经人。 但未遇到唐僧之前，猪悟能又入赘高老庄，娶妻高翠兰（第十八回：“三年前被一个妖精占了，那妖整做了这三年女婿。”，可见原著中确实结婚了）。唐僧与孙悟空路过高老庄，高翠兰的父母请求唐僧和孙悟空帮助捉妖怪，在孙悟空与猪悟能打斗后，孙悟空说出自己是取经人的徒弟，猪悟能表示愿意跟随取经人，于是猪悟能拜唐僧为师，唐僧又为其取名猪八戒，一同赴西天取经，唐僧的徒弟中排行第二。 取经途中，由于他的懒惰、贪吃和好色，常常使唐僧师徒陷于困境当中，他两次撺掇唐僧赶走孙悟空，并多次在危难时刻要分行李散伙回高老庄。取回真经后，猪八戒由于“又有顽心，色情未泯”被封为净坛使者，为如来佛祖的部下，负责享用一切人世间作功德的供品。 沙僧 沙僧，又叫沙和尚，法号悟净，其前身为卷帘大将军，是中国古典小说《西游记》中的人物，他是唐僧在流沙河收的徒弟。 原是天庭武将，受封卷帘大将，失手打碎琉璃盏被贬下凡，盘踞在流沙河成为妖怪，以人为食，项下挂着九个骷髅，串为项链[3]。其后被观世音菩萨指点成为唐僧徒弟，其后与师傅、师兄孙悟空、猪八戒以及白龙马一起赴西天取经，取经途中，沙僧勤勤恳恳任劳任怨，历经九九八十一难后，功德圆满，获封为金身罗汉。 唐朝玄奘法师 玄奘（602年4月6日[2]－664年3月7日），俗姓陈，名祎，洛州缑氏县（今河南省偃师市南境）人，师承印度那烂陀寺的戒贤大师，为汉传佛教史上最伟大的译经师之一，被誉为中国四大翻译家之一，也是中国佛教法相唯识宗创始人。由其所口述、弟子辩机撰文的《大唐西域记》[3]亦成为研究古代印度历史的重要文献。 西行求法 玄奘感到多年来在各地所闻异说不一，特别是当时流行的摄论宗（后并入法相宗）、地论宗两家有关法相之说多有乖违，因此渴望得到总赅三乘学说的《瑜伽师地论》，以求融汇贯通一切[6]，于是决心前往印度求法。因得不到唐朝发放的过所（护照），所以始终未能如愿以偿。 贞观三年（629年），玄奘毅然由长安私发，冒险前往天竺。经过高昌国时，得高昌王麹文泰礼重供养，复欲强留玄奘以为国之法导，玄奘“水浆不涉于口三日，至第四日，麹文泰发觉玄奘气息渐惙，深生愧惧，乃稽首礼谢”，遂与玄奘结为义兄弟，相盟自天竺返国时更住高昌三载受其供养，讲经说法。离开高昌后，玄奘继续沿着西域诸国越过帕米尔高原，在异常险恶困苦的条件下，终于到达天竺。 在天竺的十多年间，玄奘跟随、请教过许多著名的高僧，他停留过的寺院包括当时如日中天的著名佛教中心那烂陀寺，他向该寺的住持戒贤法师学习《瑜伽师地论》与其余经论；瑜伽行派大师戒贤是护法的徒弟，世亲的再传弟子。在贞观十三年，他曾在那烂陀寺代戒贤大师讲授《摄大乘论》和《唯识抉择论》。此后，玄奘还徒步考察了整个南亚次大陆。 贞观十七年(公元643年)学成以后，他立真唯识量[7]论旨，在曲女城无遮辩论法会上，等待十八天，结果无人敢出来辩难，他因此不战而胜，名声鹊起，威震全天竺，被当时大乘行者誉为摩诃耶那提婆（iAST Mahāyānadeva महायानदेव），亦即“大乘天”，被小乘佛教徒誉为木叉提婆（iAST Mokṣadeva मोक्षदेव），亦即“解脱天”。[8] 翻译经文 643年，玄奘载誉启程回国，并将657部佛经带回中土。贞观十九年（645年），回到长安，受到唐太宗的热烈欢迎[9]。玄奘初见太宗时即表示希望前往嵩山少林寺译经，但没有得到批准，被指定住长安弘福寺[10]。652年（永徽三年），玄奘在长安城内慈恩寺的西院筑五层塔，即今天的大雁塔，用以贮藏自天竺携来的经像。寺内建立了玄奘纪念馆。大雁塔成为玄奘西行求法、归国译经的建筑纪念物。在唐太宗（李世民）大力支持下，玄奘在长安设立译经院（国立翻译院），参与译经的优秀学员来自全国以及东亚诸国。他花了十几年时间在今西安北部约150公里的铜川市玉华宫内将约1,330卷经文译成汉语。玄奘本身最感兴趣的是“唯识”部分。这些佛经后来从中国传往朝鲜半岛、越南和日本。显庆二年（657年）五月，高宗下敕，要求“其所欲翻经、论，无者先翻，有者在后”[11]。显庆二年（657年）九月，玄奘借着陪驾住在洛阳的机会，第二次提出入住少林寺的请求，“望乞骸骨，毕命山林，礼诵经行，以答提奖”。次日，高宗回信拒绝[12]。 玄奘依翻译佛典与对经文的阐释而开创了中国法相唯识宗，其学说却深深地影响了其他诸多宗派。玄奘一生所翻经论，合七十四部，总一千三百三十八卷[13]（目前学界流行说法为七十五部，一三三五卷），为中土一切译师之最。 考古证验 另外，由玄奘大师口述，弟子僧辩机笔撰的《大唐西域记》，堪称中国历史上的经典游记。尤有甚者，由于印度历史纪录的缺乏，这本珍贵的游记更成为历史文化学者研究古天竺地理历史时不可或缺的文献，而近现代以来，根据本书记载所进行之考古遗迹挖掘，亦证明玄奘当时所述真实可信，允为瑰宝。 辩机 辩机迷案 欧阳修所编的《新唐书》记载辩机与高阳公主有私情而被唐太宗赐死，而司马光的《资治通鉴》说法更为具体，辩机是被太宗腰斩。 有学者质疑辩机被太宗所杀之说，认为欧阳修与司马光的立场非常可疑，二者均有激烈鲜明的排佛立场。 许敬宗在《瑜伽师地论》后序写道：“三藏法师玄奘，敬执梵文译为唐语。……弘福寺沙门玄谟，证梵语大总持寺沙门玄应，正字……大总持寺沙门辩机，受旨证文……臣许敬宗，奉诏监阅，至二十二年五月十五日。绝笔。总成一百卷。……僧徒并戒行圆深，道业贞固。”认为若辩机同高阳公主有染，在贞观二十二年即公元648年，许敬宗在给太宗的呈书中又怎么会对玄奘和辩机师徒大加褒奖呢！ 有资料证实辩机被太宗所杀之说为不实之传。《大唐内典录》、《开元释教录》、《贞元新定释教目录》记载永徽元年九月十日至十一月八日玄奘大师于大慈恩寺翻经院译《本事经》，而辩机、静迈、神昉等为笔受。《宋高僧传》卷4之《靖迈传》也同样记载：“同普光寺栖玄、广福寺明𤀹、会昌寺辩机、终南山丰德寺道宣同执笔缀文，翻译《本事经》七卷。”永徽元年为650年，而历史上太宗死于公元649年，从史实资料上来看辩机在太宗死后一年仍在翻经，是不可能为太宗所杀的。 西游记原型人物 唐三藏：玄奘三藏 孙悟空：释悟空（俗名车奉朝） 或者 石槃陀 猪八戒：朱士行 玄奘三藏 神魔小说《西游记》中唐三藏以玄奘三藏为原型。一般人对玄奘的印象多来自《西游记》。 朱士行 朱士行（203年－282年），又称朱子行、朱士衡，法号八戒，颍川（今河南许昌市）人，三国时期魏国佛教僧侣，为汉族地区最早的西行求经僧侣，亦是中国历史上第一位僧人。 他可能是中国著名古典小说《西游记》中人物猪八戒的原型 少年出家为僧，但未受戒。直到公元250年，印度律学沙门昙柯迦罗到洛阳译经，在白马寺建立戒坛，首创戒度僧制度。当时朱士行正在洛阳，立志学佛，首先登坛受戒，成为汉人第一个出家受戒的比丘。 朱士行因《僧祇戒本》而皈依羯磨法，并受戒成为比丘。出家后讲《道行般若经》于洛阳，后感难以理解，决意西行求原经[2]。甘露五年（260年）从长安赴于阗学习直至身故。[3]期间写得梵本《放光般若经》。 西晋太康三年（282年）其弟子法饶送回洛阳，元康元年（291年）由无罗叉和竺叔兰译为汉文[4]。该经文对汉传佛教影响深远[5]。 传说 据说在他圆寂后，当地人按照西域荼毗法焚烧他的遗体时，居然“柴薪灰尽，遗体不损”，种人啧啧称奇。当时有一位高僧合十诵念道：“汝果得道，身自当灭迹，何必如此惊世。”旋即，他的遗体便闻声而化。于是佛门中有句话为“金刚不坏之身”也就由此而来。 释悟空（俗名车奉朝） 悟空（731年－812年），俗姓车，本名奉朝，唐朝僧人，京兆云阳（今陕西泾阳县）人，北魏拓跋氏后裔。 天宝十年（751年）奉旨随中使张韬光等40余人出使西域，因疾遂留居健陀罗国（今巴基斯坦白沙瓦附近，包括阿富汗附近）。至德二年（757年）拜当地三藏法师舍利越魔为师，正式剃度为僧，法号“达摩驮都”，汉译为“法界”，时年27岁。 此后，又去迦温弥罗国（今克什米尔南部）学习佛法，不久，入印度遍游北天竺、中天竺等地，访师求道，巡礼佛迹，苦心学习梵文，历经四年之久，他是中国著名古典小说《西游记》中人物孙悟空的原型。 由于长年在外，离国日久，思恋故乡亲朋，难以自抑，于是向师父提出归国请求，师父怜悯其心，准其所求，临行时送给他三部梵文佛经和佛牙舍利一枚。悟空取道今阿富汗瓦罕走廊进入新疆，在疏勒和于阗等地逗留半年多后，抵达安西四镇治所龟兹（今新疆库车），应当地莲花寺僧人之请，译出《十力经》一卷。随后，转赴庭州（北庭都护府，今新疆吉木萨尔）。当时北庭节度使、御史大夫杨袭古也是一位虔诚的佛教信士，他倡议组织当地龙兴寺僧人和西域高僧尸罗达摩，与悟空合译《十地经》《回向轮经》。悟空在龙兴寺的译经活动，历时十余年，至贞元五年（789年）9月13日全部完成。此时他归心似箭，遂与唐朝庭州官员段秀明、牛昕和程锷同行入朝，由回鹘路（今蒙古）于贞元六年（790年）2月到长安（今陕西西安），因回鹘不信佛法，梵文佛经便藏于龙兴寺，将带回的佛牙舍利及所译经卷进奉入内，经宦官窦文场的奏请，唐德宗敕命车奉朝住长安章敬寺，并赐法号“悟空”。 自离开国到返回长安，前后共计40年，已年逾60，才返回故乡云阳探亲，但此时父母、子侄、家人，已无一人在世。永和七年（812年）1月23日，圆寂于长安护法寺，归葬嵯峨山二台之顶（在泾阳县北部），建振锡寺纪念。贞元十六年（800年）长安高僧圆照奉敕编撰《贞元释教录》，将悟空所译佛经三部十一卷悉数收录。圆照所撰《悟空入竺记》详细记述了悟空求佛事迹。悟空历尽艰辛，学佛译经，为中外文化交流做出了贡献。 石槃陀 石槃陀，或写作石磐陀、石盘陀，姓石，字盘陀[1]，芮乐伟·韩森（Valerie Hansen）认为石姓表明他来自石国（Chach，今乌兹别克斯坦塔什干），盘陀是粟特语Vandak的音译，义为“神的仆人”[2]；生卒年不详，唐朝时胡人，生活在今甘肃省安西县锁阳城（古瓜州东部）一带[3]。事迹载于玄奘法师《大唐西域记》、《大慈恩寺三藏法师传》。 据记载，玄奘法师欲偷渡唐境，前往西域，再绕行印度，然而在边境甘肃瓜州时，苦于没有引路人，虽买了一匹壮马，却为即将面临的茫茫大漠和五座戒备森严的烽火台所困。629年，玄奘在当地弥勒寺的佛像前祈求出现转机，胡僧达摩告之夜梦玄奘坐莲花向西而去，玄奘虽口斥梦本虚妄，但也感到这是即将成行的兆头。果然不久，胡人石槃陀前来礼佛，见玄奘后，绕师三匝行礼并央求玄奘为他授五戒。玄奘为其授戒后，石槃陀辞谢而去，随即送了些饼、果来供养玄奘。玄奘便请求石槃陀作他穿越大漠的向导，石槃陀允诺了。 翌日，石槃陀带来一胡人，胡人又引来一匹赤色马相赠；长安曾有个何弘达占卜先生告诉玄奘“你如果骑一匹赤色的老马，便能平安通过沙漠”，此时玄奘见到赤色马，心喜定能成行。入夜后两人出发，三更时便到达瓠𤬜河（葫芦河），遥见玉门关；石槃陀砍下树木架设了桥梁，渡过了瓠芦河，穿过了玉门关。就在当夜，两人相距五十余步，铺褥休息，但玄奘感觉到一些不对劲，许是石槃陀觊觎玄奘携带的盘缠，许是因当时的官府通令捉拿偷渡者送官，可以得到银两的奖励，又许是石槃陀见莫贺延碛沙漠环境恶劣，产生了退悔心[4]，总之石槃陀表现出异样，他先是抽出短刀，悄悄走向玄奘，走了约十步又折回。玄奘恐石槃陀起了异心，赶忙起身打坐，念诵观世音菩萨圣号，石槃陀见状只好继续躺下。 天亮时，玄奘整装待发，唤石槃陀起身，石槃陀却告之：“前途艰险，只有五座烽台下有水可取，必须夜里去偷取，但凡一座烽台处发现，我们就死定了。”便劝玄奘回国，玄奘誓不至西终不还，石槃陀又拔刀威胁，玄奘依然不从。见状，石槃陀哀求道：“家中上有老下有小，我不敢触犯王法。”玄奘允其离去，石槃陀又说：“如果师父被捉，请不要供出我引路之事。”玄奘发誓绝不出卖他，方辞谢而去。 孙悟空原型说 孙悟空的形象虽然因《西游记》而妇孺皆知，但考古发现早在西夏年间，甘肃省安西县万佛峡的榆林窟内就已经创作出《唐僧取经图》壁画[5]，画中唐僧玄奘身旁跟着一个弟子，头戴金环，尖嘴披髪。此应是唐僧带着“孙悟空”西行的原型，而“沙和尚”的出现要到南宋、“猪八戒”则要等到元代了。学者考证，石槃陀作为胡人，或许比汉人的毛发更加丰富，加之披髪，形象似人似猴，故后人有了想象空间，将石槃陀与猿猴联系起来；同时，石槃陀在传说中以“胡僧”之名示人，很可能讹变为“猢狲”，故也为等同于猿猴添了一笔[2][6]。还有学者认为，壁画中的石槃陀形象，其头上的发箍即“紧箍”的来源[7]。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/mythology/封神演义.html":{"url":"docs/commonsense/mythology/封神演义.html","title":"封神演义","keywords":"","body":"封神演义 参考封神演义(封神榜).xmind.xmind) Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/City/南京.html":{"url":"docs/commonsense/City/南京.html","title":"南京","keywords":"","body":"南京 南京简介 六朝古都、十朝都会 南京是外包之都，互联网沙漠 南京软件外包大道 外包人，外包魂，外包都是人上人 南京和杭州的区别： 1、打12345一打就通，帮你耐心直接转线到相应部门，一步一步教你怎么操作 2、第二天又有人打电话来回访，问你问题解决没有啊，需要帮忙吗 1、杭州一打就40多个人排队，每分钟要按照提示音输入一个1，需要这么频繁输入吗？ 2、等待一刻钟左右，输入了十几个1，总算接通了，对方很不耐烦而且快速的回你自己去咨询XXX电话，一点都听不清楚说的什么 3、打了XXX电话，直接说自己去网上申请，说不清楚YYY填什么，还是不耐烦回自己去找转出地询问 4、杭州是工作人员太少了，搞得都很疲惫还是都是脾气火爆的性格的人 南京简介 南京市，简称“宁”，别称金陵、建业、建康。金陵、建康、应天、天京等“南京”、“建业”、“建康”、“秣陵”、“金陵”和“升州” 先后有东吴、东晋、南朝宋、齐、梁、陈，南唐、明朝、太平天国、中华民国等朝代或政权定都于此，故有“六朝古都”、“十朝都会”之称 著名景点 中山陵、总统府 夫子庙 明孝陵 秦淮河 明城墙 六朝古都、十朝都会 先后有东吴、东晋、南朝宋、齐、梁、陈，南唐、明朝、太平天国、中华民国等朝代或政权定都于此，故有“六朝古都”、“十朝都会”之称 第一朝：东吴 东吴国号并不是东吴，而是吴。是孙权建立的那个国家。也是第一个在南京定都的国家。东吴222年建立，280年被西晋司马炎灭亡。存在了58年。 第二朝：东晋 永嘉之乱之后，司马睿南迁在南京建立了晋，也就是我们所说的东晋。东晋317年建立，420年灭亡。存在了103年，最后被刘裕灭亡。 第三朝：南朝宋 宋武帝刘裕灭了东晋之后建立了宋，标志着进入南北朝。宋是420年建立的，479年被齐取代灭完。宋是南北朝时期南朝存在时间最长的政权。 第四朝：南朝齐 齐是479年建立，502年灭亡。是萧道成建立的。公元502年齐和帝被迫禅位于起兵夺位的将领萧衍。南齐覆灭，南齐是南朝四个朝代中最短命的，仅有二十三年。 第五朝：南朝梁 502年，雍州刺史萧衍取代南齐称帝，建立梁国。南朝开国皇帝梁武帝刚开始的时候也算励精图治，不过后期开始相信佛教，最后被困饿死。557年，两朝被灭。 第六朝：南朝陈 557年，陈霸先代南梁所建立，都建康（今南京），控制江陵以东、长江以南的、交趾以北的地区。不过陈国是南北朝时期南朝最弱的国家，这个时候控制地盘明显不如之前的朝代，国力比较弱小。588年陈国被灭，最后一个国君陈叔宝。 以上就是南京六朝古都中的六朝。南京十朝都会除了包含上面的六个朝代之外，还有以下四个朝代： 第七朝：五代十国南唐 937年，李昪在江南建立的政权，国号唐。南唐是十国里面国力比较强大的。不过宋朝崛起之后，被宋朝在975年灭亡了。最后一个皇帝是李煜。 第八朝：明朝 1368年朱元璋在南京建立明朝。靖难之役之后，朱棣把首都从南京迁到北京。不过南京仍保留首都的头衔，是陪都。南京又一套的官制体系。1644年崇祯皇帝煤山自缢，标志着明朝的灭亡。之后的南明小朝廷没撑几年彻底被灭了。 第九朝：太平天国 1851年太平天国建国，1853年太平天国攻占南京，改南京为天京，定都天京。1864年天京被攻破，太平天国灭亡。 第十朝：中华民国 1927年北伐的时候，蒋介石在南京建立国民政府。1949年人民解放军攻占南京，标志着中华民国的彻底失败。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/City/杭州.html":{"url":"docs/commonsense/City/杭州.html","title":"杭州","keywords":"","body":"杭州 杭州简介 杭州西湖 赖有岳于双少保，人间始觉重西湖 西湖三杰 岳飞 于谦 张苍水 北高峰路线 京杭大运河广场、拱宸桥、运河博物馆 钱江新城灯光秀 西湖：三潭映月、断桥、苏堤、白堤、雷峰塔、灵隐寺 宝石山、 龙井村、十里锒铛 杭州简介 杭州，简称“杭”，古称临安、钱塘 杭州古称“余杭”、“临安”、“钱塘”、“武林”等 杭城 杭州市下辖10个市辖区、2个县，代管1个县级市。 市辖区：上城区、拱墅区、西湖区、滨江区、萧山区、余杭区、富阳区、临安区、临平区、钱塘区 县级市：建德市 县：桐庐县、淳安县 夕照山的雷峰塔与宝石山的保俶塔（“俶”，拼音：chù，注音：ㄔㄨˋ）隔湖相映 西湖十景通常是指南宋时期形成的苏堤春晓、曲院风荷、平湖秋月、断桥残雪、花港观鱼、南屏晚钟、双峰插云、雷峰夕照、三潭印月以及柳浪闻莺这十个景点。 杭州西湖 赖有岳于双少保，人间始觉重西湖 西湖三杰 赖有岳于双少保，人间始觉重西湖 《谒岳王墓》 清代 袁枚江山也要伟人扶，神化丹青即画图。赖有岳于双少保，人间始觉重西湖。 ①谒（yè）：到陵墓致敬。岳王墓：即岳飞的坟墓。②江山：江河和山岭，即大自然的山水。神化：出神入化，形容技艺高妙到了极点。丹青：朱砂和石青，是中国古绘画中常用的颜色。③岳于双少保：指岳飞和于谦，他俩曾官封少保，两人的墓都在西湖边。 西湖三杰 西湖三杰是指岳飞、于谦和张苍水三人 岳飞 岳飞（1103年3月24日－1142年1月27日），字鹏举，宋相州汤阴（今中国河南省安阳市汤阴县）人，抗金名将，又有“民族英雄”称号。官至少保、枢密副使，封武昌郡开国公。 岳飞被宋高宗下令杀害，死后多年宋孝宗为其平反，追谥武穆、后追赠太师、追封鄂王，改谥忠武，故后人称呼岳武穆、武穆王、岳忠武王。明神宗万历帝加封三界靖魔大帝忠孝庙法天尊岳圣帝君，配奉于各地武庙[2]。 著有词作《满江红·写怀》 于谦 于谦（明朝名臣、民族英雄） 于谦（1398年5月13日－1457年2月16日），字廷益，号节庵，官至少保，世称于少保 ，汉族，浙江杭州府钱塘县（今浙江省杭州市上城区）人。明朝名臣、民族英雄。 北京保卫战： 抵御瓦剌大军、瓦剌太师也先 于谦与岳飞、张煌言并称“西湖三杰”。 《石灰吟》：千锤万凿出深山，烈火焚烧若等闲。粉骨碎身浑不怕，要留清白在人间。 张苍水 张煌言（1620年7月8日—1664年10月25日），字玄著，号苍水，浙江鄞县（今宁波市鄞州区）人，汉族，南明儒将、诗人、民族英雄。 北高峰路线 1、坐公交到古荡公交站下车或者地铁古荡站（地铁还在修建）上去（具体路口可以百度）,老和山，将军山上去：住城西，建议将军山上去，在西溪路，古荡对面，那边有个加油站。 2、然后经过老和山、将军山、美女山（大概半小时多点） 3、然后后面就可以到北高峰了，大搞1个小时多 4、下去可以走灵隐寺里面 5、然后到了灵隐寺最下面，就是飞来峰了，就是一个山的侧面有很多石刻 或者 1、从飞来峰进去，然后进去灵隐寺，一直上去就可以到北高峰（这条路比较近，感觉1个小时内就可以上去，暂时没有走过） 其他线路： 登山路线：浙大玉泉校区-老和山-将军山-美女山-灵峰山-桃源岭-北高峰，全程大约2.5小时，总体上是比较轻松的一次徒步，穿行于山林，精神很放松。 爬山线路一：老和山，将军山上去；住城西，建议将军山上去，在西溪路，古荡对面，那边有个加油站的，问一下即可。 峰爬山线路二：从浙大后面的老和山上去的(浙大玉泉校区图书馆右边的那条道)，一直到梅家坞才下山，很远过了北高峰以后山上基本上都没有人，道路为新铺的青石板。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/City/河南.html":{"url":"docs/commonsense/City/河南.html","title":"河南","keywords":"","body":"河南 我就见过一个河南人自黑，说“犯我大河南者，有井无盖”，真的天才。 河南人是中国的黑人 “河南的烟吸不着，河南的酒不中喝，河南的粉条爱粘锅，河南的小鸡孵不活，河南的媳妇骂公婆，河南的小伙儿二尿多，河南的假货没法说，河南的骗子能出国” “十个河南九个骗，总部设在驻马店；九个河南八个偷，指挥机关在郑州；八个河南七个抢，贼子窝窝在洛阳” 十个河南九个骗，总部设在驻马店，剩下一个是教练。 九个河南八个偷，指挥机关在郑州，剩下一个在练手。 八个河南八个抢，贼子窝窝在洛阳，剩下一个在张望。 “十个河南九个骗，总部设在驻马店；九个河南八个偷，机关总部在郑州。” “河南特产：信阳美女，南阳汉，焦作的痞子满街窜。” 大部分段子源头不可考，除了下面这一个：董存瑞跟河南战友炸碉堡，战友让他先撑着炸药包，自己去寻个棍儿来支，河南人一去不回，总攻的号角吹了，董存瑞只好拉了导火索，一边拉一边喊：河南人——你日弄了我……就牺牲了。 1、十亿人民九亿骗, 2、河南人民是教练, 3、十个河南九个骗 4、总部设在驻马店 5、分部设在沁阳县 6、全国都有连锁店 7、炸铁路，抢银行 8、一把大火烧洛阳 9、假电缆，假电线 10、已把中国骗个遍 11、最近上了电力线 12、收购瓷瓶也不善 13、回来翻新赚大钱 14、骗江北，骗江南 15、骗了整个南海岸 16、骗电网，骗供电 17、最近和网连了线 18、发信息，建网站 19、天天都象在大站 20、王式家族最为先 21、找业务，拉客观 22、人人都象大老板 23、三一群，俩一伙 24、骗了车主骗饭店 25、大多都是好良民，要骂河南诈骗人 26、河南骗子比例大，感到光荣不怕骂。 27、河南骗子出现频，惹坏外省评价人。 28、河南没有好心人，那里专出傻流氓。 29、河南坏人心最贱，世界各国排第一。 30、河南出了大傻必，中华大地很有名。 31、我的邻居河南人，正是傻必第一人。 河南为什么被黑得这么惨？丨视知地图炮 消除地域黑的最好方法，是南征北战 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/NFC.html":{"url":"docs/commonsense/NFC.html","title":"NFC","keywords":"","body":"NFC NFC，全称是Near Field Communication，即“近场通信”，也叫“近距离无线通信”。 NFC是一种短距离的高频无线通信技术，允许电子设备之间进行非接触式点对点数据传输。 RFID，Radio Frequency Identification，即射频识别，又名电子标签。 顾名思义，RFID的工作原理就是给一件件物品上贴上一个包含RFID射频部分和天线环路的RFID电路。 NFC与RFID在物理层面看上去很相似，但实际上是两个完全不同的领域，因为RFID本质上属于识别技术，而NFC属于通信技术。 NFC有三种工作模式： 主动模式 在主动模式下NFC终端可以作为一个读卡器，发出射频场去识别和读/写别的NFC设备信息。 被动模式 这个模式正好和主动模式相反，此时NFC终端则被模拟成一张卡，它只在其他设备发出的射频场中被动响应，被读/写信息。 双向模式 在此模式下NFC终端双方都主动发出射频场来建立点对点的通信。相当于两个NFC设备都处于主动模式。 近场通信（Near Field Communication，简称NFC），是一种新兴的技术，使用了NFC技术的设备（例如移动电话）可以在彼此靠近的情况下进行数据交换，是由非接触式射频识别（RFID）及互连互通技术整合演变而来的，通过在单一芯片上集成感应式读卡器、感应式卡片和点对点通信的功能，利用移动终端实现移动支付、电子票务、门禁、移动身份识别、防伪等应用。 近距离无线通信（英语：Near-field communication，NFC），又简称近距离通信或近场通信，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。[1] 三分钟看懂NFCRFID与NFC技术区别与联系近距离无线通信 wiki近场通信 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/SIM卡的PIN码和PUK码.html":{"url":"docs/commonsense/SIM卡的PIN码和PUK码.html","title":"SIM卡的PIN码和PUK码","keywords":"","body":"SIM卡的PIN码和PUK码 常见名词 SIM介绍 SIM卡四种类型的密码 SIM卡大小分类 虚拟SIM技术 USIM卡 RUIM卡 UIM卡 常见名词 SIM（Subscriber Identity Module）：GSM网络 UIM（User Identify Module）：CDMA网络 USIM卡（英语：UMTS Subscriber Identity Module），是用于UMTS网络中的用户身份识别模块。 RUIM卡（Removable User Identity Module）内含可移动用户识别模块(RUIM) SIM大小分类：标准SIM卡、Mini SIM卡、Micro SIM卡、Nano SIM卡 SIM通信协议分类：SIM卡、UIM卡、USIM卡、RUIM卡 虚拟SIM技术：eSIM、softSIM和vSIM，都是虚拟SIM技术。 PIN (Personal Identification Number)：4位，身份认证 PUK (Personal Unblocking Key)：8位，解锁PIN码 PIN2码：主要用于计费等 PUK2码：该密码由运营商提供，可用于在PIN2码输错3次后解锁并重置PIN2码 OTA，也就是Over The Air，空中放号。 SIM介绍 用户身份模块（Subscriber Identity Module，SIM），通常称为“SIM卡”或“电话卡”，是主要用于存储用户身份识别数据、短信数据和电话号码的智能卡。 SIM卡主要用于GSM网络和TD-SCDMA网络，但是兼容的模块也可以用于IDEN电话。有人把CDMA2000和cdmaOne的RUIM卡和UIM卡，也称作SIM卡，虽然两者作用类似，并遵守了一样的所有机械、电气标准和部分软件标准，但是上层应用并不一定兼容。 SIM由CPU、ROM、RAM、EEPROM和I/O电路组成。用户使用SIM时，实际上是手机向SIM卡发出命令，SIM卡应该根据标准规范来执行或者拒绝；SIM卡并不是单纯的信息存储器。 SIM( Subscriber Identity Module)卡是GSM系统的移动用户所持有的IC卡，称为用户识别卡。GSM系统通过SIM卡来识别GSM用户。同一张SIM卡可在不同的手机上使用。GSM手机只有插入SIM卡后，才能入网使用 SIM卡，通常简称SIM，全名是Subscriber Identity Module（用户识别模块），因为它一直以卡片形式存在，所以我们都习惯叫它SIM卡。 实际上，SIM卡是一个装有微处理器的芯片卡。嗯，没错，SIM卡里竟然有个CPU！除了CPU之外，SIM卡上面还有程序存储器ROM、工作存储器RAM、数据存储器EEPROM，以及串行通信单元。是不是觉得很耳熟？对，一台计算机就有CPU、ROM、RAM、I/O设备。所以说，一个SIM卡，基本上就是一个微型计算机了。 SIM卡四种类型的密码 SIM卡内共有四种类型的密码： PIN码（Personal Identification Number，又称PIN1码）：该密码可由用户自行设置，可用于开机解锁等操作，如果输错3次，SIM卡会被锁住，此时需要使用PUK码解锁 PUK码（Personal Unlock Key，又称PUK1码）：该密码由运营商提供，可用于在PIN码输错3次后解锁并重置PIN码，如果输错超过10次，SIM将无法继续使用，此时需要向运营商申请换卡 PIN2码：主要用于计费等，如果输错3次，SIM卡会被锁住，此时需要使用PUK2码解锁 PUK2码：该密码由运营商提供，可用于在PIN2码输错3次后解锁并重置PIN2码，如果输错超过10次，SIM将无法继续使用，此时需要向运营商申请换卡 PIN是指SIM卡的密码，为4位，存在SIM卡中。激活PIN码后，每次开机要输入PIN码才能登入网络，绝大部分手机PIN的出厂值为0000。PUK码是用来解PIN码的万能钥匙，8位长，用户不知道，只有到营业厅由营业员操作。当PIN码输错3次后，SIM卡会自动上锁。此时只有通过输入PUK码才能解锁，共有10次机会输入，超过10次后，SIM卡会自动启动自毁程序，使SIM卡失效，此时，只有重新到营业厅换卡。在使用手机的过程中，用户切莫自行输入PIN码、PUK码，以确保您手机的安全使用和保密性。 PIN (Personal Identification Number)代码旨在保护您的 SIM 卡免遭未经授权的使用。我们为每张 SIM 卡设置了默认 PIN 码 1234。我们建议您更改它。任何人都无法找到更改后的 PIN，因为您将其直接输入到电话中。 PUK (Personal Unblocking Key) 码是由 8 位数字组成的代码。当您输入 3 次错误的 PIN 码时，它用于解锁您的 SIM 卡。被PUK码屏蔽的卡无法解锁；它不能再使用了，您必须更换它。 PUK其实就是PIN解锁码（Personal ldentification NumberUnlock Key）的缩写，它的主要功能就是当SIM卡输入错误的PIN码，导致手机被锁住时用来解锁的码。 [1] 一般来说，PIN码只要连续3次输入错误，手机便会被暂时锁住而无法使用。此时，只要尽快和手机号码所属的系统业者联络，通过身份查验的认证程序后，对方就会给你一组PUK码，只要依据指示就能解锁。 PUK（PUK1）码全称PIN Unlocking Key，是PIN码（PIN1）的解锁码，PUK码（PUK1）由8位数字组成，这是用户无法更改的。当手机PIN码被锁，并提示输入PUK码时，千万不要随意操作，因为PUK码只有10次输入机会，10次都输入错误，SIM卡将会被永久锁死，也就是报废。 所有的移动用户SIM卡密码分为PIN码、PIN2码，PUK码和PUK2码共四种，这四种密码的初始码都是由提供SIM卡的运营商提供的，四种密码的关系如下： PIN码 PIN码（PIN1）就是SIM卡的个人识别密码。如果启用了开机PIN码，那么每次开机后就要输入4位数PIN码，PIN码是可以修改的，用来保护自己的SIM卡不被他人使用。 PUK码 PUK码（PUK1）由8位数字组成，这是用户无法更改的。当手机PIN码被锁，并提示输入PUK码时，千万不要轻举妄动，因为PUK码只有10次输入机会，10次都输错的话，SIM卡将会被永久锁死，也就是报废。 PIN2码 PIN2码是设定手机计费时使用的。如果输入三次错误，手机会需要用PUK2码解锁，过程与先前介绍的PIN码、PUK码相同。不过这两种密码与网络计费及SIM卡内部资料的修改有关，所以不会公开，而且即便PIN2密码锁死，也不会影响手机的正常使用。 PUK2码 PUK2码是用来进入SIM卡下从属功能（如通话计费功能）的解锁码，如果PIN2码三次输错，SIM卡将自动锁定该从属功能，PUK2码由网络运营商提供，由于网络暂不支持故无PUK2码，即使锁了也不影响手机使用。 PIN2用来进入SIM卡下从属功能（如通话计费功能）的密码，如果PIN2码三次输错，SIM卡将自动锁定，必须输入PIN2码的解锁密码（PUK2）。 SIM卡大小分类 独立实体形态的SIM卡，一共有四个标准。 关于SIM卡的变化，大家其实都看得出来了，并不是什么技术演进，说白了，就是剪塑料（剪卡）。 虚拟SIM技术 eSIM是指Embedded-SIM（嵌入式SIM卡），本质上还是一张SIM卡，只不过它变成了一颗SON-8的封装IC，直接嵌入到电路板上。 eSIM是可编程的，支持通过OTA（空中写卡）对SIM卡进行远程配置，实现运营商配置文件的下载、安装、激活、去激活及删除。 前面提到，是GSMA发布了eSIM的规范。而GSMA（GSM协会）是一个代表全球移动运营商利益的组织，按理来说应该抵制才对，为什么会推动eSIM呢？ 因为运营商们根本不是为了手机才推进eSIM的。他们关注的重点，是物联网。 如果说eSIM至少还算是一个硬件，那么，softSIM和vSIM干脆一不做二不休，彻底消灭了硬件。 例如SoftSIM，依托操作系统软件实现SIM功能，没有实际的物理芯片存在，对基带进行修改后，基带重定向直接通过其它接口和操作系统层交互，而不再需要访问SIM硬件。（这应该是虚拟SIM的终极形态吧！） 虚拟SIM技术的未来 eSIM、softSIM和vSIM，都是虚拟SIM技术。 USIM卡 USIM卡（英语：UMTS Subscriber Identity Module），是用于UMTS网络中的用户身份识别模块。USIM卡还可以存储用户资料、电话号码、认证资料及为短信提供存储空间。 USIM卡通常被认为是SIM卡的升级，在LTE网络中必须使用USIM卡，同时USIM卡兼容2G、3G网络。 当用户需在外国使用漫游服务时，可以把原用的USIM卡插入对应该地制式，及兼容此USIM卡的手机以使用漫游服务。 为提供认证服务，USIM卡存储一组长期的加密钥匙K，与网络的认证中心（AuC）共享。USIM卡亦认证一串连续数字，这些数字不可超过一个范围，以避免被重放攻击。 RUIM卡 RUIM是应用在CDMA2000手机的一种智能卡，可插入对应的3G手机以使用移动电话服务。 RUIM卡可以储存使用者资料、电话号码、认证资料及为SMS提供储存空间。 RUIM卡的标准化工作由3GPP2（第三代伙伴计划2）负责进行。 UIM卡 UIM(User Identity Model)，是应用在cdmaOne手机的一种智能卡，可插入对应的2G手机以使用移动电话服务。 UIM卡可以储存使用者资料、电话号码、认证资料及为SMS提供储存空间。UIM卡的标准化工作由3GPP2（第三代伙伴计划2）负责进行。 在cdmaOne系统的原始设计中，用户识别资讯是直接存储在手机中的，并没有一个与手机可以分离的储存用户资讯的功能实体。虽然一些电信业者和制造商希望在cdmaOne系统中也能有一个与GSM系统中的SIM卡类似的设备以实现机卡分离，但这种思想一直没有成为主流思想。直到中国联通公司声明希望在cdmaOne手机上实现SIM卡的功能，才极大地加快了在cdmaOne系统中实施UIM卡的进程。 How to find the PIN and PUK code?PUK码SIM卡SIM卡关于SIM和eSIM，看这一篇就够啦！USIM卡RUIM卡UIM卡 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/不可能的物体.html":{"url":"docs/commonsense/不可能的物体.html","title":"不可能的物体","keywords":"","body":"不可能的物体 不可能的图形（不可能的物体） 1.1 不可能三角：彭罗斯三角（Penrose triangle）是不可能物体中的一种。 1.2 难以捉摸的拱：难以捉摸的拱是由塞尔维亚贝尔格莱德大学的德杨·托多罗维奇先生提出的一种不可能图形。 1.3 无限循环楼梯：彭罗斯阶梯不可能在三维空间内存在，但只要放入更高阶的空间，彭罗斯阶梯就可以很容易的实现。如同莫比乌斯环（带）、克莱因瓶。 1.4 恶魔的音叉：魔鬼叉子（英语：blivet），也被叫作poiuyt（大多数打字机或者拉丁文键盘最上排从右边数起的六个字母），魔鬼叉子或者部件（widget） 1.5 不可能楼梯：爱薛尔创作的不可能图形，无论怎么走都到不了楼梯的顶点。 1.6 不可能方块：不可能方块是由M. C.埃舍尔在版画望楼中创作的一个不可能的物体。 奈克方块（Necker cube） 多稳态知觉 克莱因瓶（Klein bottle） 莫比乌斯带（莫比乌斯环） 奈克方块（Necker cube），或称为内克尔立方体，是一个错视的图像，由瑞士晶体学家路易斯·艾伯特·奈克在其1832年发表的论文中首次提出[1]。 奈克方块是一个由12条线组成的图像，是等大透视的角度绘画一个立方体，等长的平行线不论其远近，在图中会画成等长的平行线，其中没有任何关于立体的资讯。因此对于立方体的放置位置及观看角度会有模棱两可的诠释。 多稳态知觉 多稳态知觉是一种较少见的视知觉现象。多稳态知觉常被描述为在观看一图形时，会主观性的观察到图形无法预期的自发性改变，并且这改变会接续不断发生。 当一个图形对人类的视觉系统来说，是具有歧义性时，就会引发多稳态知觉的现象。如一些知名的例子如奈克方块、运动中探知结构（structure from motion）、单眼竞争（monocular rivalry）和双眼竞争。但更为人所知的是暧昧图形（ambiguous image）。因为这些图形通常会在两种知觉状态之间相互交换，所以又称为双稳态知觉。[1]. 克莱因瓶 在数学领域中，克莱因瓶（Klein bottle）是指一种无定向性的平面，比如二维平面，就没有“内部”和“外部”之分。在拓扑学中，克莱因瓶（Klein Bottle）是一个不可定向的拓扑空间。 克莱因瓶最初由德国几何学大家菲立克斯·克莱因 (Felix Klein) 提出。在1882年，著名数学家菲立克斯·克莱因 (Felix Klein) 发现了后来以他的名字命名的著名“瓶子”。 克莱因瓶的结构可表述为：一个瓶子底部有一个洞，现在延长瓶子的颈部，并且扭曲地进入瓶子内部，然后和底部的洞相连接。和我们平时用来喝水的杯子不一样，这个物体没有“边”，它的表面不会终结。 它和球面不同 ，一只苍蝇可以从瓶子的内部直接飞到外部而不用穿过表面，即它没有内外之分。 莫比乌斯带 公元1858年，德国数学家莫比乌斯（Mobius，1790～1868）和约翰·李斯丁发现：把一根纸条扭转180°后，两头再粘接起来做成的纸带圈，具有魔术般的性质。 普通纸带具有两个面（即双侧曲面），一个正面，一个反面，两个面可以涂成不同的颜色；而这样的纸带只有一个面（即单侧曲面），一只小虫可以爬遍整个曲面而不必跨过它的边缘。 这种纸带被称为“莫比乌斯带”（也就是说，它的曲面从两个减少到只有一个）。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/中国三大电信公司.html":{"url":"docs/commonsense/中国三大电信公司.html","title":"中国三大电信公司","keywords":"","body":"中国三大电信公司 中国移动通信-----chinamobile CMCC 中国联通通讯-----chinaunicom CUCC 中国电信 ------CHINATELECOM CTCC 网通的全称: chinanetcom 他们的官方网址分别是: 电信: http://www.chinatelecom.com.cn 联通: http://www.chinaunicom.com.cn 移动: http://www.chinamobile.com 网通: http://www.chinanetcom.com.cn Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/八卦和六十四卦.html":{"url":"docs/commonsense/八卦和六十四卦.html","title":"八卦和六十四卦","keywords":"","body":"八卦和六十四卦 爻 单卦（经卦） 重卦(别卦)) 八卦/六十四卦 爻 爻（音同肴，汉拼：yáo，注音：ㄧㄠˊ，粤拼：ngaau4）的本义是“交”、“效”，综横之交、阴阳之交，“效”则是通过“交”所产生的“效用”，可以通过全局计算来衡量，依不同方法、体系、定位立极，有相应不同解释。 《易经》八卦中有两个符号，一个是“⚊”，另一个是“⚋”。在《易经》中并没有“阴阳”二字，数百年后的《易传》才把“⚊”叫阳爻，把“⚋”叫阴爻。八卦是以阴阳符号反映客观现象。 “爻”是最基本的符号，意指交错，以奇画（“⚊”称阳爻）或偶画（“⚋”称阴爻）表示。 爻有阴、阳两种仪态，若两两相重则形成四象（太阳、少阴、少阳、太阴）。四象再增加一爻，就形成八卦。 爻自下而上排列。“三个”爻的含义，象征着“天人地”（上有天、下为地、人在其中）。 单卦（经卦） 由三个爻可组成一个单卦（经卦）。 八卦，意谓八个单卦（八个经卦）。 重卦(别卦) 经由八卦可再演化出六十四卦。两个八卦相叠(复卦)，即成八八六十四卦。 六十四卦，意谓六十四个重卦(六十四个别卦)。亦即八个“单卦”(经卦)如经纬交织组成六十四个“重卦”(别卦)。 在下的单卦称“内卦”，上者则称其“外卦”。 八卦/六十四卦 ☰ 乾三连 天 乾qián☷ 坤六断 地 坤kūn☵ 坎中满 水☲ 离中虚 火☳ 震仰盂 雷 震zhèn☴ 巽下断 风 巽xùn☶ 艮覆碗 山 艮gèn☱ 兑上缺 泽 兑duì 八卦是《易经》的基本概念，可代表一切自然现象的动静状态，每个卦由三个爻组成。 天为象。一种卦可挂在很多很多的现象，但不是任意挂，有特定的规则。每一现象都可以找到一种卦去挂，也不是任意的。先有象，后有卦。万象纳入八卦，八卦悬挂万象。将万象以八卦作为模型，硏究理解八卦这个模型，有助理解万象。 易经八卦的产生可回溯至河图与洛书，以及太极。 太极生两仪、两仪生四象、四象生八卦、八卦定吉凶、吉凶生大业。 若将八卦两两相重，形成六十四卦。原本八卦（三个爻）亦称为八个“单卦”，而两个八卦上下组合（六个爻）则称“重卦”。 在下的单卦称“内卦”，上者则称其“外卦”。 每一卦代表一种状态或过程。 宋代朱熹在《周易本义》中写了一首《八卦取象歌》帮助人记住八卦的卦象： 乾三连（☰），坤六断（☷）； 震仰盂（☳），艮覆碗（☶）； 离中虚（☲），坎中满（☵）； 兑上缺（☱），巽下断（☴）。 宋朝学者邵雍认为四象演八卦（方位），八八生成六十四卦，此为伏羲八卦，也叫先天八卦； 亦有学者认为八卦应该出自周文王的乾坤学说，他认为先有天地，天地相交而生成万物，天即乾，地即坤，八卦其余六卦皆为其子女：震为长男，坎为中男，艮（普通话读音：gèn；国语注音：ㄍㄣˋ；粤音：gan3，同“觐”）为少男；巽（普通话读音：xùn；国语注音：ㄒㄩㄣˋ；粤音：seon3，同“逊”）为长女，离为中女，兑为少女，是为文王八卦，又称后天八卦。 参考八卦 wiki六十四卦周易六十四卦列表 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/关内、关外、关中、关东.html":{"url":"docs/commonsense/关内、关外、关中、关东.html","title":"关内、关外、关中、关东","keywords":"","body":"关内、关外、关中、关东 明长城地图 关内：指长城山海关以西或嘉峪关以东一带地区，秦汉时期指潼关以西的渭河平原（关中地区），也称关中谷地。 关外：指长城山海关以东或嘉峪关以西一带地区。 关中：秦汉时候此关指函谷关所谓关中是陕西渭河流域的平原地区。 关东：明代以来对山海关以东地区的称呼，又称“关外”；相当于中国东北地区，包括辽宁、吉林、黑龙江等省份 嘉峪关： 嘉峪关位于甘肃省嘉峪关市向西5公里处，是明长城西端的第一重关，也是古代“丝绸之路”的交通要冲。 嘉峪关关城，位于嘉峪关最狭窄的山谷中部，地势最高的嘉峪山上，城关两翼的城墙横穿沙漠戈壁。嘉峪关以地势险要，巍峨壮观著称于世，被称为“天下第一雄关”。与千里之外的“天下第一关”——山海关遥相呼应，闻名天下。 山海关： 山海关位于中华人民共和国河北省秦皇岛市山海关区与辽宁省的省界附近，又名渝关、榆关[1]。 山海关位于燕山和渤海之间，是明长城最东端的关隘，故而被称为“天下第一关”。 此处早在战国时期就曾修筑有长城，明洪武十四年（1381年）修筑现有关隘，自此山海关成为地理分界，该关口以东区域被称为“关外”。 明长城 明长城，为明朝从洪武帝至万历帝的二百多年，经过20次大规模的修建，筑成的一条西起甘肃嘉峪关，东至辽东虎山，全长8851.8公里的长城[1]。这也是现在所见到的大部分完整长城。 辽宁 位于辽宁省的明代万里长城，亦称辽东边墙，东起丹东市宽甸鸭绿江畔的虎山，西至辽宁省绥中县锥子山与河北省明长城相接。 虎山长城 河北 位于河北省的明代万里长城，东起秦皇岛市山海关老龙头，西至河北张家口地区怀安县马市口村进入山西省天镇县界。同时由北京市怀柔区结起一道内长城，经八达岭后进入河北省怀来县，复入北京市门头沟区，然后再进入涿鹿县，至涞源县，由涞源县七亩地村进入山西灵丘县境内。 山海关 大境门 天津 黄崖关 北京 北京段明长城由河北蓟县进入北京平谷县彰作关，经密云县到怀柔区北京结地区分为两叉，外线长城向北经延庆四海冶由白河堡附近出北京进入河北赤城县境内，内线长城经昌平、延庆、河北怀来县，复入北京门头沟地区，再从东灵山地区出北京市。北京段明长城在明十三陵外存在多道长城。 居庸关 山西 平型关 雁门关 娘子关 陕西 陕西省长城东起清水营（今陕西府谷县东北），经过府谷县﹑神木县﹑榆阳区﹑横山县﹑靖边县﹑吴起县﹑定边县七县区。西至花马池（今宁夏盐池县东北）。成化年间由延绥镇巡抚都御史余子俊率领将士4万人历时3月筑成。 宁夏 宁夏位于黄河河套，自古为兵家必争之地。《读史方舆纪要》称其为“关中之屏蔽，河陇之上噤喉”。宁夏长城位于黄河之东，所以被称为“河东墙”，每隔30里修筑一军堡，每隔60里筑一城。明朝中叶后放弃内蒙古河套平原，退守宁夏。[7] 甘肃 位于甘肃嘉峪关市的一段明长城，又称“悬壁长城” 嘉峪关 青海 明廷在青海浩门城、门源城、永安城皆修建有长城，长约360公里。至今大都损毁严重。 湖南 主条目：苗疆长城 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/切尔诺贝利核电站爆炸.html":{"url":"docs/commonsense/切尔诺贝利核电站爆炸.html","title":"切尔诺贝利核电站爆炸","keywords":"","body":"切尔诺贝利核电站爆炸 核电站： 1、核裂变：链式反应（雪崩效应） U235 + 一个中子 --> Ba141 + Kr90 + 3个中子 反应物质量>生成物质量 --> 出现质量亏损 --> 放出热能 --> 蒸汽机+ 发电机 --> 电能 2、切尔诺贝利核电站：RBMK 或者叫 石墨沸水堆 燃料棒：U235，在水道中 水：水轮机带进冷水，带走热量，生成蒸汽，涡轮机发电 石墨：减速中子，撞到石墨，便于U235捕获，便于促进发生链式反应 控制棒：吸收中子，减慢链式反应 插入控制棒：减速链式反应 拔出控制棒：加速链式反应 3、切尔诺贝利核电站爆炸： 核反应后的生成物也会衰变，产生余热，如果不处理，过热发生问题 断电后，怎么保证水轮机可以继续转动使冷水循环，带走余热 因为水轮机停止工作，会导致过热，只能倚赖紧急柴油发电机驱动电子系统与冷却系统。 因为关闭自动控制，拔掉过多的控制棒，反应过于剧烈，可能过热爆炸，自动控制被关闭处理不了 于是按下紧急停机按钮，使其放下控制棒，但是核反应堆出于某些原因，在控制棒下面有一段石墨，放下来初期反而加快核反应，过热导致燃料棒变形，控制棒放不下来，然后就发生了爆炸，堆芯熔毁，爆炸后出现石墨等 图片来自https://www.youtube.com/watch?v=Cc-xlILOeEM 切尔诺贝利核事故（俄语：Авария на Чернобыльской АЭС，乌克兰语：Чорнобильська катастрофа，英语：Chernobyl disaster），或简称切尔诺贝利事件，是1986年4月26日于苏联乌克兰普里皮亚季市切尔诺贝利核电站发生的核反应堆破裂事故。该事故是历史上最严重的核电事故，也是首例被国际核事件分级表评为最高第七级事件的特大事故。事故的主因为反应堆进行紧急停机后的后备供电测试时，因操作人员的训练不足，最终使功率急剧增加，破坏反应堆。与早期各国核反应堆类似，RBMK-1000缺乏严重意外下的多重防护措施，设计缺陷使大量的放射性物质被释放到环境中。最初发生的蒸气爆炸导致两人死亡，接踵而至的绝大部分受害者的病因及死因都归咎于事故中释放的高能量辐射，然而辐射尘少量放射导致的影响依旧争论不休。在苏联建成使用的与切尔诺贝利4号机组同型号的15座RBMK-1000反应堆中，除切尔诺贝利的4座于2000年前被相继关闭外，其余11座均运行至今，预计在2019年后逐步关闭。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/古代四大文明和七大奇迹.html":{"url":"docs/commonsense/古代四大文明和七大奇迹.html","title":"古代四大文明和七大奇迹","keywords":"","body":"古代四大文明和七大奇迹 参考古代四大文明和七大奇迹.xmind 四大文明古国（Four ancient civilizations） 世界七大奇迹（Seven wonders of the world） 所属文明：华夏(中国)、古巴比伦、古埃及、古印度 现今位置：中国、伊拉克、埃及、印度 中国黄河流域、美索不达平原两河流域、埃及尼罗河流域、印度河流域 以长江黄河为中心的华夏文明、以两河流域为中心的古巴比伦文明、以尼罗河为中心的古埃及文明、以印度河为中心的古印度文明。 中国（位于东亚） 古巴比伦（位于西亚，今地域属伊拉克）、 古埃及（位于西亚及北非交界处，今地域属埃及）、 古印度（位于南亚，地域范围包括今印度、巴基斯坦等国） 目前世界公认的四大文明是中国文明，印度文明，埃及文明，两河文明。 世界七大奇迹（Seven wonders of the world）即古代世界七大建筑奇迹：大多已经毁灭，只有埃及胡夫金字塔得以保存至今 埃及胡夫金字塔、 巴比伦空中花园、 阿尔忒弥斯神庙、 奥林匹亚宙斯神像、 摩索拉斯陵墓、 罗德岛太阳神巨像 亚历山大灯塔。 胡夫金字塔（埃及吉萨，仍存在） 空中花园（伊拉克巴比伦，毁于地震） 奥林匹亚宙斯神像（希腊奥林匹亚，毁于火灾） 阿耳忒弥斯神庙（土耳其以弗所，毁于火灾） 摩索拉斯王陵墓（土耳其哈利卡纳苏斯，毁于地震） 罗得岛太阳神铜像（希腊罗得港，毁于地震） 亚历山大灯塔（埃及亚历山大，毁于地震） 世界中古七大奇迹： 意大利的罗马大斗兽场， 利比亚沙漠边缘的亚历山大地下陵墓， 英格兰的巨石阵， 中国的万里长城， 中国南京的大报恩寺琉璃宝塔， 意大利的比萨斜塔， 土耳其的索菲亚大教堂（圣索菲亚大教堂）。 四大文明古国（Four ancient civilizations） 像苏美尔文明、玛雅文明、古印度文明这些夭折的文明，我认为是发展不健康的文明，有缺陷的文明，比如玛雅人的天文历法相当的厉害，甚至现在的人都怀疑是外星人的后羿，古埃及文明的建筑艺术登峰造极，也有人怀疑是外星人帮忙，但古埃及部分文明甚至到了中国才得以保存，玛雅文明现在学术界探讨最多的也是它为什么消失，古埃及文明已经人去楼空，就剩几座金字塔和几具木乃伊，挽歌都唱不起来了。 苏美尔（阿卡德语：Šumeru；苏美尔语：𒆠𒂗𒂠，ki-en-ĝir15）为目前发现于美索不达米亚文明中最早的文明体系，同时也是全世界最早产生的文明之一。 苏美尔文明主要位于美索不达米亚的南部，通过放射性碳十四的断代测试，表明苏美尔文明的开端可以追溯至公元前4500年。在约公元前2000年结束，被亚摩利人建立的巴比伦所代替。 这里发现的含有楔形文字前文字的最古老的石板被定期为距今约56世纪前。苏美尔人被认为发明了世界上最早的文字，他们在粘土片上书写自己的文字。 四大文明古国，华夏是内地关于世界四大古代文明的统称。分别是 古巴比伦（位于西亚，今地域属伊拉克）、 古埃及（位于西亚及北非交界处，今地域属埃及）、 古印度（位于南亚，地域范围包括今印度、巴基斯坦等国）和 中国（位于东亚）。 四大文明古国，实际上对应着世界四大文明发源地，分别是两河流域、尼罗河流域、恒河流域、黄河流域这四个大型人类文明最早诞生的地区，而稍后的爱琴文明未被包含其中。 四大古文明的意义并不在时间的先后，而在于它们是后来诸多文明的发源地，对其所在地区产生了巨大影响。四大文明是原生文明，而其他文明属于派生文明，深受临近地区原生文明的影响。 [2] 世界七大奇迹（Seven wonders of the world） 世界七大奇迹（Seven wonders of the world）即古代世界七大建筑奇迹，是指古代已知世界上的七处宏伟的人造景观。最早提出世界七大奇迹的说法的是公元前3世纪的旅行家安提帕特，还有一种说法是由公元前2世纪的拜占庭科学家斐罗提出的。 世界七大奇迹是指古代西方人眼中已知世界上的七处宏伟的人造景观。最早提出世界七大奇迹的说法的是公元前三世纪的旅行家昂蒂帕克，还有一种说法是公元前二世纪的拜占庭科学家斐罗提出的。 “七大奇迹”指的是公元前三世纪左右，在地中海东部沿岸地区七座宏伟的建筑和雕塑。它们是：埃及胡夫金字塔、巴比伦空中花园、阿尔忒弥斯神庙、奥林匹亚宙斯神像、摩索拉斯陵墓、罗德岛太阳神巨像和亚历山大灯塔。 由于上述奇迹大多已经毁灭，后人又提出了世界中古七大奇迹。即意大利的罗马大斗兽场，利比亚沙漠边缘的亚历山大地下陵墓，英格兰的巨石阵，中国的万里长城，中国南京的大报恩寺琉璃宝塔，意大利的比萨斜塔，土耳其的索菲亚大教堂（圣索菲亚大教堂）。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/各种单位换算.html":{"url":"docs/commonsense/各种单位换算.html","title":"各种单位换算","keywords":"","body":"各种单位换算 时间单位换算 时间单位换算 1s(秒)=10^3ms(毫秒)=10^6μs(微秒)=10^9ns(纳秒)=10^12ps(皮秒)=10^15fs(飞秒)=10^18as(阿秒)=10^21zm(仄秒)=10^24ym(幺秒) 秒 seconds 毫秒 millisecond 微秒 microsecond 纳秒 nanoseconds 皮秒，符号ps（英语：picosecond ） 飞秒（femtosecond） 阿秒(AttoSecond) 仄秒(zeptosecond) 幺秒(yoctosecond) 千秒（ks）：103秒 1千秒（kilosecond）即1000秒，相当于16分钟40秒，或16又2/3分钟。 兆秒（Ms）：106秒 1兆秒（megasecond）即1000千秒，相当于约11.57天(或277小时， 46分钟， 40秒。) 吉秒（Gs）：109秒 吉秒（英文：Gigasecond，符号 Gs），1吉秒等于1,000,000,000秒，大概等于31.7年。 在典型PC机上各种操作的近似时间： 执行典型指令 1/1,000,000,000 秒 =1 纳秒 从一级缓存中读取数据 0.5 纳秒 分支预测错误 5 纳秒 从二级缓存中读取数据 7 纳秒 互斥锁定 / 解锁 25 纳秒 从主存储器中读取数据 100 纳秒 在 1Gbps 的网络中发送 2KB 数据 20,000 纳秒 从内存中读取 1MB 数据 250,000 纳秒 从新的磁盘位置读取数据 ( 寻轨 ) 8,000,000 纳秒 从磁盘中读取 1MB 数据 20,000,000 纳秒 在美国向欧洲发包并返回 150 毫秒 =150,000,000 纳秒 古籍中的时间长度 佛教梵典《摩诃僧祇律》这本书中记载着： 一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾。日极长时有十八须臾，夜极短时有十二须臾；夜极长时有十八须臾，日极短时有十二须臾。 根据这段文字所推算出的具体时间： 一昼夜 ＝ 30须臾 ＝ 600罗预 ＝ 12000弹指 ＝ 240000瞬间 ＝ 4800000刹那 因为一昼夜＝86400秒，因此把每个单位换算成秒数，可以得到： 一“须臾” ＝ 2880秒（48分钟） 一“罗预” ＝ 144秒（2.4分钟） 一“弹指” ＝ 7.2秒 一“瞬间” ＝ 0.36秒 一“刹那” ＝ 一“念”之间＝0.018秒 数量级 (时间)) Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/工作总结和绩效考核.html":{"url":"docs/commonsense/工作总结和绩效考核.html","title":"工作总结和绩效考核","keywords":"","body":"工作总结和绩效考核 绩效考核的方法 工作总结 工作周报怎么写 绩效考核的方法 目标和关键成果法（Objectives and Key Results，OKR）。 关键绩效指标（KeyPerformance Indicator，KPI） 关键事件法（Critical Incident Method，CIM） 目标管理（Management By Objective，MBO） 平衡记分卡（The BalanceScore-Card，BSC） 360度绩效评估法 大型企业，建议BSC、360度、OKR（行业垄断企业）、NKEP 中型企业：MBO、KPI、CIM、KPI、OKR、NKEP 小型企业：KPI、MBO、CIM、NKEP SMART原则 SMART原则:管理和绩效考核标准 SMART原则(S=Specific、M=Measurable、A=Attainable、R=Relevant、T=Time-bound)，实施目标管理不仅是为了利于员工更加明确高效地工作，更是为了管理者将来对员工实施绩效考核提供了考核目标和考核标准，使考核更加科学化、规范化，更能保证考核的公正、公开与公平。 SMART原则是目标管理中的一种方法。目标管理的任务是有效地进行成员的组织与目标的制定和控制以达到更好的工作绩效，由管理学大师彼得·杜拉克于1954年首先提出。SMART原则便是为了达到这一目的而提出的一种方法，目前在企业界有广泛的应用。 SMART原则中的“S”、“M”、“A”、“R”、“T”五个字母分别对应了五个英文单词：Specific（明确）、Measurable（可衡量）、Achievable（可达成）、Relevant（相关）和Time-bound（有时限）。 绩效考核一定遵循SMART原则，Specific具体的，不是模糊的定义，Measurable，可测量的，即判断有依据，Attainable，可达到的，不能不可实现，Relevent, 相关性的，也就是能够反映工作绩效的，Time-based,就是说要确定周期。 MBO、KPI、BSC、360度、CIM等绩效考核的方法谷歌内部考核制度 OKR 是怎样的？OKR和KPI有什么区别？OKR vs. KPI: How they compare and work together 工作总结 年中总结和年终总结 总结-复盘 复盘的能力，是每个职场人必备的。 你在和领导汇报时，讲自己做了些什么，怎么做的。关注的是What和How。 但是领导在和他的上司沟通中，要讲的是Why Why-为什么要这么做？ Why this-只能这么做吗？有其他选择？ Why now-必须现在做吗？优先级上有更重要的吗？ 比如一个文章讲解CR（Code Review） what—什么是CR Why—为什么要引入CR Who—参与CR的主体 Where—不同的研发节点进行CR when--什么时候引入CR How--如何进行CR 重要项目汇报结构：使用STAR原则进行介绍——Situation/项目背景；Target/项目目标；Action/项目中采取行动；Result：项目结果 若您不是项目owner，则需要额外细化到个人在项目中的角色和分配到的任务 年终总结的意义何在？你们都是怎么写年终总结的？如何写自己的绩效评估 工作周报怎么写 1、本周工作 2、下周计划 3、风险及问题 PDCA循环 PDCA循环的含义是将质量管理分为四个阶段，即Plan(计划)、Do(执行)、Check(检查) 和 Act(处理)。 PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Act(处理)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。 我们可以用“5W2H”方法，去系统地确定具体的行动方案： ①what(做什么）：要实现的目标和要交付的成果； ②WHY（为什么）：公司的目标和部门的计划； ③WHO（谁来做）：主要负责人、核心负责人以及其他参与人员； ④WHEN（什么时候完成）：工作排期和截止时间； ⑤HOW（怎么做）：关键结果和具体实施方案； ⑥WHERE（在哪里做）：在什么地方进行这项工作； ⑦HOW MUCH（需要多少资源）：具体的预算、人员安排等支持。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/手机OTG功能.html":{"url":"docs/commonsense/手机OTG功能.html","title":"手机OTG功能","keywords":"","body":"手机OTG功能 OTG概念 存在即有理，手机的基本功能就是通讯和数据处理，而OTG功能就是对数据处理功能的扩展，OTG从其出现就是为了在设备间进行数据交换。从这个层面上说，虽然很多人都不知道手机有这个功能，但其存在非常必要。 OTG是On-The-Go的缩写，此技术于2001年12月18日由USB Implementers Forum公布，在2014年左右开始在市场普及。OTG技术主要是基于USB技术的发展和普及而来，完全兼容USB2.0协议。 OTG是On-The-Go的缩写，是近年发展起来的技术。主要应用于各种不同的设备或移动设备间的联接，进行数据交换。OTG U盘就是支持OTG技术的U盘，可以u盘连接手机，也可以手机连接u盘。现在OTG U盘基本上是一个标准USB接口(连电脑等设备)和一个Micro USB接口(链接手机)。 USB On-The-Go通常缩写为USB OTG，是USB 2.0规格的补充标准。它可使USB设备，例如播放器或手机，从USB周边设备变为USB主机，与其他USB设备连接通信。在正常情况下，这些支持OTG的USB设备和USB主机（如台式机或者笔记本电脑），仍然作为USB周边设备使用。 使用OTG可以脱离计算机设备，利用各种设备上的USB口进行数据交换。解决了各种设备间不同制式的连接接口的数据交换不便的问题。 也就是说，OTG主要应用于各种不同的设备（包括移动设备）间的联接，尤其是现在市面上琳琅满目的各种移动电子设备，比如平板电脑、移动电话、打印机、消费类电子设备等。目前市面上的智能手机上基本都支持OTG。 支持OTG的设备，如USB打印机，可以不连接电脑的情况下直接接入U盘来读取设备内文件进行打印；或平板电脑可以直接接入USB存储碟、键盘或鼠标来扩充外界硬件功能。 OTG功能有哪些?OTG U盘在USB端搭载USB 3.0高速传输规范与PC传输稳定快速，要传资料时，再也不用四处找数据线了。而另一端的Micro USB接口，可适配于Android手机、平板计算机，实时传输音乐、照片、电影及录像，轻松分享精彩的移动生活。运用双头功能，节省多设备间传输的时间，令分享简单又轻松! 现在还有些 OTG U盘 自带软件可以帮助用户整理归类设备自身以及优盘中的资料。当我们需要使用时，再也不用每个文件夹打开细细找，通过文件类型就可以轻松找到。灵活运用于在工作事业上，为您的效率、专业形象更加分。 OTG分类 鉴于设备接口及USB类型的不一致，一般OTG有如下几类： USB2.0 OTG：包括Micro 5PIN OTG（常见安卓手机）、Mini 5PIN OTG（常见安卓平板） Micro USB3.0 OTG：三星Note3、Galaxy S5等在2016年以前的安卓手机OTG接口 Type-C OTG：目前支持Type-C接口的设备（比如小米Mix系列等） Lightning OTG：苹果手机专用OTG OTG应用场景 数据传输 系统重做（刷机） 外接设备 临时反向充电 USB On-The-Go维基百科OTG是何物，手机的OTG功能还有存在的必要么？OTG是什么意思 OTG功能有哪些【详解】（中文）USB OTG（On-The-Go）简介（英文）USB On-The-Go官方网站 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/方舱医院.html":{"url":"docs/commonsense/方舱医院.html","title":"方舱医院","keywords":"","body":"方舱医院 方舱医院是一种以方舱形式快速建成的模块化医院，这里指的是直接透过征用空间进行设置的大型医疗隔离所，有些甚至是大型活动场地与休课高校改建的。 由于2019冠状病毒病疫情的爆发，一般医疗院所以及新扩建的肺炎专科医院仅收容重症患者人满为患，而家庭自主隔离者仍能感染家人与社区成员，使疫情风险增大。 在此情况下，改以采取轻症状者集中收治的原则进行传染病控管，中华人民共和国政府于湖北省武汉市内建立了16所方舱医院，共提供2万多个床位[1]。 2020年3月10日，武汉武昌洪山体育馆方舱医院收治的病患全部出院。至此，武汉市全部16家方舱医院皆完成任务，休舱停运。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/移动通信标准和分类.html":{"url":"docs/commonsense/移动通信标准和分类.html","title":"移动通信标准和分类","keywords":"","body":"移动通信标准和分类 1G - First Generation 2G - Second Generation：GSM、CDMA 3G - Third Generation：WCDMA、CDMA2000、TD-SCDMA、WiMAX 4G - Fourth Generation 5G - Fifth Generation SMS：Short message service (SMS) MMS：Multimedia Messaging Service MMS 多媒体短信（英语：Multimedia Messaging Service，缩写：MMS）是传送文字、图片、动画、音频和视频等多媒体信息的功能，中国移动公司称其为“彩信”。这是移动电话接收和发送多媒体信息的一种方式。与只能传送160字符的短信相比，多媒体短信扩充了收发文本的长度。 1G 1G时代的摩托罗拉与大哥大 2G Global System for Mobile communication (GSM) GSM是Global System for Mobile Communica TI ons，中文为全球移动通讯系统，是一种源于欧洲的无线通信技术， 当前我们用的移动和联通的网络就是GSM制式， 如果GSM网络能够提供GPRS上网，则称为2.5G;如果GSM网络不能提供GPRS则称为2G网络。 Code Division Multiple Access(CDMA) 码分多址是指利用码序列相关性实现的多址通信 [1] ;码分多址(CDMA)的基本思想是靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波(为同一载波)既受基带数字信号调制，又受地址码调制。 3G 第三代移动通信技术（3G），是指支持高速数据传输的蜂窝移动通讯技术。国际电信联盟(ITU)确定3G通信三大主流标准是W-CDMA(宽带码分多址接入)、CDMA2000(码分多址接入)和TD-SCDMA (时分同步码分多址接入)，WiMAX是继W-CDMA、CDMA2000、TD-SCDMA后的第四个3G标准。 WCDMA 4G 长期演进技术（英语：LTE，Long Term Evolution） LTE 全球4G通信标准（移动、联通、电信） LTE是第四代移动通信技术制式,其中分为LTE TDD和LTE FDD 两种,LTE TDD在中国的名字叫TD-LTE 双工方式分为FDD（频分双工）和TDD（时分双工） IMT唯一承认的4G是LTE-Advanced（LTE-A，增强版的LTE） IMT-Advanced的4G标准 1、LTE-Advanced（长期演进技术升级版）：是LTE的升级演进，由3GPP所主导制定，完全向后兼容LTE，通常通过在LTE上通过软件升级即可，升级过程类似于从W-CDMA升级到HSPA。峰值速率：下行1Gbps，上行500Mbps。是第一批被国际电信联盟承认的4G标准，也是事实上的唯一主流4G标准。另有TD-LTE的升级演进TD-LTE-Advanced（TD-LTE-A）。 - LTE FDD（频分双工长期演进技术）：最早提出的LTE制式，目前该技术最成熟，全球应用最广泛，终端种类最多[5]。峰值速率：下行150Mbps，上行40Mbps[6]。 - LTE TDD（时分双工长期演进技术）：又称TD-LTE，是LTE的另一个分支。峰值速率：下行100Mbps，上行50Mbps。由上海贝尔、诺基亚西门子通信、大唐电信、华为技术、中兴通信、中国移动、高通、ST-Ericsson等业者共同开发。 2、WirelessMAN-Advanced（无线城域网升级版）：又称WiMAX-Advanced、WiMAX 2，即IEEE 802.16m是WiMAX的升级演进，由IEEE所主导制定，接收下行与上行最高速率可达到100Mbps，在静止定点接收可高达1Gbps。[7]也是国际电信联盟承认的4G标准，不过随着Intel于2010年退出，WiMAX技术也已经被运营商放弃，并开始将设备升级为TD-LTE。[8] 分时长期演进（英语：Long Term Evolution，Time-Division Duplex，简称“LTE-TDD”）是基于3GPP长期演进技术（英语：LTE）的一种通讯技术与标准，属于LTE的一个分支。该技术由上海贝尔、诺基亚西门子通信、大唐电信、华为技术、中兴通信、中国移动、高通、ST-Ericsson等业者共同开发。 TDD即指时分双工（英语：Time-division duplex），LTE更加普遍使用的是FDD即频分双工（英语：Frequency-division duplex）。 值得注意的是，中国媒体普遍将TD-LTE宣传为中国国产标准，事实上其技术属于LTE（长期演进技术）。 正因为都是LTE的分支，LTE-TDD与LTE-FDD标准的重合度很高，差别不大，也各有优缺点。两者分别跟3G的TD-SCDMA和WCDMA的继承性不大，LTE-FDD跟WCDMA的继承性甚至更小。 中国政府和企业是TD-LTE的主要推动者。LTE-TDD技术主要吸引了三类运营商，分别是：PHS运营商、WiMAX运营商、以及大量持有持零散频谱的非对称频段的小规模运营商。 What are the differences between 2G, 3G, 4G LTE, and 5G networks?1G Vs. 2G Vs. 3G Vs. 4G Vs. 5GFrom 1G to 5G: A Brief History of the Evolution of Mobile StandardsGSM、TD-SCDMA、WCDMA、LTE 蜂窝网络 蜂窝网络（英语：Cellular network），又称移动网络（mobile network）是一种移动通信硬件架构，分为模拟蜂窝网络和数字蜂窝网络。由于构成网络覆盖的各通信基地台的信号覆盖呈六边形，从而使整个网络像一个蜂窝而得名。 常见的蜂窝网络类型有：GSM网络（有些国家叫pcs-1900）、CDMA网络、3G网络、FDMA、TDMA、PDC、TACS、AMPS等。 蜂窝网络的组成：蜂窝网络组成主要有以下三部分：移动站，基站子系统，网络子系统。 移动站就是我们的网络终端设备，比如手机或者一些蜂窝工控设备 。 基站子系统包括我们日常见到的移动基站（大铁塔）、无线收发设备、专用网络（一般是光纤）、无数的数字设备等等的。我们可以把基站子系统看作是无线网络与有线网络之间的转换器。 蜂窝式移动通信网络一般就是代指采用蜂窝组网结构的公众移动通信网络，从俗称的1G（第一代移动通信网络）到现在的4G都可以算作是蜂窝式移动通信网络。 但现实中因为地形以及用户量分布不均、建网/建站的规划、现实站址的选择和各代技术的更新迭代（比如从GSM的异频组网到现在3G和LTE的同频组网）等等种种原因，我们现在的2G、3G、LTE网络已经不能算是严格意义上的“蜂窝式”网络了，至少看起来已经不像”蜂窝“了。但是估计是已经叫习惯了，或者是为了纪念，所以一直沿用蜂窝网络这个名词来称呼公众移动通信网络吧。 蜂窝网络，英语是Cellular network。普遍来说，「蜂窝网络」和「移动网络（英语：Mobile network）」是一回事，是一个概念的两个名称，这个概念由贝尔实验室在1970年代发明。 蜂窝网络指的是一种移动通信的硬件架构，它可以分为两种：模拟蜂窝网络和数字蜂窝网络。之所以叫作「蜂窝」网络，原因在于这种网络的基本组成部分——通信基站，它们的信号覆盖范围是六边形的，整个网络就像蜂窝，所以这种网络就被命名为蜂窝网络了。 蜂窝网络又有多种技术类型，当前，全球主流的蜂窝网络类型包括：2G时代的GSM、3G时代的WCDMA／CDMA2000，以及4G时代的LTE／LTE－A等。 我们现在家用Wi-Fi的设备，一般称为路由器或者无线接入点AP（Access Point），其实Wi-Fi发展早期的时候，接入的中心其实就叫做基站。 蜂窝，到底跟移动通信网有啥关系？蜂窝网络百度百科 蜂窝网络维基百科蜂窝移动网络是什么？它和 Wi-Fi 有什么区别什么是蜂窝网络Cellular network？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/网络流行语.html":{"url":"docs/commonsense/网络流行语.html","title":"网络流行语","keywords":"","body":"网络流行语 饭圈，就是粉丝圈子的简称，指的是粉丝群体，具体来说，某明星的粉丝在一起组成一个团体就是一个饭圈。 “天王盖地虎”是什么梗 作为网络流行语的该词常常作为一种暗号暗语来被大家使用，借此来寻找志同道合的朋友。 最早的句式为“天王盖地虎，宝塔镇河妖”。 天王盖地虎，小鸡炖蘑菇 糗事百科糗友之间的默认暗号：天王盖地虎，小鸡炖蘑菇。宝塔镇河妖，蘑菇放辣椒…… 和 一入糗百深似海，从此纯洁是路人 都差不多 霓虹语，指日语，出自于《十万个冷笑话》的第四集。因为“日本”两个字在日本的发音接近普通话的“霓虹”,所以“日本语”被网友恶搞成了“霓虹语” \"今晚月色真美\"的意思是\"我喜欢你\"。然而回答\"风也温柔\"说明对方也喜欢你,\"适合刺猹\"就是委婉的拒绝而已了。 作为一个梗 “今晚月色很美”是一句表白的话 如果对方答应就会回答“风也温柔” 如果不答应就是“适合刺猹” 撸铁是年轻人对健身运动的戏称 撸铁是健身的衍生词 简单来说就是 举铁 举哑铃杠铃 撸铁和肌霸 都是健身圈里的名词 有点污有点暴力 俗话说得好 男人撸串不如去撸铁 打游戏不如撸铁 撸胸不撸腿迟早要残废 撸胸不撸背迟早要报废 坚持撸铁普通人可以成为小肌霸 小肌霸坚持撸铁成为大肌霸 TLDR，其实是英文中流行的网络用语，它是Too Long; Didn’t Read的缩写，有时也会加上分号，写作：TL;DR。这个缩写表达的意思是：太长不看。常常出现在论坛、贴吧一类的地方，用于回复某个过于冗长的帖子，表示：内容实在是太长了，我没有时间或兴趣仔细看（the posting above me is way too lengthy to keep my interest）。 不过，TLDR也有另外一种流行用法，它可以被发帖者用作对过长内容进行简化、提取内容主旨、以方便读者阅读的一种手段。表示：下文太长，这里是摘要（here is a summary of the lengthy text that follows）。 天雨大不润无根之草;道法宽不渡无缘之人 含义：雨虽然大，却滋润不了无根的草；佛法宽大，却没法引导无缘的人。在好的机会也是给有准备和有进取心的人。 天上下大雨不会滋润没有根的草，道法非常宽泛但是不会度化没有缘分的人。应该是比喻做事必须现有准备，否则机遇来了也无法抓住 出自春秋老子所著的《道德经》。 “天雨虽宽不润无根之草；佛法虽广不度无缘之人。”这是白马寺后殿门上的对联。 天上下来的雨虽然覆盖面广，浇灌大地所有之物，但是无法润泽无根之草，因为草是通过根吸收水分的，断根、缺根的草，就是泡在水里也无法得到滋润； 佛法虽然无所不在，包含在我们周围的方方面面，但是对与佛无缘的人来说，此生却没有机会得到救度。 佛法虽然无所不在，可以运用到我们生活的方方面面，但是对与佛无缘的人来说，此生却很难有机会领略佛陀的智慧。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/美国常见的公司.html":{"url":"docs/commonsense/美国常见的公司.html","title":"美国常见的公司","keywords":"","body":"美国常见的公司 “财富十强企业中有六家是我们的客户，财富 100 强企业中有 40％是我们的客户，五大通信公司中有三家是我们的客户，四大信用卡公司中有三家是我们的客户，五大医疗保健公司中有三家是我们的客户。具体地说，它们包括美国运通、沃尔玛、梦工厂和 United Health。” HBO（Home Box Office的缩写，直译为家庭票房）是一个美国的付费有线和卫星联播网，为华纳媒体公司所拥有，由Home Box Office公司负责营运。HBO主要播出曾在戏院放映的电影和独立制播的电视剧，此外也有为电视而制作的电影、纪录片、拳击赛，以及偶尔播出的喜剧脱口秀和演唱会特别节目。 如权力的游戏 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/美国政治常识.html":{"url":"docs/commonsense/美国政治常识.html","title":"美国政治常识","keywords":"","body":"美国政治常识 根据《美国宪法》，美国是一个三权分立的国家，其中立法权力归国会；行政权力归美国总统；司法权力归美国联邦法院。 1、美国国会（英语：United States Congress）是《美国宪法》规定的立法机构，位于国会大厦。国会由经直接选举产生的参议院议员与众议院议员组成，每个议员代表其选区内的选民，但是作为一个整体，国会议员代表整个国家的选民，通过立法来规范政府与人民的行为。 美国国会由两院组成：参议院又称为上院；众议院又称为下院 两院制的国会 美利坚合众国参议院（英语：United States Senate）是美国的立法机构──美国国会的两院之一，是美国的上议院，另一院为众议院。参议院的组成和权力建基于美国宪法第一条第三款[1]。美国每一州于联邦参议院中均有两位议员作为代表，与各州人口无关，所以全院员额为100名议员。参议员任期为六年，相互交错，每隔两年改选约三分之一的席位。 参议院公认较众议院更为审慎；参议院单独拥有的权力较众议院单独拥有的权力更为重要，参议院亦拥有通过大法官人事任命的同意权，包括美国最高法院大法官。 利坚合众国众议院（英语：United States House of Representatives）为美国国会两院之一，另一院为参议院。美国各州在众议院中拥有的席位比例以人口为基准，但至少会有一名议员。院内议员总数经法律明定为435名。众议员任期两年，无连任限制。 2、美利坚合众国总统（英语：President of the United States，缩写为POTUS[1]；中文简称美国总统）是美利坚合众国的国家元首、政府首脑和武装最高总司令，根据1787年通过的美国宪法而设立，行使宪法赋予的行政权 总统每四年选举一次，个人最多只能任两届。 美国总统的妻子称为“第一夫人” 家庭称为“第一家庭” 美国总统官邸为位于哥伦比亚特区的白宫。 总统专用客机称为“空军一号”， 专用直升机称为“海军陆战队一号”， 官方的进行曲是《向统帅致敬》。 3、美国联邦法院是根据美国宪法和美国法律成立的法院。其中美国宪法只指明要成立最高法院，其余法院由美国国会授权成立。 美国联邦法院是美国联邦政府的一部分，可分为普通法院和专门法院。普通法院分为三级，从下到上分别是： 地方法院 上诉法院（除了美国联邦巡回上诉法院） 最高法院 4、共和党（英语：Republican Party），又常被称为大佬党（英语：Grand Old Party，简称GOP）是美国的一个政党，与民主党并列为美国当代的两大主要政党之一。 红色已经成为共和党的代表颜色 标志物大象 5、民主党（英语：Democratic Party）是美国的一个政党，与共和党并列为美国当代的两大主要政党之一。现时民主党支持者多为东西岸的知识精英或中上阶层，其中不少是受过高等教育或中产阶级的选民。 蓝色则成为民主党的代表颜色 标志物公驴 虽然美国的两大党（以及其他小政党）都习惯以美国国旗传统的红、白、蓝三色作为作为它们的宣传和代表颜色，但在2000年总统选举后，红色已经成为共和党的代表颜色，而蓝色则成为民主党的代表颜色 美国国会由两院组成：参议院又称为上院；众议院又称为下院，两院之间并无从属关系。虽然参议院和众议院是同一个立法机构的两个部分，但是它们之间的区别也不少。 参议院和众议院最明显的差别是它们的大小。众议院中有各州众议员435名，以及华盛顿特区、关岛、美属维尔京群岛、美属萨摩亚、波多黎各及北马里亚纳群岛的无投票权代表[5]，而参议员来自50个州，为数100名。这也使得众议院需要更多的法案来规范议员的辩论行为。 参议院通常允许针对所有问题进行无限制的演讲，但是也允许参议员通过投票来终止冗长辩论。众议院有专门的法案委员会，对几乎每个提案的讨论都加以时间限制。这使得众议院在机构比参议院更加庞大的情况下仍旧可以以比参议院更快的速度通过议案。 因为数目原因，加上参议院拥有的权力及重要性较众议院大，参议员通常比众议员具有更多的媒体曝光度，以及在政党内具有更高的地位，不少参议员在完成任期后加入内阁，甚至成为总统，而众议员则可能逐渐成为制定某个方面的政策的专家，例如财务、税务、环境或者教育政策等。 美利坚合众国参议院（英语：United States Senate）是美国的立法机构──美国国会的两院之一，是美国的上议院，另一院为众议院。 参议院的组成和权力建基于美国宪法第一条第三款[1]。美国每一州于联邦参议院中均有两位议员作为代表，与各州人口无关，所以全院员额为100名议员。参议员任期为六年，相互交错，每隔两年改选约三分之一的席位。根据美国宪法第一条第三款第四节，美国副总统兼任参议院议长，但无参议员资格；且除非是为了在表决平手时打破僵局，否则不得投票。 参议院公认较众议院更为审慎；参议员名额较少而任期较长，容许学院派看法与党派之见，较众议院更易置外于公共舆论。参议院拥有若干表列于宪法而未授予众议院的权力，其中最重要的是，美国宪法明列总统在批准条约或任命重要人事时，须“采酌参议院之建议并得其认可”，参议院拥有对内阁层级官员的同意权，总统提名的阁员均须得到参议院投票通过任命，此外，参议院亦拥有通过大法官人事任命的同意权，包括美国最高法院大法官。与其他民主国家相比，参议院单独拥有的权力较众议院单独拥有的权力更为重要，使得参议院所负的责任较众议院更广泛，亦更具政治影响力。 两院制的国会是于制宪会议中所订立的康涅狄格协议所得的结果。依该协议，各州在众议院中的代表权以人口为基础，但在参议院中具均等代表权。宪法规定法律之制定须经两院通过。 美利坚合众国众议院（英语：United States House of Representatives）为美国国会两院之一，另一院为参议院。美国各州在众议院中拥有的席位比例以人口为基准，但至少会有一名议员。 院内议员总数经法律明定为435名。众议员任期两年，无连任限制。众议院议长由众议员选举产生，传统上为多数党之领导人。然而多数党领袖另由该多数党于院内之第二重要议员担任。据美国总统继位条例，众议院议长继任总统之顺序仅次于兼任参议院议长的副总统，为政坛上第三重要的领袖人物。 美利坚合众国总统（英语：President of the United States，缩写为POTUS[1]；中文简称美国总统）是美利坚合众国的国家元首、政府首脑和武装最高总司令，根据1787年通过的美国宪法而设立，行使宪法赋予的行政权，首任总统乔治·华盛顿于1789年4月30日就职，之后至1933年的历任总统均为3月4日就职，而其后则于1月20日就职。1951年开始生效的美国宪法第二十二修正案规定总统每届任期4年，连选连任不得多于2次，也不能担任总统或执行总统职责超过2年后再当选为总统多于1次。 身为当今世界上最强大国家的元首，美国总统亦号称“自由世界”的领导者及“世界上最有权力的人”。美国总统的妻子称为“第一夫人”，家庭称为“第一家庭”。美国建国以来，前43位总统均为白人男性（主要为英格兰裔，爱尔兰裔6人、荷兰裔3人、德裔3人），第44任总统贝拉克·奥巴马是首位非裔男性。 美国总统官邸为位于哥伦比亚特区的白宫。总统专用客机称为“空军一号”，专用直升机称为“海军陆战队一号”，官方的进行曲是《向统帅致敬》。 根据《美国宪法》，总统须年满35岁，在美国居住14年以上，而且一定要是“自然出生的美国公民”[注 1]或者是在宪法通过时为美国公民（参见：美国宪法）。美国公职只有总统、副总统必须“出生时为合众国公民”。 美国联邦法院是美国联邦政府的一部分，可分为普通法院和专门法院。普通法院分为三级，从下到上分别是： 地方法院 上诉法院（除了美国联邦巡回上诉法院） 最高法院 美国法院（courts of the United States；List of courts of the United States）由美国联邦法院与各州或领地的州法院两系统所组成。美国的联邦法院是由美国联邦政府的司法部门所构成，并依据美国宪法与联邦法律来运作。美国各州与领地拥有个别的州／领地法院，并依据各自的州／领地宪法与州／领地法律来运作。 在美国联邦法官一词通常是指依照美国宪法第三条经美国总统提名并被美国参议院批准的法官。 另外，按照美国宪法国会不能改变最高法院。国会立法在美国不同地区建立了13个上诉法院（也叫巡回法院）和94个地区法院。这些法院的每个法官都属于联邦法官范畴。这包括了最高法院的首席大法官和陪审法官，上诉法院的巡回法官和地区法院的法官。另外，国际贸易法院的法官依据宪法第三条任命。 其他在联邦法院任职的法官包括破产法院的法官有时也被称为联邦法官。然而，他们不是按照宪法第三条的规定任命的。这种区别有时是表示说他们不是“第三条法官”，因为这些联邦法官的权力并不来源于美国宪法第三条。 共和党（英语：Republican Party），又常被称为大佬党（英语：Grand Old Party，简称GOP）是美国的一个政党，与民主党并列为美国当代的两大主要政党之一。目前为美国执政党，并拥有美国国会参众两院多数党地位，34个州的执政权，并控制绝大部分的州议会。其支持票源现主要来自白人蓝领工人阶级、农民、宗教保守派、工商业、能源业及专业人士。 1854年创党以来，由共和党首位总统亚伯拉罕·林肯至今，30任美国总统有19位都是共和党人。共和党创立时的早期，结合了当时反对奴隶制扩张的政治势力，并且将党的价值奠基于“个人自由”和“国家团结”之上。而在当代政治中，共和党则被视为是社会保守主义（也就是文化保守主义，包括维护“家庭价值”）、经济古典自由主义（包括支持“保守财政政策”）的右派政党。 民主党（英语：Democratic Party）是美国的一个政党，与共和党并列为美国当代的两大主要政党之一。现时民主党支持者多为东西岸的知识精英或中上阶层，其中不少是受过高等教育或中产阶级的选民。 1828年第七任美国总统安德鲁·杰克逊创建民主党，1848年成立民主党全国委员会，本杰明·富兰克林·哈利特为首任主席，但它的起源最早可以追溯至托马斯·杰斐逊于1792年创立的民主共和党[11]。 民主党在建立之初主要为保障美国农业发展。因此民主党在19世纪中期通过法案强制驱逐印第安人，发动美墨战争，获得大量土地以供农耕。在美国内战中则支持奴隶制以维护成型的农业体制。20世纪初，民主党加入民粹主义的农本主义，支持维护白人的工人权利，创建了联邦储备系统，并通过了反垄断法，限制大企业的垄断。自从1930年代以来，富兰克林·德拉诺·罗斯福总统推行新政并称之为美国的自由主义，成为了之后民主党的主要政策走向。新政一直到1960年代的民权运动。1960年代的民权运动以及越战导致在民主党内部引发了对国外军事干预的立场及国内政策严重分歧，这种分歧导致之后民主党失去执政地位，但民主党维持对国会两院的控制权直至至1995年。而民主党的根基也逐渐从倾向白人、蓝领、工人阶级和农民利益转变为以东西岸的都会精英、富裕阶层、女性和少数族裔为主。比尔·克林顿1993年上台后，由于共和党1995年起控制国会两院，民主党转走温和中间路线，2009年贝拉克·奥巴马领导民主党重新上台后，民主党加强其自由派和进步主义路线，强调对女性、非裔、拉美裔、亚裔及LGBT族群的支持，但逐渐失去过往作为民主党基本盘的白人、蓝领及工人阶级的支持，导致2017年再度成为在野党。 虽然美国的两大党（以及其他小政党）都习惯以美国国旗传统的红、白、蓝三色作为作为它们的宣传和代表颜色，但在2000年总统选举后，红色已经成为共和党的代表颜色，而蓝色则成为民主党的代表颜色 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/视频处理和图片处理软件.html":{"url":"docs/commonsense/视频处理和图片处理软件.html","title":"视频处理和图片处理软件","keywords":"","body":"视频处理和图片处理软件 视频剪辑工具 视频下载 电影下载 图片去除水印：Inpaint youtube视频下载：Gihosoft TubeGet Mac 系列软件推荐第一弹：8 款好用的免费视频后期软件10年Mac OS X上2021个最佳免费视频编辑软件 视频分辨率类型 三类 三类和分辨率关系 HB和BD是什么 HD和BD哪个高清? 蓝光和超清哪个好? 电影TS、TC、SCR、R5、BD、HD等版本 视频电影的格式 视频分辨率类型 三类 （1）标清（Standard Definition），是物理分辨率在720p以下的一种视频格式。 （2）高清（High Definition），是我们目前相对比较熟悉的一个词语。高清是在广播电视领域首先被提出的，最早是由美国电影电视工程师协会(SMPTE)等权威机构制定相关标准，视频监控领域同样也广泛沿用了广播电视的标准。将“高清”定义为720p、1080i与1080p三种标准形式，而1080P又有另外一种称呼——全高清（Full High Definition）。关于高清标准，国际上公认的有两条: 视频垂直分辨率超过720p或1080i; 视频宽纵比为16:9。 （3）超高清（Ultra High-Definition），这是我们今天的重点内容。来自国际电信联盟 (International Telecommunication Union)最新批准的信息显示，“4K分辨率(3840×2160 像素)”的正式名称被定为“超高清 Ultra HD(Ultra High-Definition)”。同时，这个名称也适用于“8K分辨率 (7680×4320像素)”。 与此同时，电视行业里，同对高清电视机命名为HDTV一样，对于4K电视机的命名，美国消费者电子协会针对4K电视进行了一个官方的命名UHDTV，这个命名也就是超高清电视。 而目前的市场也推出不少支持4K蓝光片源播放的影音播放设备，如索尼、松下、三星、OPPO、开博尔等国外国内多个品牌推出最新4K蓝光播放器迎合发烧友的需求。 三类和分辨率关系 HD高清：高清晰度,通常高清的画面分辨率为1280x720及以上，也就是常说的720P。 BD蓝光：通常蓝光的画面分辨率为1920×1080P及以上，也就是常说的1080P。 蓝光：全高清FHD、超(高)清或称2K、4K、8K 标清SD：480x320, 640x480 高清HD（720p）：1024x720p (隔行扫描) 也属于高清：1920x1080i 全高清FHD（1080p）：1920x1080p 超(高)清或称4K：3840x2160,7680x4320 720p格式：分辨率为1280×720p/60Hz，行频为45kHz。 1080p格式：辨率为1920×1080 2K格式: 4K格式：分辨率是1080p的4倍 3840×2160 = 1920×2×1080×2 8K格式：分辨率是4K的4倍 7680×4320 = 3840×2×2160×2 2015年，美国消费电子协会（CEA）将4K的分辨率正式命名为Ultra HD（Ultra High-Definition） SD—标清—分辨率：1280×720以下 HD—高清（通常指我们所说的720P）—分辨率：1280×720 FHD—全高清（也就是我们所说的1080P）—分辨率：1920x1080 2K—分辨率：2048×1080 4K—UHD—分辨率：3840×2160或4096×2160 6K—IMAX胶片版 8K—SHV—分辨率：7680x4320 如何区别高清、极清、超清、1080p、蓝光、4K？「蓝光」「720/1080p」「HR-HDTV」等视频制式都是什么意思？清晰度对比如何？ HB和BD是什么 HD:高清晰度,分辨率在1280×720及以上 BD:是蓝光 分辨率在1920X1080P及以上 HD，即HDRip。是HDTVRip(高清电视资源压缩)的缩写，是用DivX/XviD/x264等MPEG4压缩技术对HDTV的视频图像进行高质量压缩，然后将视频、音频部分封装成一个.avi或.mkv文件，最后再加上外挂的字幕文件而形成的视频格式，画面清晰度更高。 HD通常把物理分辨率达到720p以上的格式称作为高清，英文表述High Definition，简称HD。所谓全高清(FullHD)，是指物理分辨率高达1920x1080逐行扫描，即1080p，是目前顶级的高清规格，所以这种高清电影被称为HD版本。 BD是BuleDisk的简称，翻译成中文是“蓝光影碟”的意思。就是从蓝光影碟转录的视频和音频，画面清晰度很高。BD英文全名是Blu-ray Disk，一种高清的电影版本，这种电影十分清晰但是数据量巨大，占数十G甚至上百G的容量，只有蓝光光碟才能装得下，所以这种高清电影被称为BD版。 蓝光(Blu - ray)或称蓝光盘(Blu - ray Disk，缩写为BD)利用波长较短(405nm)的蓝色激光读取和写入数据，并因此而得名。蓝光光碟，英文名Blu - ray Disc，简称BD。是DVD之后的下一代光盘格式之一，用以存储高品质的影音以及高容量的数据存储。一个单层的蓝光光碟的容量为25或是27GB，足够录制一个长达4小时的高解析影片。 高清：高清，英文为“High Definition”，意思是“高分辨率”。一般所说的高清，有四个含义：高清电视，高清设备，高清格式，高清电影等。 蓝光：蓝光，也称蓝光光碟，英文翻译为Blu-ray Disc。是DVD之后下一时代的高画质影音储存光盘媒体（可支持Full HD影像与高音质规格）。 蓝光或称蓝光盘利用波长较短的蓝色激光读取和写入数据，并因此而得名。蓝光极大地提高了光盘的存储容量，对于光存储产品来说，蓝光提供了一个跳跃式发展的机会。 高清：由于高清视频数据传输量巨大，所以需要有新的压缩算法。现在的高清音频格式有：DTS、Dolby Digital、Dolby TrueHD、LPCM等。视频格式，主要有：H.264、WMA-HD、MPEG2-TS、AVC、MPEG4和VC-1等。 蓝光：蓝光光碟格式缩写为BD。采用了一种新的高密度物理格式使得每层能够存储23-27G的数据量，双层蓝光光碟容量可达50G。蓝光技术可以录制2小时的数字高清视频或者超过13小时的标准电视广播节目(相当于家用录像系统VHS的质量，数据流约3.8Mbps) 。 HD和BD哪个高清? 清晰度：BD>HD>DVD BD是蓝光的简写，HD是高清的简写，蓝光版属于高清版的一种。以前蓝光和HD-DVD两大阵营竞争，一部电影既发行蓝光又发行HD碟。最后蓝光胜出，HD碟不再有了，现在的电影只发行蓝光了。蓝光原盘或者REMUX是最清晰的，其次是根据蓝光原盘压缩的1080P等等。有时还有HDTV版，应该是高清电视转录，一般不如BD清晰。BD和HD要比DVD清晰得多。看电影，要首选BD版本的，再是HD，最后是DVD版本。 蓝光和超清哪个好? 高清：通常高清的画面分辨率为1280x720，也就是常说的720P。 蓝光：通常蓝光的画面分辨率为1920×1080，也就是常说的1080P。 蓝光电影是正版的高清电影，必须有蓝光碟机或蓝光光驱才能播放，门槛较高，但画质通常是最好的。 一般的高清电影多半是从蓝光电影、国外的高清电视频道上压制而来的，可以通过网络下载，多数都经过二次压缩，画质要逊于原视频，不过压缩后的容量从蓝光的25G - 50G会减少成4G - 8G等(15G - 20G不等) 通常视频的分辨率达到1280x720左右称之为720P，达到1920x1080左右称之为1080P，720P和1080P都是合格的超清电影。当然也与码率、压缩编码等一系列内容相关。 另外，不管是高清还是蓝光，您用来观看的设备要达到要求，否则效果就出不来。 BD和HD是什么意思?蓝光和高清相比哪个更好更清晰 BD电影和HD电影有什么区别啊？哪个好啊？ 蓝光和高清的区别 电影TS、TC、SCR、R5、BD、HD等版本 CAM（枪版） TS(准枪版) TC(胶片版) DVDSCR(预售版) HD RIP（高清版） BD（蓝光版） 电影TS、TC、SCR、R5、BD、HD等版本是什么意思 电影TS/TC/SCR/R5/BD/HD/HC版本意思收集 视频电影的格式 SD—标清—分辨率：1280×720以下 HD—高清（通常指我们所说的720P）—分辨率：1280×720 FHD—全高清（也就是我们所说的1080P）—分辨率：1920x1080 2K—分辨率：2048×1080 4K—UHD—分辨率：3840×2160或4096×2160 6K—IMAX胶片版 8K—SHV—分辨率：7680x4320 AVI即音频视频交错格式，是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，压缩率比较高，因此画面质量不是太好。 MKV不是一种压缩格式，而是一种新的多媒体封装格式，也称多媒体容器。 MOV：高清预告片首选。 MP4：手机、平板的新宠儿。 TS：这个TS代表的是文件后缀名为 .ts 的高清格式。 RMVB：这个现在差不多被淘汰了，具体原因在后文。 需要说明的也就是，如果是MKV等格式意味着可能封装了多个字幕和音轨，而AVI，MP4，RM等则不能 关于电影资源画质和一些视频格式的解析 赶紧收藏了！最全的电影格式介绍来了！ 电影的各种版本，格式，视频音频编码，字幕，你都了解吗？ 视频文件格式 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/运营知识.html":{"url":"docs/commonsense/运营知识.html","title":"运营知识","keywords":"","body":"运营知识 MCN KOL UGC、PGC、OGC、PUGC、MGC SLA,SLO,SLI UGC、PGC、OGC、PUGC、MGC UGC：User-generated Content的缩写，用户生产内容。也称UCC（User-created Content）。 PGC：Professionally-generated Content的缩写，专业生产内容。又作PCC。 PGC有时候泛指个性化、视角多元化、传播民主化、社会关系虚拟化的内容。 OGC：Occupationally-generated Content，品牌生产内容。 PUGC (Professional User Generated Content)，即专业用户生产内容，以UGC形式产出的相对接近PGC的专业内容 MGC（Machine Generated Content）即机器生产内容或技术生产内容，指万物互联和全时在线的数据通过数据挖掘和智能算法生成海量的传感器资讯。 UGC是user-generated content，即用户生产内容的缩写。比如作为微博用户的你，随手发的一条微博。 PGC是Professionally-generated content,专业生产内容的缩写，也称为PPC，即Professionally-produced Content。比如你是专业学习的运营，那你在微博上发布的专业内容，就是PGC。 OGC是Occupationally-generated Content，职业生产内容的缩写。比如，你是以生产运营知识为职业，并从中获取了报酬。 UGC ( User-Generated Content），也称UCC（User-created Content），即用户生产内容，泛指以任何形式在网络上发表的由用户创作的文字、图片、音频、视频等内容，是 Web 2．0 环境下一种新兴的网络信息资源创作与组织模式。它的发布平台包括微博、博客、视频分享网站、维基、在线问答、SNS 等社会化媒体。 PGC（Professionally-generated Content），也称PPC（Professionally-produced Content），即专业生产内容， 生产创作主体是由专业精英构成，其发展历程早于 UGC，生产程序偏向专业性，内容质量可控性更强，对生产者知识背景和专业资质的要求较高。社会化媒体兴起后，部分专业内容生产者既是平台的用户，也以专业身份（专家）贡献具有一定水平和质量的内容（如资深用户的点评）。在内容创作方面，体现为更加专业化、优质化、垂直化、具有平台核心价值的内容。 OGC（Occupationally-generated Content），即职业生产内容，指主要通过具有一定知识和专业背景的行业人士生产内容，并且这些人会领取相应的报酬（如部分新闻网站雇佣的内容编辑）。生产主体主要是来自相关领域的职业人员，他们对内容产出严格把控，尽力满足用户对内容的需求，其创作行为属于职责义务，是履行人事契约的体现。 运营干货丨UGC、PGC和OGC是什么？ 【干货】关于UGC、PGC、OGC三者详细区别！ UGC、PGC、OGC、PUGC、MGC…小田心一文帮你辨清楚！ KOL 运营人员都在说KOL，到底什么是KOL？ 也有说网红、明星就是KOL的 KOL的定义 关键意见领袖（Key Opinion Leader,简称KOL）是营销学上的概念，通常被定义为：拥有更多、更准确的产品信息，且为相关群体所接受或信任，并对该群体的购买行为有较大影响力的人。 关键意见领袖（Key Opinion Leader，KOL） 基本上就是在微博上有话语权的那些人。包括在行业内有话语权的人。 运营人员都在说KOL，到底什么是KOL？ MCN 揭秘MCN：网红“大红大紫的背后推手” mcn是multi-channel network的简称，直译就是多频道网络。 MCN（Muti-Channel Network）的前身可以追溯到UGC、PGC和OGC时代，即用户原创内容、专业生产内容和职业生产内容。 通俗来说，UGC是用户展示自己的原创内容，例如原创微博，知乎问答等。 PGC是有一定专业能力者生产的内容，例如干活经验分享或者测评等， 而OGC是为职业工作者制作的内容，常见的有新闻网站，新闻客户端等等。 三者之间可以是相互独立的个体，又可以集二者为一体，就例如运营中的公众号，我们既可以称之为原创内容又可以称之为是专业的生产内容。 其实说白了MCN就像是一个中介公司，上游对接优质内容，下游寻找推广平台变现。 国外的MCN早期以经纪模式为主，帮助视频红人变现。而国内的MCN模式不同，机构只需要和内容生产者对接上，内容生产者专心做内容，MCN机构帮你包装、营销、推广和变现。 其实MCN并不神秘，也不复杂，用我们的大白话讲，MCN其实就是一个内容创作者的公司型管家，也称网红经纪人，网红中介机构。 MCN机构一般签约有各种类型的内容创作者（网红），比如：图文创作者、短视频创作者、直播主播。MCN机构会负责对内容创作者进行培训、包装、推广、变现等一整套服务，并从中获取一定的经济利益分成。 举个栗子：某MCN机构，会从网红湾里挑选长相有记忆点、有擅长领域、有合理人设的素人（有潜力成为网红的人，准网红），进行签约合作，并根据素人的特点，进行相应的培训。 MCN是一种多渠道网络服务，随着YouTube等平台上内容的爆发式增长，多渠道网络开始整合众多专业生成内容（PGC），从而打造规模化、组织化的竞争优势。简单来说，MCN就是一种网红经济运作模式，MCN公司将PGC联合在一起形成网红矩阵，MCN的优势是：一方面帮助内容生产者专注于内容创作，另一方面对接平台、粉丝进行包装、强化推广以及推动变现。 PARKLU是Launchmetrics的子公司，Launchmetrics是专注于时尚、奢侈品及美容（FLB）行业的品牌绩效分析与管理云平台（Brand Performance Cloud）。 PARKLU帕克街，KOL关系管理与数据分析平台，为品牌对接、分析、管理众多意见领袖资源，并在微博、抖音等数十个主流社媒资源上进行有效传播，从而为品牌主提供有效的KOL营销解决方案。PARKLU的数据库拥有超过10万名来自十个社交媒体平台的KOL，涵盖了时尚、美妆、美食、旅游、亲子、健身等领域，覆盖9亿多中国用户。KOL活跃于抖音、小红书、微信、微博、微淘、一直播、哔哩哔哩等。 KOL关系管理(KRM)与营销分析平台 MCN 是什么？ 揭秘MCN：网红“大红大紫的背后推手” SLA,SLO,SLI SLI（Service Level Indicator）:服务水平指标 SLO（Service Level Object）:服务水平目标 SLA（Service Level Agreement）:服务水平协议 再有就是SLI/SLO/SLA都是和服务联系在一起的，脱离了服务这三个概念就没有什么意义了。 Service 什么是服务？ 简单说就是一切提供给客户的有用功能都可以称为服务。 服务一般会由服务提供者提供，提供这个有用功能的组织被称为服务提供者，通常是人加上软件，软件的运行需要计算资源，为了能对外提供有用的功能软件可能会有对其他软件系统的依赖。 客户是使用服务提供者提供的服务的人或公司。 SLI SLI是经过仔细定义的测量指标，它根据不同系统特点确定要测量什么，SLI的确定是一个非常复杂的过程。 Service Level Indicator 服务水平指示器，服务水平，简称SLI。对于业务来说是最重要的指标。比如，对于网站来说，一个常见的SLI是请求得到正常响应的百分比。 SLO SLO(服务等级目标)指定了服务所提供功能的一种期望状态。SLO里面应该包含什么呢？所有能够描述服务应该提供什么样功能的信息。 服务提供者用它来指定系统的预期状态；开发人员编写代码来实现；客户依赖于SLO进行商业判断。SLO里没有提到，如果目标达不到会怎么样。 Service Level Object 服务水平目标，是围绕SLI构建的目标。通常是一个百分比，并与一个时间范围挂钩。比如，月度、季度、年度等。通常用一连串9来度量。如果脱离了时间的度量，SLO的意义就不大了。 SLA SLA是一个涉及2方的合约，双方必须都要同意并遵守这个合约。当需要对外提供服务时，SLA是非常重要的一个服务质量信号，需要产品和法务部门的同时介入。 SLA用一个简单的公式来描述就是： SLA = SLO + 后果 Service Level Agreement 服务水平协议，是企业围绕SLO发布的协议。它要求在不满足SLO时向客户补偿的协议。 深度剖析什么是 SLI、SLO和SLA？使用 Prometheus 和 Grafana 实现 SLO一文读懂什么是SLI、SLO、SLA DAU Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/Google%20Cloud%20Platform免费申请.html":{"url":"docs/commonsense/Google%20Cloud%20Platform免费申请.html","title":"Google Cloud Platform免费申请","keywords":"","body":"Google Cloud Platform免费申请 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:50:24 "},"docs/commonsense/饭圈词汇.html":{"url":"docs/commonsense/饭圈词汇.html","title":"饭圈词汇","keywords":"","body":"饭圈词汇 瑞思拜是一个网络流行词，是英语respect的音译，是尊重的意思。该词在说唱歌手中广泛流行，渐成为了饭圈词汇。后逐渐引申为“厉害了大哥我佛了”的含义。 yyds 永远滴神 xswl 笑死我了 dbq 对不起 nsdd 你说得对 zqsg 真情实感 xfxy 腥风血雨 u1s1 有一说一 bdjw 不懂就问 blx 玻璃心 271 爱奇艺 内心OS 内心OS （内心独白(overlapping sound)） 经常看动漫或者泡论坛的同学可能会一直看到例如“某某人内心的OS”这样的表达法 我们平时遇到的OS多指“内心独白”的意思，这是一个英文缩写，全称为“overlapping sound”。 overlap这个词表示“（时间上）重叠；与……同时发生”，比如说：My vacation overlaps with yours, so we won't see each other for a month or so.（我的假期和你的假期前后相连，所以我俩将有一个月左右见不着面。） 一方正在说话，而另一方同时也有自己的内心独白，内心独白的“话”用overlapping sound来表示会比较形象。 另外值得注意的是，我们有的时候还会在某些歌曲的注释处看到“OS版”的字样，这里的OS(Original Sound)通常指的是新歌正式发布前用于宣传的小样。 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"docs/commonsense/常识名词.html":{"url":"docs/commonsense/常识名词.html","title":"常识名词","keywords":"","body":"常识名词 “鲸落”（Whale Fall） 生当似鹏起，终当如鲸落 一鲸现，穹宇惊。 一鲸鸣，沧海静。 一鲸落，万物生。 “鲸落”（Whale Fall） 世上有没有一种死法，如此温柔？据说，鲸是可以预知自己死亡的。预感生命将尽时，它便孤独离去，下沉，下沉……而后，安静如水，来者不拒，任由自身被汲取享用。 生于海，逝于海，接着，归于海，反哺海。这一切在深海之境悄然上演。 世上有没有一种死法，如此慷慨？它的死，竟不是生的终结，而是喧闹的开始。 人间最美，不过鲸落，一念山河成，一念百草生。 摘 刘诗瑶《一鲸落万物生》 Hackathon 先说一下什么是Hackathon吧，这个词其实是由hacker和marathon 两个词合成的。 hacker就是黑客，这个我留到下面谈兴起的时候再讲。 marathon就是马拉松， 那Hackathon顾名思义，其实就是黑客的马拉松或者编程马拉松——以电脑为跑道、以编程为体力的一场技术比赛。跟马拉松的精神很类似，黑客马拉松可以让很多不认识的人在一个特定的时间内相聚在一起，以他们想要的方式，去做他们想做的事情。 Hackathon的具体流程是什么？Hackathon 参赛指南——如何愉快地参加一场 Hackathon 极客Geek 极客，又译为技客、奇客，是英文单词geek的音译兼义译。原本的俚语是指反常的人。 这个词在“美国俚语”中意指智力超群，善于钻研但不爱社交的学者或知识分子，含有贬义，因为极客经常钻研于自己感兴趣的领域，可以牺牲个人卫生，社交技巧或社会地位（但并不是所有的geek都会这么做）。但近年来，随着互联网文化兴起，其贬义的成分正慢慢减少。 但这个词仍保留拥有超群的智力和努力的本意，又通常被用于形容对计算机和网络技术有狂热兴趣并投入大量时间钻研的人。所以俗称发烧友或怪杰。如电脑怪杰（Computer Geek），技术/科技怪杰（Techno-geek），玩家怪杰（gamer geek）等。 好奇与行动，或者说是好奇之心与改变之力，但这两者必须建立在能力的基础上。其实我们更应追寻的是这背后的人文关怀和精神。这个精神是让极客不再是最初的“怪客群体”，而成为世界的改变者和引领者的关键动力。 而在中国，这种“极客精神”是否拥有足够多的人群在践行和传承，则更是一个意义深远的话题，需要意识到这背后首先需要一种文化来支撑，也需要一个更庞大的“基数”来孕育。 极客文化，是一种起源于美国的新的反主流文化。极客一词，来自于美国俚语“Geek”的音译，一般理解为性格古怪的人。极客文化以令人惊异的产品及电影、音乐和游戏引 领潮流时尚。 极客极客精神本质内容是什么？极客文化 发烧友 发烧友、狂热入迷者（英语：fanatic）、狂热爱好者 爱好者（英语：enthusiast）或粉丝（英语：fans），有时又叫发烧友、狂热入迷者（英语：fanatic）、狂热爱好者、迷（英语：aficionado）、拥趸，是指对于各类组织、人物、产品、艺术品、信念或流行趋势抱有极度、无法抑制的喜爱与支持的人。 爱好者 出了五服不是亲戚 本宗九族 中国人常说的“亲戚没出五福”是什么意思，是哪五福？ 老人常说“出了五服不是亲戚”，五服指的是什么？ 直系亲属中的五服是指高祖父，曾祖父，祖父，父亲，自身五代。 出五服的意思是：亲属关系超过五代，不再为之服丧，叫做出服，也叫出五服，在婚嫁中出五服即可通婚，现代人多认为五服是五代，这种说法是错误的。五代算一服，出五服要二十五代。 本宗九族 五服，是由父系家族组成的中国古代社会，以父宗为重。其亲属范围包括自高祖以下的男系后裔及其配偶，即自高祖至玄孙的九个世代，通常称为本宗九族。 五服也指代五辈人，比如在山东胶东半岛一带，有“五服之内为亲”的说法，就是利用上面那句话，往上推五代，从高祖开始，高祖、曾祖、祖父、父、自己，凡是血缘关系在这五代之内的都是亲戚，即同出一个高祖的人都是亲戚，从高祖到自己是五代，就成为五服。 老百姓说的家族五福准确的说法是“脱五服”、“出五服”。五服：原是指古人出丧时穿戴的五种孝服。后用来表示家族宗亲世代，谓高祖﹑曾祖﹑祖父﹑父亲﹑自身五代。 凡是血缘关系在这五代之内的都是亲戚，即同出一个高祖的人都是亲戚。从高祖到自己是五代，就成为五服。五服之后，则称谓“出五服”，就没有了亲缘关系，就可以通婚。一般情况下，家里有婚丧嫁娶之事，都是五服之内的人参加。 五服是指以自己为中心,向上推五代,向下推五代.上推高祖、曾祖、祖父、父辈、自己,这算“五服”;下推五代是即自己、儿子、孙子、曾孙、玄孙,即自高祖至玄孙的九个世代,通常称为本宗九族. 几乎大部分的人都知道“五福临门”这个成语，可是很少人知道“五福”所指的是那五种福。至于五福临门的原理，明白的人就少之又少了。到底什么是五福呢？第一福是“长寿”、第二福是“富贵”、第三福是“康宁”、第四福是“好德”、第五福是“善终”。 注：《书经》上所记载的五福是：一曰寿、二曰富、三曰康宁、四曰攸好德，五曰考终命。 长寿是命不夭折而且福寿绵长 富贵是钱财富足而且地位尊贵 康宁是身体健康而且心灵安宁 好德是生性仁善而且宽厚宁静 善终是能预先知道自己的死期。临命终时，没有遭到横祸，身体没有病痛，心里没有挂碍和烦恼，安详而且自在地离开人间。 亲戚关系中「出五服」具体指的是哪些人？ 良药苦口利于病，忠言逆耳利于行 “良药苦口利于病，忠言逆耳利于行”，是一个汉语成语，意思是形容应该虚心接受别人的意见和批评或教育人们要勇于接受批评。良药多数是带苦味的，却有利于治病；而教人从善的语言多数是不太动听的，但有利于人们改正缺点。这句贤文是在教育人们要勇于接受批评，常用来说明应该正确地对待别人的意见和批评。 良药苦口利于病，忠言逆耳利于行Good medicine is bitter in the mouth but beneficial to the disease；while good advice goes against the ear but helps to act. 出处 “良药苦口利于病，忠言逆耳利于行”。出自《史记·留侯世家》 [1] 沛公刘邦十万义军攻破峣关，在蓝田大败秦朝关中守军，领先天下义军，顺利地进入咸阳。进入秦朝的咸阳宫后，沛公刘邦被宫中的美色珍玩吸引，忘乎所以，准备留在秦宫里玩个尽兴不出来了。他的连襟兄弟樊哙劝他他也听不进去。这个时候，张良入宫直谏，很严厉地数落了刘邦一顿，说明了他这样做的错误，并且说了这么一句：“忠言逆耳利于行，毒药苦口利于病，请沛公听樊哙言。”沛公这才依依不舍地离开了秦宫，宣布军队开出城市，到咸阳郊外的霸上乖乖驻扎，不许扰民。 《孔子家语·六本》：“良药苦口利于病，忠言逆耳利于行”。药虽然是苦的，但有利于疾病的治疗。忠实的劝告往往都是不喜欢听的，但对行动有好处。 三皇五帝 常言说:自从盘古开天地，三皇五帝到如今。 三皇：天皇、地皇、人皇（出自《史记·秦始皇本纪》。还有其他的说法等） 传说中的五帝：黄帝、颛顼（zhuan一声 xu四声）帝喾（ku四声）尧、舜 三皇也是说天皇，地皇，人皇 天皇原始天尊，地皇地藏皇，人皇斩辕皇帝，五帝灶君，就是同一时代分工管辖天皇最大，管辖三界，而地藏皇管则管鬼界，如妖魔鬼人死后经六度地回再判投生，而人皇就是人类皇帝， 而五帝就是管辖人的生活，食，穿，住的问题，就是同一时代分工管理，等于现在国家的中央，省，县，公安局，粮食局分工管理的意思。 而三皇五帝时化就是沒有历史记截，到了尧舜禹时代才有历史文代记截，尧舜禹时代之前就是人们称为三皇五帝时代。 二五仔 二五仔（ji ng zai），广东话、粤语 指告密者、叛徒、出卖组织的内奸和专门在人后说是非的人。 二五仔，是粤语俚语，即告密者或者出卖其他人者的俗称。粤语俚语，同反骨仔、鬼头仔及叛徒等。 「二五仔」是粤语里的一个市井俗语，跟它意思相近的一个词叫「反骨仔」，也就是对「叛徒」的鄙称。 粤语俚语，即告密者或者出卖其他人者的俗称。 粤语俚语，同反骨仔、鬼头仔及叛徒等。 点造句： 佢个二五仔，之前应承同我做野，宜家又去咗帮其他人。（他这个叛徒，之前答应了帮我做事，现在又去帮别人。） 你千祈唔好做二五仔，做人最紧要脚踏实地。（你千万不要当叛徒，做人最重要的是脚踏实地。） 来源说法有两种： 其一说是在东周春秋时期，晋国人称呼梁五和东关嬖五为二五耦，二人为骊姬谋害太子申生，因此二五就成为了奸佞、背叛者的简称，后世二五仔的说法应源于此。 另一说是原是中国清代秘密会社的切口，二五仔即“义忤仔”，意指告密者、叛徒、出卖组织的内奸和专门在人后说是非的人。 民间关于“二五仔”的来源说法不一，其中有一种说法是：清朝康、雍年间，朝廷要消灭反清复明的秘密会社，查得少林寺与天地会有千丝万缕的关系，派兵前往剿灭。但需要有少林寺内奸里应，于是收买了武功排名第七的少林俗家弟子马宁儿，马宁儿成为了少林寺的叛徒。秘密会社中人不齿其所为，日后便称那些告密者、叛徒为“二五仔”。 也有人认为，二，即“贰”，是“有异心”（异、二粤语读音相同）的意思；五，即“忤”，“忤逆”之意。 天干地支 天干，是中国古代的一种文字计序符号，共10个字: 甲、乙、丙、丁、戊、己、庚、辛、壬、癸，循环使用。 中国等汉字文化圈国家古代常以之来命名、排序、纪时。 地支，是指木星轨道被分成的十二个部分，记为子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥。木星的公转周期大约为十二年，所以中国古代用木星来纪年，故而称为“岁星”。后来又将这十二个部分命名，这就是“地支”。 天干 wiki 地支 wiki 干支纪年法 干支纪年 干支纪月 干支纪日 干支纪时 干支是天干与地支的合称，由两者经一定的组合方式搭配成六十对，为一个周期，循环往复，称为六十甲子或六十花甲。 古代中国用以记录年、月、日、时。日本、朝鲜、越南、琉球等汉字文化圈地区也曾跟随古代中国，使用干支来记录时间。 用干支纪年法纪年时一个周期为六十年，所以也用“甲子之年”或“花甲之年”来形容60岁的老年人。 六十甲子 还历、还甲、回甲、花甲等，指人的年龄满六十虚岁，也说六十甲子。 汉民族及周边许多民族受到此文化的影响，在计算年龄时，都以天干地支的顺序来表示。一个循环从甲子开始，接着是乙丑、丙寅……依序共有六十个组合，因此，干支每六十年就会循环一次，即一个人到60岁（出生时1虚岁）时，就逢一甲子，又称一轮，正是新一轮重新算起的时候，故称“还历”、“还甲”、“回甲”，又名“花甲”，与天干地支有关。 传统上，满一甲子会有一定的庆祝仪式。 干支 wiki 生辰八字 八字源自古代的中国，是一种利用天干和地支来准确记录年、月、日、时的方式，由“年干，年支”、“月干，月支”、“日干，日支”、“时干，时支”，共八个干支所组成（共八个字），年、月、日、时的干支组合称为“柱”，形成“年柱”、“月柱”、“日柱”、“时柱”，故八字又称为“四柱”或“四柱八字”。 十二时辰 古人把一昼夜划分成十二个时段，每一个时段叫一个时辰。十二时辰既可以指一天，也可以指任何一个时辰。十二时辰是古人根据一日间太阳出没的自然规律、天色的变化以及自己日常的生产活动、生活习惯而归纳总结、独创于世的。 十二时辰，十二时辰与二十四小时对照表。昼夜分为十二个时辰：子(zǐ)、丑(chǒu)、寅(yín)、卯(mǎo)、辰(chén)、巳(sì)、午(wǔ)、未(wèi)、申(shēn)、酉(yǒu)、戌(xū)、亥(hài)。每个时辰相当于现在的两个小时。 古代将一昼夜分为十二时辰，即：子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥。每一时辰相当于现代的两个小时。古人根据中国十二生肖中的动物的出没时间来命名各个时辰。 看过武侠小说的人，肯定知道一炷香，一盏茶，一弹指，一刹那等说法，那么一炷香的时间是多久？一盏茶是多长时间？一弹指，一刹那究竟多么短暂？ 一日有十二辰（一时辰合现代2小时），一时辰有八刻（一刻合现代15分钟），一刻有三盏茶（一盏茶合现代5分钟），一盏茶有两炷香（一炷香合现代2分30秒），一炷香有五分（一分合现代30秒），一分有六弹指（一弹指合现代5秒），一弹指有十刹那（一刹那合现代0.5秒）。 佛说：一弹指等于六十刹那，一刹那有九百生灭。 1、“一刹那”： 按古代印度《僧只律》(又有资料是《倡只律》) 解释：一刹那即为一念，二十念为一瞬。二十瞬为一弹指，二十弹指为一罗预。二十罗预为一须叟，一日一昼为三十须叟。照此计算：一须叟为48分钟，一罗预为114秒。一弹指为7.2秒，一瞬为0.36秒，一刹那为0.018秒。 一眨眼等于二十四刹那。 十二时辰： 子时23～1点， 丑时1～3点， 寅时3～5点， 卯时5～7点， 辰时7～9点， 巳时9～11点， 午时11～13点， 未时13～15点， 申时15～17点， 酉时17～19点， 戌时19～21点， 亥时21～23点。 十二时辰和二十四小时对照表 十二个时辰的部分别称汇总 夜半 【yè bàn】：子夜　夜分　中夜　未旦　宵分 鸡鸣 【jī míng】：荒鸡 平旦 【píng dàn】：平明　旦明　黎明　早旦　日旦　昧旦　早晨　早夜　早朝　昧爽　旦日　旦时 日出 【rì chū】：日上　日生　日始　日晞　旭日　破晓 食时 【shí shí】：早食　宴食　蚤食 隅中 【yú zhōng】：日禺　禺中　日禺 日中 【rì zhōng】：日正　日午　日高　正午　亭午　日当午 日昳 【rì dié】：日昃　日仄　日侧　日跌　日斜 晡时 【bū shí】：馎时　日馎　日稷　夕食 日入 【rì rù】：日没　日沉　日西　日落　日逝　日晏　日旴　日晦　傍晚 黄昏 【húang hūn】：日夕　日末　日暮　日晚　日闇　日堕　日曛　曛黄 人定 【rén dìng】：定昏　夤夜 十二时辰和十二生肖的关联 表示十二时辰的十二个字与十二生肖相结合，便有了：子鼠、丑牛、寅虎、卯兔、辰龙、巳蛇、午马、未羊、申猴、酉鸡、戌狗、亥猪。 表示时间的“更”、“鼓”、“刻”的区分 古人说时间，白天与黑夜各不相同，白天说“钟”，黑夜说“更”或“鼓”。又有“晨钟暮鼓”之说，古时城镇多设钟鼓楼，晨起（辰时，今之七点）撞钟报时，所以白天说“几点钟”；暮起（酉时，今之十九点）鼓报时，故夜晚又说是几鼓天。夜晚说时间又有用“更”的，这是由于巡夜人，边巡行边打击梆子，以点数报时。一声声的报时提醒着人们一去不回的时间，要珍惜当下不负光阴。 全夜分五个更（此处“更”在方言中读“jīng”，汉语规范化后读“gēng”），第三更是子时，所以又有“三更半夜”之说。出处：《宋史·赵昌言传》：“四人者（陈象舆、胡旦、董俨、梁灝）日夕会昌言第。京师为之语曰：‘陈三更，董半夜’。” 戌时（xū） 黄昏 19:00-21:00 一更 亥时（hài） 人定 21:00-23:00 二更 夜子时（zǐ） 夜半 23:00-24:00 三更 早子时（zǐ） 夜半 24:00-01:00 三更 丑时（chǒu） 鸡鸣 01:00-03:00 四更 寅时（yín） 平旦 03:00-05:00 五更 刻———古代用漏壶计时。漏壶分播水壶和受水壶两部。播水壶分二至四层，均有小孔，可滴水，最后流入受水壶，受水壶里有立箭，箭上刻分100刻，箭随蓄水逐渐上升，露出刻数，以显示时间。而一昼夜24小时为100刻，即相当于现在的1440分钟。可见每刻相当于现在的14.4分钟。所以“午时三刻”相当于现在的中午11时 43.2分 旧小说有“午时三刻开斩”之说，意即，在午时三刻钟（差十五分钟到正午）时开刀问斩，此时阳气最盛，阴气即时消散，此罪大恶极之犯，应该“连鬼都不得做”，以示严惩。阴阳家说的阳气最盛，与现代天文学的说法不同，并非是正午最盛，而是在午时三刻。古代行斩刑是分时辰开斩的，亦即是斩刑有轻重。一般斩刑是正午开刀，让其有鬼做；重犯或十恶不赦之犯，必选午时三刻开刀，不让其做鬼。皇城的午门阳气也最盛，不计时间，所以皇帝令推出午门斩首者，也无鬼做。 十二时辰介绍 十二时辰导读 MBTI人格理论 迈尔斯-布里格斯性格分类指标（英语：Myers-Briggs Type Indicator，简称MBTI）是性格分类理论模型的一种，其基本理论是根据瑞士心理分析家卡尔·荣格于1921年所出版的书籍《心理类型》。最先的研究者是美国心理学家凯瑟琳·布里格斯及其女儿伊莎贝尔·迈尔斯。 人的性格倾向，就象分别使用自己的两只手写字一样，都可以写出来，但惯用的那只写出的会比另一只更好。MBTI是根据荣格的心理类型理论著成，目前已经成为权威的性格测试，Psytopic特别制作了这一在线测试，希望能帮助一些朋友。欢迎人力资源部的朋友，在招聘和任职中试用本测试；同时也可作为个人职业生涯规划分析的参考工具。 MBTI（Myers-Briggs Type Indicator），一种迫选型、自我报告式的性格评估测试，用以衡量和描述人们在获取信息、作出决策、对待生活等方面的心理活动规律和性格类型。 MBTI人格理论的基础是著名心理学家卡尔·荣格先生关于心理类型的划分，后由美国的心理学家Katharine Cook Briggs 与Isabel Briggs Myers研究并加以发展。 此测验的性格分类源自卡尔·荣格的主观观察，而非控制实验。荣格认为人的认知有四个部分，各有两个极端。MBTI测验就是依此理论为基础所发展出来的。 MBTI 测试的四个维度 “外向（E）”与“内向（I）” “实感（S）”与“直觉（N）” “情感（F）”与“思考（T）” “判断（J）”与“感知（P）” 用字母代表如下： 精力支配：外向 E — 内向 I 认识世界：实感 S — 直觉 N 判断事物：思维 T — 情感 F 生活态度：判断 J — 知觉 P 其中两两组合，可以组合成16种人格类型。 参考 迈尔斯-布里格斯性格分类法 wiki MBTI人格理论 荣格的心理类型理论 心理学学术界是怎样看待 MBTI 的？ 较真你就输了 On the Internet, nobody knows you're a dog 键盘侠，真没必要 键盘侠数量多不多，多（因为人口基数大） 键盘侠比例大不大，肯定不大 为什么感觉比例大，因为键盘侠发声比较多，正常人谁那么多时间扯这个 你越较真，键盘侠就越有力量 “在互联网上，没人知道你是一条狗”（英语：On the Internet, nobody knows you're a dog）是一句互联网上的常用语，因为《纽约客》1993年7月5日刊登的一则由彼得·施泰纳（Peter Steiner）创作的漫画标题而变得流行。这则漫画中有两条狗：一条坐在计算机前的一张椅子上，与坐在地板上的另一条狗说出了漫画的标题：“在互联网上，没人知道你是一条狗”。时至2000年，这一漫画是《纽约客》中被重印最多的一则漫画，施泰纳因为此漫画的重印而赚取了超过50,000美元。 小孩没娘，说来话长 幼儿园从外面看里面，养老院是里面看外面，还都是同一波人【小孩开学家长在围栏外观看场景】 如有雷同，纯属意外！！！：刘备用兵如神！！！关羽谦虚谨慎！！！张飞爱兵如子！！！【反讽刘关张的】 酒过三巡是一个汉语词汇，拼音：jiǔ guò sān xún 释义：三并不是指具体的三杯或者三轮。而是指时间长数量多的意思。酒过三巡是指酒已经喝了有一段时间，喝了不少酒了。 有句话叫“酒过三巡，菜过五味”，就是指跟同桌的人喝过三轮(每个人都喝过三杯)，菜色也上了五道之后。这是指饭局已到了尾声的意义。 四海之内皆兄弟 “仗义每多屠狗辈，负心多是读书人”。这是明代诗人曹学佺的著名对联，意思是说，讲义气的多半是从事卑贱职业的普通民众，而有知识的人却往往做出违背良心、背弃情义的事情。 屠龙的勇士终将成为龙？ 嫁错老公毁一生，娶错老婆灭三代 宁与智者争高下，不与傻瓜论短长，如一你果定要与傻瓜论长短，这不是傻瓜的问题，是自己的问题 领导开门你上车，领导夹菜你转桌 过了星期二不愁星期三 过了星期三等于翻过一座山[偷笑] 过了星期三，一天快一天。 过了星期三，翻过一座山， 过了星期四，基本没大事， 过了星期五，还有一上午。 到了礼拜五还有一上午[破涕为笑] 不吐槽也不毒舌，安静的看看电影，品品生活 健身教练的目的很单纯，就是想骗你钱，也有不单纯的（还想要色的） 销售的目的很单纯，就是想骗你钱，也有不单纯的（还想要色的） 科技中立 Open source is dead. Long live open source! 向技术致敬，向开源致敬，向理想主义致敬。 技术无罪，开源不死 开源不死，江湖再见 好人一生平安 不怕贼偷，就怕贼惦记 NGO：非政府组织（英语：non-governmental organization，缩写：NGO， 法语：organisation non gouvernementale，缩写：ONG）是一类不属于任何政府、不由任何国家建立的组织，通常独立于国家政府。虽然从定义上包含以营利为目的的企业，但该名词一般仅限于非商业化、合法的、与社会文化和环境相关的倡导群体。非政府组织通常是非营利组织，他们的基金至少有一部分来源于私人捐款。 由于各国文化、法律等的差异，不同国家对这个概念的指称所适用的对象范围也各不相同。美国一般称之为“非营利组织”、“独立组织”或“第三部门”（The Third Sector），英国称之为“志愿组织”（voluntary organization），还有许多国家则用“社团”称之[1]。因为“非政府组织”的名称可以涵盖一切非政府的组织而存在被滥用的问题，一些非政府组织倾向于使用“民间志愿组织”（private voluntary organization，PVO）的名称。 KOL：关键意见领袖（Key Opinion Leader,简称KOL）是营销学上的概念，通常被定义为：拥有更多、更准确的产品信息，且为相关群体所接受或信任，并对该群体的购买行为有较大影响力的人。 Talk is cheap, Show me the code. 能说算不上什么，有本事就把你的代码给我看看。 赢了天上人间，输了北极海狼 拳打南山幼儿园，脚踢北海养老院 跟人沾边的事情你是一点不干 春风刮驴耳 石狮子灌米汤 长虫钻竹筒 锅里妙石头 好药难治冤孽病，好话难劝糊涂虫 伶俐人一拨三转，糊涂人棒打不回。 大约在几个小时以后，这个浑身散发着土豪气息得男人再次艾特了我，真是运气来了挡都挡不住啊，小编顿时想起来8年前扶过一个老爷爷过马路，那个老爷爷当时帮我摸了一下手相，说我8年后会有一笔横财，难道指的是这个？ 遇事不决，量子力学 风格跳跃，虚拟世界 解释不通，穿越时空/平行时空 不懂配色，赛博朋克 脑洞不够，平行宇宙 画面老土，追求复古 不清不楚，致敬克苏鲁 这充分说明两件事， 一，天下苦（乐？）脑残网文沙雕剧情久矣，以至于连这种调侃都能流行 二，为了押韵什么都写得出来 如何看待「遇事不决，量子力学」的现象？ Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "},"ReadingChart.html":{"url":"ReadingChart.html","title":"ReadingList","keywords":"","body":"待办 ReadingChart ReadingList [ ] 剑指Offer.md [ ] 程序员面试宝典.md [ ] 程序员面试金典.md [ ] Java编程思想.md [ ] 深入理解Java虚拟机 JVM高级特性与最佳实践.md [ ] Effective Java中文版.md [ ] Netty权威指南.md [ ] 鸟哥的Linux私房菜.md [ ] 从PAXOS到ZOOKEEPER分布式一致性原理与实践.md [x] 《代码整洁之道》 1/296 [ ] 《大型网站技术架构——核心原理与案例分析》 218/218 [ ] 《枕边算法书》 243/243 [ ] 《Solr 实战》 77/577 [ ] 《Redis 实战》 [ ] 《Redis 设计与实现》 [ ] 《Java 工程师修炼之道》 [ ] 《编程珠玑第二版》 [ ] 《编程之美：微软技术面试心得》 [ ] 《程序员代码面试指南——IT名企算法与数据结构题目最优解》 [ ] 《Java 程序员面试笔试宝典》 [ ] 《实战 Java 高并发程序设计》 [ ] 《深入分析 Java Web 技术内幕》 [ ] 《高性能 MySQL》 Java OS（OperatingSystem操作系统） Company（各个公司文档） SystemDesign（系统设计） DB（Database数据库） CloudNative（云原生） APMCon演讲PPT Office（办公类） Framework（框架） 计算机书籍查询下载 http://gnetna.com/books/ APMCon演讲PPT 应用性能管理 & 监控：Application Performance Management & Monitoring APMCon是由听云、极客邦科技与InfoQ联合主办的全球高水准APM技术盛会，聚焦当前最为关键的移动端、Web端和Server端的性能监控和管理技术。整个会议包含智能运维、数据库性能优化、移动性能优化、前端性能优化、业务数据实时分析和可视化、微服务与容器与CDN加速等话题。 APMCon内容源于实践并面向社区，来自国内外的演讲嘉宾依据热点话题，面向5年以上的技术团队负责人、中高级开发和运维人员、工程总监分享APM技术创新、趋势和最佳实践。 1、图解spring IOC容器的核心实现原理 2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 3、spring的扩展实现二：BeanPostProcessor接口详解 4、必知必会的13个Bean生命周期处理机制 5、Spring Bean实现Aware接口的意义 6、BeanFactory和FactoryBean的接口对比与实 🔥1、图解spring IOC的实现机制 🔥2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 🔥3、spring的扩展实现二：BeanPostProcessor接口详解 🔥4、必知必会的13个Bean生命周期处理机制 🔥5、BeanFactory和FactoryBean的接口对比与实现机制 🔥6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 🔥7、jdk和cglib动态代理的原理及源码讲解 🔥8、Spring AOP的实现机制及扩展实现 🔥9、巧妙回答spring源码问题，让你成为源码专家 🌟1、spring程序是如何启动的？ 🌟2、spring是如何加载配置文件到应用程序的？ 🌟3、掌握核心接口BeanDefinitionReader 🌟4、掌握核心接口BeanFactory 🌟5、彻底搞懂Spring的refresh方法 🌟6、BeanPostProcessor接口的作用及实现 🌟7、BeanFactoryPostProcessor接口的作用及实现 🌟8、Spring Bean有没有必要实现Aware接口 🌟9、彻底理解bean的生命周期 🌟10、循环依赖问题 🌟11、factoryBean接口的作用 🌟12、bean的初始化都经历了什么 🌟13、cglib和jdk动态代理的机制 🌟14、aop是如何处理的 🌟15、如何回答spring相关的问题 [玫瑰]1、@SpringBootApplication注解解析 [玫瑰]2、@AutoConfiguration注解解析 [玫瑰]3、AutoConfigurationImportSelector解析 [玫瑰]4、spring.factories配置文件的解析过程 [玫瑰]5、@Import标签的解析过程分析 [玫瑰]6、springboot启动流程如何扫描对应的注解 [玫瑰]7、springboot自动装配原理总结 1、阿里对同步深刻思考问题，顶级难度 2、经典老炮哲学家就餐问题，绞尽脑汁 3、异步线程事务咋回滚问题，八月最新 1、美团触及灵魂的同步问题，死伤无数 2、华为经典的线程交替问题，血流成河 3、变种的生产者消费者问题，尸横遍野 🌟高性能架构设计涉及哪些方案 🌟TCP、NIO、reids、分布式性能强悍的核心 🌟微博朋友圈社交系统三高设计 🌟redis与12306票务系统的高并发优化 🌟redis与秒杀类场景的高并发优化 🌟redis与抽奖兑奖的高并发优化 🌟redis分布式锁最容易出现的生产事故 🌟BIO、NIO、EPOLL在三高场景下的优势 🌟高性能中间件有哪些 🌟高性能计算和高性能传输有哪些技术实现 🌟高性能单机内核技术栈有哪些 🌟高性能为什么被很多程序员理解错误 🌟架构师成长路径分享 🌟高效学习，快速提升，系统化掌握技术分享 🌟程序员涨薪跳槽的职业规划分享 01.互联网三高是什么? 👊02.互联网三高演变过程中诞生了哪些技术? 💪03.高并发情况下的单机解决方案 ✌04.高并发情况下的集群解决方案 👉05.高并发情况下的微服务解决方案 [加油]06.高可用解决方案有哪几种 07.是否存在真的高可用 08.互联网三高中的高可用和CAP [耶]09.互联网三高中的高可用和AKF [机智]10.互联网三高中的高可用和ZOOKEEPER [哇]11.互联网三高中的高可用和KEEPALIVED 网约车业务中的派单功能设计。 网约车中微信、支付宝支付流程设计。 网约车中开放平台接口设计。 CAP定理在实际生产中的应用。 网约车中数据一致性的保障上：分布式锁。 网约车中数据一致性的保障上：分布式事务。 项目扩展应用，学项目如何让自己薪资涨10k。 ✨1、以网约车为例，切入分布式项目。 ✨2、互联网高并发项目需求分析（乘客端、司机端、车机端、大屏端）。 ✨3、高并发场景的业务漏洞，正确理解技术赋能业务。 ✨3、实际生产项目中高并发微服务架构设计。 ✨4、如何合理的制定业务架构图来支持高并发和扩展性的挑战。 ✨5、如何在项目开发中沉淀中台能力。 ✨6、项目拆解技术选型以及技术架构图。 ✨7、承载项目关键解决方案的实现。 1、NIO之Channel通道原理 2、NIO之Buffer缓冲区原理 3、NIO之Selector选择器原理 4、Reactor模型原理 5、netty架构分析 6、netty事件循环组原理 7、netty内存管理 8、netty编码器与解码器 9、netty高并发优化 1、NIO之Channel通道原理 2、NIO之Buffer缓冲区原理 3、NIO之Selector选择器原理 4、NIO之网络编程 5、Reactor模型原理 6、游戏开发高并发交互优化 1.综合掌握redis为什么快 2.实力理解redis的6大特征 3.敢用redis的5大value类型 4.再探mysql的性能原理 5.解密kafka为什么快 6.分治、路由、网关、索引 7.贯穿架构设计和面试高频提 8.如何做存储层技术选型 9.应对跳槽涨薪需求 10.解惑学习迷茫问题 11.掌控提升进阶路线 1：从并行到并发 - 垃圾回收基本理论 2：三色标记 - 并发垃圾回收算法 3：CMS的理论与缺陷 4: G1对CMS的修正 5：为什么一个百万级TPS系统会频繁GC？ 6：用一线大厂专业工具进行定位与调优 高并发场景下秒杀超卖Bug复现 秒杀场景下JVM锁现场压测实战 高并发场景下，分布式锁思路分析 高并发秒杀场景下MySQL分布式锁实战 高并发秒杀场景下Redis分布式锁实战 如何在双十一大促中提升分布式锁性能 抗住双十一流量峰值的其他方案 从源码级别看分布式锁如何实现 CAP和BASE理论在分布式场景中的应用 分布式锁全部代码实战压测演示 1、mysql事务的特点有哪些-ACID指的是什么 2、mysql原子性和持久性是如何实现的？ 3、mysql事务的隔离性是如何实现的 4、当前读，快照读，到底读的是什么？ 5、mysql并发访问的核心机制-MVCC 6、共享锁、排它锁、意向锁、自增锁有什么应用场景 7、面试中常问的幻读问题，如何巧妙回答 8、如何监控并查看mysql的锁竞争情况及死锁问题 1、TCP三次握手等面试题 2、SOCKET通信的面试题 3、TCP状态切换的面试题 4、长连接、短连接、有无状态通信、会话等面试题 5、OIO/BIO/NIO/AIO/DIO等IO模型面试题 6、多路复用器EPOLL的面试题 7、NettyIO框架的常见面试题 8、粘包、拆包、粘包、半包、编解码面试题 9、HttpClient、连接池等面试题 10、redis、nginx、tomcat常见通用面试题 11、如何备战金九银十面试突击 12、斩获大厂offer要具备的能力点总结 [玫瑰]1：JAVA的对象有四部分你知道吗？ [玫瑰]2：对象头的三大作用你了解吗？ [玫瑰]3：HashCode就记录在对象内部你清楚吗？ [玫瑰]4：线程的锁信息记录在对象脑袋上你晓得吗？ [玫瑰]5：所谓的锁升级其实就是对象头信息的变化你明白吗？ [玫瑰]6：一个Java\"对象\"到底有多大你衡量过吗？ [玫瑰]7：一线大厂70~100万的年薪你拿的到吗？ 1，小红书笔试题魔法石头过河问题。 2，网易笔试题环形孩子分糖果问题。 3，美团笔试题括号分数问题 ✨1、海量数据下，必知必会的mysql分布式集群 ✨2、海量数据下，如何保证不同事务的数据一致性 ✨3、mysql事务的ACID的底层实现机制全解析 ✨4、mysql海量数据并发访问的核心机制--MVCC ✨5、数据并发访问的mysql幻读问题及解决方案 ✨6、如何监控并调整mysql的锁状态 ✨7、金九银十面试季，如何完美的回答mysql的调优问题 🌟1、海量数据下，如何根据执行计划调优SQL？ 🌟2、mysql索引体系如何应对海量数据存储？ 🌟3、海量数据下，如何设计性能优良的mysql索引 🌟4、mysql的聚簇索引和非聚簇索引全解析 🌟5、mysql索引面试必问名词：回表、索引覆盖，最左匹配 🌟6、如何针对特定SQL场景，来进行索引的调优 🌟7、海量数据下，必知必会的mysql分布式集群 🌟8、海量数据下，如何保证不同事务的数据一致性 🌟9、mysql事务的ACID的底层实现机制全解析 🌟10、mysql海量数据并发访问的核心机制--MVCC 🌟11、数据并发访问的mysql幻读问题及解决方案 🌟12、如何监控并调整mysql的锁状态 🌟13、金九银十面试季，如何完美的回答mysql的调优问题 [玫瑰]1.分布式场景系统中数据一致性问题如何解决 [玫瑰]2.分布式事务的设计思路分析。 [玫瑰]3.两阶段提交协议、三阶段提交协议。 [玫瑰]4.组合存储组件，分布式事务如何解决？ [玫瑰]5.TCC（Try Confirm Cancel）解决方案。 [玫瑰]6.阿里巴巴分布式事务框架：Seata实际落地方案。 [玫瑰]7.消息队列+本地事件表+定时任务方案。 [玫瑰]8.自定义可靠消息服务方案。 1、如何进行自我介绍？ 2、如何陈述自己的项目？ 3、如何回答自己会的问题？ 4、如何回答自己不会的问题？ 5、如何谈薪资？ 6、如何谈缺点？ 7、如何说明自己的职业规划？ 8、如何回答你有什么想问的？ 9、如何回答离职原因 1、Tomcat架构分析 2、Tomcat三大协议处理器 3、NIO多路复用模式原理 4、NIO2全异步处理模式原理 5、APR本地链接库原理 6、Tomcat整体流程分析 🌟1. Java NIO原理 🌟2. Java 网络IO模型原理 🌟3. Reactor组合模型原理 🌟4.BIO，NIO，多种异步IO原理 🌟5. Tomcat 线程模型 🌟6. Tomcat IO模型 🌟7. Tomcat 常见面试题讲解 1、为什么学习Tomcat 2、Tomcat 架构原理 3、Tomcat 源码结构分析 4、Tomcat 核心模块介绍 5、Tomcat IO模型基础之NIO架构 6、Tomcat 源码分析之IO模型原理 7、Tomcat 源码分析之线程模型原理 8、Tomcat 处理Servlet原理 🌟1，通过redis解决千万级并发压力架构设计 🌟2，项目中遇到哪些问题？设计方案？秒杀？雪崩？穿透？击穿？预热？ 🌟3，无锁化，串行化，扁平化克制高并发瓶颈！ 🌟4，redis 宕机了咋办，如何做到可用性和一致性的trad off？ 🌟5，12306抢票，微信红包，电商详情页等高频面试问题！ 🌟6，redis持久化，主从复制，分片集群在BAT中的具体使用设计 🌟7，redis分布式锁造成的架构压力和错误的架构设计问题 🌟8，正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 9，如何和面试官互动获得offer 10，学习方法和面试方法分享 11，逃避认知偏差，技术诅咒，幸存者偏差 12 . 高并发秒杀场景下Redis分布式锁实战 13 .双十一下分布式高并发场景下的存储技术选型 redis为什么快的多个原因？ redis是单线程还是多线程？TCP三次握手四次分手详解什么是长连接和短连接？有状态，无状态？redis和mysql数据同步问题？粘包，拆包，半包等面试题及解决方案 redis、kafka、es、hbase等技术技术选型总结\" [强]一线大厂Redis高并发架构与源码深度剖析 [礼物]1，通过redis解决千万级并发压力架构设计 [礼物]2，项目中遇到哪些问题？设计方案？秒杀？雪崩？穿透？击穿？预热？ [礼物]3，无锁化，串行化，扁平化克制高并发瓶颈！ [礼物]4，redis 宕机了咋办，如何做到可用性和一致性的trad off？ [礼物]5，12306抢票，微信红包，电商详情页等高频面试问题！ [礼物]6，redis持久化，主从复制，分片集群在BAT中的具体使用设计 [礼物]7，redis分布式锁造成的架构压力和错误的架构设计问题 [礼物]8，正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 Day One-大数据数仓平台构建思路及落地深度剖析 🌟1.数据分析平台业务落地痛点分析 🌟2.ER实体关系与范式建模设计与实战案例 🌟3.构建企业战略决策数仓平台原因剖析 🌟4.自上而下与自下而上构建EDW优缺点分析 🌟5.数据仓库维度建模之事实表与维度表划分 🌟6.星型模型、雪花模型、星座模型对比分析 🌟7.企业级数据仓库通用分层设计划分 🌟8.企业级数据仓库案例及数据分层落地实践 [爱心]什么是线程thread [爱心]什么是内核kernel [爱心]什么是锁lock，synchronized [爱心]什么是CAS自旋 [爱心]什么是重量级锁 [爱心]什么是系统调用SC [爱心]什么是函数调用FC [爱心]什么是IO thread [爱心]redis和nginx在epoll下如何工作 [爱心]epoll的内核调用都有哪些如何工作 1、为什么学习Netty 2、Netty架构原理 3、Netty源码结构分析 4、Netty核心模块介绍 5、Netty IO模型基础之NIO架构 6、Netty 源码分析之IO模型原理 7、Netty 源码分析之线程模型原理 🌂1：系统设计方法论多如牛毛，为何DDD如此火热？ 🌂2：设计方案对比，DDD的长处究竟在哪里？ 🌂3：实体、聚合、领域服务、防腐、工厂、仓库都是些什么？ 🌂4：DDD四层架构到底长啥样儿？ 🌂5：讲理论不如举实例，一个案例让你透彻理解DDD 1、一节课教你看懂mysql的执行计划 2、mysql索引的实现原理和数据结构 3、mysql索引设计的技巧 4、mysql聚簇索引和非聚簇索引的区别 5、mysql索引的终极调优方案 6、mysql分布式集群的设计原则 7、mysql如何实现高效的读写分离和分库分表 8、mysql事务隔离性的实现原理 9、mysql的原子性和持久性是如何实现的 10、当前读、快照读，到底读的是什么 11、mysql的并发访问核心机制-MVCC 12、共享锁、排他锁、意向锁、自增锁 13、mysql幻读的实现原理 14、如何查看mysql中的锁等待情况 15、其他mysql问题也可以问 [爱心]1、网约车业务中的派单功能设计。 [爱心]2、网约车中微信、支付宝支付流程设计。 [爱心]3、网约车中开放平台接口设计。 [爱心]4、CAP定理在实际生产中的应用。 [爱心]5、网约车中数据一致性的保障上：分布式锁。 [爱心]6、网约车中数据一致性的保障上：分布式事务。 [爱心]7、项目扩展应用，学项目如何让自己薪资涨10k。 1、以网约车为例，切入分布式项目。 2、互联网高并发项目需求分析（乘客端、司机端、车机端、大屏端）。 3、高并发场景的业务漏洞，正确理解技术赋能业务。 3、实际生产项目中高并发微服务架构设计。 4、如何合理的制定业务架构图来支持高并发和扩展性的挑战。 5、如何在项目开发中沉淀中台能力。 6、项目拆解技术选型以及技术架构图。 7、承载项目关键解决方案的实现。 1，最长无重复子串 2，子数组最大累加和 3，子数组最大累乘积 4，折纸问题 5，返回缺失的最小正整数 1：从并行到并发 - 垃圾回收基本理论 2：三色标记 - 并发垃圾回收算法 3：CMS的理论与缺陷 4: G1对CMS的修正 5：为什么一个百万级TPS系统会频繁GC？ 6：用一线大厂专业工具进行定位与调优 课程内容： 掌握IO性能瓶颈的基本点 掌握架构性能突破的方法 生产事故如何入手定位 67%的生产事故来自于协调问题 97%的生产事故来自于原理的模糊 秒杀场景中架构性能优化解决方案 三高系统中存储层技术的致命问题 技术壁垒，技术边界，技术选型问题 程序员的技术诅咒问题 架构师修炼之路，如何走的更快 从程序员变身架构师的核心知识点分享 从“0”开始，10分钟构建SpringCloud Alibaba项目 抗住淘宝双十一的三大利器：Sentinel、Nacos、RocketMQ Sentinel在淘宝双十一洪峰时限流底层实现原理 Alibaba Sentinel对比 Netflix Hystrix区别与优势 Nacos在淘宝中如何抗住百万服务注册发现与配置下发 RocketMQ在双十一秒杀时如何抗住亿级订单数据 RocketMQ对比其他中间件选型 Alibaba Sentinel、Nacos、RocketMQ常见高薪面试题 实战微服务项目基于KVM虚拟化云原生运维 Apache Skywalking微服务链路追踪实战 Prometheus整合Grafana实现微服务监控大屏 一节课彻底精通同步阻塞非阻塞 Netty 整体架构分析 Netty 事件循环组和事件原理 4.Tomcat 整体架构分析 Tomcat NioEndPointNio2EndPoint原理 Redis 事件循环组抽象模型 BIO NIO AIO模型快速实战与压测分析 深入JDK源码与Hotspot源码 深入Linux内核源码全面掌握Epoll实现机制 深入Redis源码彻底掌握Redis高并发线程模型 大厂面试selectpollepoll区别与分析 Netty多主多从Reactor高并发线程模型优化 ----------------------------------------- 一节课带你搞定高并发场景 一节课带你搞定分布式锁 实战压测在线演示 [玫瑰]1、图解spring IOC的实现机制 [玫瑰]2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 [玫瑰]3、spring的扩展实现二：BeanPostProcessor接口详解 [玫瑰]4、必知必会的13个Bean生命周期处理机制 [玫瑰]5、BeanFactory和FactoryBean的接口对比与实现机制 [玫瑰]6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 [玫瑰]7、jdk和cglib动态代理的原理及源码讲解 [玫瑰]8、Spring AOP的实现机制及扩展实现 [玫瑰]9、巧妙回答spring源码问题，让你成为源码专家\"\"\" [爱心]三高架构中的核心之一：流量网关和业务网关 [爱心]集群化服务与分布式服务的区别 [爱心]项目上线前如何得到正确的全接口性能压测结果 [爱心]通过底层了解Hystrix/Sentienl如何主动隔离资源 [爱心]应该什么时候使用异步响应式Web [爱心]Webflux/ProjectReactor/RxJava/Netty对比Tomcat [爱心]Zuul 1.x zuul2.x Openresty SpringCloudGateway主流网关对比与选型 [爱心]单体应用向微服务异构平台架构演变 [爱心]传统项目如何向微服务升级 [爱心]京东案例 -商城-大规模电商系统的技术挑战 1、CompletableFuture概念与原理 2、CompletableStage接口原理 3、CompletableFuture常见使用方法 4、CompletableFuture与Stream关联与异同 5、CompletableFuture业务线程池隔离技巧 6、CompletableFuture与Servlet3.x异步联合使用技巧 7、CompletableFuture与WebFlux完全异步联合高并发优化 [爱心]tcpip在开发中的作用 [爱心]什么是socket [爱心]什么是三次握手四次挥手 [爱心]如何应对百万连接，如何制造百万连接 [爱心]数据包如何发送出去 [爱心]什么是路由表什么IP地址什么是掩码 [爱心]什么是网关，什么是下一跳 [爱心]什么是链路层，什么是原子通信 [爱心]什么是连接池，并发和连接的关系 [爱心]什么时候能复用什么时候不能复用连接 [爱心]有状态无状态通信的本质是啥 [爱心]拆包粘包到底谁才是罪魁祸首 [爱心]什么是面向连接，什么是可靠传输 [爱心]什么是负载均衡的原子保障 [爱心]百万连接下代理层如何保障后端服务器 [爱心]深刻理解分层解耦的软件工程 1、为什么早期计算机只有进程没有线程？ 2、进程、线程、协程的区别是什么？ 3、现代CPU架构给多线程编程带来了哪些挑战？ 4、三级缓存架构造成的可见性问题如何解决？ 5、内存屏障是如何解决代码乱序性问题的？ 6、为什么阿里京东都喜欢问JUC？ 7、为什么CAS和AQS是JUC的核心？ 8、Latch、Barrier、Semaphore、Phaser等同步器适用于什么场景？ 9、有哪些同步队列可以用于线程池？ 10、Exchanger交换器适用于什么场景？ 11、各种同步器在大厂面试中的综合运用怎么做？ 12、首次公开：从CPU架构的角度理解底层高并发的构成。 1、mysql事务隔离性的实现原理 2、mysql的原子性和持久性是如何实现的 3、当前读、快照读，到底读的是什么 4、mysql的并发访问核心机制-MVCC 5、共享锁、排他锁、意向锁、自增锁 6、mysql幻读的实现原理 7、如何查看mysql中的锁等待情况 8、其他mysql问题也可以问\" ﻿1.为什么一定要听这节课？！ 2.9个面试10个在问NIO 3.IO模型属于底层必须掌握知识点 4.9000块的程序员都被问epoll了 5.张三介绍如何面进京东，腾讯 6.redis 新的面试题已经问到底层了 7.netty面试要聊到源码了 8.kafka的io模型也得懂源码呀 9.reactor原理和实现你知道几个呀 @所有人 [礼物]授课老师：黄俊老师 [月亮]上课时间：晚8点 1、BIO、NIO、AIO模型快速实战与压测分析 2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 3、深入Linux内核源码全面掌握Epoll实现机制 4、深入Redis源码彻底掌握Redis高并发线程模型 5、大厂面试select、poll、epoll区别与分析 6、Reactor响应式编程与Proactor设计模式精讲 7、Netty多主多从Reactor高并发线程模型优化与精讲 8、C10K、C100K、C100K解决与高并发架构实现 9、一节课彻底精通同步、阻塞、非阻塞、异步原理 10、Netty 整体架构分析 11、Netty 事件循环组和事件原理 12、Tomcat 整体架构分析 13、Tomcat NioEndPoint、Nio2EndPoint原理 14、Redis 事件循环组抽象模型 15、Linux内核select、poll、epoll源码分析 🎥上课链接：https://ke.qq.com/course/3579957?tuin=96bc1866 @所有人 [礼物]公开课（VIP体验）：SpringCloud微服务面试技术突击班 [月亮]时间：晚8点 [强]讲师：张一明 ———— 面试必问之微服务生态体系 面试必问之微服务项目架构设计 杀鸡用牛刀 面试必问之微服务治理 面试必问之分布式系统一致性问题 面试必问之微服务亿级流量网关设计与高并发技术架构问题 面试必问之微服务核心组件（SpringCloud Netflix/Alibaba）技术选型 面试必问之互联网公司必问四大类微服务中间件选型 ———— 🎥上课地址：https://ke.qq.com/course/399017?taid=11895294178760361&tuin=6c381156 @所有人 [礼物]深入Hotspot源码与Tomcat、Redis源码多维分析高性能架构设计 [强]授课老师：黄俊老师 [月亮]上课时间：24日晚8点 1、BIO、NIO、AIO模型快速实战与压测分析 2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 3、深入Linux内核源码全面掌握Epoll实现机制 4、深入Redis源码彻底掌握Redis高并发线程模型 5、大厂面试select、poll、epoll区别与分析 6、Reactor响应式编程与Proactor设计模式精讲 7、Netty多主多从Reactor高并发线程模型优化与精讲 8、C10K、C100K、C100K解决与高并发架构实现 9、一节课彻底精通同步、阻塞、非阻塞、异步原理 10、Netty 整体架构分析 11、Netty 事件循环组和事件原理 12、Tomcat 整体架构分析 13、Tomcat NioEndPoint、Nio2EndPoint原理 14、Redis 事件循环组抽象模型 15、Linux内核select、poll、epoll源码分析 🎥上课链接：https://ke.qq.com/course/3579957?tuin=96bc1866 @所有人 [礼物]公开课（VIP体验）：SpringCloud微服务面试技术突击班 [月亮]时间：晚8点 [强]讲师：张一明 ———— 面试必问之微服务生态体系 面试必问之微服务项目架构设计 杀鸡用牛刀 面试必问之微服务治理 面试必问之分布式系统一致性问题 面试必问之微服务亿级流量网关设计与高并发技术架构问题 面试必问之微服务核心组件（SpringCloud Netflix/Alibaba）技术选型 面试必问之互联网公司必问四大类微服务中间件选型 ———— 🎥上课地址：https://ke.qq.com/course/399017?taid=11895294178760361&tuin=6c381156 @所有人 [礼物]一节课学会系统秒杀设计 [月亮]晚8点， 阿里晁老师带你飞 ······· 高并发场景的业务漏洞，正确理解技术赋能业务。 如何进行高纬度思考设计，高并发秒杀系统。 高并发场景下秒杀超卖Bug复现 秒杀场景下JVM锁现场压测实战 高并发场景下，分布式锁思路分析 高并发秒杀场景下MySQL分布式锁实战 高并发秒杀场景下Redis分布式锁实战 如何在双十一大促中提升分布式锁性能 抗住双十一流量峰值的其他方案 从源码级别看分布式锁如何实现 CAP和BASE理论在分布式场景中的应用 分布式锁全部代码实战压测演示 秒杀系统全套解决方案\" ······ 🎥上课地址：https://ke.qq.com/course/399017?taid=11895294178760361&tuin=6c381156 @所有人 [烟花]\"人人畏惧的spring源码，一节课带你成为专家 [强]主讲老师：连鹏举 [月亮]上课时间：晚八点 1、图解spring IOC的实现机制 2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 3、spring的扩展实现二：BeanPostProcessor接口详解 4、必知必会的13个Bean生命周期处理机制 5、BeanFactory和FactoryBean的接口对比与实现机制 6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 7、jdk和cglib动态代理的原理及源码讲解 8、Spring AOP的实现机制及扩展实现 9、巧妙回答spring源码问题，让你成为源码专家\"\"\" [月亮]直播地址：https://ke.qq.com/course/399017?taid=11895294178760361&tuin=6c381156 @所有人 👍大厂算法和数据结构常见面试题 下午4点整 左程云老师分享 ········ 用位运算解决一个有关字符串的分类问题 数组中一种数出现了K次，其他数出现M次，如何省空间的找到这个数？ 丑数问题 构造特殊标准的数组 ······· [太阳]直播地址：https://ke.qq.com/course/399017?taid=11895294178760361&tuin=6c381156 @所有人 [礼物]解密烂大街的Nginx+Redis+MQ+DB架构设计 讲师：周志垒 时间：今晚8点 —————— [爱心]1，Nginx+Redis+MQ+DB下秒杀实现原理 [爱心]2，Nginx+Redis+MQ+DB下限购实现原理 [爱心]3，Nginx+Redis+MQ+DB下亿级流量实现原理 [爱心]4，Redis在架构中的意义 [爱心]5，分布式微服务是快了还是慢了 [爱心]6，高可用和可用性对架构的重要性 [爱心]7，CP v.s AP，在CAP中，到底有没有CP [爱心]8，Redis集群在架构中的重要意义 —————— [烟花]直播链接：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 训练营： 👍能进大厂的实战项目来了，本次课无回放 【亿级流量多级缓存高并发系统架构最优设计】 20-21号 每天晚8点直播 报名链接：https://ke.qq.com/course/3613681?tuin=a028e035 [礼物]马士兵亲授：NB美团7连问,JVM到骨髓\" \"美团：没有深厚JVM功力，你答不出这道题 讲师：马士兵 时间：20:00 —————— \"1：请解释对象的创建过程？ 2：DCL需不需要volatile？ 3：请解释对象在内存中的存储布局？ 4：对象头具体包括什么？ 5：JVM如何定位一个对象？ 6：对象在内存中如何分配？栈上？堆上？ 7：一个Object对象在内存中占用多少字节？ 8：为什么Hotspot不用C++对象代表Java对象？ 9：Class对象到底是位于堆内存还是方法区？ 10：为什么大厂要刨根问底？ —————— [烟花]直播链接：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 今天晚上马老师直播间抽【苹果手机12plus】，【音箱】，【500套书】，来直播间的必中 [庆祝]非VIP 和VIP 都可以参加 @所有人 深入Hotspot源码与Tomcat、Redis源码多维分析高性能架构设计 讲师：黄俊 时间：15:00 —————— 1、BIO、NIO、AIO模型快速实战与压测分析 2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 3、深入Linux内核源码全面掌握Epoll实现机制 4、深入Redis源码彻底掌握Redis高并发线程模型 5、大厂面试select、poll、epoll区别与分析 6、Reactor响应式编程与Proactor设计模式精讲 7、Netty多主多从Reactor高并发线程模型优化与精讲 8、C10K、C100K、C100K解决与高并发架构实现 9、一节课彻底精通同步、阻塞、非阻塞、异步原理 10、Netty 整体架构分析 11、Netty 事件循环组和事件原理 12、Tomcat 整体架构分析 13、Tomcat NioEndPoint、Nio2EndPoint原理 14、Redis 事件循环组抽象模型 15、Linux内核select、poll、epoll源码分析 —————— [烟花]直播链接：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 @所有人 [666]vip课抢先听，复杂的spring源码从哪儿开始看 💎主讲老师：连鹏举老师 [月亮]上课时间：20：00 1、图解spring IOC的实现机制 2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 3、spring的扩展实现二：BeanPostProcessor接口详解 4、必知必会的13个Bean生命周期处理机制 5、BeanFactory和FactoryBean的接口对比与实现机制 6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 7、jdk和cglib动态代理的原理及源码讲解 8、Spring AOP的实现机制及扩展实现 9、巧妙回答spring源码问题，让你成为源码专家 [勾引]上课地址：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 @所有人 [礼物]超高并发下分布式锁的应用场景及最优解决方案 [强]主讲老师：晁鹏飞 [月亮]上课时间：20：00 高并发场景秒杀超卖Bug复现 秒杀场景下JVM锁现场压测实战 高并发场景下 高并发秒杀场景下MySQL分布式锁实战 高并发秒杀场景下Redis分布式锁实战 如何在双十一大促中提升分布式锁性能 抗住双十一流量峰值的其他方案 从源码级别看分布式锁如何实现 CAP和BASE理论在分布式场景中的应用 分布式锁全部代码实战压测演示 分布式锁思路分析 秒杀系统全套解决方案 [勾引]上课地址：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 @所有人 [炸弹]更新大量redis新版本的问题 上课时间：20：00 主讲老师：周志垒老师 1、redis 6.x主从同步机制？ 2、redis 6.x集群原理及问题？ 3、redis 6.x百万的QPS？十万QPS？ 4、redis 6.x分布式锁实现？ 5、redis 6.x是好还是坏，有哪些争论？ 6、redis 6.x留给程序员的时间不多了！ [勾引]上课链接：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [烟花]微服务SpringCloud Alibaba高并发压测实战 上课时间：晚八点 主讲老师：一明老师 \"抗住淘宝双十一的三大利器：Sentinel、Nacos、RocketMQ Alibaba Sentinel在淘宝双十一洪峰时限流底层实现原理 Alibaba Sentinel对比 Netflix Hystrix区别与优势 微服务生态体系SpringCloud Netflix/Alibaba Nacos 与 Apollo 、SpringCloud Config技术选型 SpringCloud+ Skywalking微服务全链路压测与监控预警 基于云原生Sentinel百万并发限流压测 Nginx+mysql方案 单机压测对比 SpringBoot + Mysql 方案 单机压测对比 SpringBoot + redis 方案 单机压测对比 Nginx+静态缓存方案 单机压测对比 Nginx+redis方案 单机压测对比\" 上课链接：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [礼物]\"月薪2W必问spring源码，如何完美应对，这节课给你答案\" [强]讲师：连鹏举老师 [月亮]时间：20：00 🌟1、图解spring IOC的实现机制 🌟2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 🌟3、spring的扩展实现二：BeanPostProcessor接口详解 🌟4、必知必会的13个Bean生命周期处理机制 🌟5、BeanFactory和FactoryBean的接口对比与实现机制 🌟6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 🌟7、jdk和cglib动态代理的原理及源码讲解 🌟8、Spring AOP的实现机制及扩展实现 🌟9、巧妙回答spring源码问题，让你成为源码专家\" 🎥上课链接：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 💻亿级流量电商系统，秒杀如何设计？ 💝讲师：晁鹏飞老师 🔔时间：20：00 1.高并发场景的业务漏洞，正确理解技术赋能业务。 2.如何进行高纬度思考设计，高并发秒杀系统。 3.高并发场景下秒杀超卖Bug复现 4.秒杀场景下JVM锁现场压测实战 5.高并发场景下，分布式锁思路分析 6.高并发秒杀场景下MySQL分布式锁实战 7.高并发秒杀场景下Redis分布式锁实战 8.如何在双十一大促中提升分布式锁性能 9.抗住双十一流量峰值的其他方案 10.从源码级别看分布式锁如何实现 11.CAP和BASE理论在分布式场景中的应用 12.分布式锁全部代码实战压测演示 13.秒杀系统全套解决方案\" 🍻上课链接：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 🎉30万面试题：巧用弱引用解决ThreadLocal内存泄漏 [哇]主讲老师：马士兵老师 [月亮]上课时间：20:00 🌟强引用的原理与应用场景 🌟软引用的原理与应用场景 🌟弱引用的原理与应用场景（重点） 🌟虚引用的原理与应用场景 🌟ThreadLocal到底存不存在内存泄漏？ 🌟深入JDK源码解读ThreadLocal的私有领地 🌟面试官问题ThreadLocal泄漏问题如何回答才完善？ 🚀上课链接：https://ke.qq.com/course/399017 @所有人 [爱情]MySQL训练营第二节课： 超高并发下如何优雅的设计mysql数据库 [玫瑰]主讲老师：连鹏举 [月亮]上课时间：晚20：00 ⭕mysql事务隔离性的实现原理 ⭕mysql的原子性和持久性是如何实现的 ⭕当前读、快照读，到底读的是什么 ⭕mysql的并发访问核心机制-MVCC ⭕共享锁、排他锁、意向锁、自增锁 ⭕mysql幻读的实现原理 ⭕如何查看mysql中的锁等待情况 [勾引]上课链接：https://ke.qq.com/course/399017 @所有人 🔫完整成体系的从BIO到NIO到EPOLL多路复用器 [太阳]今晚8点 💎主讲老师：周志垒老师 🎈网络IO的本质是什么 🎈BIO模型如何实现通信，优缺点？ 🎈NIO在内核中的表现是什么，优缺点？ 🎈NIO在JDK中的表现是什么，优缺点？ 🎈多路复用器的演变过程是什么？ 🎈select，poll，epoll多路复用器的差异？ 🎈IO知识体系的重要性，重点在那里？ 🎈什么是系统调用？ 🎈什么是内核？和IO什么关系？ 🎈不同IO模型在内核的演变过程？ 🚀戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [机智]大厂考察算法和数据结构的几个侧重点 ☀下午3点30，左程云老师 🌟1，字符串数组中有几类的问题 🌟2，绳子最大覆盖问题 🌟3，超级水王问题 🌟4，zigzag打印矩阵问题 🌟5，顺时针旋转正方形矩阵的调整 ········ 🎥上课地址：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]如此简单！BATJ千亿级数据搜索服务 [月亮]时间：20:00 [耶]讲师：吴磊 ………… ✨1、海量数据搜索服务的技术选型 ✨2、为什么MySQL不适合大数据文本检索 ✨3、刨根问底，带你深入索引的本质 ✨4、倒排索引的核心原理 ✨5、倒排索引的数据结构 ✨6、倒排表中的压缩算法（FOR和RBM） ✨7、Trie字典树（前缀树）原理 ✨8、FST的底层原理 ✨9、Lucene源码剖析 ✨10、跳槽的正确姿势 ………… 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [得意]薪水的天花板！技术+管理，让老板为你打工。 [激動]主讲老师：张一明老师 🌙上课时间：20：00 面试两大难题 微服务和高并发系统架构 微服务生态体系：30个框架全栈架构生态体系链路解析 双十一秒杀系统多级缓存“读、写”分离 京东电商详情页系统架构演化过程 高并发系统中的限流与降级处理 SpringCloud Alibaba Sentinel在淘宝双十一洪峰时限流底层实现原理 Nacos 与 Apollo 、SpringCloud Config技术选型 技术+管理：员工心态切换的六大谬误 如何解决学了很多东西却记不住 一个普通程序员在35岁以后该如何生存 野生程序员生存法则 8k ~ 80k的简历这么写？！快来看一下 在线修改简历 [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [嘿哈]训练营第二天：可以写简历进大厂的网约车微服务项目 💎主讲老师：阿里P7晁鹏飞老师 [月亮]上课时间：晚20:00 网约车业务中的派单功能设计 网约车中微信、支付宝支付流程设计 网约车中开放平台接口设计 CAP定理在实际生产中的应用 网约车中数据一致性的保障上：分布式锁 网约车中数据一致性的保障上：分布式事务 项目扩展应用，学项目如何让自己薪资涨10k [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [让我看看]面试突击微服务分布式拿下十多个offer [玫瑰]讲师：周志垒 [蛋糕]上课时间:20:00-23:00 从0到1参与项目架构设计 从0到1参与项目功能重构 项目中的亮点有哪些 项目中的痛点有哪些 三高架构面临的问题 线程池、连接池、分库分表 threadlocal、nio、netty redis、kafka、rabbitmq 负载均衡、高可用、微服务划分 传统项目如何应对三高问题 高并发、大数据的首选解决方案 大厂面试高频架构设计题思路 为什么大厂都不用主从同步 读写分离、业务隔离、分片集群常见的坑 秒杀、12306抢票、抢红包等高频面试问题 [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [吃瓜]听说一问HashMap你就懵逼？ [月亮]上课时间：今晚20点 [庆祝]授课老师：赵珊珊老师（马士兵教育首位美女讲师） 1.全网最细致源码解读 2.HashMap1.8深度解读（1.7赠送） 3.底层原理揭秘 4.面试必问： 1）为什么主数组长度要为2的n次幂？ 2）底层如何确保主数组长度为2的n次幂？ 3）哈西算法技巧揭秘？ 4）为什么桶中节点个数超过8才会转为红黑树？ 5）装填因子为0.75的原因？ 6）key的equals方法一定会被调用吗？ [勾引]上课链接：https://ke.qq.com/course/399017 @所有人 [机智]高并发系统架构：揭秘SpringCloud Alibaba如何应对双十一 [耶]讲师：张一明 [月亮]时间：20:00 ———————— [玫瑰]1. 从“0”开始，10分钟构建SpringCloud Alibaba项目 [玫瑰]2. 抗住淘宝双十一的三大利器：Sentinel、Nacos、RocketMQ [玫瑰]3. Sentinel在淘宝双十一洪峰时限流底层实现原理 [玫瑰]4. Alibaba Sentinel对比 Netflix Hystrix区别与优势 [玫瑰]5. Nacos在淘宝中如何抗住百万服务注册发现与配置下发 [玫瑰]6. RocketMQ在双十一秒杀时如何抗住亿级订单数据 [玫瑰]7. RocketMQ对比其他中间件选型 [玫瑰]8. Alibaba Sentinel、Nacos、RocketMQ常见高薪面试题 [玫瑰]9. 实战微服务项目基于KVM虚拟化云原生运维 [玫瑰]10. Apache Skywalking微服务链路追踪实战 [玫瑰]11. Prometheus整合Grafana实现微服务监控大屏 —————————— [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 ⭕多线程训练营第二天：两天让你彻底征服多线程 [拥抱]主讲老师：马士兵老师 [月亮]上课时间：20:00 [玫瑰]为什么百度腾讯喜欢跟你聊线程池？ [玫瑰]JDK有哪些直接可用的线程池？ [玫瑰]线程池如果需要自定义，有哪些参数可以定义？ [玫瑰]生产环境中的线程池如何监控？ [玫瑰]线程池有哪些在实际中的应用场景？ [玫瑰]面向未来，学习路线指引与职业规划指导 [勾引]上课链接：https://ke.qq.com/course/399017 @所有人 [愉快]听完这节课，让你轻松进入蚂蚁金服 今晚8点，连老师 ········ 1、图解spring IOC的实现机制 2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 3、spring的扩展实现二：BeanPostProcessor接口详解 4、必知必会的13个Bean生命周期处理机制 5、BeanFactory和FactoryBean的接口对比与实现机制 6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 7、jdk和cglib动态代理的原理及源码讲解 8、Spring AOP的实现机制及扩展实现 9、巧妙回答spring源码问题，让你成为源码专家\" ········· [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [炸弹]一万到三万，掌握这些点就够了 [拥抱]主讲：马士兵教学总监，周老师 [月亮]上课时间：20:00 ✨ 三高系统必然涉及的面试题核心讲解 ✨高并发、大数据的首选解决方案 ✨双十一下分布式高并发场景下的存储技术选型 ✨redis、kafka、es、hbase等技术技术选型总结 ✨大厂面试高频架构设计题思路 ✨为什么大厂都不用主从同步 ✨读写分离、业务隔离、分片集群常见的坑 ✨正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 ✨mysql索引的性能问题 ✨redis为什么快的多个原因 ✨redis是单线程还是多线程 ✨秒杀、12306抢票、微信红包、电商详情页等高频面试问题 [勾引]上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 [爱心]MCA绝版价+终身免费升级学习30号结束 [爱心]MCAplus-大厂合作真实项目班，大厂合作人才定向培养班即将上线31980 [爱心]金九银十跳槽涨薪班预售30号结束 [爱心]预售期间，奖金福利+学生和之前有过培训经历，减免学费 @所有人 [咖啡]深入Hotspot源码与Tomcat、Redis源码多维分析高性能架构设计 [激動]主讲老师：黄俊老师 [月亮]晚上20：00~23：00 1、BIO、NIO、AIO模型快速实战与压测分析 2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 3、深入Linux内核源码全面掌握Epoll实现机制 4、深入Redis源码彻底掌握Redis高并发线程模型 5、大厂面试select、poll、epoll区别与分析 6、Reactor响应式编程与Proactor设计模式精讲 7、Netty多主多从Reactor高并发线程模型优化与精讲 8、C10K、C100K、C100K解决与高并发架构实现 9、一节课彻底精通同步、阻塞、非阻塞、异步原理 10、Netty 整体架构分析 11、Netty 事件循环组和事件原理 12、Tomcat 整体架构分析 13、Tomcat NioEndPoint、Nio2EndPoint原理 14、Redis 事件循环组抽象模型 15、Linux内核select、poll、epoll源码分析 [勾引]课程链接：https://ke.qq.com/course/2770807?taid=11786983695861623&tuin=2dba14c7 [爱心]MCA绝版价+终身免费升级学习30号结束 [爱心]MCAplus-大厂合作真实项目班，大厂合作人才定向培养班即将上线31980 [爱心]金九银十跳槽涨薪班预售30号结束 [爱心]预售期间，奖金福利+学生和之前有过培训经历，减免学费 @所有人 [啤酒]数据库终极讲解，搞定这些，涨薪5k [月亮]晚上20：00~23：00 [玫瑰]主讲老师：连鹏举 1、一节课教你看懂mysql的执行计划 2、mysql索引的实现原理和数据结构 3、mysql索引设计的技巧 4、mysql聚簇索引和非聚簇索引的区别 5、mysql索引的终极调优方案 6、mysql分布式集群的设计原则 7、mysql如何实现高效的读写分离和分库分表 8、mysql事务隔离性的实现原理 9、mysql的原子性和持久性是如何实现的 10、当前读、快照读，到底读的是什么 11、mysql的并发访问核心机制-MVCC 12、共享锁、排他锁、意向锁、自增锁 13、mysql幻读的实现原理 14、如何查看mysql中的锁等待情况 15、其他mysql问题也可以问 [勾引]https://ke.qq.com/course/399017?taid=10693923106592425&tuin=a028e035 [爱心]MCA绝版价+终身免费升级学习30号结束 [爱心]MCAplus-大厂合作真实项目班，大厂合作人才定向培养班即将上线31980 [爱心]金九银十跳槽涨薪班预售30号结束 [爱心]预售期间，奖金福利+学生和之前有过培训经历，减免学费 @所有人 [坏笑]手把手带你实战定位高并发系统的内存溢出 [月亮]晚上20：00~23：00 💎主讲老师：马士兵 🍏为什么一个百万级TPS系统会频繁GC？ 🍏定位JVM问题的实用参数设置 🍏用top jps jstat jmap 等“业余”命令行工具进行定位 🍏 用图形化工具visual VM，MAT，Jprofiler进行定位 🍏 用一线大厂专业工具进行定位与调优 🍏手把手带你学习瞬间涨薪5K的JVM优化操作 🍏错标 漏标 增量更新-三色标记深入详解 🍏面向未来的GC-G1 Shenandoah ZGC 🍏国内首发，绝密一手GC资料大放送 [勾引]戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [礼物]快速上手SpringCloud微服务系统架构+常用中间件服务,划重点：【两天上课打卡签到送书籍一本】 [玫瑰]主讲老师：张一明 [月亮]上课时间：20:00 🌟1.SOA、Webservice、Dubbo、SpringCloud究竟什么是微服务？ 🌟2.单体应用向微服务异构平台架构演变 🌟3. SpringCloud微服务组件生态体系 🌟1）SpringCloud Netflix 🌟2）•SpringCloud Alibaba 🌟4. 从零开始构建微服务项目各组件应用场景及代码实现 🌟1）Eureka 微服务注册与发现 🌟2）Actuator 微服务监控 🌟3）RestTemplate 服务器远程调用 🌟4）Ribbon 客户端的负载均衡 🌟5）OpenFeign 声明式服务调用 🌟6）Hystrix 微服务熔断、降级、资源隔离 🌟7）HystrixDashboard 🌟8）Zuul 微服务网关 🌟9）Config 微服务配置中心 🌟10）Sleuth zipkin 微服务链路追踪 🌟5. 常用中间件服务核心解密与技术选型 🌟1）分布式文件存储中间件 FastDFS 🌟2）分布式消息中间件 RocketMQ Kafka RabbitMQ ActiveMQ 🌟3）分布式搜索中间件ElasticSearch 🌟4）分布式缓存中间件 Redis 🌟5）高并发高性能接入层中间件 LVS、Keepalived、Nginx、Haproxy 报名+上课链接：https://ke.qq.com/course/3550234?tuin=6b8f4996 @所有人 [礼物]618电商销量是如何预测的？ ☀15：30 [机智]讲师：吴老师 🌟1.回归的主要任务是什么? 🌟2.使用Kaggle公开数据跑线性回归 🌟3.如何进行特征工程、特征向量化 🌟4.高中数学足够带你玩转机器学习 🌟5.机器学习调参是怎么调的 🌟6.参数调节可视化 🌟7.如何判断模型训练过头了？ 🌟8.带你花式玩转线性回归 🌟9.训练集数据量真的越大越好吗？ 🌟10.线性回归怎么进行交叉验证？ 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10318882267338409&tuin=a982d3d7 @所有人 [礼物]一节课搞定，分布式事务全套解决方案 [月亮]时间：晚8点 [耶]讲师：阿里晁老师 [玫瑰]分布式场景系统中数据一致性问题如何解决 [玫瑰]分布式事务的设计思路分析。 [玫瑰]两阶段提交协议、三阶段提交协议。 [玫瑰]组合存储组件，分布式事务如何解决？ [玫瑰]TCC（Try Confirm Cancel）解决方案。 [玫瑰]阿里巴巴分布式事务框架：Seata实际落地方案。 [玫瑰]消息队列+本地事件表+定时任务方案。 [玫瑰]自定义可靠消息服务方案。 [玫瑰]最大努力通知方案。 🎥上课链接：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [机智]挑战薪水的天花板！一堂课让你看透程序员这个行业 [耶]主讲老师：马士兵及联合创始人 [月亮]上课时间：20:00 [玫瑰]掌握的技术和对应的工资 [玫瑰]70w以上年薪是靠这100个技术点支撑的 [玫瑰]那些大佬是这样从月薪3000到日薪3000的 [玫瑰]从0k~50k+必备技能栈 [玫瑰]宝贵的学习时间，需要高效的学习方法 [玫瑰]厚积薄发 你的大刀已经饥渴难耐了 跳槽/涨薪/晋升 [玫瑰]需要多久，才能让我的银行卡余额有100万元 [玫瑰]架构师这个岗位那些不为人知的秘密 [玫瑰]VIP学员收集的经典问题，在线答疑 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [礼物]掌握linux内核，jvm，拿下十多个offer [月亮]晚20：00 [耶]主讲老师：教学总监周老师 🌟传授程序员跳槽涨薪的核心方法 🌟掌握linux内核，就掌握了中间件、分布式 🌟什么是线程，什么是锁，和内核什么关系？ 🌟什么是tcp/ip，什么是epoll，和内核什么关系？ 🌟什么是心跳，什么是脑裂，为什么提出CAP？ 🌟闪断、掉电、切断光纤对架构的影响？ 🌟揭秘程序员毁了程序员的三件事！ 🌟应届生怎么学，学那些可以进大厂？ 🌟社招如何突击，学那些可以进大厂？ 🌟传统项目如何面进互联网公司，触及三高项目？ 🌟专科学历怎么学，学那些可以涨薪？ 🌟大龄危机如何破解轻松涨薪？ 🌟程序员都在寻求规划，那么规划指的是那些？ 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [礼物]深入Hotspot源码与Tomcat、Redis源码多维分析高性能架构设计 [月亮]晚上20：00~23：00 [强]主讲老师：黄俊老师 [爱心]1、BIO、NIO、AIO模型快速实战与压测分析 [爱心]2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 [爱心]3、深入Linux内核源码全面掌握Epoll实现机制 [爱心]4、深入Redis源码彻底掌握Redis高并发线程模型 [爱心]5、大厂面试select、poll、epoll源码分析 [爱心]6、Reactor响应式编程与Proactor设计模式精讲 [爱心]7、Netty多主多从Reactor高并发线程模型优化与精讲 [爱心]8、C10K、C100K、C100K解决与高并发架构实现 [爱心]9、一节课彻底精通同步、阻塞、非阻塞、异步原理 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [机智]微服务SpringCloud Alibaba高并发压测实战 [奸笑]20:00 秋名山车神张一明 [玫瑰]1、抗住淘宝618、双11的三大利器：Sentinel、Nacos、RocketMQ [玫瑰]2、Alibaba Sentinel在淘宝618、双11洪峰时限流底层实现原理 [玫瑰]3、Alibaba Sentinel对比 Netflix Hystrix区别与优势 [玫瑰]4、微服务生态体系SpringCloud Netflix/Alibaba [玫瑰]5、Nacos 与 Apollo 、SpringCloud Config技术选型 [玫瑰]6、SpringCloud+ Skywalking微服务全链路压测与监控预警 [玫瑰]7、基于云原生Sentinel百万并发限流压测 [玫瑰]8、Nginx+mysql方案 单机压测对比 [玫瑰]9、SpringBoot + Mysql 方案 单机压测对比 [玫瑰]10、SpringBoot + redis 方案 单机压测对比 [玫瑰]11、Nginx+静态缓存方案 单机压测对比 [玫瑰]12、Nginx+redis方案 单机压测对比 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [强]亿级流量电商系统，如何解决超卖问题 [玫瑰]授课老师：阿里p7晁鹏飞老师 [月亮]上课时间：今晚8点 🌟1. 高并发场景下秒杀超卖Bug复现 🌟2. 秒杀场景下JVM锁现场压测实战 🌟3. 高并发场景下，分布式锁思路分析 🌟4. 高并发秒杀场景下MySQL分布式锁实战 🌟5. 高并发秒杀场景下Redis分布式锁实战 🌟6. 如何在双十一大促中提升分布式锁性能 🌟7. 抗住双十一流量峰值的其他方案 🌟8. 从源码级别看分布式锁如何实现 🌟9. CAP和BASE理论在分布式场景中的应用 🌟10. 分布式锁全部代码实战压测演示 🌟11. 秒杀系统全套解决方案 🚀上课链接：https://ke.qq.com/course/399017 @所有人 [强]亿级流量电商系统，如何解决超卖问题 [玫瑰]授课老师：阿里p7晁鹏飞老师 [月亮]上课时间：今晚8点 🌟1. 高并发场景下秒杀超卖Bug复现 🌟2. 秒杀场景下JVM锁现场压测实战 🌟3. 高并发场景下，分布式锁思路分析 🌟4. 高并发秒杀场景下MySQL分布式锁实战 🌟5. 高并发秒杀场景下Redis分布式锁实战 🌟6. 如何在双十一大促中提升分布式锁性能 🌟7. 抗住双十一流量峰值的其他方案 🌟8. 从源码级别看分布式锁如何实现 🌟9. CAP和BASE理论在分布式场景中的应用 🌟10. 分布式锁全部代码实战压测演示 🌟11. 秒杀系统全套解决方案 🚀上课链接：https://ke.qq.com/course/3547707?tuin=6b8f4996 @所有人 [礼物]训练营第一天：更新大量redis新版本的问题redis 6.x为什么快？ [强]主讲老师：周志垒老师 [月亮]上课时间：20:00 [玫瑰]redis 6.x多线程原理及IO模型原理？ [玫瑰]redis 6.x持久化机制有哪些痛点？ [玫瑰]redis 6.x新特性有哪些？ [玫瑰]redis 6.x计算向数据移动原理？ [玫瑰]redis 6.x原子操作和事务原理？ 🎥上课链接：https://ke.qq.com/course/3547707?tuin=6b8f4996 @所有人 [机智]深入Hotspot源码与Linux内核多维度理解NIO、Netty、Redis线程模型 [月亮]晚上20：00~23：00 [耶]主讲老师：黄俊老师 [玫瑰]1、BIO、NIO、AIO模型快速实战与压测分析 [玫瑰]2、深入JDK源码与Hotspot源码彻底掌握NIO多路复用器 [玫瑰]3、深入Hotspot源码与Linux内核理解Epoll红黑树与链表模型 [玫瑰]4、大厂面试select、poll、epoll模型原理分析 [玫瑰]5、深入Redis源码彻底掌握Redis高并发线程模型 [玫瑰]6、Reactor响应式编程与Proactor设计模式精讲 [玫瑰]7、Netty多主多从Reactor高并发线程模型优化与精讲 [玫瑰]8、C10K、C100K、C100K解决与高并发架构实现 [玫瑰]9、彻底讲透同步、阻塞、非阻塞、异步原理 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [机智]掌握TCP / IP，NIO拿下十多个offe [耶]今晚：20:00 讲师：周志垒老师 [爱心]tcpip在开发中的作用 [爱心]什么是socket [爱心]什么是三次握手四次挥手 [爱心]如何应对百万连接，如何制造百万连接 [爱心]数据包如何发送出去 [爱心]什么是路由表什么IP地址什么是掩码 [爱心]什么是网关，什么是下一跳 [爱心]什么是链路层，什么是原子通信 [爱心]什么是连接池，并发和连接的关系 [爱心]什么时候能复用什么时候不能复用连接 [爱心]有状态无状态通信的本质是啥 [爱心]拆包粘包到底谁才是罪魁祸首 [爱心]什么是面向连接，什么是可靠传输 [爱心]什么是负载均衡的原子保障 [爱心]百万连接下代理层如何保障后端服务器 [爱心]深刻理解分层解耦的软件工程程 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=4430044017858217&tuin=6c381156 @所有人 [强]算法和数据结构大厂经典面试题 [机智]下午3点半，左成云老师 内容： [玫瑰]1，容器装水问题 [玫瑰]2，随机函数的加工问题 [玫瑰]3，01函数调整成等概率问题 [玫瑰]4，寻找出现奇数次的数 [玫瑰]5，寻找出现K次的数 ········· 🎥上课地址：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [强]理论+实践：BATJ千亿级数据分布式搜索服务（上） [玫瑰]主讲老师：吴磊 [月亮]上课时间：晚八点 [礼物]1 两小时搞定搜索引擎：课程介绍 [礼物]2 海量数据搜索服务的技术选型 [礼物]3 Elasticsearch的应用场景有哪些 [礼物]4 基础服务的安装和搭建 [礼物]5 Luncene和Elasticsearch [礼物]6 啥是分布式搜索引擎 [礼物]7 实操：MySQL和ES的数据同步方案 [礼物]8 ES Java客户端 [礼物]9 Elastic学习方法论？ [礼物]10 面试的那点事儿 🎥上课地址：https://ke.qq.com/course/3518559?tuin=a1b820d2 @所有人 [耶]京东618秒杀系统，独家深度解密。 [月亮]今晚：20:00 [强]讲师：晁鹏飞（阿里p7） 🌟1. 京东618和淘宝双11架构设计的区别 🌟2. 高并发场景的业务漏洞，正确理解技术赋能业务。 🌟3. 如何进行高纬度思考,设计高并发秒杀系统。 🌟4. 高并发场景下秒杀超卖Bug复现 🌟5. 秒杀场景下JVM锁现场压测实战 🌟6. 高并发场景下，分布式锁思路分析 🌟7. 高并发秒杀场景下MySQL分布式锁实战 🌟8. 高并发秒杀场景下Redis分布式锁实战 🌟9. 如何在双十一大促中提升分布式锁性能 🌟10. 抗住双十一流量峰值的其他方案 🌟11. 从源码级别看分布式锁如何实现 🌟12. CAP和BASE理论在分布式场景中的应用 🌟13. 分布式锁全部代码实战压测演示 🌟14. 秒杀系统全套解决方案 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]一节课学会人工智能思想 [机智]主讲老师：吴老师 ☀上课时间：15：30 [玫瑰]1.3分钟带你了解AI的前世今生 [玫瑰]2.一节课带你学会70%人工智能算法思想 [玫瑰]3.如何进行特征工程、特征向量化 [玫瑰]4.回归问题的本质是什么？ [玫瑰]5.大样本中如何找到合适的拟合线？ [玫瑰]6.线性回归MSE能用MAE代替吗？ [玫瑰]7.数学不懂一样带你弄懂啥叫梯度下降？ [玫瑰]8.训练集中的MSE真的越小越好吗？ [玫瑰]9.Kaggle比赛线性回归房价预测 [玫瑰]10.你做过的模型训练姿势对吗 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]618三高架构微服务分布式设计实现 [强]主讲老师：周志垒老师 [月亮]上课时间：20:00 [爱心]从0到1参与项目架构设计 [爱心]从0到1参与项目功能重构 [爱心]项目中的亮点有哪些 [爱心]项目中的痛点有哪些 [爱心]三高架构面临的问题 [爱心]线程池、连接池、分库分表 [爱心]threadlocal、nio、netty [爱心]redis、kafka、rabbitmq [爱心]负载均衡、高可用、微服务划分 [爱心]传统项目如何应对三高问题 [爱心]高并发、大数据的首选解决方案 [爱心]大厂面试高频架构设计题思路 [爱心]为什么大厂都不用主从同步 [爱心]读写分离、业务隔离、分片集群常见的坑 [爱心]秒杀、12306抢票、抢红包等高频面试问题 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]京东618亿级并发下各种常用中间件该如何选型？ [强]﻿主讲老师：张一明 [月亮]上课时间：20:00 🌟\"1. Eureka 微服务注册与发现 🌟2. Actuator 微服务监控 🌟3. RestTemplate 服务器远程调用 🌟4. Ribbon 客户端的负载均衡 🌟5. OpenFeign 声明式服务调用 🌟6. Hystrix 微服务熔断、降级、资源隔离 🌟7. HystrixDashboard 🌟8. Zuul 微服务网关 🌟9. Config 微服务配置中心 🌟10、 淘宝网/拼多多 高并发秒杀系统需求拆解\" 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]训练营第二讲：投资55亿网约车项目下 [耶]﻿主讲老师：阿里晁老师（霍州） [月亮]上课时间：20:00 [玫瑰]1. 网约车业务中的派单功能设计。 [玫瑰]2. 网约车中微信、支付宝支付流程设计。 [玫瑰]3. 网约车中开放平台接口设计。 [玫瑰]4. CAP定理在实际生产中的应用。 [玫瑰]5. 网约车中数据一致性的保障上：分布式锁。 [玫瑰]6. 网约车中数据一致性的保障上：分布式事务。 [玫瑰]7. 项目扩展应用，学项目如何让自己薪资涨10k。 🎥上课链接：https://ke.qq.com/course/3489179?tuin=2dba14c7 @所有人 [礼物]听说一问HashMap你就懵逼？ [月亮]上课时间：今晚20点 [玫瑰]授课老师：赵珊珊老师（马士兵教育首位美女讲师） 🌟1.全网最细致源码解读 🌟2.HashMap1.8深度解读（1.7赠送） 🌟3.底层原理揭秘 🌟4.面试必问： 1）为什么主数组长度要为2的n次幂？ 🌟2）底层如何确保主数组长度为2的n次幂？ 3）哈西算法技巧揭秘？ 🌟4）为什么桶中节点个数超过8才会转为红黑树？ 🌟5）装填因子为0.75的原因？ 🌟6）key的equals方法一定会被调用吗？ 🎥上课链接：https://ke.qq.com/course/399017 @所有人 💝618来袭，一节课带你搞定索引系统，快速检索数据 🌟1、一节课教你看懂mysql的执行计划 🌟2、mysql索引的实现原理和数据结构 🌟3、mysql索引设计的技巧 🌟4、mysql聚簇索引和非聚簇索引的区别 🌟5、mysql索引的终极调优方案 🌟6、mysql分布式集群的设计原则 🌟7、mysql如何实现高效的读写分离和分库分表 [玫瑰]主讲老师：连鹏举老师 [月亮]授课时间：20：00 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035@所有人 [跳跳]大厂算法和数据结构题目改怎么准备 [飞吻]主讲老师：左程云老师 ☀上课时间：15:30-17:00 🎁主讲内容： 🌟1，多个有序链表排序。 🌟2，最长无重复子串长度。 🌟3，绳子的最多覆盖点问题。 🌟4，有一个数出现了K次，其他数都出现了M次，找到出现K次的数 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]震惊！618活动用redis的巨坑 [耶]主讲老师：周志垒 [月亮]上课时间：20:00 🌟三高系统必然涉及的面试题核心讲解 🌟高并发、大数据的首选解决方案 🌟双十一下分布式高并发场景下的存储技术选型 🌟redis、kafka、es、hbase等技术技术选型总结 🌟大厂面试高频架构设计题思路 🌟为什么大厂都不用主从同步 🌟读写分离、业务隔离、分片集群常见的坑 🌟正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 🌟mysql索引的性能问题 🌟redis为什么快的多个原因 🌟redis是单线程还是多线程 🌟秒杀、12306抢票、微信红包、电商详情页等高频面试问题 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [炸弹]薪水的天花板！技术+管理，让老板为你打工。 [强]马士兵、张一明老师主讲 [月亮]今晚20：00，主讲 #面试两大难题 微服务和高并发系统架构 🌟- 微服务生态体系：30个框架全栈架构生态体系链路解析 🌟- 618秒杀系统多级缓存“读、写”分离 🌟- 京东电商详情页系统架构演化过程 🌟- 高并发系统中的限流与降级处理 🌟- SpringCloud Alibaba Sentinel在淘宝双十一洪峰时限流底层实现原理 🌟- Nacos 与 Apollo 、SpringCloud Config技术选型 🌟- 技术+管理：员工心态切换的六大谬误 🌟- 如何解决学了很多东西却记不住 🌟- 一个普通程序员在35岁以后该如何生存 🌟- 野生程序员生存法则 🌟- 8k ~ 80k的简历这么写？！快来看一下 🌟- 在线修改简历 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [耶]2小时带你搞定mysql中的事务和锁机制，薪水必涨5k [玫瑰]讲师：连鹏举 [月亮]晚8点呦 [爱心]1、mysql事务隔离性的实现原理 [爱心]2、mysql原子性和持久性是如何实现的？ [爱心]3、当前读，快照读，到底读的是什么？ [爱心]4、mysql并发访问的核心机制-MVCC [爱心]5、共享锁、排它锁、意向锁、自增锁有什么应用场景 [爱心]6、mysql中的幻读实现原理 [爱心]7、如何查看mysql中的锁等待情况 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [皱眉]如何通过redis解决亿万级并发压力？ [机智]讲师：周老师 [月亮]上课时间：晚8点 ✨1，通过redis解决千万级并发压力架构设计 ✨2，项目中遇到哪些问题？设计方案？秒杀？雪崩？穿透？击穿？预热？ ✨3，无锁化，串行化，扁平化克制高并发瓶颈！ ✨4，redis 宕机了咋办，如何做到可用性和一致性的trad off？ ✨5，12306抢票，微信红包，电商详情页等高频面试问题！ ✨6，redis持久化，主从复制，分片集群在BAT中的具体使用设计 ✨7，redis分布式锁造成的架构压力和错误的架构设计问题 ✨8，正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 ✨9，如何和面试官互动获得offer ✨10，学习方法和面试方法分享 ✨11，逃避认知偏差，技术诅咒，幸存者偏差 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [耶]2小时学会：分布式事务全套解决方案 [强]讲师：阿里晁老师 [月亮]晚20：00 [爱心]1、分布式场景系统中数据一致性问题如何解决 [爱心]2、分布式事务的解决思路分析。 [爱心]3、两阶段提交协议、三阶段提交协议。 [爱心]4、TCC（Try Confirm Cancel）解决方案。 [爱心]5、LCN（Lock Confirm Notify）解决方案。 [爱心]6、阿里巴巴分布式事务框架：Seata实际落地方案。 [爱心]7、消息队列+本地事件表+定时任务方案。 [爱心]8、可靠消息服务方案。 [爱心]9、最大努力通知方案。 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]Java高性能无锁并发安全队列设计与实现 [耶]授课讲师：阿里黄师傅 [月亮]上课时间：20:00 [爱心]1、JUC包核心-AQS等待队列实现原理 [爱心]2、锁队列与无锁队列 [爱心]3、CAS、Volatile也会造成性能损耗 [爱心]4、一把锁、多把锁、无锁？ [爱心]5、单向链表的并发安全 [爱心]6、独家揭秘：ConcurrentLinkedQueue无锁并发队列优化 [爱心]7、独家分享：一次看四本书的学习方法 [爱心]8、惊喜彩蛋：JUC包作者 Doug Lea 的bug？ 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [疑问]超高并发下MySQL如何设计索引更高效 [飞吻]主讲老师：连鹏举 [色]vip报名咨询老师：自己的小姐姐 [月亮]上课时间：20:00 [爱心]1.一节课教你看懂mysql的执行计划 [爱心]2.mysql的索引原理和数据结构能介绍？ [爱心]3.B+树跟B树的区别是什么？ [爱心]4.mysql聚簇索引和非聚簇索引的区别 [爱心]5.使用mysql索引都有什么原则？ [爱心]6.不同的存储引擎是如何进行实际存储的？ [爱心]7.mysql的组合索引的结构是什么样的？ [爱心]8.什么是回表、索引覆盖、最左匹配原则、索引下推 [爱心]9.mysql索引如何进行优化呢？ [爱心]10.mysql索引设计的技巧 [爱心]11.mysql索引的终极调优方案 [爱心]12.mysql分布式集群的设计原则 [爱心]13.mysql如何实现高效的读写分离和分库分表 🎥8点上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 了解报名MCA课程，私聊自己的小姐姐，现在报名送黑卡+面试突击班+尖刀班+分期补贴+学生补贴，到计时最后3天 @所有人 [强]作为程序员，知识储备是必须的 [耶]主讲老师：马士兵 [飞吻]vip报名咨询老师：自己的小姐姐 [月亮]上课时间：20:00 ● 什么是JUC？ ● 为什么CAS和AQS是JUC的核心？ ● ReentrantLock适用于什么场景？ ● 门闩（Latch）同步器适用于什么场景？ ● 篱笆（Barrier）同步器适用于什么场景？ ● 信号量（Semaphore）同步器适用于什么场景？ ● 阶段同步器（Phaser）适用于什么场景？ ● 原生锁支持（LockSupport）适用于什么场景？ ● 有哪些同步队列可以用于线程池？ ● Exchanger交换器适用于什么场景？ ● 各种同步器在大厂面试中的综合运用怎么做？ ● （首次公开）通过阿里一道面试题理解大厂面试多线程代码题的要求 🎥8点上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 了解报名MCA课程，私聊自己的小姐姐，现在报名送黑卡+面试突击班+尖刀班+分期补贴+学生补贴，到计时最后2天 @所有人 [机智]吊打面试官的硬核技能-多线程与高并发 [月亮]晚上：20：00 [飞吻]主讲老师：马老师 [爱心]线程的本质(操作系统与CPU是如何执行线程的 [爱心]并发编程为什么充满挑战？ [爱心]并发编程三大特性：可见性、有序性、原子性 [爱心]无锁、偏向锁、轻量级锁、重量级锁升级过程 [爱心]有没有一种一定能保证线程安全的终极代码？ [爱心]如何理解NC(1+C/W)的计算公式? 🎥https://ke.qq.com/course/399017?taid=10693923106592425&tuin=a028e035 @所有人 [机智]吊打面试官的硬核技能-多线程与高并发 [月亮]晚上：20：00 [飞吻]主讲老师：马老师 [爱心]线程的本质(操作系统与CPU是如何执行线程的 [爱心]并发编程为什么充满挑战？ [爱心]并发编程三大特性：可见性、有序性、原子性 [爱心]无锁、偏向锁、轻量级锁、重量级锁升级过程 [爱心]有没有一种一定能保证线程安全的终极代码？ [爱心]如何理解NC(1+C/W)的计算公式? 🎥https://ke.qq.com/course/399017?taid=10693923106592425&tuin=a028e035 马老师在直播间等候，还犹豫什么，快来听马老师在线解惑！ @所有人 [机智]月薪2W必问spring源码，如何完美应对，这节课给你答案 [月亮]晚上：20：00 [飞吻]讲师老师：连鹏举 [爱心]1、图解spring IOC的实现机制 [爱心]2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 [爱心]3、spring的扩展实现二：BeanPostProcessor接口详解 [爱心]4、必知必会的13个Bean生命周期处理机制 [爱心]5、BeanFactory和FactoryBean的接口对比与实现机制 [爱心]6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 [爱心]7、jdk和cglib动态代理的原理及源码讲解 [爱心]8、Spring AOP的实现机制及扩展实现 [爱心]9、巧妙回答spring源码问题，让你成为源码专家\" --------------- 🎥https://ke.qq.com/course/399017?taid=10693923106592425&tuin=a028e035 @所有人 [机智]ES是如何支撑起Github千亿+代码的检索服务的 [月亮]时间：20:00 [耶]讲师：吴磊老师 [玫瑰]1、三高系统之上你必须掌握的硬核技能 [玫瑰]2、海量数据系统架构的技术选型 [玫瑰]3、深入底层，解读Lucene源码 [玫瑰]4、说一下你理解的倒排索引 [玫瑰]5、B+Trees为什么不适合大数据搜索 [玫瑰]6、千亿级数据集群的性能调优 [玫瑰]7、字典树的底层原理 [玫瑰]8、FST的构建原理和读写过程 [玫瑰]9、在高并发的情况下，ES如何保证数据读写一致性 [玫瑰]10、关于ES的高频面试题干货分享 [玫瑰]11、Elasticsearch学习方法论 🚀上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [哇]几万人排队等的课 [加油]从汇编到linux内核，到jvm源码，到微服务项目管理，互联网大牛讲师亲情奉献 [月亮]今晚：20:00 [天啊]讲师：宝藏级阿里P7讲师24岁黄俊老师 [社会社会]今晚福利：3张京东卡200元 🔥1，Java并发包JUC结构体系 🔥2，ReentrantLock背后的哲学 🔥3，小白都能听得懂的：AQS设计与思考 🔥4，小白都能听得懂的：AQS实现与优化 🔥5，独家详解：AQS核心代码逐行分解 🔥6，独家解密：AQS虚假唤醒问题？Doug Lea Bug还是故意为之！ 🎥8点上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 今晚黄老师讲课开工前大福利，直播间领取。来狂欢 @所有人 [跳跳]微服务SpringCloud Alibaba高并发实战 ```````` [飞吻]今晚8点, 一明哥主讲 [爱心]1.抗住淘宝双十一的三大利器：Sentinel、Nacos、RocketMQ [爱心]2.Alibaba Sentinel在淘宝双十一洪峰时限流底层实现原理 [爱心]3.Alibaba Sentinel对比 Netflix Hystrix区别与优势 [爱心]4.微服务生态体系SpringCloud Netflix/Alibaba [爱心]5.Nacos 与 Apollo 、SpringCloud Config技术选型 [爱心]6.SpringCloud+ Skywalking微服务全链路压测与监控预警 [爱心]7.基于云原生Sentinel百万并发限流压测 [爱心]8.Nginx+mysql方案 单机压测对比 [爱心]9.SpringBoot + Mysql 方案 单机压测对比 [爱心]10.SpringBoot + redis 方案 单机压测对比 [爱心]11.Nginx+静态缓存方案 单机压测对比 [爱心]12.Nginx+redis方案 单机压测对比 ````````` 🎥上课地址:https://ke.qq.com/course/399017?taid=11517212502660777&tuin=6c381156 @所有人 [哇]亿级电商秒杀系统数据库调优终极方案 [月亮]上课时间：晚20：00 [耶]授课老师：连鹏举 ------------------- ✨1、一节课教你看懂mysql的执行计划 ✨2、mysql索引的实现原理和数据结构 ✨3、mysql索引设计的技巧 ✨4、mysql聚簇索引和非聚簇索引的区别 ✨5、mysql索引的终极调优方案 ✨6、mysql分布式集群的设计原则 ✨7、mysql如何实现高效的读写分离和分库分表 -------------------- 🎥上课地址:https://ke.qq.com/course/399017?taid=11517212502660777&tuin=6c381156 @所有人 [机智]30万面试题：巧用弱引用解决ThreadLocal内存泄漏 [月亮]今晚：20:00 [耶]讲师：马士兵老师 🌟福利1：3张京东E卡 🌟福利2：公开课所有笔记资料 ------------------------------------- [爱心]强引用的原理与应用场景 [爱心]软引用的原理与应用场景 [爱心]弱引用的原理与应用场景（重点） [爱心]虚引用的原理与应用场景 [爱心]ThreadLocal到底存不存在内存泄漏？ [爱心]深入JDK源码解读ThreadLocal的私有领地 [爱心]面试官问题ThreadLocal泄漏问题如何回答才完善？ --------------------------------------- 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10318882267338409&tuin=a982d3d7 [天啊]无录播！无录播！无录播！ @所有人 [疑问]亿级流量电商系统，秒杀如何设计？ [月亮]今晚：20:00 [机智]讲师：晁鹏飞（阿里p7） 🌟高并发场景的业务漏洞，正确理解技术赋能业务。 🌟如何进行高纬度思考设计，高并发秒杀系统。 🌟高并发场景下秒杀超卖Bug复现 🌟秒杀场景下JVM锁现场压测实战 🌟高并发场景下，分布式锁思路分析 🌟高并发秒杀场景下MySQL分布式锁实战 🌟高并发秒杀场景下Redis分布式锁实战 🌟如何在双十一大促中提升分布式锁性能 🌟抗住双十一流量峰值的其他方案 🌟从源码级别看分布式锁如何实现 🌟CAP和BASE理论在分布式场景中的应用 🌟分布式锁全部代码实战压测演示 🌟秒杀系统全套解决方案 🎥8点上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]代码面试中看似和数学相关其实和coding相关的面试题 ☀下午：15:30~17:00 [耶]讲师：左程云 🌟1，分苹果的最小袋子问题 🌟2，牛羊吃草问题 🌟3，左右最大值的最大差值问题 🌟4，矩阵旋转问题 🌟5，之字形打印矩阵问题 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]蚂蚁金服面试真题--一节课教你轻松通过蚂蚁金服第三面 [月亮]晚上：20：00 [强]讲师老师：连鹏举 [爱心]1、图解spring IOC的实现机制 [爱心]2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 [爱心]3、spring的扩展实现二：BeanPostProcessor接口详解 [爱心]4、必知必会的13个Bean生命周期处理机制 [爱心]5、BeanFactory和FactoryBean的接口对比与实现机制 [爱心]6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 [爱心]7、jdk和cglib动态代理的原理及源码讲解 [爱心]8、Spring AOP的实现机制及扩展实现 [爱心]9、巧妙回答spring源码问题，让你成为源码专家\" 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]一万到三万，掌握这些点就够了 [耶]主讲：马士兵教学总监，周老师 [月亮]上课时间：20:00 🌟三高系统必然涉及的面试题核心讲解 🌟高并发、大数据的首选解决方案 🌟双十一下分布式高并发场景下的存储技术选型 🌟redis、kafka、es、hbase等技术技术选型总结 🌟大厂面试高频架构设计题思路 🌟为什么大厂都不用主从同步 🌟读写分离、业务隔离、分片集群常见的坑 🌟正确用布隆过滤器，跳表skiplist，HashMap解决并发场景问题 🌟mysql索引的性能问题 🌟redis为什么快的多个原因 🌟redis是单线程还是多线程 🌟秒杀、12306抢票、微信红包、电商详情页等高频面试问题 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [社会社会]这可能是全网最详细的死锁讲解 [耶]主讲：资深讲师 黄俊 [月亮]上课时间：20:00 [爱心]1、大厂必问死锁核心问题 [爱心]2、死锁定义与产生条件 [爱心]3、死锁避免、预防、检测、恢复 [爱心]4、Hotspot虚拟机的自省行为 [爱心]5、Tools与SA-JDI原理 [爱心]6、手写死锁检测算法 [爱心]7、真实情况下如何合理运用公平锁与非公平锁 [爱心]8、tryLock和lockInterruptibly也能解决死锁？ 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]亿级流量电商系统，秒杀如何设计？ [月亮]今晚：20:00 [耶]讲师：晁鹏飞（阿里p7） [爱心]高并发场景的业务漏洞，正确理解技术赋能业务。 [爱心]如何进行高纬度思考设计，高并发秒杀系统。 [爱心]高并发场景下秒杀超卖Bug复现 [爱心]秒杀场景下JVM锁现场压测实战 [爱心]高并发场景下，分布式锁思路分析 [爱心]高并发秒杀场景下MySQL分布式锁实战 [爱心]高并发秒杀场景下Redis分布式锁实战 [爱心]如何在双十一大促中提升分布式锁性能 [爱心]抗住双十一流量峰值的其他方案 [爱心]从源码级别看分布式锁如何实现 [爱心]CAP和BASE理论在分布式场景中的应用 [爱心]分布式锁全部代码实战压测演示 [爱心]秒杀系统全套解决方案 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]如何与能力强的人进行高效沟通提问的智慧 ☀时间：17：00-18:00 [耶]讲师：马海阳 ………… [玫瑰]程序员之间的沟通技巧入门 [玫瑰]1 使用专业术语 [玫瑰]2 准确具体描述问题 [玫瑰]3 提供分析材料 [玫瑰]程序调试技巧入门 [玫瑰]1 学习查看日志 [玫瑰]2 查阅网络博客和工具网站的使用 [玫瑰]3 断点调试模式 ………… 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [哇]其实不用学技术，掌握这个点，保你薪水涨5k [月亮]时间：20:00 [机智]讲师：连鹏举 —————— [爱心]1、掌握这点，让你不靠技术，涨薪5k [爱心]2、自我介绍如何说，让面试官耳目一新 [爱心]3、如何称述项目，让本来很low的项目显得高大上 [爱心]4、如何巧妙的化解自己不会的技术难题 [爱心]5、如何让hr和面试官了解你的实力，给到预期的薪水 [爱心]6、如何变相的将自己的优点转为缺点 [爱心]7、被问到职业规划，如何让hr对你刮目相看 [爱心]8、被问到你有什么想问的，应该怎么回答 —————— 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]揭秘大厂薪资结构，职级与薪资考核体系 ☀17:00-18:00 [耶]主讲老师：赵珊珊老师 🌟1.你是如何入行的？ 🌟2.什么样的人适合进大厂？ 🌟3.阿里职级、薪资、晋升 🌟4.腾讯职级、薪资、晋升 🌟5.字节跳动职级、薪资、晋升 🌟6.京东职级、薪资、晋升 🌟7.百度职级、薪资、晋升 🌟8.滴滴职级、薪资、晋升 🌟9.职业路线、下一步怎么走 🎥戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035 @所有人 [机智]IO高并发优化,从一万到百万并发性能优化 [耶]主讲讲师：周志垒老师 [月亮]直播时间：20:00 [爱心]双十一亿级并发下IO模型的优劣 [爱心]高并发下IO模型高频面试题 [爱心]高并发下同步IO与异步IO的区别 [爱心]高并发下阻塞IO与非阻塞IO的本质 [爱心]高并发下多路复用器原理及实现区别 [爱心]高并发下select、poll、epoll原理解析 [爱心]高并发下服务器如何突破十万、百万并发 [爱心]高并发下netty性能和IO模型的对应关系 [爱心]高并发下内核提供的系统调用原理 [爱心]高并发下中断及线程调度原理 [爱心]高并发下redis、nginx的io模型分别是如何实现的 [爱心]高并发下kafka使用的IO模型和netty是否一样 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]一小时上手ES，教你搭建自己的搜索引擎 [耶]下午15:30，吴老师亲自分享 🌟1、首次公开：关于ES的内核级原理揭秘 🌟2、海量数据系统架构的技术选型 🌟3、透过现象看本质：教你如何看穿“索引” 🌟4、小白也能听得懂：提问的艺术 🌟5、教你跳槽的正确姿势 🌟6、ELastic学习方法论 🌟7、普通的简历如何做到夺人眼球 🌟8、如何做到和面试官侃侃而谈 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]极限并发下分布式事务的常见问题及最优解决方案 [耶]主讲讲师：晁鹏飞老师 [月亮]直播时间：20:00 🌟分布式场景系统中数据一致性问题如何解决 🌟分布式事务的设计思路分析。 🌟两阶段提交协议、三阶段提交协议。 🌟组合存储组件，分布式事务如何解决？ 🌟TCC（Try Confirm Cancel）解决方案。 🌟阿里巴巴分布式事务框架：Seata实际落地方案。 🌟消息队列+本地事件表+定时任务方案。 🌟自定义可靠消息服务方案。 🌟最大努力通知方案。 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [机智]千亿级 Elasticsearch 技术解密 [耶]主讲老师：吴磊 [礼物]上课时间：20：00 🌟1、Java中的位移算法 🌟2、FST的实现原理 🌟3、FST的构建和读取过程 🌟4、ES的性能调优 🌟5、高并发下ES如何保证数据的读写一致性 🌟6、Elasticsearch的搜索过程是怎样的 🌟7、Elastic学习方法论 🌟8、跳槽的正确姿势 🌟9、普通的简历如何做到夺人眼球 🌟10、如何做到和面试官侃侃而谈 🚀上课链接：https://ke.qq.com/course/2868276?tuin=a1b820d2 @所有人 [强]JUC技术核心AQS同步队列设计与实现 [机智]主讲老师：CTO黄俊老师 [月亮]上课时间：20：00 [爱心]1，Java并发包JUC结构体系 [爱心]2，ReentrantLock背后的哲学 [爱心]3，小白都能听得懂的：AQS设计与思考 [爱心]4，小白都能听得懂的：AQS实现与优化 [爱心]5，独家详解：AQS核心代码逐行分解 [爱心]6，独家解密：AQS虚假唤醒问题？Doug Lea Bug还是故意为之！ 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]这可能是全网最详细的死锁讲解 [强]主讲老师：CTO黄俊老师 [月亮]授课时间：20：00 [玫瑰]1、大厂必问死锁核心问题 [玫瑰]2、死锁定义与产生条件 [玫瑰]3、死锁避免、预防、检测、恢复 [玫瑰]4、Hotspot虚拟机的自省行为 [玫瑰]5、Tools与SA-JDI原理 [玫瑰]6、手写死锁检测算法 [玫瑰]7、真实情况下如何合理运用公平锁与非公平锁 [玫瑰]8、tryLock和lockInterruptibly也能解决死锁？ 💻上课地址；https://ke.qq.com/course/399017@所有人 [机智]亿级并发抢票系统MySQL如何设计索引更高效？ [耶]主讲老师：连鹏举老师 [月亮]上课时间：20：00 [爱心]1、一节课教你看懂mysql的执行计划 [爱心]2、mysql索引的实现原理和数据结构 [爱心]3、mysql索引设计的技巧 [爱心]4、mysql聚簇索引和非聚簇索引的区别 [爱心]5、mysql索引的终极调优方案 [爱心]6、mysql分布式集群的设计原则 [爱心]7、mysql如何实现高效的读写分离和分库分表 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035@所有人 [礼物]小白也能听懂SpringCloud Alibaba 技术选型 [强]讲师：张一明 [月亮]时间：20：00 ———————————— 🌟抗住淘宝双十一的三大利器： 🌟Sentinel、Nacos、RocketMQ 🌟Alibaba Sentinel在淘宝双十一洪峰时限流底层实现原理 🌟Alibaba Sentinel对比 Netflix Hystrix区别与优势 🌟微服务生态体系SpringCloud Netflix/Alibaba 🌟Nacos 与 Apollo 、SpringCloud Config技术选型 🌟SpringCloud+ Skywalking微服务全链路压测与监控预警 🌟基于云原生Sentinel百万并发限流压测 🌟Nginx+mysql方案 单机压测对比 🌟SpringBoot + Mysql 方案 单机压测对比 🌟SpringBoot + redis 方案 单机压测对比 🌟Nginx+静态缓存方案 单机压测对比 🌟Nginx+redis方案 单机压测对比 ———————— 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 [礼物]福利1：电商项目高并发系统架构图 [礼物]福利2：1元秒杀JVM、多线程、mysql调优、Redis等众多纸质书 [礼物]福利3：SpringCloud + 高并发架构+中间件全栈图@所有人 [强]BATJ海量数据搜索服务是如何做到秒级查询的 [玫瑰]讲师：吴磊 ☀时间：16：00 ———————————— 🔥1、ES面试必问的倒排索引底层原理（数据结构、算法以及源码分析） 🔥2、MySql的索引使用的B+Trees为什么不适合做大数据文本检索 🔥3、亿级数据索引应该怎么创建 🔥4、你了解Trie（字典树）吗 🔥5、开放性问题：大型搜索服务如何实现海量数据秒查 🔥6、Lucene底层你了解过吗 ———————— 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [强]亿级并发抢票系统架构中JVM为何频繁FGC？ [玫瑰]讲师：马士兵 [月亮]时间：20：00 ———————————— 🌟1. 为什么一个百万级TPS系统会频繁GC？ 🌟2. 定位JVM问题的实用参数设置 🌟3. 用top jps jstat jmap 等“业余”命令行工具进行定位 🌟4. 用图形化工具visual VM，MAT，Jprofiler进行定位 🌟5. 用一线大厂专业工具进行定位与调优 🌟6. 手把手带你学习瞬间涨薪5K的JVM优化操作 🌟7. 错标 漏标 增量更新-三色标记深入详解 🌟8. 面向未来的GC-G1 Shenandoah ZGC 🌟9. 国内首发，绝密一手GC资料大放送 ———————— 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]蚂蚁金服面试真题--一节课教你轻松通过蚂蚁金服第三面 [强]讲师：连鹏举 [月亮]时间：20:00 🌟\"1、图解spring IOC的实现机制 🌟2、spring的扩展实现一：BeanFactoryPostProcessor接口详解 🌟3、spring的扩展实现二：BeanPostProcessor接口详解 🌟4、必知必会的13个Bean生命周期处理机制 🌟5、BeanFactory和FactoryBean的接口对比与实现机制 🌟6、循环依赖问题中的三级缓存和提前暴露对象原理讲解 🌟7、jdk和cglib动态代理的原理及源码讲解 🌟8、Spring AOP的实现机制及扩展实现 🌟9、巧妙回答spring源码问题，让你成为源码专家 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [礼物]月入3W的必学技能，助你踢破大厂门槛 [玫瑰]主讲：吴磊老师 ☀上课时间：15：30 🌟1、三高系统之上你必须掌握的核心技能 🌟2、浅谈倒排索引 🌟3、高谈Elastic学习方法论 🌟4、会用不就行了为什么要了解原理 🌟5、ES高频面试题分享 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 @所有人 [玫瑰]618三高架构微服务分布式设计实现 [强]主讲：周志垒老师 [月亮]上课时间：20：00 [机智]从0到1参与项目架构设计 [耶]从0到1参与项目功能重构 ✨项目中的亮点有哪些 ✨项目中的痛点有哪些 ✨三高架构面临的问题 ✨线程池、连接池、分库分表 ✨threadlocal、nio、netty ✨redis、kafka、rabbitmq ✨负载均衡、高可用、微服务划分 ✨传统项目如何应对三高问题 ✨高并发、大数据的首选解决方案 ✨大厂面试高频架构设计题思路 ✨为什么大厂都不用主从同步 ✨读写分离、业务隔离、分片集群常见的坑 ✨秒杀、12306抢票、抢红包等高频面试问题 🎥上课链接：https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035@所有人 [嘿哈]如何在人群中脱颖而出？618电商项目微服务系统架构 ·········· [奸笑]晚上8点 张一明老师 [玫瑰]1. 从零开始构建互联网电商项目如何架构演化 [玫瑰]2. 京东单品百万点击量的一次秒杀中的难点与需求拆解 [玫瑰]3.高并发系统架构中的四大类中间件 [玫瑰]4. 构建亿级流量多级缓存高并发高可用高吞吐量系统的15个必备技术点 [玫瑰]5. 90%的公司不知道的SpringCloud Alibaba Sentinel 底层原理 [玫瑰]6. 微服务系统架构在高并发场景下踩过的30个坑 ··········· 🎥上课地址：https://ke.qq.com/course/399017?taid=11619952415348393&tuin=6c381156 @所有人 [跳跳]一节课带你搞定mysql中的事务和锁机制，薪水必涨5k [飞吻]讲师：连鹏举 [月亮]时间：20:00 [玫瑰]1、mysql事务隔离性的实现原理 [玫瑰]2、mysql原子性和持久性是如何实现的？ [玫瑰]3、当前读，快照读，到底读的是什么？ [玫瑰]4、mysql并发访问的核心机制-MVCC [玫瑰]5、共享锁、排它锁、意向锁、自增锁有什么应用场景 [玫瑰]6、mysql中的幻读实现原理 [玫瑰]7、如何查看mysql中的锁等待情况 🎥上课地址:https://ke.qq.com/course/399017?taid=11124390498801321&tuin=a028e035 🎉马士兵老师多线程训练营，今晚8点开播 🚀报名及上课链接 ：https://ke.qq.com/course/468257?tuin=8f56bbee 参与直播 两天上课到课率 达80% 送《多线程，jvm。Redis，MySQL，Java基础》VIP五本全套书籍包邮 Copyright © 2018-2021 | Distributed under CC BY 4.0 | Peter all right reserved，powered by Gitbook Updated at 2022-08-24 11:47:32 "}}