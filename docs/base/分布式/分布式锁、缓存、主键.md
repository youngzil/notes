分布式锁：
DB
memcached(add)
Redis(setnx)
zookeeper(临时有序节点)



分布式缓存：Redis、Memecached
缓存的好处：读取速度、系统承载能力、
缓存的失效是为了保证与数据源真实的数据保证一致性和缓存空间的有效利用性。
数据一致性：Master与副本一致性、Cache与Storage一致性、业务各维度缓存数据一致性
失效机制：LRU/LFU/FIFO、超时剔除、主动更新
存储机制：懒汉式(读时触发)、饥饿式(写时触发)、定期刷新
缓存穿透、缓存击穿、缓存雪崩：
缓存穿透指查询一个根本不存在的数据，缓存层和存储层都不命中
解决缓存击穿问题：缓存预热、定时更新，直接保存key=NULL，BloomFilter过滤，请求队列控制并发，

缓存雪崩：保证缓存层服务的高可用性、并发控制（依赖隔离组件为后端限流并降级、互斥锁）、项目资源隔离



分布式ID的生成方案：分段
1. 数据库自增长序列或字段
2. Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。
3. UUID
4. Twitter的snowflake雪花算法
5、其他框架
美团 Leaf
滴滴 Tinyid
百度 UidGenerator



分布式ID：
1、UUID
2、使用每个应用分一段序列号，请求的时候一次请求一段放在本地待使用，Zookeeper记录最大的Id
3、主要思路采用了MySQL自增长ID的机制(auto_increment + replace into)，以MySQL举例，利用给字段设置 auto_increment_increment 和 auto_increment_offset 来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。
4、CenterCode+AppCode+使用Redis的原子操作 INCR和INCRBY，
5、类snowflake方案：这种方案生成一个64bit的数字，64bit被划分成多个段，分别表示时间戳、机器编码、序号。 
6、TDDL序列生成方式：按应用进行每次一个步长的增长，步长变动可以使用Zookeeper来通知




https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect


---------------------------------------------------------------------------------------------------------------------
分布式锁
DB
memcached(add)
Redis(setnx)
zookeeper(临时有序节点)


---------------------------------------------------------------------------------------------------------------------
深入理解分布式缓存设计
https://zhuanlan.zhihu.com/p/55303228
https://juejin.im/entry/57e39e320e3dd90058021bff
https://blog.csdn.net/wang123459/article/details/82114013

分布式缓存
Redis、Memecached


缓存的失效是为了保证与数据源真实的数据保证一致性和缓存空间的有效利用性。



在数据层引入缓存，有以下几个好处：
提升数据读取速度
提升系统扩展能力，通过扩展缓存，提升系统承载能力
降低存储成本，Cache+DB的方式可以承担原有需要多台DB才能承担的请求量，节省机器成本

根据业务场景，通常缓存有以下几种使用方式
懒汉式(读时触发)：写入DB后, 然后把相关的数据也写入Cache
饥饿式(写时触发)：先查询DB里的数据, 然后把相关的数据写入Cache
定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性



分布式缓存的实现方式
1 数据分片
2 高可用性
3 扩展性（扩缩容）


数据一致性
    我们知道，在CAP理论下，只能取其二，而无法保证全部。在分布式缓存中，通常要保证可用性(A)和可扩展性(P)，并折中采用数据最终一致性，最终一致性包括：
Master与副本一致性
Cache与Storage一致性
业务各维度缓存数据一致性


几种缓存的更新策略：

1、LRU/LFU/FIFO：LRU淘汰最久没有被访问过的，LFU淘汰访问次数最少的，FIFO先进先出。
使用场景：适合内存空间有限，数据长期不变动，基本不存在数据一不致性业务。比如一些一经确定就不允许变更的信息。

2、超时剔除
给缓存数据手动设置一个过期时间，比如Redis expire命令。当超过时间后，再次访问时从数据源重新加载并设回缓存。
使用场景：适合于能够容忍一定时间内数据不一致性的业务，比如促销活动的描述文案。

3、主动更新
如果数据源的数据有更新，则主动更新缓存。
使用场景：对于数据的一致性要求很高，比如交易系统，优惠劵的总张数。

所以总的来说缓存更新的最佳实践是：
低一致性业务：可以选择第一并结合第二种策略。
高一致性业务：二、三策略结合。



缓存穿透、缓存击穿、缓存雪崩：

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

缓存穿透指查询一个根本不存在的数据，缓存层和存储层都不命中。一般的处理逻辑是如果存储层都不命中的话，缓存层就没有对应的数据。但在高并发场景中大量的缓存穿透，请求直接落到存储层，稍微不慎后端系统就会被压垮。所以对于缓存穿透我们有以下方案来优化。

解决缓存击穿问题：缓存预热、定时更新，直接保存key值为空，BloomFilter过滤，请求队列控制并发，

1、缓存空对象
2、布隆过滤器

所以对于这种方案需要做到：第一，做好业务过滤。比如我们确定业务ID的范围是[a, b]，只要不属于[a,b]的，系统直接返回，直接不走查询。第二，给缓存的空对象设置一个较短的过期时间，在内存空间不足时可以被有效快速清除。



缓存雪崩：
缓存雪崩：由于缓存层承载着大量请求，有效保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求到达存储层，存储层的调用量会暴增，造成存储层级联宕机的情况。预防和解决缓存雪崩问题可以从以下几方面入手。
(1)保证缓存层服务的高可用性，比如一主多从，Redis Sentine机制。
(2)依赖隔离组件为后端限流并降级，比如netflix的hystrix。关于限流、降级以及hystrix的技术设计可参考以下链接。
(3)项目资源隔离。避免某个项目的bug，影响了整个系统架构，有问题也局限在项目内部。



热点key重建优化：
开发人员使用"缓存+过期时间"的策略来加速读写，又保证数据的定期更新，这种模式基本能满足绝大部分需求。但是如果有两个问题同时出现，可能会对应用造成致命的伤害。

当前key是一个hot key，比如热点娱乐新闻，并发量非常大。
重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL, 多次IO，多个依赖等。

当缓存失效的瞬间，将会有大量线程来重建缓存，造成后端负载加大，甚至让应该崩溃。要解决这个问题有以下方案：
1、互斥锁
优化方法：除了重建线程之外，其它线程拿旧值直接返回。比如Google 的 Guava Cache 的refreshAfterWrite采用的就是这种方案避免雪崩效应。

2、永不过期
这种就是缓存更新操作是独立的，可以通过跑定时任务来定期更新，或者变更数据时主动更新。

3、后端限流





缓存无底洞问题
http://ifeve.com/redis-multiget-hole/





缓存雪崩
缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。
(1) 碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
（2）缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存
缓存穿透
　　缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。
（1）解决的办法就是：如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。
（2）缓存预热
　　缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。
解决思路：
a直接写个缓存刷新页面，上线时手工操作下。
b数据量不大，可以在WEB系统启动的时候加载。
c定时刷新缓存，
（3）缓存更新
缓存淘汰的策略有两种：
　　a定时去清理过期的缓存。
　　b当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 

大家可以根据自己的应用场景来权衡。1. 预估失效时间 2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。





如何实现分布式缓存
https://www.cnblogs.com/yangxiaolan/p/5786123.html
http://blog.csdn.net/singit/article/details/54917884
http://blog.csdn.net/qq_33647837/article/details/69375147
关于缓存雪崩和缓存穿透等问题：http://blog.csdn.net/csdn265/article/details/56012271


解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


布隆过滤器的原理和实现：可以判断一个元素一定不在集合中，不能判断一个元素是否一定在集合中
https://github.com/cpselvis/zhihu-crawler/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0
布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k
首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。
查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。
如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。

1、布隆过滤器添加元素：
将要添加的元素给k个哈希函数
得到对应于位数组上的k个位置
将这k个位置设为1

2、布隆过滤器查询元素：
将要查询的元素给k个哈希函数
得到对应于位数组上的k个位置
如果k个位置有一个为0，则肯定不在集合中
如果k个位置全部为1，则可能在集合中


---------------------------------------------------------------------------------------------------------------------
https://yq.aliyun.com/articles/648038
https://www.jianshu.com/p/9d7ebe37215e
https://tech.meituan.com/2017/04/21/mt-leaf.html
https://www.cnblogs.com/haoxinyue/p/5208136.html
https://github.com/beyondfengyu/SnowFlake


https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect


分布式主键

1. 数据库自增长序列或字段
2. UUID
3. Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。
4. Twitter的snowflake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。



www.toutiao.com/i6682672464708764174
分布式ID的生成方案

唯一ID的特性：
1、整个系统ID唯一
2、ID是数字类型，而且是趋势递增的
3、ID简短，查询效率快


1、UUID
2、MySQL主键自增
3、雪花snowflake算法
4、Redis生成方案



分布式ID的生成方案：分段
1. 数据库自增长序列或字段
2. Redis生成ID：可以用Redis的原子操作 INCR和INCRBY来实现。
3. UUID
4. Twitter的snowflake雪花算法
5、其他框架
美团 Leaf
滴滴 Tinyid
百度 UidGenerator


1、UUID

优点：
代码实现简单。
本机生成，没有性能问题
因为是全球唯一的ID，所以迁移数据容易

缺点：
每次生成的ID是无序的，无法保证趋势递增
UUID的字符串存储，查询效率慢
存储空间大
ID本事无业务含义，不可读

应用场景：
类似生成token令牌的场景
不适用一些要求有趋势递增的ID场景


2、MySQL主键自增：这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。

优点：
数字化，id递增
查询效率高
具有一定的业务可读

缺点：
存在单点问题，如果mysql挂了，就没法生成iD了
数据库压力大，高并发抗不住


3、MySQL多实例主键自增：这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长
每台的初始值分别为1,2,3...N，步长为N（这个案例步长为4）
可以自行定义max_id的起点，和step步长，保存在在数据库中，每次业务请求都去请求一段数据【max_id + 1，max_id+step】区间的ID保存在JVM本地缓存中
多个节点请求同一个业务的ID，可以使用事务的方式，把查询和更新max_id放在一个事务中
步长是可以随时修改的
因为会有一个线程，会观察什么时候去自动获取。两个buffer之间自行切换使用。就解决了突发阻塞的问题。


优点：
解决了单点问题

缺点：
一旦把步长定好后，就无法扩容；
而且单个数据库的压力大，数据库自身性能无法满足高并发

应用场景：
数据不需要扩容的场景



4、雪花snowflake算法
这个算法网上介绍了很多，老顾这里就不详细介绍。雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成：
1位标识符：始终是0
41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的
10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成
12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号

优点：
此方案每秒能够产生409.6万个ID，性能快
时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增
灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求

缺点：
依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成
在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。


5、Redis生成方案
利用redis的incr原子性操作自增，一般算法为：
年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增

优点：
有序递增，可读性强

缺点：
占用带宽，每次要向redis进行请求
每次都要去Redis去请求，有网络请求耗时，并发强依赖了Redis。这个设计是有风险的，一旦Redis挂了，整个系统不可用。                       
考虑到ID安全性的问题，如：Redis方案中，用户是可以预测下一个ID号是多少，因为算法是递增的。




---------------------------------------------------------------------------------------------------------------------







