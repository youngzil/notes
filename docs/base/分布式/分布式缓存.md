分布式缓存：Redis、Memecached
缓存的好处：读取速度、系统承载能力、
缓存的失效是为了保证与数据源真实的数据保证一致性和缓存空间的有效利用性。
数据一致性：Master与副本一致性、Cache与Storage一致性、业务各维度缓存数据一致性
失效机制：LRU/LFU/FIFO、超时剔除、主动更新
存储机制：懒汉式(读时触发)、饥饿式(写时触发)、定期刷新
缓存穿透、缓存击穿、缓存雪崩：
缓存穿透指查询一个根本不存在的数据，缓存层和存储层都不命中
解决缓存击穿问题：缓存预热、定时更新，直接保存key=NULL，BloomFilter过滤，请求队列控制并发，

缓存雪崩：保证缓存层服务的高可用性、并发控制（依赖隔离组件为后端限流并降级、互斥锁）、项目资源隔离


https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247489245&idx=3&sn=0205f0fd8c9aa03fc8d84b4f3a176b57&scene=21#wechat_redirect


---------------------------------------------------------------------------------------------------------------------
深入理解分布式缓存设计
https://zhuanlan.zhihu.com/p/55303228
https://juejin.im/entry/57e39e320e3dd90058021bff
https://blog.csdn.net/wang123459/article/details/82114013

分布式缓存
Redis、Memecached


缓存的失效是为了保证与数据源真实的数据保证一致性和缓存空间的有效利用性。



在数据层引入缓存，有以下几个好处：
提升数据读取速度
提升系统扩展能力，通过扩展缓存，提升系统承载能力
降低存储成本，Cache+DB的方式可以承担原有需要多台DB才能承担的请求量，节省机器成本

根据业务场景，通常缓存有以下几种使用方式
懒汉式(读时触发)：写入DB后, 然后把相关的数据也写入Cache
饥饿式(写时触发)：先查询DB里的数据, 然后把相关的数据写入Cache
定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性



分布式缓存的实现方式
1 数据分片
2 高可用性
3 扩展性（扩缩容）


数据一致性
    我们知道，在CAP理论下，只能取其二，而无法保证全部。在分布式缓存中，通常要保证可用性(A)和可扩展性(P)，并折中采用数据最终一致性，最终一致性包括：
Master与副本一致性
Cache与Storage一致性
业务各维度缓存数据一致性


几种缓存的更新策略：

1、LRU/LFU/FIFO：LRU淘汰最久没有被访问过的，LFU淘汰访问次数最少的，FIFO先进先出。
使用场景：适合内存空间有限，数据长期不变动，基本不存在数据一不致性业务。比如一些一经确定就不允许变更的信息。

2、超时剔除
给缓存数据手动设置一个过期时间，比如Redis expire命令。当超过时间后，再次访问时从数据源重新加载并设回缓存。
使用场景：适合于能够容忍一定时间内数据不一致性的业务，比如促销活动的描述文案。

3、主动更新
如果数据源的数据有更新，则主动更新缓存。
使用场景：对于数据的一致性要求很高，比如交易系统，优惠劵的总张数。

所以总的来说缓存更新的最佳实践是：
低一致性业务：可以选择第一并结合第二种策略。
高一致性业务：二、三策略结合。



缓存穿透、缓存击穿、缓存雪崩：

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

缓存穿透指查询一个根本不存在的数据，缓存层和存储层都不命中。一般的处理逻辑是如果存储层都不命中的话，缓存层就没有对应的数据。但在高并发场景中大量的缓存穿透，请求直接落到存储层，稍微不慎后端系统就会被压垮。所以对于缓存穿透我们有以下方案来优化。

解决缓存击穿问题：缓存预热、定时更新，直接保存key值为空，BloomFilter过滤，请求队列控制并发，

1、缓存空对象
2、布隆过滤器

所以对于这种方案需要做到：第一，做好业务过滤。比如我们确定业务ID的范围是[a, b]，只要不属于[a,b]的，系统直接返回，直接不走查询。第二，给缓存的空对象设置一个较短的过期时间，在内存空间不足时可以被有效快速清除。



缓存雪崩：
缓存雪崩：由于缓存层承载着大量请求，有效保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求到达存储层，存储层的调用量会暴增，造成存储层级联宕机的情况。预防和解决缓存雪崩问题可以从以下几方面入手。
(1)保证缓存层服务的高可用性，比如一主多从，Redis Sentine机制。
(2)依赖隔离组件为后端限流并降级，比如netflix的hystrix。关于限流、降级以及hystrix的技术设计可参考以下链接。
(3)项目资源隔离。避免某个项目的bug，影响了整个系统架构，有问题也局限在项目内部。



热点key重建优化：
开发人员使用"缓存+过期时间"的策略来加速读写，又保证数据的定期更新，这种模式基本能满足绝大部分需求。但是如果有两个问题同时出现，可能会对应用造成致命的伤害。

当前key是一个hot key，比如热点娱乐新闻，并发量非常大。
重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL, 多次IO，多个依赖等。

当缓存失效的瞬间，将会有大量线程来重建缓存，造成后端负载加大，甚至让应该崩溃。要解决这个问题有以下方案：
1、互斥锁
优化方法：除了重建线程之外，其它线程拿旧值直接返回。比如Google 的 Guava Cache 的refreshAfterWrite采用的就是这种方案避免雪崩效应。

2、永不过期
这种就是缓存更新操作是独立的，可以通过跑定时任务来定期更新，或者变更数据时主动更新。

3、后端限流





缓存无底洞问题
http://ifeve.com/redis-multiget-hole/





缓存雪崩
缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。
(1) 碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
（2）缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存
缓存穿透
　　缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。
（1）解决的办法就是：如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。
（2）缓存预热
　　缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。
解决思路：
a直接写个缓存刷新页面，上线时手工操作下。
b数据量不大，可以在WEB系统启动的时候加载。
c定时刷新缓存，
（3）缓存更新
缓存淘汰的策略有两种：
　　a定时去清理过期的缓存。
　　b当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 

大家可以根据自己的应用场景来权衡。1. 预估失效时间 2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。





如何实现分布式缓存
https://www.cnblogs.com/yangxiaolan/p/5786123.html
http://blog.csdn.net/singit/article/details/54917884
http://blog.csdn.net/qq_33647837/article/details/69375147
关于缓存雪崩和缓存穿透等问题：http://blog.csdn.net/csdn265/article/details/56012271


解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


布隆过滤器的原理和实现：可以判断一个元素一定不在集合中，不能判断一个元素是否一定在集合中
https://github.com/cpselvis/zhihu-crawler/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0
布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k
首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。
查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。
如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。

1、布隆过滤器添加元素：
将要添加的元素给k个哈希函数
得到对应于位数组上的k个位置
将这k个位置设为1

2、布隆过滤器查询元素：
将要查询的元素给k个哈希函数
得到对应于位数组上的k个位置
如果k个位置有一个为0，则肯定不在集合中
如果k个位置全部为1，则可能在集合中


---------------------------------------------------------------------------------------------------------------------




