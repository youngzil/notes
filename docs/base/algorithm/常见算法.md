1、排序算法：十种
2、查找算法：七种
3、其他查找算法
树的数据结构和复杂度（时间和空间）
图：有向图、无向图、图的出度和入度


---------------------------------------------------------------------------------------------------------------------
十种常见排序算法可以分为两大类：

比较类排序：
1、冒泡排序（Bubble Sort）
2、选择排序（Selection Sort）
3、插入排序（Insertion Sort）
4、快速排序（Quick Sort）
5、堆排序（Heap Sort）
6、希尔排序（Shell Sort）
7、归并排序（Merge Sort）


非比较类排序：
8、计数排序（Counting Sort）
9、桶排序（Bucket Sort）
10、基数排序（Radix Sort）



参考
http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1
https://www.cnblogs.com/onepixel/p/7674659.html
https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md





---------------------------------------------------------------------------------------------------------------------
查找算法分类


1）静态查找和动态查找；
注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。

2）无序查找和有序查找。
    无序查找：被查找数列有序无序均可；
    有序查找：被查找数列必须为有序数列。
    
查找性能：从快到慢：
    顺序查找，时间复杂度O(N),
    分块查找，时间复杂度O(logN+N/m);
    二分查找，时间复杂度O(logN)
    Fibonacci查找，时间复杂度O(logN)
    差值查找，时间复杂度O(log(logN))
    哈希查找，时间复杂度O(1)


[Data Structure & Algorithm] 七大查找算法

1. 顺序查找
2. 二分查找（折半查找） 
3. 插值查找
4. 斐波那契查找
5. 树表查找：
    二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，
    平衡查找树之2-3查找树（2-3 Tree）
    平衡查找树之红黑树（Red-Black Tree）
    B树和B+树（B Tree/B+ Tree）
6. 分块查找
7. 哈希查找：哈希表法（散列表） 


1. 顺序查找：条件：无序或有序队列。     按顺序比较每个元素，直到找到关键字为止。    时间复杂度：O(n) 
2. 二分查找（折半查找） ：条件：有序数组      先跟中间比较，再跟较大或较小那一边比较   时间复杂度：O(logn) 
3. 插值查找
4. 斐波那契查找
5. 树表查找
6. 分块查找：思想：顺序查找和二分查找的结合。    原理：将n个数据元素"按块有序"划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字； 而第2块中任一元素又都必须小于第3块中的任一元素，……。 然后使用二分查找及顺序查找。        时间复杂度：介于O(n) 和O(logn)之间。
7. 哈希查找：哈希表法（散列表） 条件：先创建哈希表（散列表）    原理：根据键值方式(Key Value)进行查找，通过散列函数，定位数据元素。   时间复杂度：几乎是O(1)，取决于产生冲突的多少。 


参考
https://www.cnblogs.com/maybe2030/p/4715035.html
https://blog.csdn.net/guoweimelon/article/details/50906299
https://zhuanlan.zhihu.com/p/37440434
http://codingxiaxw.cn/2017/01/14/66-leetcode-find/
https://juejin.im/post/5c7e843351882546c20a8669


---------------------------------------------------------------------------------------------------------------------
其他查找算法


参考
docs/SQL/数据库索引.md

查找算法：  
 1、最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。   
 数据结构：有序或无序队列   
 复杂度：O(n)   
   
 2、二分查找（binary search）  
 数据结构：有序数组   
 复杂度：O(logn)   
   
 3、二叉排序树的特点是：  
   
 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；  
 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；  
 它的左、右子树也分别为二叉排序树。  
 搜索的原理：  
   
 若b是空树，则搜索失败，否则：  
 若x等于b的根节点的数据域之值，则查找成功；否则：  
 若x小于b的根节点的数据域之值，则搜索左子树；否则：  
 查找右子树。  
 数据结构：二叉排序树   
 时间复杂度： O(log2N)  
   
 4、哈希散列法(哈希表)  
 其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。  
   
 数据结构：哈希表   
 时间复杂度：几乎是O(1)，取决于产生冲突的多少，也就是链表长度，因为链表查找复杂度为O(n)  
   
 5、分块查找  
 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。   
   
 算法流程：  
 先选取各块中的最大关键字构成一个索引表；  
 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。  
   
   
 6、平衡多路搜索树B树（B-tree）  
 B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。  
   
 首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。  
 例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)  
   
 由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质  
   
   
 7、B+Tree  
 其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。  
   
   
 树的概念：  
 结点：指二叉树中一个个的点，就是下图中的0、1、2、3、4、5、6；  
 度：指父结点下面有几个孩子结点，举两个例子你就明白了。针对结点1，他下面有两个孩子3、4，所以说结点1的度为2；针对结点4，他下面一个孩子都没有，所以说结点4的度为0；叶子就是度为0的结点。  
 置于遍历有一点点麻烦，但要抓住以下要点就可以了（不管任何大小的树）：  
 前序：是先访问根，再访问左子树，然后访问右子树  
 后序：是先访问左子树，再访问右子树，然后访问根  
 中序：是先访问左子树，再访问根，然后访问右子树  
 完全二叉树，除了叶子结点这层外，其他层结点都是度为2的，所以这样的树高度应该最矮了。  
 以下图为例子：  
 前序序列：0134256后序序列：3415620中序序列：3140526  
 ![http连接过程图片](./image/treeSort.png.jpeg "ReferencePicture")  
   
  
  
图论（离散数学）：  
  
出度和入度  
可以把人与人之间为识的关系对应到一个图中。如果a认识b就a->b连一条边。  
有向图来说，结常与结点间的连接。V1到V2，V1到V3。说明V1的出度是2。V2到V1说明V1的入度是1  
  
数据结构中入度出度分别用什么符号表示  
入度：ID in degree  
出度：OD out degree  
  
有向图顶点集的度数是不是等于出度加入度  
在一个有向图中，所有顶点的入度之和等于所有顶点出度之和，一条边必有起点和终点，这是同时存在的，不存在一条边只有起点或者只有终点，所以所有顶点的入度之和等于所有顶点出度之和  
  
在有向图中，入度高的点和出度高的点各自的含义是不同的。粗浅地说，出度高的点我们往往叫做Authority，就是那种权威性很好，所以对其他点影响力较强或者输出信息较多的点。而相应的，入度比较高的点称为Hub，即那种作为中介的，从别人那里获取信息比较多的点。当然，计算Authority和Hub更权威的方法有HITS算法等，往往并非单纯依赖出入度这么简单。  
  
度数这个概念仅适用于无向图，即相邻的点的个数（或者说是连接的边的个数）。在有向图中，一般来说只分开考虑入度和出度，基本上见不到说把两者加起来记做度数的。  







---------------------------------------------------------------------------------------------------------------------

