1.TCP/IP 三次握手 四次挥手
osi参考模型：
tcp/ip四层概念模型：应用层（应用层、表现层、会话层）、传输层、网络层、数据链路层（数据链路层、物理层）（3 1 1 2）

TCP/IP:协议的集合，代表性的有ip、tcp、http。
ip:网络层。代表网际协议。
tcp：传输层。tcp是可靠的，udp是不可靠的。
http：应用层协议，主要解决如何包装数据。除了http还有ftp、telnet等等
把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。

tcp三次握手：建立tcp连接。client端发送一个数据包，server端确认收到连接并返回给client，client确认然后连接建立完成。随后client和server端可以开始传输数据。
tcp四次握手：断开tcp连接。client端发送一个FIN请求，server收到一个FIN请求表示client这一端不在发送数据了，但是还能接收数据，此时tcp连接还没有关闭。直到server端再发送一个FIN请求，表示server端也不会再发送数据了；client端收到FIN后，给server一个ack响应，server端进入closed状态。



2.Http的格式说明
request由请求行、请求头、请求体组成
请求行（参考：GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1      请求类型 请求地址  协议版本）
请求头（参考：HOST是主机地址，User-Agent是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送，等等
Host: www.fishbay.cn
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
）
空行：请求头后面必须有一行空行
请求数据：请求体

response由状态行、响应头、响应体组成。参考如下：
HTTP/1.1 200 OK   状态行
Server: nginx  响应头
Date: Mon, 20 Feb 2017 09:13:59 GMT
Content-Type: text/plain;charset=UTF-8
Vary: Accept-Encoding
Cache-Control: no-store
Pragrma: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: no-cache
Content-Encoding: gzip
Transfer-Encoding: chunked
Proxy-Connection: Keep-alive
				空行
{"res":ok"}   响应体


3.状态码说明
200 OK 请求成功
301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
今后任何新的请求都应使用新的URI代替
302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
400 Bad Request 客户端请求的语法错误，服务器无法理解
401 Unauthorized 请求要求用户的身份认证
403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
404 Not Found 资源未找到
500 Internal Server Error 服务端内部错误
502	Bad Gateway	充当网关或代理的服务器，从远端服务器接收到了一个无效的请求


4.进程间通讯方式（IPC）  扩展：半双工（即数据只能在一个方向上流动）、全双工
a、管道（无名管道）
b、FIFO（命名管道）
c、共享内存
d、消息队列
e、信号量


5.数据库事务的4大特性、数据库隔离级别，索引类别，oracle的SID 实例  explain
ACID 原子性、一致性、隔离性（Isolation）、持久性

read-uncommited 读未提交，别人修改了未提交就能看得到。会产生脏读
read-commited  读提交，默认的就是这个。  会产生读取旧数据，
repeatable-read  可重复读。会产生幻读，就是突然蹦出来的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
serializable  可串行化，强制事务串行执行。但是性能低下。


索引类型：
a、普通索引：没有限制
b、唯一索引：索引列的值必须唯一，但允许有空值。
c、主键索引：特殊的唯一索引，不允许有空值。
d、组合索引：最左前缀。
1):查询条件中出现联合索引第一列,或者全部,则能利用联合索引.
2)条件列中只要条件相连在一起,以本文例子来说就是:
last_name=’1′ and first_name=’1′
与first_name=’1′ and last_name=’1′,无论前后,都会利用上联合索引.
3)查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询.复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的
e、全文索引

索引的坏处：虽然大大提高了查询速度，但是会降低表的更新速度，例如insert、delete、update时，不仅要更新表，还要更新索引文件。

oracle的sid与实例
1.SID:对应着实例，一个数据库可以有多个实例（如RAC），SID是用来标识这个数据库内部每个实例的名字。
2.SERVICE_NAME：是这个数据库对外宣称的名字，对应着数据库。


6.启动一个包含main方法的类时，输出字符，整个启动到输出的详细流程
 首先java.exe 会帮助我们找到 JRE ，接着找到位于 JRE 内部的 jvm.dll ，这才是真正的 Java 虚拟机器 , 最后加载动态库，激活 Java 虚拟机器。虚拟机器激活以后，会先做一些初始化的动作，比如说读取系统参数等。一旦初始化动作完成之后，就会产生第一个类加载器―― Bootstrap Loader
	1.加载字节码（启动类加载器，扩展类，应用程序类，自定义加载器）
	2.验证格式
	3.准备（分配内存）
	4.解析（解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程）
	5.初始化
整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于<clinit>（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

7.双亲委派
a、类加载器分为启动类加载器，bootstrap classloader 加载JAVA_HOME/lib目录下面的class
b、扩展类加载器extensnion classloader 加载JAVA_HOME/lib/ext目录下面的class
c、程序类加载器application classloader 加载用户类路径（classpath）上所指定的类库
d、自定义类加载器 继承ClassLoader抽象类

双亲委派机制：
指的是类加载器收到类加载的请求有，将这个请求为派给父类加载器完成。若父类无法完成这个加载请求，子类加载器进行加载。*
也就是说，所有的请求多会传送到顶层的启动类加载器，从顶层开始试图加载类，无法加载再向下传递。

打破双亲委派机制：
JNDI 线程上下文类加载器。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。
这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？
为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。


OSGI 热部署 使用的是自定义的类加载器机制，每一个程序模块（bundle）都有一个自己的类加载器。

扩展问题
a、能不能自己写一个java.lang.Object的类？如果能怎么写,如果不能为什么?
不能自己写以"java."开头的类，其要么不能加载进内存，要么即便你用自定义的类加载器去强行加载，也会收到1个SecurityException。

b、请设计一个能够在服务端执行的分析JVM中状态的程序。

8.classloader的功能和工作模式





JVM内存区域：
堆（新生代、老年代）、栈（java虚拟机栈、native方法栈）、方法区（永久代）、程序计数器、


1、面试官可以先问你什么时候一个对象会被GC？　　 算法，根搜索算法，当一个对象不可达时，通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

2、接着继续问你为什么要在这种时候对象才会被GC？　　gc经常发生的是在堆区，堆区分为新生代、老年代，新生代分为
一个eden空间和两个survivor空间。
a、 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；
b、 Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；
c、发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。

方法区：存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）
来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代

3、接着继续问你GC策略都有哪些分类？
标记-清除算法----------标记和清除效率低，而且产生一堆不连续的内存碎片
复制算法------------将内存按照容量划分成几块，当某一块的用完之后，直接把存活的对象复制到另一块上面，然后把已使用的一次性清除掉。新生代用的比较多，划分比例为8：1:1，一个eden，两个survivor空间。每次可用的空间能够达到90%。  缺点是较多的复制操作，效率会变低，还会浪费空间。
标记-整理算法----------标记之后，整理一下，然后清除掉。    老年代常用算法
分代收集算法---------根据对象存活周期，将内存分为几块，根据不同的特点采用最适合的收集算法


4、你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？　　
5、你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？　　
6、你如果选出来了，继续问你，为什么要选择这个策略？


GCROOT哪里来的(哪些可以是GCROOT)？
GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。主要有以下几种：
a.虚拟机栈(栈桢中的本地变量表)中的引用的对象
b.本地方法栈中JNI的引用的对象
c.方法区中的类静态属性引用的对象 
d.方法区中的常量引用的对象 


回收器：
1、新生代，均使用标记-复制算法。
serial收集器 单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。使用标记-复制垃圾收集算法
ParNew收集器 serial的多线程版本，新生代收集器，使用标记-复制垃圾收集算法。可以和CMS一起使用，很重要。
Parallel Scavenge收集器，也是多线程的垃圾收集器，但是和parNew的关注点不同，关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是CPU用于运行应用程序的时间和CPU总时间的占比，吞吐量 = 代码运行时间 / (代码运行时间 + 垃圾收集时间) 

2、老年代：Serial Old收集器、Parallel Old收集器以及CMS收集器。
Serial Old收集器   标记整理算法，单线程。 主要是在JDK1.5版本之前和Parallel Scavenge年轻代收集器配合使用，或者作为CMS收集器的后备收集器。
Parallel Old收集器    标记整理算法，多线程。和Parallel Scavenge一样，是关注吞吐量的，经常和Parallel Scavenge一起使用。
CMS收集器    目前老年代收集器中比较优秀的垃圾收集器。使用"标记-清除"算法的并发收集器，以获取最短停顿时间为目标的收集器。
分为个阶段：1、初始标记  stop the world  2、并发标记  3、重新标记 stop the world
 4、并发清除。 
 由于并发清理阶段，如果用户产生了垃圾对象，但是过了标记阶段，所以会产生浮动垃圾，因为不能像其他收集器那样等到完全填满了老年代以后才进行垃圾收集，需要预留一部分空间来保证当出现浮动垃圾的时候可以有空间存放这些垃圾对象。这个空间比例可以设置。

 3、G1收集器：不区分所谓的新生代、老年代，将整个内存区域混合在一起，划分成不同的子区域。
 在小范围内还是会划分成年轻代、老年代。采用不同的GC方式来处理。
 是用什么GC可以设置的，例如java -Xmx10m -Xms10m -XX:+UseG1GC -XX:+PrintGCDetails TestDemo




类加载机制的简单连环炮。
1、首先肯定是先问你Java的类加载器都有哪些
2、回答了这些以后，可能会问你每个类加载器都加载哪些类？　　
3、说完以后，可能会问你这些类加载之间的父子关系是怎样的？　　
4、你在回答的时候可能会提到双亲委派模型，
5、那么可以继续问你什么是双亲委派模型？　　
6、你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？　　
例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。

6、你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？
看自己的类加载器的逻辑了，如果只重写了findClass方法并没有重写loadClass方法，就没有改变父类委托机制。如果改写了loadClass，就以自己改写的loadClass逻辑为准。
a、重写findClass方法的自定义类，首先会通过父类加载器进行加载，如果所有父类加载器都无法加载，再通过用户自定义的findClass方法进行加载。
b、重写loadClass来实现，可以在JVM的不同类加载器中保留具有相同全限定名的类，这种情况下，就有可能有大量相同的类，被不同的自定义类加载器加载到JVM中，并且这种实现方式是不符合双亲委派模型。

注意：defineClass 将二进制字节转换成Class类

class文件加载过程：加载（资源，将二进制字节文件存到方法区中）--》验证（文件格式）--》准备（分配类变量的内存空间、设置类变量初始值）--》解析（将常量池的符号引用转换为直接引用）--》初始化（执行java代码，初始化类变量和其他资源）


Java的内存模型是怎么设计的？（线程之间的通信机制有两种共享内存和消息传递，java采用的是共享内存模型）
a、java内存模型（JAVA Memory Model）描述的是一组规则或规范，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
所有的变量都存储在主存中，每条线程有自己的工作内存，工作内存保存了被该线程所使用到的变量的主内存的副本拷贝。线程对变量的所有操作，都要在工作内存中进行。线程之间的互相访问，也要通过主内存。
b、Happens-Before
c、定义了8种操作：lock unlock read->load(不能单独出现) use assign  store->write(不能单独出现)、


你回答了以后，还会继续问你为什么要这么设计？
问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？
只能保证可见性，不能保证写入操作的原子性。
当且仅当满足以下条件时，才应该使用
a、对变量的写入操作不依赖当前的值，或者只有单个线程更新变量的值。
b、该变量不会与其他变量一起，纳入不变性条件。



你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。



==========================================================================================

9.synchronized和lock的用法区别  各自底层原理
synchronized：
对象级别的同步块，底层包含monitorenter和monitorexit指令
方法级别同步，底层是 ACC_SYNCHRONIZED 标识来判断
Java虚拟机对synchronized的优化
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。
lock：

10.分布式锁
11.如何设计线程池 需要什么特性  怎么扩容 缩容  如何去取资源 分配资源
12.spring中的transactional注解，requestMapping注解的实现原理
13.springMvc原理 如何集成web
14.什么是缓存击穿 如何避免
缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


15.自己做的项目对自己帮助很大的方面 成长的方面
16.如何排查oom
a、查看服务器运行日志、项目日志，捕捉到异常
JAVA heap space  （dump堆转储快照，用工具进行分析，确认到底是内存泄漏还是内存溢出，如果是内存泄漏，查看泄露对象为什么无法回收；如果不存在内存泄漏，说明对象都是必须存活的，则需要修改堆参数-Xms -Xmx）
StackOverflowError 线程请求的栈深度大于虚拟机所允许的栈深度（-Xss设置栈内存大小）
OutOfMemoryError 虚拟机在扩展栈时，无法申请到足够的空间
PermGen space 运行时常量池溢出 or 方法区溢出
unsafe.allocateMemory() 直接内存溢出
b、查看linux日志 /var/log/message 看看有没有kill掉进程的记录
c、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryError，当应用抛出OutOfMemoryError时生成dump文件。


dump文件的几种方式：
1、使用jmap -dump命令
2、使用jconsole工具
3、增加jvm启动参数，-XX:+HeapDumpOnOutOfMemoryErro
4、使用hprof。启动虚拟机加入-Xrunhprof:heap=site，会生成java.hprof.txt文件。该配置会导致jvm运行非常的慢，不适合生产环境。（HPROF可以用来展示和跟踪cpu的使用情况，内存分配的统计数据等。不仅如此，它还支持对 java进程完整的内存dump，所有线程的monitor stats数据）


jdk的命令行工具；
1、jps 等同于ps，列出正在运行的虚拟机进程
2、jstat 用于监视虚拟机各种运行状态信息（例如：jstat gc 2764 250 20）
3、jinfo 实时地查看和调整jvm的各项参数
4、jmap 用于生成堆转储快照
5、jhat 堆转储快照的分析工具
6、jstack java堆栈信息跟踪工具（一般多jstack几次才能看出来）

jdk的可视化工具：
1、JConsole
2、VisualVM



=====================================
问题：
Redis Bitmap是什么？


HikariCP连接池（号称性能最好的JDBC连接池:HikariCP）？
常用的JDBC连接池包括：
DBCP：单线程，性能较差，适用于小型系统
C3P0：单线程，并发量低，性能不好
BoneCP：一个高效、免费、开源的Java数据库连接池实现库，它的性能几乎是C3P0、DBCP的25倍。性能高于durid
Druid：Druid是Java语言中最好的数据库连接池。能够提供强大的监控和扩展功能。特色：为分析监控设计；快速的交互式查询；高可用；可扩展。



springboot自动启动类?---------》
答案：SpringApplication.run();


spring常用的接口和类，实现原理（在什么时候初始化，什么时候注入，什么时候调用）？
BeanFactory.java，基本的接口类
ApplicationContext.java，BeanFactory的扩展类
1、DefaultListableBeanFactory是整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory集成自DefaultListableBeanFactory。XmlBeanFactory与DefaultListableBeanFactory不同的地方是XmlBeanFactory使用了自定义的XML读取器XmlBeanDefinitonReader,实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory接口。
2、XmlBeanDefinitonReader集成自AbstractBeanDefinitionReader，完成了XML配置文件的读取过程。
1）使用ResourceLoader将资源文件路径转换成对应的Resource文件
2）通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件
3）通过实现接口BeanDefinitonDocumentReader的DefaultBeanDefinitonDocumentReader类对Document进行解析，并使用BeanDefinitonParserDelegate对Element进行解析。
3、XmlBeanFactory


IOC容器的初始化过程：BeanDefiniton的Resource的资源定位、载入和注册的过程



GC，问怎么标记回收对象的，从GCROOT不可达的对象（根据四种引用关系，强软弱虚），GCROOT哪里来的(哪些可以是GCROOT)？
java提供finalize()方法？GC和finalize()方法都是不可靠的


什么时候一个对象会被GC？
答：GC发生在堆区，分为新生代和老年代。新生代还分为Eden和两个Survivor区域。
a、对象优先在eden分配，当eden空间不够用的时候，发生minor gc
b、当老年代空间不够用的时候，发生full gc，一般会伴随着一次minor gc，大对象直接进入老年代。
c、发生minor gc时，会检测之前每次晋升到老年代的内存大小，是否大于当前的老年代的剩余大小。如果大于，则进行一次full gc。如果小于，则看是否允许担保失败，如果允许担保失败，则进行一次minor gc，如果不允许，进行full gc。

为什么要在这个时候对象才会被GC？
GC策略都有哪些分类？
答：标记-清除算法，产生不连续的内存空间，标记和清除效率不高   适用于老年代
复制算法，浪费一部分空间，较多的复制操作，效率变低   适用于新生代
标记-整理算法，整理需要时间，但是必要的    适用于老年代


这些策略分别都有什么优劣势？都适用于什么场景？
给你举个实际的场景，让你选择一个GC的策略？为什么要选择这个策略？
什么是gc，什么是cms算法？
并发标记清除算法，分为4个步骤，初始标记-》并发标记-》重新标记-》并发清除。会产生浮动垃圾，就是重新标记过程中生产的垃圾，所以要保留一部分空间。


cms算法实现原理？整个过程是怎么样的？
怎么避免full gc？
1、system.gc() 调用大多数情况下会出发full gc，应该禁止使用。
2、老年代空间不足 调优时尽量做到让对象在minor gc阶段呗回收，避免创建过大的对象和数组。
3、永久代空间不足也会触发full gc。增大永久代空间、或者改成cms gc。
4、cms gc出现promotion failed和concurrent mode failure两种状况会出现full gc。
都是因为老年代空间不足造成的
措施：增大survivor space、老年代空间或者调低触发并发gc的比例。
5、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间
6、堆中分配很大的对象，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。设置-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程





java g1垃圾收集器？

类加载机制的相关问题：
java的类加载器都有哪些？
每个类加载器都加载哪些类？
这些类加载器之间的父子关系是怎么样的？
回答的时候可能会提到双亲委派模型，双亲委派模型是什么？
java的类加载器为什么要使用双亲委派模型？
如何自定义自己的类加载器？自己的类加载器和java自带的类加载器关系如何处理？
bootstrap
Extend
system/app
self defined

内存的相关问题：
内存分为哪几部分？这些部分分别都存储哪些数据？
一个对象从创建到销毁都是怎么在这些部分里存活和转移的？
内存的哪些部分会参与GC的回收？
java的内存模型是怎么设计的？为什么这么设计？
回答：Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。
在并发编程领域，有两个关键问题：线程之间的通信和同步。线程之间的通信机制有两种：共享内存和消息传递。
Java的并发采用的是共享内存模型
Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。
JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。

java线程、java线程池、java集合、java队列、java正则表达式、java native方法、JAVA泛型
jdk和jre的区别

java、Spring中的ServletContext相关
Spring的DispacherServlet和ContextLoaderListener中的WebApplicationContext的关系
获取spring的ApplicationContext几种方式：直接创建（2种），工具类WebApplicationContextUtils，extends或者implements（ApplicationObjectSupport就是实现ApplicationContextAware）

java nio的selector  和linux的epoll select，类似与epoll或者java里面的selector

ZeroCopy和mmap思想


集合重写写equals，就必须重写hashCode？使用hash表的时候需要重写


Java基础
概述、语言基础、OO、Exceptio处理、Array、常用Class、集合、IO与文件、多线程、反射


============================
面试题：
1、nio、Bio，aio的区别，大概机制，接口
nio 同步非阻塞io（不等待，但是主动查询io是否完成），高并发的程序一般用这.Channel、Buffer、Selector     Reactor就是Java的NIO。
bio 同步阻塞io（等待操作完成）    
aio 异步非阻塞io（不等待，也不主动查询，io完成会主动通知）   AsynchronousChannel、AsynchronousSocketChannel


2、数据库，innobd，隔离级别，行级锁
3、分布式
4、类加载器和双亲委派机制，何时破坏双亲委派机制
5、几种垃圾回收器
6、java8新特性，lamda，函数接口
7、多线程：创建线程池，两个线程一个初始化，一个循环，改变一个值，并发包下接口类
8、java虚拟机的内存模型，内存工作方式
9、spring 、aop、ioc
10、二叉树算法
11、MySQL的事务级别，mybatis一个mapper实现两个sql
12、多线程，100个子线程，执行完成，将结果返回主线程
13、如何在大量数据中查找某一段的数据，不用limit
14、dubbo的原理，结构
15、整体介绍负载均衡架构
16、多线程的好处？一定能加快运行速度么？因为线程切换也是需要时间的
17、Integer和int类型，哪个放在堆内存？哪个在栈内存？

18、堆里面和栈内存，分别是什么时候回收？
19、outofmemory的问题，怎么定位？
20、常用有哪些设计模式？
21、一致性hash的实现原理