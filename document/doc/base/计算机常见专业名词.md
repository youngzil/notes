计算机常见专业名词.md


---------------------------------------------------------------------------------------------------------------------
DDD（Domain-Driven Design，领域驱动设计）
充血模型：
贫血模型(Anemic Model)（失血模型）

CQRS
CQRS(Command Query Responsibility Segregation)，即命令查询职责分离，这里的命令可以理解为写操作，而查询可以理解为读操作。与“基于数据模型的读操作”不同的是，在CQRS中写操作和读操作使用了不同的数据库，数据从写模型数据库同步到读模型数据库，通常通过领域事件的形式同步变更信息。


实现业务的3种常见方式
1、基于“Service + 贫血模型”的实现
这种方式当前被很多软件项目所采用，主要的特点是：存在一个贫血的“领域对象”，业务逻辑通过一个Service类实现，然后通过setter方法更新领域对象，最后通过DAO(多数情况下可能使用诸如Hibernate之类的ORM框架)保存到数据库中。

这种方式依然是一种面向过程的编程范式，违背了最基本的OO原则。另外的问题在于职责划分模糊不清，使本应该内聚在Order中的业务逻辑泄露到了其他地方(OrderService)，导致Order成为一个只是充当数据容器的贫血模型(Anemic Model)，而非真正意义上的领域模型。在项目持续演进的过程中，这些业务逻辑会分散在不同的Service类中，最终的结果是代码变得越来越难以理解进而逐渐丧失扩展能力。


2、基于事务脚本的实现
在上一种实现方式中，我们会发现领域对象(Order)存在的唯一目的其实是为了让ORM这样的工具能够一次性地持久化，在不使用ORM的情况下，领域对象甚至都没有必要存在。于是，此时的代码实现便退化成了事务脚本(Transaction Script)，也就是直接将Service类中计算出的结果直接保存到数据库(或者有时都没有Service类，直接通过SQL实现业务逻辑):

事实上，事务脚本并不是一种全然的反模式，在系统足够简单的情况下完全可以采用。但是：一方面“简单”这个度其实并不容易把握；另一方面软件系统通常会在不断的演进中加入更多的功能，使得原本简单的代码逐渐变得复杂。因此，事务脚本在实际的应用中使用得并不多。


3、基于领域对象的实现
  在这种方式中，核心的业务逻辑被内聚在行为饱满的领域对象(Order)中，所有业务（“检查Order状态”、“修改Product数量”以及“更新Order总价”）都被包含在了Order对象中，这些正是Order应该具有的职责。
  
实例代码
https://github.com/e-commerce-sample



参考
https://www.infoq.cn/article/should-we-focus-on-ddd
https://insights.thoughtworks.cn/backend-development-ddd/
https://insights.thoughtworks.cn/tag/ddd/
https://insights.thoughtworks.cn/ddd-architecture-design/
https://medium.com/the-coding-matrix/ddd-101-the-5-minute-tour-7a3037cf53b8
https://tech.meituan.com/2017/12/22/ddd-in-practice.html


---------------------------------------------------------------------------------------------------------------------
OOD

面向对象设计（Object-Oriented Design，OOD）方法是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。

OOA--->OOD--->OOP

OOD的目标是管理程序内部各部分的相互依赖。为了达到这个目标，OOD要求将程序分成块，每个块的规模应该小到可以管理的程度，然后分别将各个块隐藏在接口（interface）的后面，让它们只通过接口相互交流。比如说，如果用OOD的方法来设计一个服务器-客户端（client-server）应用，那么服务器和客户端之间不应该有直接的依赖，而是应该让服务器的接口和客户端的接口相互依赖。

这种依赖关系的转换使得系统的各部分具有了可复用性。还是拿上面那个例子来说，客户端就不必依赖于特定的服务器，所以就可以复用到其他的环境下。如果要复用某一个程序块，只要实现必须的接口就行了。

OOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。我们刚才说到：OOD是一种抽象的范式。抽象可以分成很多层次，从非常概括的到非常特殊的都有，而对象可能处于任何一个抽象层次上。另外，彼此不同但又互有关联的对象可以共同构成抽象：只要这些对象之间有相似性，就可以把它们当成同一类的对象来处理。

OO方法以对象为基础，利用特定的软件工具直接完成从对象客体的描述到软件结构之间的转换。这是OO方法最主要的特点和成就。OO方法的应用解决了传统结构化开发方法中客观世界描述工具与软件结构的不一致性问题，缩短了开发周期，解决了从分析和设计到软件模块结构之间多次转换映射的繁杂过程，是一种很有发展前途的系统开发方法。


计算机硬件技术却在飞速发展。从几十年前神秘的庞然大物。当软件开发者们还在寻找能让软件开发生产力提高一个数量级的“银弹”时，硬件开发的生产力早已提升了百倍千倍。
硬件工程师们能够如此高效，是因为他们都很懒惰。他们永远恪守“不要去重新发明轮子”的古训。Grady Booch把这些黑箱称为类属（class category）。
类属是由被称为类（class）的实体组成的，类与类之间通过关联（relationship）结合在一起。一个类可以把大量的细节隐藏起来，只露出一个简单的接口，这正好符合人们喜欢抽象的心理。所以，这是一个非常伟大的概念，因为它给我们提供了封装和复用的基础，让我们可以从问题的角度来看问题，而不是从机器的角度来看问题。
软件的复用最初是从函数库和类库开始的，这两种复用形式实际上都是白箱复用。到90年代，开始有人开发并出售真正的黑箱软件模块：框架（framework）和控件（control）。框架和控件往往还受平台和语言的限制，实现更高程度的复用。但是想一想，其实Web Service也是面向对象，只不过是把类与类之间的关联用XML来描述而已。


面向对象设计(OOD)原则

SOLID 六大原则
单一职责原则
开闭原则
里氏代换原则
迪米特法则
接口隔离原则
合成复用原则


参考
https://www.jianshu.com/p/9677b15e4d73



---------------------------------------------------------------------------------------------------------------------

SMART原则:管理和绩效考核标准
SMART原则(S=Specific、M=Measurable、A=Attainable、R=Relevant、T=Time-bound)，实施目标管理不仅是为了利于员工更加明确高效地工作，更是为了管理者将来对员工实施绩效考核提供了考核目标和考核标准，使考核更加科学化、规范化，更能保证考核的公正、公开与公平。


开箱即用功能（out-of-the-box feature，也称OOTB或off the shelf）在软件上指产品在安装后，无需配置或修改，即可使用的功能或特性。也指默认即对所有用户可用，不需支付额外费用或进行另外的配置。


惊群问题(The "thundering herd" problem) 
linux 惊群问题：我试验平台内核3.8， 和我看的代码版本3.6, 都是解决了。而在2.6.1版本是存在的
惊群是指多个进程/线程在等待同一资源时，每当资源可用，所有的进程/线程都来竞争资源的现象。
但是，只有这些进程中的一个能够真正的accept这个连接，其他的进程accept将返回EAGAIN
惊群造成的结果是系统对用户进程/线程频繁的做无效的调度、上下文切换，系统系能大打折扣。
解决：
1、在linux 2.6版本之后，通过引入一个标记位，解决掉了惊群问题，每次只有一个进程唤醒，已经解决掉了惊群问题。
2、Nginx使用epoll，如何解决惊群：Nginx采用互斥锁



CLI:命令行界面（英语：command-line interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）。
CUI:指冯诺依曼体系机构。在电子技术领域表示为Command User Interface，命令行用户交互。是和GUI(图形界面(Graphical User Interface，简称 GUI，又称图形用户接口))相对应的一种说法。
GUI:图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。


Internet of things（IoT）物联网


客户端通过域名 + 端口访问 TCP 网关，域名不同的运营商对应不同的 VIP，VIP 发布在 LVS 上，LVS 将请求转发给后端的 HAProxy，再由 HAProxy 把请求转发给后端的 Netty 的 IP+Port。


格式是所谓的WYSIWYG（所见即所得（What You See Is What You Get））格式，如Python三引号（triple quotes）


lamp 的全称是linux + apache + mysql +php
lnmp 的全称是linux + nginx + mysql + php （国外喜欢简称为LEMP，搜英文资料需要搜LEMP）


栈：后进先出（Last In First Out），简称为LIFO线性表
队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out)
LoadBalance--负载均衡
Docker daemon 
daemon：守护神; （希腊神话中） 半人半神的精灵; [计] 守护进程;
hypervisor：
super、hyper是同意词，意思都是超级，感觉hyper比super还要高级。
hypertext，超文本。
supervisor，n.监督者
hypervisor，n.超级监督者，引申为超级管理程序、超多功能管理器、虚拟机管理器、VMM
ConsistentHashAlgorithm中的算法和treemap
Scrum是迭代式增量软件开发过程，通常用于敏捷软件开发


服务器图形化编辑器
FTP软件：winscp、File Zilla、Xftp、flashfxp
终端仿真：Xshell、securecrtCRT
java IDE：idea、eclipse、myeclipse
python IDE：pycharm
文本编辑器：notepad、UltraEdit（UE）、editplus、Emacs (所有平台)、vim


archive  档案馆，归档
Internet 互联网
alpha、beta、gamma
release 释放，发布
candidate 候选人，候选的
close beta、open beta


BOM(Browser Object Model):
DOM(Document Object Model):

OOP(Object-Oriented Programming Language)
OBP(Object-Based Programming Language)


SLB（Server Load Balancer）为英文缩写，有多种含义。一是服务器负载均衡（Server Load Balancing）
负载均衡算法有两种：
Weighted round robin(WRR)和Weighted least connections(WLC),
WRR使用加权轮询算法分配连接，WLC通过一定的权值，将下一个连接分配给活动连接数少的服务器。
配置分为两部分，
第一部分是使用slb serverfarm serverfarm_name命令定义SLB选项，包括指定真实服务器地址；
第二部分是使用ip slb vserver virtual_server-name来指定虚拟服务器地址。


DNS域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。


CDN的全称是Content Delivery Network，即内容分发网络
CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。


OpenDNS 是一个免费的域名解析服务提供商（DNS）。
https://www.opendns.com/


网关和路由器：
概念理解有错误。首先‘网关’一个大概念，不具体特指一类产品，只要连接两个不同的网络的设备都可以叫网关；而‘路由器’么一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。当然电信行业说的‘路由器’又和家用的‘路由器’两个概念，这个暂且不表。回到题目中你说问的默认网关是什么，默认网关事实上不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。

网关是默认的数据出口。如果你的数据不知道往哪里走的话，那么他会去默认网关那里报道。路由器包含许多这样的网关，其中之一是默认网关。也就是说数据到了路由器以后，如果不知道自己下一步该怎么走了，那么他会去默认网关那里去报道。但路由器还包含许多其他的网关，比如数据要去买饮料，那么路由器就送数据去小卖铺。如果数据内急，那么路由器送数据去卫生间。这种起点－终点的对应就叫路由（routing）。这也是路由器（router）名字的由来。


API Gateway:
APIGateway 即API网关，所有请求首先会经过这个网关，然后到达后端服务，有点类似于Facade模式。API网关作为系统接口对外的统一出口，可以减少调用方对服务实现的感知。 
http://blog.csdn.net/Tredemere/article/details/78246413?locationNum=10&fps=1


API Gateway/Backend for Front-End 作为一种目前非常流行并且经过验证的 Pattern，不论是在 Netflix/Amazon 还是 BAT 都得到了广泛的应用。在 Microservice architecture pattern 大行其道的当下，API Gateway 的建设显得尤为重要
https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247487357&idx=1&sn=794b57e6bae5f3639ed38e017a67a6ed&chksm=96c9b91da1be300b8722df814b28d68a58fcbd993c24f6800333f2bbe855cc872f62f9453f31#rd


关于进程、线程和轻量级进程，线程模型的讨论 
http://blog.csdn.net/tianyue168/article/details/7403693
https://blog.csdn.net/mm_hh/article/details/72587207
http://blog.chinaunix.net/uid-22287947-id-1775625.html
进程是资源管理的最小单元；而线程是程序执行的最小单元。
一个进程的组成实体可以分为两大部分：线程集合和资源集合。
资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。
进程中的线程是动态的对象；代表了进程指令的执行。
线程有自己的私有数据：程序计数器，栈空间以及寄存器。

线程：其实可以先简单理解成cpu的一个执行流，指令序列。



传统进程的缺点
a. fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用现代的写时复制(copy-on-write)技术。
b. 各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC（进程间通信）技术，如***消息队列、共享内存、信号量***等。

用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。

轻量级进程 (LWP, light weight process)
轻量级进程 (LWP, light weight process) 是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有 LWP 。每一个进程有一个或多个 LWPs ，每个 LWP 由一个内核线程支持。这种模型实际上就是恐龙书上所提到的一对一线程模型。在这种实现的操作系统中， LWP 就是用户线程。 由于每个 LWP 都与一个特定的内核线程关联，因此每个 LWP 都是一个独立的线程调度单元。即使有一个 LWP 在系统调用中阻塞，也不会影响整个进程的执行。
轻量级进程具有局限性。首先，大多数 LWP 的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在 user mode 和 kernel mode 中切换。其次，每个 LWP 都需要有一个内核线程支持，因此 LWP 要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的 LWP 。


CWD（Current Working Directory，当前工作目录）


开放源代码促进会（Open Source Initiative，缩写：OSI），又译作开放源代码组织，是一个旨在推动开源软件发展的非盈利组织。https://opensource.org/
开放软件基金会，即OSF。是由IBM、DEC和HP等国际计算机巨头组建的一个会员式机构。OSF的出现是为了促进和支持ISO指定的OSI/RF（开放系统互联模型），其出发点就是网络操作系统的开放性。



SOA面向服务的体系结构（英语：service-oriented architecture）并不特指一种技术，而是一种分布式运算的软件设计方法。软件的部分组件（调用者），可以透过网络上的通用协议调用另一个应用软件组件运行、运作，让调用者获得服务。SOA原则上采用开放标准、与软件资源进行交互并采用表示的标准方式。因此应能跨越厂商、产品与技术。一项服务应视为一个独立的功能单元，可以远程访问并独立运行与更新，例如在线查询信用卡账单。

SOA中的一项服务应有以下四个特性：
1、针对某特定要求的输出，该服务就是运作一项商业逻辑
2、具有完备的特性（self-contained）
3、消费者并不需要了解此服务的运作过程
4、可能由底层其他服务组成


https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84

APM （应用性能管理）Application Performance Management & Monitoring
在信息科学和系统控制领域，APM致力于监控和管理应用软件性能和可用性。通过监测和诊断复杂应用程序的性能问题，来保证软件应用程序的良好运行(预期的服务),APM已经商用 [1]  。



电脑：计算机启动用的BIOS芯片（ROM）、内存（RAM）、硬盘
手机：内存（RAM） +  存储（ROM）

RAM-RamdomAccessMemory易挥发性随机存取存储器，高速存取，读写时间相等，且与地址无关，如计算机内存等。
ROM-Read Only Memory只读存储器。断电后信息不丢失，如计算机启动用的BIOS芯片。存取速度很低，（较RAM而言）且不能改写。由于不能改写信息，不能升级，现已很少使用。

RAM（random access memory）即随机存储内存，这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。
ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。


手机中的RAM和ROM与电脑类似，由于RAM被称为随机存取内存，也就是运行内存，它支撑的是手机软件的运行，存放手机软件运行后进行的数据交换等工作。也就是，RAM决定了您的手机可以开多少后台程序，当然，RAM越大，手机的运行速度就越快。一旦手机关机，RAM中的数据就丢失，开机后也不会恢复。

ROM被称为只读内存，即只能读不能随意写，也就是只能读取里面的数据，而不能随意修改和删除里面的数据，就像安卓系统Root前是无法修改系统文件的，这都是一个道理。但是，为什么我们可以在里面存储照片呢？其实，现在ROM的概念也包含了可以“写”（删除、修改文件）的概念，尤其在安卓系统中。所以ROM包含了一部分手机系统占据的空间，剩余的空间您就可以用来存储您的视频、照片、音乐等，并且可以随意删除和修改。


---------------------------------------------------------------------------------------------------------------------


eq相等 ne、neq不相等， gt大于， lt小于


lt：less than 小于
le：less than or equal to 小于等于
eq：equal to 等于
ne：not equal to 不等于
ge：greater than or equal to 大于等于
gt：greater than 大于


eq 等于 
neq 不等于 
gt 大于 
egt 大于等于 
lt 小于 
elt 小于等于 
like LIKE 
between BETWEEN 
notnull IS NUT NULL 
null IS NULL


equal : 相等、
not equal：不等于、
greater than：大于、
less than：小于、
less than or equal：小于等于、
great than or equal：大于等于、
is even：是偶数、
is odd：是奇数、
is not even：不是偶数、
is not odd：不是奇数、
not：非、
mod：取余、
div by：被。。。除。










---------------------------------------------------------------------------------------------------------------------

































