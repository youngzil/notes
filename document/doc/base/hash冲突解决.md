常用的Hash冲突解决方法有以下几种：开放地址法、再散列（双重散列，多重散列）、拉链法：hashmap、建立一个公共溢出区


---------------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/u012104435/article/details/47951357
https://zhuanlan.zhihu.com/p/29520044

常用的Hash冲突解决方法有以下几种：
1.开放定址法
这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：


2.再哈希法
这种方法是同时构造多个不同的哈希函数：

Hi=RH1（key） i=1，2，…，k

当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。


3.链地址法
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

4.建立公共溢出区
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

---------------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/qq_38182963/article/details/78942764

java中hashmap是通过数据+链表/红黑树的方式来解决的
1、判断数组是否为空，如果是空，则创建默认长度位 16 的数组。
2、通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。
3、如果有元素，说明 hash 冲突了，则再次进行 3 种判断。 
  3.1、判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。
  3.2、如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。
  3.3、如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。
4、最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。
5、对维护着迭代器的modCount 变量加一。
6、最后判断，如果当前数组的长度已经大于阀值了。则重新hash。
  



---------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------


