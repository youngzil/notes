加解密
单向加密和双向加密（对称加密和非对称加密）
单向加密(信息摘要)：MD5、SHA、HMAC
对称加密：DES、3DES、AES
非对称加密：RSA、DSA、ECDSA
Base64编解码

加盐加密：通常是密码学
加密、散列和加盐的区别

查看项目quickstart-crypto
/Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/加解密.md

加解密算法：加密模式和填充方式
非对称加密技术- RSA算法数学原理分析



---------------------------------------------------------------------------------------------------------------------
常用加解密算法实现

加解密算法：加解密(AES,RSA)和签名(MD5,HmacSHA256,SHA1WithRSA,SHA256WithRSA)
https://blog.csdn.net/weixin_33747129/article/details/87078189
https://www.cnblogs.com/mmzs/p/10127332.html



https://blog.csdn.net/MJM_49/article/details/77429883
http://www.iteye.com/topic/1122076/
http://63938525.iteye.com/blog/1051667
https://www.cnblogs.com/jfzhu/p/4020928.html
https://blog.csdn.net/u010849331/article/details/52997211
https://www.jianshu.com/p/a82203397ccb
https://blog.csdn.net/lplj717/article/details/51828692
https://www.zhihu.com/question/19816240


对称加密（Symmetric Cryptography）
非对称加密（Asymmetric Cryptography）

Message Digest Algorithm MD5（中文名为消息摘要算法第五版）：文件的校验
安全散列算法SHA（Secure Hash Algorithm，SHA)：文件的校验，签名算法中的
哈希消息认证码HMAC（Hash-based Message Authentication Code）：HTTP身份校验

DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法
3DES（即Triple DES）是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。是DES的一个更安全的变形。
3DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。
AES，全称为 Advanced Encryption Standard，原名叫做 Rijndael 加密法
AES 的出现就是为了取代原来的数据加密标准（DES），


RSA就是三个提出人姓氏开头字母拼在一起组成的
DSA (Digital Signature Algorithm)，DSA 一般用于数字签名和认证。
ECDSA：The Elliptic Curve Digital Signature Algorithm (ECDSA)，椭圆曲线数字签名算法-ECDSA


Base64并不是一种加密/解密算法，而是一种编码方式：
Base64：Base64编码是从二进制值到某些特定字符的编码
Base64应用场景：网页内容、URL、邮件传输



加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。
大体上分为双向加密和单向加密，
双向加密又分为对称加密和非对称加密(有些资料将加密直接分为对称加密和非对称加密)。 

双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。
而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密的一种，应该算是摘要算法吧。



对称加密：DES、3DES、AES
对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 
由于其速度，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 
常用的对称加密有：DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES算法等 



非对称加密：RSA、DSA、ECDSA
非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥 （privatekey）。
公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 
RSA 公钥加密算法
DSA:Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。


单向加密(信息摘要)：MD5、SHA、HMAC
Java一般需要获取对象MessageDigest来实现单项加密(信息摘要)。
MD5  即Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。 
除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等 

SHA 是一种数据加密算法，该算法经过加密专家多年来的发展和改进已日益完善，现在已成为公认的最安全的散列算法之一，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说时对明文的一种“指纹”或是“摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。

SHA256：256位，通常使用64位十六进制表示


HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。
HMAC计算、HMAC-MD5、HMAC-SHA1、HMAC-SHA256、HMAC-SHA512在线计算


HMAC的应用
hmac主要应用在身份验证中，它的使用方法是这样的：
(1) 客户端发出登录请求（假设是浏览器的GET请求）
(2) 服务器返回一个随机值，并在会话中记录这个随机值
(3) 客户端将该随机值作为密钥，用户密码进行hmac运算，然后提交给服务器
(4) 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的hmac运算，然后与用户发送的结果比较，如果结果一致则验证用户合法
在这个过程中，可能遭到安全攻击的是服务器发送的随机值和用户发送的hmac结果，而对于截获了这两个值的黑客而言这两个值是没有意义的，绝无获取用户密码的可能性，随机值的引入使hmac只在当前会话中有效，大大增强了安全性和实用性。大多数的语言都实现了hmac算法，比如php的mhash、python的hmac.py、java的MessageDigest类，在web验证中使用hmac也是可行的，用js进行md5运算的速度也是比较快的。




Base64：Base64编码是从二进制值到某些特定字符的编码
Base64应用场景：网页内容、URL、邮件传输
Base64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。

严格来说Base64并不是一种加密/解密算法，而是一种编码方式。Base64不生成密钥，通过Base64编码后的密文就可以直接“翻译”为明文，但是可以通过向明文中添加混淆字符来达到加密的效果。
Base64是一种基于64个可打印字符来表示二进制数据的表示方法。

Base64编码是从二进制值到某些特定字符的编码，这些特定字符一共64个，所以称作Base64。

为什么不直接传输二进制呢？比如图片，或者字符，既然实际传输时它们都是二进制字节流。而且即使Base64编码过的字符串最终也是二进制（通常是UTF-8编码，兼容ASCII编码）在网络上传输的，那么用4/3倍带宽传输数据的Base64究竟有什么意义？

真正的原因是二进制不兼容。某些二进制值，在一些硬件上，比如在不同的路由器，老电脑上，表示的意义不一样，做的处理也不一样。同样，一些老的软件，网络协议也有类似的问题。

但是万幸，Base64使用的64个字符，经ASCII/UTF-8编码后在大多数机器，软件上的行为是一样的。


Base64应用场景：
Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。
比如在网页中，图片是二进制的，可以把图片二进制使用Base64编码之后，把编码后的字符串放入对应位置
在URL中，把参数使用Base64编码后变成较短的字符串放在URL后面
比如邮件中，很多比较老的协议还是只支持纯文本的，比如SMTP协议。可以把邮件内容使用Base64编码成字符串后传输


在URL中的应用
Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java持久化系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。

然而，标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的/和+字符变为形如%XX的形式，而这些%号在存入数据库时还需要再进行转换，因为ANSI SQL中已将%号用作通配符。

为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充=号，并将标准Base64中的+和/分别改成了-和_，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。

另有一种用于正则表达式的改进Base64变种，它将+和/改成了!和-，因为+，*以及前面在IRCu中用到的[和]在正则表达式中都可能具有特殊含义。

此外还有一些变种，它们将+/改为_-或._（用作编程语言中的标识符名称）或.-（用于XML中的Nmtoken）甚至_:（用于XML中的Name）。

为了克服Base64由于输出内容中包括两个以上“符号类”字符（+, /, =等)而带来的互不兼容多变种问题，一种输出内容无符号的Base62x编码方案被引入软件工程领域，Base62x被视为无符号化的Base64改进版本。




常用的加密/解密算法

1.Base64
    Base64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。
　　严格来说Base64并不是一种加密/解密算法，而是一种编码方式。Base64不生成密钥，通过Base64编码后的密文就可以直接“翻译”为明文，但是可以通过向明文中添加混淆字符来达到加密的效果。

2.DES
　　DES是一种基于56位密钥的对称算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。现在DES已经不是一种安全的加密算法，已被公开破解，现在DES已经被高级加密标准（AES）所代替。

3.3DES
　　3DES是DES的一种派生算法，主要提升了DES的一些实用所需的安全性。

4.AES
　　AES是现在对称加密算法中最流行的算法之一。

 

二、实现所需的一些库

　　为了实现上述的算法，我们可以实用JDK自带的实现，也可以使用一些开源的第三方库，例如Bouncy Castle（https://www.bouncycastle.org/）和comnons codec（https://commons.apache.org/proper/commons-codec/）。

---------------------------------------------------------------------------------------------------------------------
加盐加密：通常是在密码的特定部位"加盐"，然后再进行MD5 或者 SHA
可以在不同的部分多次"加盐"，倒序等多种方式改变原始密码

盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。

在大部分情况，盐是不需要保密的。盐可以是随机产生的字符串，其插入的位置可以也是随意而定。如果这个散列结果在将来需要进行验证（例如：验证用户输入的密码），则需要将已使用的盐记录下来。

安全因素
通常情况下，当字段经过散列处理（如MD5），会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的彩虹表，通过在表中搜索该MD5值，很有可能在极短的时间内找到该散列值对应的真实字段内容。

加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。


实现原理
加盐的实现过程通常是在需要散列的字段的特定位置增加特定的字符，打乱原始的字符串，使其生成的散列结果产生变化。比如，用户使用了一个密码：

x7faqgjw
经过SHA散列后，可以得出结果：
58ecbf2b3136ceda7fddfd986ba8bd8d59b2d73779691e839f3f176ce2c04b84

但是由于用户密码位数不足，短密码的散列结果很容易被彩虹表破解，因此，在用户的密码末尾添加特定字符串（绿色字体为加盐的字段）：
x7faqgjwabcdefghijklmnopqrstuvwxyz

因此，加盐后的密码位数更长了，散列的结果也发生了变化：
7b5001a5a8bcdcfa1b64d41f6339cfa7a5c0eca04cca6ff6a6c1d6aad17794cc

以上就是加盐过程的简单描述，在实际使用过程中，还需要通过特定位数插入、倒序或多种方法对原始密码进行固定的加盐处理，使得散列的结果更加不容易被破解或轻易得到原始密码

可以在不同的位置多次插入不同的字符串



https://www.bisend.cn/blog/difference-encryption-hashing-salting/
加密、散列和加盐的区别：
加密：将信息聚集在一起，使之只能用对应的密钥解密从而阅读它，这就叫做加密。加密是一个双向函数，当你对某物进行加密时，那么之后你就会想要解密它。

散列：使用算法将任意大小的数据映射到固定长度，这种做法就是散列。这称为散列值（有时称为散列代码或散列和）。
每个散列值都是唯一的。如果两个不同的文件产生了相同的唯一散列值，这就称为冲突，它使得算法基本上无用。

加盐是一个通常与密码散列相关的概念。本质上，它是一个惟一的值，可以添加到密码的末尾，以创建不同的散列值。这为散列过程增加了一层安全性，特别是针对蛮力攻击。蛮力攻击是指计算机或僵尸网络尝试所有可能的字母和数字组合，直到找到密码。
不管怎样，当加盐时，额外的值被称为“盐”。


总结：加密是双向函数，而散列是单向函数。
加密是一种双向函数，信息以某种方式被打乱，以便之后能够恢复回原状。
散列是一种单向函数，其中数据会被映射到固定长度的值。散列主要用于身份验证。
加盐是散列期间的一个附加步骤，通常与散列密码相关联，它能够在密码的末尾添加一个附加值，从而更改生成的散列值。



---------------------------------------------------------------------------------------------------------------------

加密模式
https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F
https://www.cnblogs.com/mafeng/p/6251207.html
https://blog.csdn.net/kikajack/article/category/7238303
https://blog.csdn.net/sadshen/article/details/50350067
https://blog.csdn.net/xiaowang627/article/details/56270206
https://blog.csdn.net/kaikevin01/article/details/78973024


填充方式
https://zh.wikipedia.org/wiki/%E5%A1%AB%E5%85%85_(%E5%AF%86%E7%A0%81%E5%AD%A6)
https://blog.csdn.net/shift_wwx/article/details/84256774
https://blog.csdn.net/makenothing/article/details/88429511
https://blog.csdn.net/jiftlixu/article/details/19030023
https://zhiwei.li/text/2009/05/17/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84pkcs5%E5%92%8Cpkcs7%E5%A1%AB%E5%85%85/



加解密算法：加密模式和填充方式

分组密码
块加密算法（ block cipher algorithm）：
跟DES，AES一样，　RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。

块密码工作模式
如电子密码本（ECB）和密文块链接（CBC）。 为对称密钥加密设计的块密码工作模式要求输入明文长度必须是块长度的整数倍，因此信息必须填充至满足要求。



分组密码有五种工作模式：
1.电码本模式（Electronic Codebook Book (ECB)）；
2.密码分组链接模式（Cipher Block Chaining (CBC)）；初始向量
3.计算器模式（Counter (CTR)）；
4.密码反馈模式（Cipher FeedBack (CFB)）；
5.输出反馈模式（Output FeedBack (OFB)）。


填充方式：
1、位填充
2、字节填充
3、PKCS5/PKCS7
4、补零


常用的填充形式
1、填充数据为填充字节的长度
2、填充数据为0x80后加0x00
3、填充数据的最后一个字节为填充字节序列的长度
4、填充数据为空格 0x20
5、填充数据为0x00



https://blog.csdn.net/guyongqiangx/article/details/74930951
为什么RSA公钥每次加密得到的结果都不一样？
为什么私钥对同一数据进行签名加密的结果是一样的，使用公钥进行加密就不一样了呢？ 
是的，这个问题跟对数据的padding即填充有关，详细说来，是跟PKCS #1 v1.5指定的padding方式有关


---------------------------------------------------------------------------------------------------------------------
非对称加密技术- RSA算法数学原理分析

https://blog.csdn.net/makenothing/article/details/90318351
https://www.jianshu.com/p/6d10955a5c05
https://blog.csdn.net/leaf_130/article/details/52825684
https://blog.csdn.net/wuguai4/article/details/7309007


RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难。


因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。
只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。


RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。
如：有很大质数p跟q，很容易算出N，使得 N = p * q，
但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试）


三个数学概念：
质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。
互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。
φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。

如果n是质数，则 φ(n)=n-1。
如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。



---------------------------------------------------------------------------------------------------------------------




