操作系统-内存管理机制


虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page).每个页都是一段连续的地址。
对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上。

虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会通过MMU（内存管理单元）去匹配对应的物理地址，而如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。  

而虚拟内存和物理内存的匹配是通过页表实现，页表存在MMU中，页表中每个项通常为32位，既4byte，除了存储虚拟地址和页框地址之外，还会存储一些标志位，比如是否缺页，是否修改过，写保护等。可以把MMU想象成一个接收虚拟地址项返回物理地址的方法。  

##页面置换算法
地址映射过程中，若在页面中发现所要访问的页面不再内存中，则产生缺页中断。
当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘的副本；  
如果该页面没有被修改过，那么它在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖掉被淘汰的页面就可以了。
而用来选择淘汰哪一页的规则叫做页面置换算法。

因为在计算机系统中，读取少量数据硬盘通常需要几毫秒，而内存中仅仅需要几纳秒。一条CPU指令也通常是几纳秒，如果在执行CPU指令时，产生几次缺页中断，那性能可想而知，因此尽量减少从硬盘的读取无疑是大大的提升了性能。
而前面知道，物理内存是极其有限的，当虚拟内存所求的页不在物理内存中时，将需要将物理内存中的页替换出去，选择哪些页替换出去就显得尤为重要，如果算法不好将未来需要使用的页替换出去，则以后使用时还需要替换进来，这无疑是降低效率的，让我们来看几种页面替换算法。



##页面替换算法

1、最优页面置换算法(Optimal Page Replacement Algorithm)
2、最近最少使用页面置换算法(Least Recently Used)
3、最近未使用页面置换算法(Not Recently Used Replacement Algorithm)
4、先进先出的页面置换算法(First-In First-Out Page Replacement Algorithm)
5、第二次机会页面置换算法(Second Chance Page Replacement Algorithm)
6、时钟替换算法(Clock Page Replacement Algorithm)
  


参考
https://blog.csdn.net/Kang_TJU/article/details/76991229
https://www.jianshu.com/p/2b11639905ec


---------------------------------------------------------------------------------------------------------------------
Linux内存管理
内核空间
页(page)是内核的内存管理的基本单位

内核把页划分在不同的区(zone)



用户空间
用户空间中进程的内存，往往称为进程地址空间。

Linux采用虚拟内存技术。进程的内存空间只是虚拟内存（或者叫作逻辑内存），而程序的运行需要的是实实在在的内存，即物理内存（RAM）。
在必要时，操作系统会将程序运行中申请的内存（虚拟内存）映射到RAM，让进程能够使用物理内存。



进程与内存
所有进程都必须占用一定数量的内存，这些内存用来存放从磁盘载入的程序代码，或存放来自用户输入的数据等。内存可以提前静态分配和统一回收，也可以按需动态分配和回收。


参考
https://www.jianshu.com/p/2b11639905ec



