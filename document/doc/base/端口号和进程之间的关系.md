1、端口号详解
2、端口号和进程关系，数量比




---------------------------------------------------------------------------------------------------------------------
端口号详解


1.端口号的作用
端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程

2.端口号的应用场景
在TCP/IP协议中，用“源IP地址”，“目的IP地址”，“源端口号”，“目的端口号”,协议号（IP协议的协议号为4，TCP的协议号为6）这样的一个五元组来标识一个通信，通信的双方在发送消息时，消息的头部会带着这样的五元组

3.端口范围划分
（1）0~1023：知名端口号，是留着备用的，一把都是用于协议，例如HTTP、FTP、SSH 
（2）1024~65535：是操作系统动态分配的端口号，客户端程序的端口号，就是由操作糸统从这个范围来分配的，在TCP与UDP的套接字通信中，客户端的端口号就是在此范围中

4.知名的端口号与端口号对应的服务器
HTTP服务器：80 
FTP服务器：21

ps：FTP有一个控制连接和一个数据连接，所以FTP是有两个端口号的，控制连接的端口号是21，数据连接的端口号是20，但是如果FTP的端口号默认是21，如果指明FTP有两个端口号的话，那就是21和20，否则FTP服务器的端口号就是21

TELNET服务器：23 
SSH服务器：22 
HTTPS：443 
WEB服务器：25

5.在linux中如何查看知名端口号？
cat /etc/services

6.一个进程是否可以bind多个端口号？
可以

因为一个进程可以打开多个文件描述符，而每个文件描述符都对应一个端口号，所以一个进程可以绑定多个端口号

7.一个端口号是否可以被多个进程绑定？
不可以

ps：如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的



参考
https://blog.csdn.net/dangzhangjing97/article/details/80958819


---------------------------------------------------------------------------------------------------------------------

端口号和进程关系，数量比


同一个进程可以监听不同的端口
同一个端口可以被不同的进程监听：但是host必须不一样，如果IP:PORT都一样是不行的，比如127.0.0.1:8899 和 0.0.0.0:8899是可以的，但是没有意义，因为所有的请求都会转发给0.0.0.0:8899，不会出现一个请求转发给两个进程，（ipv4通配符为0.0.0.0，ipv6通配符为::）



Socket关闭的时候存在TIME_WAIT阶段，强制关闭一个socket之前的最长等待时间被称为延迟时间（Linger Time）
SO_REUSEADDR选项只会检查当前的Socket是否设置了该选项，不会检查其他相关Socket的设置，host或者说IP必须不同
SO_REUSEADDR可以用在以下四种情况下
SO_REUSEPORT选项会检查所有的相关Socket是否设置了，并且允许完全相同的IP:PORT绑定
调用Connect()也可能返回EADDRINUSE




如果我们手动绑定一个端口，我们可以将socket绑定至端口0，绑定至端口0的意思是让系统自己决定使用哪个端口（一般是从一组操作系统特定的提前决定的端口数范围中），所以也就是任何端口的意思。
同样的，我们也可以使用一个通配符来让系统决定绑定哪个源地址（ipv4通配符为0.0.0.0，ipv6通配符为::）。


在默认情况下，任意两个socket不能被绑定在同一个源地址和源端口组合上。比如说我们将socketA绑定在A:X地址，将socketB绑定在B:Y地址，其中A和B是IP地址，X和Y是端口。
那么在A==B的情况下X!=Y必须满足，在X==Y的情况下A!=B必须满足。
例如一个socket绑定了0.0.0.0:21，在这种情况下，任何其他socket不论选择哪一个具体的IP地址，其都不能再绑定在21端口下。因为通配符IP0.0.0.0与所有本地IP都冲突。



唯一识别TCP/UDP连接。TCP/UDP是由以下五元组唯一地识别的： 
{<protocol>, <src addr>, <src port>, <dest addr>, <dest port>}



每一个socket都有其相应的发送缓冲区（buffer）。当成功调用其send()方法的时候，实际上我们所要求发送的数据并不一定被立即发送出去，而是被添加到了发送缓冲区中。
如果在socket的发送缓冲区中还有待发送数据的情况下调用了其close()方法，其将会进入一个所谓的TIME_WAIT状态。在这个状态下，socket将会持续尝试发送缓冲区的数据直到所有数据都被成功发送或者直到超时，超时被触发的情况下socket将会被强制关闭。

操作系统的kernel在强制关闭一个socket之前的最长等待时间被称为延迟时间（Linger Time）
在大部分系统中延迟时间都已经被全局设置好了，并且相对较长（大部分系统将其设置为2分钟）。我们也可以在初始化一个socket的时候使用SO_LINGER选项来特定地设置每一个socket的延迟时间。

如果SO_REUSEADDR选项没有被设置，处于TIME_WAIT阶段的socket任然被认为是绑定在原来那个地址和端口上的。直到该socket被完全关闭之前（结束TIME_WAIT阶段），任何其他企图将一个新socket绑定该该地址端口对的操作都无法成功。

如果我们在新的socket上设置了SO_REUSEADDR选项，如果此时有另一个socket绑定在当前的地址端口对且处于TIME_WAIT阶段，那么这个已存在的绑定关系将会被忽略。
事实上处于TIME_WAIT阶段的socket已经是半关闭的状态，将一个新的socket绑定在这个地址端口对上不会有任何问题。这样的话原来绑定在这个端口上的socket一般不会对新的socket产生影响。
但需要注意的是，在某些时候，将一个新的socket绑定在一个处于TIME_WAIT阶段但仍在工作的socket所对应的地址端口对会产生一些我们并不想要的，无法预料的负面影响。但这个问题超过了本文的讨论范围。而且幸运的是这些负面影响在实践中很少见到。

关于SO_REUSEADDR，我们还要注意的一件事是，以上所有内容只要我们对新的socket设置了SO_REUSEADDR就成立。
至于原有的已经绑定在当前地址端口对上的，处于或不处于TIME_WAIT阶段的socket是否设置了SO_REUSEADDR并无影响。
决定bind操作是否成功的代码仅仅会检查新的被传递到bind()方法的socket的SO_REUSEADDR选项。其他涉及到的socket的SO_REUSEADDR选项并不会被检查。


SO_REUSEADDR：服务端异常停止，套接字没有释放的情况
Unix提供了一个接口setsockopt()可以在bind之前设置套接字选项，其中就包括REUSEADDR这个选项，表明可以多个进程复用bind函数中指定的地址和端口号。

由此可知多个应用(进程)，包括同一个应用多次，都是可以绑定到同一个端口进行监听的。对应地C++、NET等高级语言也都提供了对应的接口。

在Linux操作系统上监听完全相同的IP:PORT会报错：java.net.BindException: Address already in use  

这种结果是正确的。因为第一个连接不是TIME_WAIT状态的，第二个连接就不能使用8899端口；
只有第一个连接是TIME_WAIT状态的，第二个连接就才能使用8899端口；
如果服务器出现意外而导致没有将这个端口释放，那么服务器重新启动后，你还可以用这个端口，因为你已经规定可以重用了，如果你没定义的话，你就会得到提示，ADDR已在使用中。 


SO_REUSEADDR可以用在以下四种情况下。 
    (摘自《Unix网络编程》卷一，即UNPv1) 
    1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启
动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。 
    2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但
每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可
以测试这种情况。 
    3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个soc
ket绑定的ip地址不同。这和2很相似，区别请看UNPv1。 
    4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的
多播，不用于TCP。



SO_REUSEPORT选项
SO_REUSEPORT允许我们将任意数目的socket绑定到完全相同的源地址端口对上，只要所有之前绑定的socket都设置了SO_REUSEPORT选项
如果第一个绑定在该地址端口对上的socket没有设置SO_REUSEPORT，无论之后的socket是否设置SO_REUSEPORT，其都无法绑定在与这个地址端口完全相同的地址上。除非第一个绑定在这个地址端口对上的socket释放了这个绑定关系。
与SO_REUSEADDR不同的是 ，处理SO_REUSEPORT的代码不仅会检查当前尝试绑定的socket的SO_REUSEPORT，而且也会检查之前已绑定了当前尝试绑定的地址端口对的socket的SO_REUSEPORT选项。


如果当前socket已经处于TIME_WAIT阶段，而这个设置了SO_REUSEPORT选项的新socket尝试绑定到当前地址，这个绑定操作也会失败。
为了能够将新的socket绑定到一个当前处于TIME_WAIT阶段的socket对应的地址端口对上，我们要么需要在绑定之前设置这个新socket的SO_REUSEADDR选项，要么需要在绑定之前给两个socket都设置SO_REUSEPORT选项。


调用Connect()也可能返回EADDRINUSE：


唯一识别TCP/UDP连接。TCP/UDP是由以下五元组唯一地识别的： 
{<protocol>, <src addr>, <src port>, <dest addr>, <dest port>}

一个连接关系是由一个五元组确定的。对于任意的连接关系而言，这个五元组必须是唯一的。否则的话，系统将无法分辨两个连接。
现在当我们采用了地址复用之后，我们可以将两个采用相同协议的socket绑定到同一地址端口对上。这意味着对这两个socket而言，五元组里的{<protocol>, <src addr>, <src port>}已经相同了。
在这种情况下，如果我们尝试将它们都连接到同一个远程地址端口上，这两个连接关系的五元组将完全相同。也就是说，产生了两个完全相同的连接。在TCP协议中这是不被允许的（UDP是无连接的）。
如果这两个完全相同的连接种的某一个接收到了数据，系统将无法分辨这个数据到底属于哪个连接。所以在这种情况下，至少这两个socket所尝试连接的远程主机的地址和端口不能相同。只有如此，系统才能继续区分这两个连接关系。

所以当我们将两个采用相同协议的socket绑定到同一个本地地址端口对上后，如果我们还尝试让它们和同一个目的地址端口对建立连接，第二个尝试调用connect()方法的socket将会报EADDRINUSE的错误，这说明一个拥有完全相同的五元组的socket已经存在了。



参考
https://blog.csdn.net/Yaokai_AssultMaster/article/details/68951150
https://blog.csdn.net/yusiguyuan/article/details/12612395
https://blog.csdn.net/daiyudong2020/article/details/52295026
https://elf8848.iteye.com/blog/1739598






---------------------------------------------------------------------------------------------------------------------

