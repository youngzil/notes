




---------------------------------------------------------------------------------------------------------------------

32位的版本：x86、i386、
64位的版本：x86_64、x64、amd64


x86=i386=IA32
amd64=x86_64=x64!=IA64


armel、armhf和arm64



i386 简单理解就是32位的版本，amd64 是64位的版本，因为是amd把64位率先引进桌面系统的，英特尔也是要追随amd并且保持兼容，一般在软件包里包含这样的字符。
i386=Intel 80386。其实i386通常被用来作为对Intel（英特尔）32位微处理器的统称。
AMD64，又称“x86-64”或“x64”，是一种64位元的电脑处理器架构。它是建基于现有32位元的x86架构，由AMD公司所开发

x86架构首度出现在1978年推出的Intel 8086中央处理器，它是从Intel 8008处理器中发展而来的，而8008则是发展自Intel 4004的。Intel之后又推出了包括80186、80286、80386以及80486。  在设计上，这些后续的处理器使用的指令集都是在8086的基础上添加新支持的指令进行改进的，因此可以说都是向下兼容的(backward  compatibie)，即能再8086上运行的程序在80486上也一定能运行。由于都是以86结尾（不过8088也是x86），所以把这一系列的指令 集  称之为x86指令集（架构）。准确的来讲，x86这一术语并不是指的某一个（具体CPU使用的）具体的指令集，而是在8086（的指令集）基础上发展而来 的所有指令集的泛称。

从1985年80386开始，intel通过对x86架构进行32位的扩展，实现了32位CPU，而之前的都是16位。Intel把支持32位的 x86指令集架构命名为ia-32(Intel Architecture  32bit)。实际上由于32位x86处理器的统治性，术语“x86”几乎等于IA-32，即32位的x86或x86-32，例如Windows和 Linux发行版的32位命名都是x86（而不是x86-32或ia-32）。

后来的“x86-64”名称也继续强化了这种约定方式。这里还是要强调 x86是一系列架构的泛称，支持16位、32位和64位的指令都有。

[i386 和 x86-64 有什么区别？](https://www.zhihu.com/question/19573226)  
[x86、i386、amd64、ia64的区别](http://www.361way.com/cpuinfo/1510.html)


armel、armhf和arm64

armel是arm eabi little endian的缩写。eabi是软浮点二进制接口，这里的e是embeded，是对于嵌入式设备而言。
armhf是arm hard float的缩写。
arm64：64位的arm默认就是hf的，因此不需要hf的后缀。

armel和armhf的区别：
它们的区别体现在浮点运算上，它们在进行浮点运算时都会使用fpu，但是armel传参数用普通寄存器，而armhf传参数用的是fpu的寄存器，因此armhf的浮点运算性能更高。

[armel、armhf和arm64](https://www.cnblogs.com/hustdc/p/7224980.html)  
[带大家了解一下armel、armhf和arm64之间有什么区别](https://www.163.com/dy/article/F8BVU5JM0531AFNT.html)
[【CPU】关于x86、x86_64/x64、amd64和arm64/aarch64](https://blog.csdn.net/michaelwoshi/article/details/105105421)  
[CPU架构/指令集：RISC / CISC | arm | amd | X86/i386 | aarch64](https://www.cnblogs.com/johnnyzen/p/13224632.html)  

---------------------------------------------------------------------------------------------------------------------

狭义的x86架构，指只支持32位的intel/AMD/VIA的CPU，并向下兼容16位（实模式）；
狭义的x64架构，指的是支持32位和64位的intel/AMD CPU，指令集与x86兼容，并向下兼容16位（实模式），目前绝大多数民用CPU和服务器CPU都是这样的；
狭义的ia64架构，指的是安腾系列的CPU，虽然指令集也是64位的，但不兼容32位，intel独有的，这种CPU比较少见，基本不生产了，近似于淘汰的状态；
广义的x86架构，泛指支持x86和x64架构intel、amd的CPU，但不包含ia64（安腾）。
目前市面上能看到的E5没有安腾架构的（安腾是独立发布的），绝大多数E5都支持x64

X86是一种架构，但是他有32位的和64位的！
32位的叫x86 ，后来出现基于它的64位版，就叫X86-64，后来有时简称X64。
而64位的系统是基于64位处理器而来的，所以64位的系统能在64位的处理器上运行，但是不能在32的处理器上运行！
而因为64位处理器是基于32位的X86而来，所以向后兼容，支持32位的系统！
情况如下：
64位处理器（X64）：64位系统，32位系统……
32位处理器（X86）：32位系统。16位系统……


x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构。最早的8086处理器于1978年由Intel推出，为16位微处理器。

Intel在早期以80x86这样的数字格式来命名处理器，包括Intel 8086、80186、80286、80386以及80486，由于以“86”作为结尾，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如奔腾（Pentium）、酷睿（Core）、锐龙（Ryzen，AMD推出）。

x86的32位架构一般又被称作IA-32，全名为“Intel Architecture, 32-bit”。其64位架构由AMD率先推出，并被称为“AMD64”。之后也被Intel采用，被其称为“Intel 64”。一般也被称作“x86-64”、“x64”。

值得注意的是，Intel也推出过IA-64架构，虽然名字上与“IA-32”相似，但两者完全不兼容，并不属于x86指令集架构家族。


x86寄存器

16位

自Intel 8086和8088起，有14个16比特寄存器。
1、其中四个（AX, BX, CX, DX）是通用目的（尽管每个寄存器都有附加目的；举个例子：只有CX可以被用来当作loop（循环）指令的计数器。）每个寄存器可以被当成两个分开的字节访问（因此BX的高比特可以被当成BH，低比特则可以当成BL）。
2、除了这些寄存器，还有四个区块寄存器（CS、DS、SS、ES）。他们用来产生存储器的绝对地址。
3、还有两个指针寄存器（SP是指向堆栈的底部，BP可以用来指向堆栈或存储器的其它地方）。
4、两个指针寄存器（SI和DI）可以用来指向数组的内部。
5、最后，有旗标寄存器（包含状态旗标比如进位、溢出、结果为零，等等）。
6、以及IP是用来指向目前运行指令的地址。

32位
自Intel 80386起，四个通用寄存器（EAX, EBX, ECX, EDX），它们较低的16位分别与原本16位的通用寄存器（AX, BX, CX, DX）重叠共用。
指针寄存器（EIP, EBP, ESP, ESI, EDI）。
区块寄存器除了原本的（CS、DS、SS、ES），另外新增（FS、GS），但是区块寄存器在32位模式下改做为存储器区块的选择子寄存器。
旗标寄存器被扩展为32位，较低的16位与原本在16位下的旗标寄存器重叠共用。

64位
MMX寄存器（MM0～MM7），它们分别与浮点运算器〈FP0～FP7〉相重叠，所以MMX与浮点运算不可同时使用，必须透过切换选择要使用哪一种。



---------------------------------------------------------------------------------------------------------------------

X86汇编指令集

一、数据传输指令
　　它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.
　　1. 通用数据传送指令.
　　　　MOV　　传送字或字节.
　　　　MOVSX　先符号扩展,再传送.
　　　　MOVZX　先零扩展,再传送.
　　　　PUSH　　把字压入堆栈.
　　　　POP　　把字弹出堆栈.
　　　　PUSHA　把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.
　　　　POPA　　把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.
　　　　PUSHAD　把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.
　　　　POPAD　把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.
　　　　BSWAP　交换32位寄存器里字节的顺序
　　　　XCHG　　交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)
　　　　CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )
　　　　XADD　　先交换再累加.( 结果在第一个操作数里 )
　　　　XLAT　　字节查表转换.
　　　　　　　　── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即
　　　　　　　　0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL )
　　2. 输入输出端口传送指令.
　　　　IN　　　I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )
　　　　OUT　　I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )
　　　　　输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,
　　　　　其范围是 0-65535.
　　3. 目的地址传送指令.
　　　　LEA　　装入有效地址.
　　　　　例: LEA DX,string　;把偏移地址存到DX.
　　　　LDS　　传送目标指针,把指针内容装入DS.
　　　　　例: LDS SI,string　;把段地址:偏移地址存到DS:SI.
　　　　LES　　传送目标指针,把指针内容装入ES.
　　　　　例: LES DI,string　;把段地址:偏移地址存到ES:DI.
　　　　LFS　　传送目标指针,把指针内容装入FS.
　　　　　例: LFS DI,string　;把段地址:偏移地址存到FS:DI.
　　　　LGS　　传送目标指针,把指针内容装入GS.
　　　　　例: LGS DI,string　;把段地址:偏移地址存到GS:DI.
　　　　LSS　　传送目标指针,把指针内容装入SS.
　　　　　例: LSS DI,string　;把段地址:偏移地址存到SS:DI.
　　4. 标志传送指令.
　　　　LAHF　　标志寄存器传送,把标志装入AH.
　　　　SAHF　　标志寄存器传送,把AH内容装入标志寄存器.
　　　　PUSHF　标志入栈.
　　　　POPF　　标志出栈.
　　　　PUSHD　32位标志入栈.
　　　　POPD　　32位标志出栈. 
二、算术运算指令
　　　　ADD　　加法.
　　　　ADC　　带进位加法.
　　　　INC　　加 1.
　　　　AAA　　加法的ASCII码调整.
　　　　DAA　　加法的十进制调整.
　　　　SUB　　减法.
　　　　SBB　　带借位减法.
　　　　DEC　　减 1.
　　　　NEC　　求反(以 0 减之).
　　　　CMP　　比较.(两操作数作减法,仅修改标志位,不回送结果).
　　　　AAS　　减法的ASCII码调整.
　　　　DAS　　减法的十进制调整.
　　　　MUL　　无符号乘法.
　　　　IMUL　　整数乘法.
　　　　　以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),
　　　　AAM　　乘法的ASCII码调整.
　　　　DIV　　无符号除法.
　　　　IDIV　　整数除法.
　　　　　以上两条,结果回送:
　　　　　　　商回送AL,余数回送AH, (字节运算);
　　　　　或　商回送AX,余数回送DX, (字运算).
　　　　AAD　　除法的ASCII码调整.
　　　　CBW　　字节转换为字. (把AL中字节的符号扩展到AH中去)
　　　　CWD　　字转换为双字. (把AX中的字的符号扩展到DX中去)
　　　　CWDE　　字转换为双字. (把AX中的字符号扩展到EAX中去)
　　　　CDQ　　双字扩展.　　(把EAX中的字的符号扩展到EDX中去)

三、逻辑运算指令
　　　   AND　　与运算.
　　　　OR　　　或运算.
　　　　XOR　　异或运算.
　　　　NOT　　取反.
　　　　TEST　 测试.(两操作数作与运算,仅修改标志位,不回送结果).
　　　　SHL　　逻辑左移.
　　　　SAL　　算术左移.(=SHL)
　　　　SHR　　逻辑右移.
　　　　SAR　　算术右移.(=SHR)
　　　　ROL　　循环左移.
　　　　ROR　　循环右移.
　　　　RCL　　通过进位的循环左移.
　　　　RCR　　通过进位的循环右移.
　　　　　以上八种移位指令,其移位次数可达255次.
　　　　　　　移位一次时, 可直接用操作码.　如 SHL AX,1.
　　　　　　　移位>1次时, 则由寄存器CL给出移位次数.
　　　　　　　　如　MOV CL,04
　　　　　　　　　　SHL AX,CL
四、串指令
　               DS:SI　源串段寄存器　:源串变址.
　　　　　　ES:DI　目标串段寄存器:目标串变址.
　　　　　　CX　　　重复次数计数器.
　　　　　　AL/AX　扫描值.
　　　　　　D标志　0表示重复操作中SI和DI应自动增量; 1表示应自动减量.
　　　　　　Z标志　用来控制扫描或比较操作的结束.
　　　　MOVS　　串传送.
　　　　　　( MOVSB　传送字符.　　MOVSW　传送字.　　MOVSD　传送双字. )
　　　　CMPS　　串比较.
　　　　　　( CMPSB　比较字符.　　CMPSW　比较字. )
　　　　SCAS　　串扫描.
　　　　　　把AL或AX的内容与目标串作比较,比较结果反映在标志位.
　　　　LODS　　装入串.
　　　　　　把源串中的元素(字或字节)逐一装入AL或AX中.
　　　　　　( LODSB　传送字符.　　LODSW　传送字.　　LODSD　传送双字. )
　　　　STOS　　保存串.
　　　　　　是LODS的逆过程.
　　　　REP　　　　　　当CX/ECX0时重复.
　　　　REPE/REPZ　　　当ZF=1或比较结果相等,且CX/ECX0时重复.
　　　　REPNE/REPNZ　　当ZF=0或比较结果不相等,且CX/ECX0时重复.
　　　　REPC　　　　　当CF=1且CX/ECX0时重复.
　　　　REPNC　　　　　当CF=0且CX/ECX0时重复.
五、程序转移指令
　　1>无条件转移指令 (长转移)
　　　　JMP　　无条件转移指令
　　　　CALL　　过程调用
　　　　RET/RETF过程返回.
　　2>条件转移指令 (短转移,-128到+127的距离内)
　　　　( 当且仅当(SF XOR OF)=1时,OP1循环控制指令(短转移)
　　　　LOOP　　　　　　CX不为零时循环.
　　　　LOOPE/LOOPZ　　CX不为零且标志Z=1时循环.
　　　　LOOPNE/LOOPNZ　CX不为零且标志Z=0时循环.
　　　　JCXZ　　　　　　CX为零时转移.
　　　　JECXZ　　　　　ECX为零时转移.
　　4>中断指令
　　　　INT　　中断指令
　　　　INTO　　溢出中断
　　　　IRET　　中断返回
　　5>处理器控制指令
　　　　HLT　　处理器暂停, 直到出现中断或复位信号才继续.
　　　　WAIT　　当芯片引线TEST为高电平时使CPU进入等待状态.
　　　　ESC　　转换到外处理器.
　　　　LOCK　　封锁总线.
　　　　NOP　　空操作.
　　　　STC　　置进位标志位.
　　　　CLC　　清进位标志位.
　　　　CMC　　进位标志取反.
　　　　STD　　置方向标志位.
　　　　CLD　　清方向标志位.
　　　　STI　　置中断允许位.
　　　　CLI　　清中断允许位.
六、伪指令
            DW　　　定义字(2字节).
　　　　PROC　　定义过程.
　　　　ENDP　　过程结束.
　　　　SEGMENT 定义段.
　　　　ASSUME　建立段寄存器寻址.
　　　　ENDS　　段结束.
　　　　END　　程序结束. 

转载自:http://blog.csdn.net/thanklife/article/details/11065063




---------------------------------------------------------------------------------------------------------------------



